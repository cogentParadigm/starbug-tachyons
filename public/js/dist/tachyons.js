/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./core/app/public/js/sb/kernel.js"
/*!*****************************************!*\
  !*** ./core/app/public/js/sb/kernel.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/Deferred */ "./libraries/dojo/Deferred.js"), __webpack_require__(/*! dojo/ready */ "./libraries/dojo/ready.js"), __webpack_require__(/*! put-selector/put */ "./libraries/put-selector/put.js"), __webpack_require__(/*! dojo/_base/config */ "./libraries/dojo/_base/config.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(Deferred, ready, put, config) {
  if (!window.sb) {
    window.sb = {
      hasLoadedTinyMCE:false,
      post: function(url, args, onsubmit) {
        if (typeof url == "object") {
          onsubmit = args;
          args = url;
          url = window.location.href;
        }
        if (url.substr(0, 4) != 'http') url = WEBSITE_URL+url;
        var form = put(window.document.body, 'form[method="post"]');
        form.style.display = 'none';
        form.setAttribute('action', url);
        if (onsubmit) form.setAttribute('onsubmit', onsubmit);
        for (var key in args) if (args.hasOwnProperty(key)) put(form, 'input[type=hidden]', {name:key, value:args[key]});
        var button = put(form, 'button[type=submit]', 'submit');
        button.click();
      },
      editable: function() {
        var sb = this;
        var rt = window.document.getElementsByClassName("rich-text");
        var ed = window.document.getElementsByClassName("editable");
        if (rt.length > 0 || ed.length > 0) {
          if (this.hasLoadedTinyMCE) {
            window.tinymce.remove();
            sb.initTinyMCE(rt, ed);
            return;
          }
          var script = window.document.createElement('script');
          script.type = 'text/javascript';
          script.src = config.websiteUrl + 'libraries/tinymce/tinymce.min.js';
          var done = false;
          script.onload = script.onreadystatechange = function() {
            if ( !done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") ) {
              done = true;
              sb.initTinyMCE(rt, ed);
              // Handle memory leak in IE
              script.onload = script.onreadystatechange = null;
            }
          };
          window.document.head.appendChild(script);
          this.hasLoadedTinyMCE = true;
        }
      },
      initTinyMCE: function(rt, ed) {
        var tiny_mce_browser_callback = function(callback, value, meta){
          window.SetUrl=function(url,width,height,caption){
            if (meta.filetype == "file") {
              callback(url, {text: caption});
            } else if (meta.filetype == "image") {
              callback(url, {alt: caption});
            } else if (meta.filetype == "media") {
              callback(url);
            }
          };
          window.open(WEBSITE_URL+'admin/media?modal=true','media','modal,width=1020,height=600');
        };

        var tiny_options = {
          // General options
          plugins: [
              "advlist autolink autoresize lists link image charmap print preview hr anchor pagebreak",
              "searchreplace wordcount visualblocks visualchars code fullscreen charmap",
              "insertdatetime media nonbreaking save table directionality",
              "emoticons template paste save"
          ],
          paste_auto_cleanup_on_paste : true,
          auto_cleanup_word: true,
          convert_urls: false,
          relative_urls: false,
          toolbar1: "undo redo | styleselect | bold italic | forecolor backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media | print preview",
          image_advtab: true,
          formats: {
            alignleft: {selector:'img', styles:{'margin':'0 15px 15px 0', 'float':'left'}},
            alignright: {selector:'img', styles:{'margin':'0 0 15px 15px', 'float':'right'}},
            btndefault: {inline:'a', classes:'btn btn-default', attributes:{href:'[uri:home]'}},
            btnprimary: {inline:'a', classes:'btn btn-primary', attributes:{href:'[uri:home]'}},
            btnsuccess: {inline:'a', classes:'btn btn-success', attributes:{href:'[uri:home]'}},
            btninfo: {inline:'a', classes:'btn btn-info', attributes:{href:'[uri:home]'}},
            btnwarning: {inline:'a', classes:'btn btn-warning', attributes:{href:'[uri:home]'}},
            btndanger: {inline:'a', classes:'btn btn-danger', attributes:{href:'[uri:home]'}}
          },
          style_formats_merge:true,
          style_formats: [
            {
              title:"Buttons", items: [
                {title:"Default Button", format:"btndefault"},
                {title:"Primary Button", format:"btnprimary"},
                {title:"Success Button", format:"btnsuccess"},
                {title:"Info Button", format:"btninfo"},
                {title:"Warning Button", format:"btnwarning"},
                {title:"Danger Button", format:"btndanger"}
              ]
            }
          ],
          file_picker_callback: tiny_mce_browser_callback
        };

        if (rt.length > 0) {
          tiny_options.selector = "textarea.rich-text";
          window.tinymce.init(tiny_options);
        }
        if (ed.length > 0) {
          tiny_options.selector = "div.editable";
          tiny_options.inline = true;
          tiny_options.save_enablewhendirty = true;
          tiny_options.toolbar1 += " save cancel";
          tiny_options.save_onsavecallback = function(editor) {
            var content = editor.getContent();
            var block_id = editor.bodyElement.getAttribute('data-block-id');
            sb.get('blocks').put({id:block_id, content:content}).then(function() {
              editor.bodyElement.blur();
            });
          };
          window.tinymce.init(tiny_options);
        }
      }
    };
  }
  ready(function() {
    window.sb.editable();
  });
  return window.sb;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./core/app/public/js/sb/main.js"
/*!***************************************!*\
  !*** ./core/app/public/js/sb/main.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! sb/kernel */ "./core/app/public/js/sb/kernel.js"),
	__webpack_require__(/*! dbootstrap */ "./libraries/dbootstrap/main.js"),
	__webpack_require__(/*! starbug/form/_FormWidget */ "./core/app/public/js/starbug/form/_FormWidget.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(sb){
	// module:
	//		sb/main
	// summary:
	//		The sb package main module
	return sb;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./core/app/public/js/starbug/form/_FormWidget.js"
/*!********************************************************!*\
  !*** ./core/app/public/js/starbug/form/_FormWidget.js ***!
  \********************************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! dijit/form/_FormWidgetMixin */ "./libraries/dijit/form/_FormWidgetMixin.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang, _FormWidget){
  lang.extend(_FormWidget, {
    scrollOnFocus:false
  });
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dbootstrap/icon_support.js"
/*!**********************************************!*\
  !*** ./libraries/dbootstrap/icon_support.js ***!
  \**********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
    :copyright: Copyright 2012 Martin Pengelly-Phillips
    :license: See LICENSE.txt.
*/

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__.dj.c(module),
    __webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js"),
    __webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"),
    __webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"),
    __webpack_require__(/*! dojo/dom-construct */ "./libraries/dojo/dom-construct.js"),
    __webpack_require__(/*! dojo/dom-class */ "./libraries/dojo/dom-class.js"),
    __webpack_require__(/*! dijit/_TemplatedMixin */ "./libraries/dijit/_TemplatedMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(require, declare, lang, array, domConstruct, domClass, TemplatedMixin) {
    // Patch templated widgets to replace icon nodes that do no support pseudo
    // states with nodes that do. This enables Font-Awesome to be used
    // everywhere for the icons.
    //
    // To use, require this module *before* Dijit.
    //
    var _replaceNodesForIconSupport = function(rootNode) {
        // Replace nodes that don't support :before with nodes that do.
        //
        var reference_tag_names = ['IMG', 'INPUT'];
        var reference_classes = [
            'dijitIcon', 'dijitTabStripIcon', 'dijitMenuExpand',
            'dijitCalendarIncrementControl', 'dijitArrowButtonInner',
            'dijitTreeExpando', 'dijitArrowNode'
        ];
        var reference_attributes = ['class', 'data-dojo-attach-point'];

        var nodes = rootNode;
        if (!lang.isArray(nodes)) {
            nodes = (rootNode.all || rootNode.getElementsByTagName("*"));
        }

        var x = lang.isArray(rootNode) ? 0 : -1;
        for (; x < 0 || nodes[x]; x++) {
            // Don't access nodes.length on IE, see #14346
            var node = (x == -1) ? rootNode : nodes[x];

            // Only deal with known problem node types.
            if (array.indexOf(reference_tag_names, node.tagName) === -1) {
                continue;
            }

            // If node contains one of the reference classes then replace
            // it with a suitable pseudo state friendly node, copying
            // relevant attributes to the new node.
            for (var i=0, l=reference_classes.length; i<l; i++) {
                if (domClass.contains(node, reference_classes[i])) {
                    var attributes = {};
                    array.forEach(reference_attributes, function(name) {
                        var attribute = node.getAttribute(name);
                        if (attribute) {
                            attributes[name] = attribute;
                        }
                    });

                    var newNode = domConstruct.create(
                        'span', attributes, node, 'replace'
                    );
                    break;
                }
            }
        }
    }

    if (TemplatedMixin.prototype._attachTemplateNodes === undefined) {
        // Dojo 1.9+ introduced new _AttachMixin module that contains code
        // to patch.
        Promise.resolve(/*! AMD require */).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! dijit/_AttachMixin */ "./libraries/dijit/_AttachMixin.js")]; Promise.all(__webpack_require__.dj.w(__WEBPACK_AMD_REQUIRE_ARRAY__)).then(function(__WEBPACK_AMD_REQUIRE_RESULT__) {return (function(AttachMixin) {
            var _original = AttachMixin.prototype._attachTemplateNodes;

            AttachMixin.prototype._attachTemplateNodes = function(rootNode) {
                // Replace nodes.
                _replaceNodesForIconSupport(rootNode);

                // Continue with normal parent method.
                return _original.call(this, rootNode);


            };
        }).apply(null, __webpack_require__.dj.u(__WEBPACK_AMD_REQUIRE_RESULT__))}.bind(this));})['catch'](__webpack_require__.oe);
    } else {
        var _original = TemplatedMixin.prototype._attachTemplateNodes;

        TemplatedMixin.prototype._attachTemplateNodes = function(rootNode,
                                                                 getAttrFunc) {
            // Replace nodes.
            _replaceNodesForIconSupport(rootNode);

            // Continue with normal parent method.
            return _original.call(this, rootNode, getAttrFunc);
        }
    }

    return TemplatedMixin;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);



/***/ },

/***/ "./libraries/dbootstrap/main.js"
/*!**************************************!*\
  !*** ./libraries/dbootstrap/main.js ***!
  \**************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
    :copyright: Copyright 2012 Martin Pengelly-Phillips
    :license: See LICENSE.txt.
*/
//'xstyle/css!./theme/dbootstrap/dbootstrap.css',
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(/*! ./icon_support */ "./libraries/dbootstrap/icon_support.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function (TemplatedMixin) {
	return {};
	/*
    return {
        'TemplatedMixin': TemplatedMixin
    };
    */
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);



/***/ },

/***/ "./libraries/dijit/Destroyable.js"
/*!****************************************!*\
  !*** ./libraries/dijit/Destroyable.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/aspect */ "./libraries/dojo/aspect.js"),
	__webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/_AttachMixin.js"
/*!*****************************************!*\
  !*** ./libraries/dijit/_AttachMixin.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module),
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/_base/connect */ "./libraries/dojo/_base/connect.js"),	// remove for 2.0
	__webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), // lang.getObject
	__webpack_require__(/*! dojo/mouse */ "./libraries/dojo/mouse.js"),
	__webpack_require__(/*! dojo/on */ "./libraries/dojo/on.js"),
	__webpack_require__(/*! dojo/touch */ "./libraries/dojo/touch.js"),
	__webpack_require__(/*! ./_WidgetBase */ "./libraries/dijit/_WidgetBase.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent, ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/_BidiMixin.js"
/*!***************************************!*\
  !*** ./libraries/dijit/_BidiMixin.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(){

	// module:
	//		dijit/_BidiMixin

	// UCC - constants that will be used by bidi support.
	var bidi_const = {
		LRM : '\u200E',
		LRE : '\u202A',
		PDF : '\u202C',
		RLM : '\u200f',
		RLE : '\u202B'
	};

	return {
		// summary:
		//		When has("dojo-bidi") is true, _WidgetBase will mixin this class.   It enables support for the textdir
		//		property to control text direction independently from the GUI direction.
		// description:
		//		There's a special need for displaying BIDI text in rtl direction
		//		in ltr GUI, sometimes needed auto support.
		//		In creation of widget, if it's want to activate this class,
		//		the widget should define the "textDir".

		getTextDir: function(/*String*/ text){
			// summary:
			//		Gets the right direction of text.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.
			return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
		},

		_checkContextual: function(text){
			// summary:
			//		Finds the first strong (directional) character, return ltr if isLatin
			//		or rtl if isBidiChar.
			// tags:
			//		private.

			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as defult.
			return fdc ? ( fdc[0] <= 'z' ? "ltr" : "rtl" ) : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
		},

		applyTextDir: function(/*DOMNode*/ element, /*String?*/ text){
			// summary:
			//		Set element.dir according to this.textDir, assuming this.textDir has a value.
			// element:
			//		The text element to be set. Should have dir property.
			// text:
			//		If specified, and this.textDir is "auto", for calculating the right transformation
			//		Otherwise text read from element.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.

			if(this.textDir){
				var textDir = this.textDir;
				if(textDir == "auto"){
					// convert "auto" to either "ltr" or "rtl"
					if(typeof text === "undefined"){
						// text not specified, get text from element
						var tagName = element.tagName.toLowerCase();
						text = (tagName == "input" || tagName == "textarea") ? element.value :
							element.innerText || element.textContent || "";
					}
					textDir = this._checkContextual(text);
				}

				if(element.dir != textDir){
					// set element's dir to match textDir, but not when textDir is null and not when it already matches
					element.dir = textDir;
				}
			}
		},

		enforceTextDirWithUcc: function(option, text){
			// summary:
			//		Wraps by UCC (Unicode control characters) option's text according to this.textDir
			// option:
			//		The element (`<option>`) we wrapping the text for.
			// text:
			//		The text to be wrapped.
			// description:
			//		There's a dir problem with some HTML elements. For some elements (e.g. `<option>`, `<select>`)
			//		defining the dir in different direction then the GUI orientation, won't display correctly.
			//		FF 3.6 will change the alignment of the text in option - this doesn't follow the bidi standards (static text
			//		should be aligned following GUI direction). IE8 and Opera11.10 completely ignore dir setting for `<option>`.
			//		Therefore the only solution is to use UCC (Unicode  control characters) to display the text in correct orientation.
			//		This function saves the original text value for later restoration if needed, for example if the textDir will change etc.
			if(this.textDir){
				if(option){
					option.originalText = text;
				}
				var dir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
				return (dir == "ltr" ? bidi_const.LRE : bidi_const.RLE ) + text + bidi_const.PDF;
			}
			return text;
		},

		restoreOriginalText: function(origObj){
			// summary:
			//		Restores the text of origObj, if needed, after enforceTextDirWithUcc, e.g. set("textDir", textDir).
			// origObj:
			//		The element (`<option>`) to restore.
			// description:
			//		Sets the text of origObj to origObj.originalText, which is the original text, without the UCCs.
			//		The function than removes the originalText from origObj!
			if(origObj.originalText){
				origObj.text = origObj.originalText;
				delete origObj.originalText;
			}
			return origObj;
		},

		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			if(!this._created || this.textDir != textDir){
				this._set("textDir", textDir);
				var node = null;
				if(this.displayNode){
					node = this.displayNode;
					this.displayNode.align = this.dir == "rtl" ? "right" : "left";
				}else{
					node = this.textDirNode || this.focusNode || this.textbox;
				}
				if(node){
					this.applyTextDir(node);
				}
			}
		}
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/_TemplatedMixin.js"
/*!********************************************!*\
  !*** ./libraries/dijit/_TemplatedMixin.js ***!
  \********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/cache */ "./libraries/dojo/cache.js"),	// dojo.cache
	__webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-construct */ "./libraries/dojo/dom-construct.js"), // domConstruct.destroy, domConstruct.toDom
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), // lang.getObject
	__webpack_require__(/*! dojo/on */ "./libraries/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./libraries/dojo/sniff.js"), // has("ie")
	__webpack_require__(/*! dojo/string */ "./libraries/dojo/string.js"), // string.substitute string.trim
	__webpack_require__(/*! ./_AttachMixin */ "./libraries/dijit/_AttachMixin.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/_WidgetBase.js"
/*!****************************************!*\
  !*** ./libraries/dijit/_WidgetBase.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module), // require.toUrl
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/aspect */ "./libraries/dojo/aspect.js"),
	__webpack_require__(/*! dojo/_base/config */ "./libraries/dojo/_base/config.js"), // config.blankGif
	__webpack_require__(/*! dojo/_base/connect */ "./libraries/dojo/_base/connect.js"), // connect.connect
	__webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom */ "./libraries/dojo/dom.js"), // dom.byId
	__webpack_require__(/*! dojo/dom-attr */ "./libraries/dojo/dom-attr.js"), // domAttr.set domAttr.remove
	__webpack_require__(/*! dojo/dom-class */ "./libraries/dojo/dom-class.js"), // domClass.add domClass.replace
	__webpack_require__(/*! dojo/dom-construct */ "./libraries/dojo/dom-construct.js"), // domConstruct.destroy domConstruct.place
	__webpack_require__(/*! dojo/dom-geometry */ "./libraries/dojo/dom-geometry.js"), // isBodyLtr
	__webpack_require__(/*! dojo/dom-style */ "./libraries/dojo/dom-style.js"), // domStyle.set, domStyle.get
	__webpack_require__(/*! dojo/has */ "./libraries/dojo/has.js"),
	__webpack_require__(/*! dojo/_base/kernel */ "./libraries/dojo/_base/kernel.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), // mixin(), isArray(), etc.
	__webpack_require__(/*! dojo/on */ "./libraries/dojo/on.js"),
	__webpack_require__(/*! dojo/ready */ "./libraries/dojo/ready.js"),
	__webpack_require__(/*! dojo/Stateful */ "./libraries/dojo/Stateful.js"), // Stateful
	__webpack_require__(/*! dojo/topic */ "./libraries/dojo/topic.js"),
	__webpack_require__(/*! dojo/_base/window */ "./libraries/dojo/_base/window.js"), // win.body()
	__webpack_require__(/*! ./Destroyable */ "./libraries/dijit/Destroyable.js"),
	__webpack_require__.dj.h(/*! dojo/has!dojo-bidi?./_BidiMixin */"dojo-bidi?./libraries/dijit/_BidiMixin.js"),
	__webpack_require__(/*! ./registry */ "./libraries/dijit/registry.js")    // registry.getUniqueId(), registry.findWidgets()
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		- Toggle DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "toggleClass" }
		//		Toggles myClass on this.domNode by this.myClass
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,

		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		// textDir: String
		//		Bi-directional support,	the main variable which is responsible for the direction of the text.
		//		The text direction can be different than the GUI direction by using this parameter in creation
		//		of a widget.
		//
		//		This property is only effective when `has("dojo-bidi")` is defined to be true.
		//
		//		Allowed values:
		//
		//		1. "" - default value; text is same direction as widget
		//		2. "ltr"
		//		3. "rtl"
		//		4. "auto" - contextual the direction of a text defined by first strong letter.
		textDir: "",

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && this.srcNodeRef.id  && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						// Deprecated, use "textContent" instead.
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "textContent":
						mapNode.textContent = value;
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
					case "toggleClass":
						domClass.toggle(mapNode, command.className || attr, value);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/a11y.js"
/*!*********************************!*\
  !*** ./libraries/dijit/a11y.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/dom */ "./libraries/dojo/dom.js"),			// dom.byId
	__webpack_require__(/*! dojo/dom-attr */ "./libraries/dojo/dom-attr.js"), // domAttr.attr domAttr.has
	__webpack_require__(/*! dojo/dom-style */ "./libraries/dojo/dom-style.js"), // domStyle.style
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), // lang.mixin()
	__webpack_require__(/*! dojo/sniff */ "./libraries/dojo/sniff.js"), // has("ie") has("extend-dojo")
	__webpack_require__(/*! ./main */ "./libraries/dijit/main.js")	// for exporting methods to dijit namespace
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	has("extend-dojo") && lang.mixin(dijit, a11y);

	return a11y;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/form/_FormWidgetMixin.js"
/*!**************************************************!*\
  !*** ./libraries/dijit/form/_FormWidgetMixin.js ***!
  \**************************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach
	__webpack_require__(/*! dojo/_base/declare */ "./libraries/dojo/_base/declare.js"), // declare
	__webpack_require__(/*! dojo/dom-attr */ "./libraries/dojo/dom-attr.js"), // domAttr.set
	__webpack_require__(/*! dojo/dom-style */ "./libraries/dojo/dom-style.js"), // domStyle.get
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"), // lang.hitch lang.isArray
	__webpack_require__(/*! dojo/mouse */ "./libraries/dojo/mouse.js"), // mouse.isLeft
	__webpack_require__(/*! dojo/on */ "./libraries/dojo/on.js"),
	__webpack_require__(/*! dojo/sniff */ "./libraries/dojo/sniff.js"), // has("webkit")
	__webpack_require__(/*! dojo/window */ "./libraries/dojo/window.js"), // winUtils.scrollIntoView
	__webpack_require__(/*! ../a11y */ "./libraries/dijit/a11y.js")    // a11y.hasDefaultTabStop
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);

			// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
			// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
			if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
				domAttr.set(this.focusNode, 'disabled', value);
				// IE has a Caret Browsing mode (hit F7 to activate) where disabled textboxes can be modified
				// textboxes marked readonly if disabled to avoid this issue.
				if (has('trident') && 'readOnly' in this) {
					domAttr.set(this.focusNode, 'readonly', value || this.readOnly);
				}
			}else{
				this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
			}

			// And also set disabled on the hidden <input> node
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/main.js"
/*!*********************************!*\
  !*** ./libraries/dijit/main.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/kernel */ "./libraries/dojo/_base/kernel.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dijit/registry.js"
/*!*************************************!*\
  !*** ./libraries/dijit/registry.js ***!
  \*************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js"), // array.forEach array.map
	__webpack_require__(/*! dojo/_base/window */ "./libraries/dojo/_base/window.js"), // win.body
	__webpack_require__(/*! ./main */ "./libraries/dijit/main.js")	// dijit._scopeName
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dist/dojo.js"
/*!********************************!*\
  !*** ./libraries/dist/dojo.js ***!
  \********************************/
(module) {

module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = "1.16.5"; (function(
	userConfig,
	defaultConfig
){
	// summary:
	//		This is the "source loader" and is the entry point for Dojo during development. You may also load Dojo with
	//		any AMD-compliant loader via the package main module dojo/main.
	// description:
	//		This is the "source loader" for Dojo. It provides an AMD-compliant loader that can be configured
	//		to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
	//		IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
	//		via the package main module dojo/main and this loader is not required; see dojo/package.json for details.
	//
	//		In order to keep compatibility with the v1.x line, this loader includes additional machinery that enables
	//		the dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed
	//		via the has.js API and statically removed via the build system.
	//
	//		This loader includes sniffing machinery to determine the environment; the following environments are supported:
	//
	//		- browser
	//		- node.js
	//		- rhino
	//
	//		This is the so-called "source loader". As such, it includes many optional features that may be discarded by
	//		building a customized version with the build system.

	// Design and Implementation Notes
	//
	// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.
	//
	// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)
	// loader that can be configured to operate in either synchronous or asynchronous modes.
	//
	// Since this machinery implements a loader, it does not have the luxury of using a load system and/or
	// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:
	//
	//	 1. Small library for use implementing the loader.
	//	 2. Define the has.js API; this is used throughout the loader to bracket features.
	//	 3. Define the node.js and rhino sniffs and sniff.
	//	 4. Define the loader's data.
	//	 5. Define the configuration machinery.
	//	 6. Define the script element sniffing machinery and sniff for configuration data.
	//	 7. Configure the loader IAW the provided user, default, and sniffing data.
	//	 8. Define the global require function.
	//	 9. Define the module resolution machinery.
	//	10. Define the module and plugin module definition machinery
	//	11. Define the script injection machinery.
	//	12. Define the window load detection.
	//	13. Define the logging API.
	//	14. Define the tracing API.
	//	16. Define the AMD define function.
	//	17. Define the dojo v1.x provide/require machinery--so called "legacy" modes.
	//	18. Publish global variables.
	//
	// Language and Acronyms and Idioms
	//
	// moduleId: a CJS module identifier, (used for public APIs)
	// mid: moduleId (used internally)
	// packageId: a package identifier (used for public APIs)
	// pid: packageId (used internally); the implied system or default package has pid===""
	// pack: package is used internally to reference a package object (since javascript has reserved words including "package")
	// prid: plugin resource identifier
	// The integer constant 1 is used in place of true and 0 in place of false.
	//
	// The "foreign-loader" has condition is defined if another loader is being used (e.g. webpack) and this code is only
	// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and 
	// require.toAbsMid are supported.  The require and define functions are not supported.

	// define global
	var globalObject = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		}
		else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	// define a minimal library to help build the loader
	var noop = function(){
		},

		isEmpty = function(it){
			for(var p in it){
				return 0;
			}
			return 1;
		},

		toString = {}.toString,

		isFunction = function(it){
			return toString.call(it) == "[object Function]";
		},

		isString = function(it){
			return toString.call(it) == "[object String]";
		},

		isArray = function(it){
			return toString.call(it) == "[object Array]";
		},

		forEach = function(vector, callback){
			if(vector){
				for(var i = 0; i < vector.length;){
					callback(vector[i++]);
				}
			}
		},

		mix = function(dest, src){
			for(var p in src){
				dest[p] = src[p];
			}
			return dest;
		},

		makeError = function(error, info){
			return mix(new Error(error), {src:"dojoLoader", info:info});
		},

		uidSeed = 1,

		uid = function(){
			// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.
			return "_" + uidSeed++;
		},

		// FIXME: how to doc window.require() api

		// this will be the global require function; define it immediately so we can start hanging things off of it
		req = function(
			config,		  //(object, optional) hash of configuration properties
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback
			callback	  //(function, optional) lambda expression to apply to module values implied by dependencies
		){
			return contextRequire(config, dependencies, callback, 0, req);
		},

		// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout
		global = globalObject,

		doc = global.document,

		element = doc && doc.createElement("DiV"),

		has = req.has = function(name){
			return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
		},

		hasCache = has.cache = defaultConfig.hasCache;

	if (isFunction(userConfig)) {
		userConfig = userConfig(globalObject);
	}

	has.add = function(name, test, now, force){
		(hasCache[name]===undefined || force) && (hasCache[name] = test);
		return now && has(name);
	};

	 0 && 0;
	if( false )// removed by dead control flow
{}

	 0 && 0;
	if( false )// removed by dead control flow
{ var baseUrl, arg, rhinoArgs, i; }

	 0 && 0;
	if( false )// removed by dead control flow
{}

	// userConfig has tests override defaultConfig has tests; do this after the environment detection because
	// the environment detection usually sets some has feature values in the hasCache.
	for(var p in userConfig.has){
		has.add(p, userConfig.has[p], 0, 1);
	}

	//
	// define the loader data
	//

	// the loader will use these like symbols if the loader has the traceApi; otherwise
	// define magic numbers so that modules can be provided as part of defaultConfig
	var requested = 1,
		arrived = 2,
		nonmodule = 3,
		executing = 4,
		executed = 5;

	if( false )// removed by dead control flow
{}

	var legacyMode = 0,
		sync = "sync",
		xd = "xd",
		syncExecStack = [],
		dojoRequirePlugin = 0,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	if( false )// removed by dead control flow
{ var XMLHTTP_PROGIDS, progid, i, locationProtocol, locationHost; }else{
		req.async = 1;
	}

	//
	// loader eval
	//
	var eval_ =    true  ?
		// noop eval if there are csp restrictions
		function(){} :
		// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution
		0;

	req.eval =
		function(text, hint){
			return eval_(text + "\r\n//# sourceURL=" + hint);
		};

	//
	// loader micro events API
	//
	var listenerQueues = {},
		error = "error",
		signal = req.signal = function(type, args){
			var queue = listenerQueues[type];
			// notice we run a copy of the queue; this allows listeners to add/remove
			// other listeners without affecting this particular signal
			forEach(queue && queue.slice(0), function(listener){
				listener.apply(null, isArray(args) ? args : [args]);
			});
		},
		on = req.on = function(type, listener){
			// notice a queue is not created until a client actually connects
			var queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			return {
				remove:function(){
					for(var i = 0; i<queue.length; i++){
						if(queue[i]===listener){
							queue.splice(i, 1);
							return;
						}
					}
				}
			};
		};

	// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
	// lexical variables hold key loader data structures to help with minification; these may be completely,
	// one-time initialized by defaultConfig for optimized/built versions
	var
		aliases
			// a vector of pairs of [regexs or string, replacement] => (alias, actual)
			= [],

		paths
			// CommonJS paths
			= {},

		pathsMapProg
			// list of (from-path, to-path, regex, length) derived from paths;
			// a "program" to apply paths; see computeMapProg
			= [],

		packs
			// a map from packageId to package configuration object; see fixupPackageInfo
			= {},

		map = req.map
			// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map
			= {},

		mapProgs
			// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
			= [],

		modules
			// A hash:(mid) --> (module-object) the module namespace
			//
			// pid: the package identifier to which the module belongs (e.g., "dojo"); "" indicates the system or default package
			// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., "dojo/io/script")
			// url: the URL from which the module was retrieved
			// pack: the package object of the package to which the module belongs
			// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed
			// deps: the dependency vector for this module (vector of modules objects)
			// def: the factory for this module
			// result: the result of the running the factory for this module
			// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define
			// load: plugin load function; applicable only for plugins
			//
			// Modules go through several phases in creation:
			//
			// 1. Requested: some other module's definition or a require application contained the requested module in
			//	  its dependency vector or executing code explicitly demands a module via req.require.
			//
			// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL
			//
			// 3. Loaded: the resource injected in [2] has been evaluated.
			//
			// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some
			//	  resources may just contain a bundle of code and never formally define a module via define
			//
			// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
			= {},

		cacheBust
			// query string to append to module URLs to bust browser cache
			= "",

		cache
			// hash:(mid | url)-->(function | string)
			//
			// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or
			// url --> string. The url key is distinguished from the mid key by always containing the prefix "url:". url keys as provided
			// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided
			// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.
			//
			// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given
			// by any mappings *iff* the config.cache was received as part of a module resource request.
			//
			// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules
			// to retrieve cached items that may have arrived consequent to another namespace.
			//
			 = {},

		urlKeyPrefix
			// the prefix to prepend to a URL key in the cache.
			= "url:",

		pendingCacheInsert
			// hash:(mid)-->(function)
			//
			// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
			// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another
			// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending
			// cache for the local configuration, possibly relocating modules.
			 = {},

		dojoSniffConfig
			// map of configuration variables
			// give the data-dojo-config as sniffed from the document (if any)
			= {},

		insertPointSibling
			// the nodes used to locate where scripts are injected into the document
			= 0;

	if( true ){
		if (false ) // removed by dead control flow
{ var consumePendingCacheInsert; }
		var escapeString = function(s){
				return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c){ return "\\" + c; });
			},

			computeMapProg = function(map, dest){
				// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
				// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
				// of-map-key. The regex looks for the map-key followed by either "/" or end-of-string at the beginning
				// of a the search source. Notice the map-value is irrelevant to the algorithm
				dest.splice(0, dest.length);
				for(var p in map){
					dest.push([
						p,
						map[p],
						new RegExp("^" + escapeString(p) + "(\/|$)"),
						p.length]);
				}
				dest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });
				return dest;
			},

			computeAliases = function(config, dest){
				forEach(config, function(pair){
					// take a fixed-up copy...
					dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]]);
				});
			},


			fixupPackageInfo = function(packageInfo){
				// calculate the precise (name, location, main, mappings) for a package
				var name = packageInfo.name;
				if(!name){
					// packageInfo must be a string that gives the name
					name = packageInfo;
					packageInfo = {name:name};
				}
				packageInfo = mix({main:"main"}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;

				// packageMap is deprecated in favor of AMD map
				if(packageInfo.packageMap){
					map[name] = packageInfo.packageMap;
				}

				if(!packageInfo.main.indexOf("./")){
					packageInfo.main = packageInfo.main.substring(2);
				}

				// now that we've got a fully-resolved package object, push it into the configuration
				packs[name] = packageInfo;
			},

			delayedModuleConfig
				// module config cannot be consumed until the loader is completely initialized; therefore, all
				// module config detected during booting is memorized and applied at the end of loader initialization
				// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but
				// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete
				= [],


			config = function(config, booting, referenceModule){
				for(var p in config){
					if(p=="waitSeconds"){
						req.waitms = (config[p] || 0) * 1000;
					}
					if(p=="cacheBust"){
						cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + "") : "";
					}
					if(p=="baseUrl" || p=="combo"){
						req[p] = config[p];
					}
					if( false)// removed by dead control flow
{ var mode; }
					if(config[p]!==hasCache){
						// accumulate raw config info for client apps which can use this to pass their own config
						req.rawConfig[p] = config[p];
						p!="has" && has.add("config-"+p, config[p], 0, booting);
					}
				}

				// make sure baseUrl exists
				if(!req.baseUrl){
					req.baseUrl = "./";
				}
				// make sure baseUrl ends with a slash
				if(!/\/$/.test(req.baseUrl)){
					req.baseUrl += "/";
				}

				// now do the special work for has, packages, packagePaths, paths, aliases, and cache

				for(p in config.has){
					has.add(p, config.has[p], 0, booting);
				}

				// for each package found in any packages config item, augment the packs map owned by the loader
				forEach(config.packages, fixupPackageInfo);

				// for each packagePath found in any packagePaths config item, augment the packageConfig
				// packagePaths is deprecated; remove in 2.0
				for(var baseUrl in config.packagePaths){
					forEach(config.packagePaths[baseUrl], function(packageInfo){
						var location = baseUrl + "/" + packageInfo;
						if(isString(packageInfo)){
							packageInfo = {name:packageInfo};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}

				// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
				// is published (see dojo-publish-privates), the published variable will always hold a valid value.

				// this must come after all package processing since package processing may mutate map
				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, function(item){
					item[1] = computeMapProg(item[1], []);
					if(item[0]=="*"){
						mapProgs.star = item;
					}
				});

				// push in any paths and recompute the internal pathmap
				computeMapProg(mix(paths, config.paths), pathsMapProg);

				// aliases
				computeAliases(config.aliases, aliases);

				if (false ) // removed by dead control flow
{ var module; }
				signal("config", [config, req.rawConfig]);
			};

		//
		// execute the various sniffs; userConfig can override and value
		//

		if( false )// removed by dead control flow
{ var scripts, i, script, dojoDir, src, match; }

		if( false )// removed by dead control flow
{ var doh; }

		// configure the loader; let the user override defaults
		req.rawConfig = {};
		config(defaultConfig, 1);

		// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides
		if( false )// removed by dead control flow
{}

		config(userConfig, 1);
		config(dojoSniffConfig, 1);

	}else// removed by dead control flow
{}


	if (false ) // removed by dead control flow
{ var injectDependencies, contextRequire, createRequire, execQ, defQ, waiting, setRequested, setArrived, execComplete, comboPending, combosPending, comboPendingTimer; }

	var runMapProg = function(targetMid, map){
			// search for targetMid in map; return the map item if found; falsy otherwise
			if(map){
			for(var i = 0; i < map.length; i++){
				if(map[i][2].test(targetMid)){
					return map[i];
				}
			}
			}
			return 0;
		},

		compactPath = function(path){
			var result = [],
				segment, lastSegment;
			path = path.replace(/\\/g, '/').split('/');
			while(path.length){
				segment = path.shift();
				if(segment==".." && result.length && lastSegment!=".."){
					result.pop();
					lastSegment = result[result.length - 1];
				}else if(segment!="."){
					result.push(lastSegment= segment);
				} // else ignore "."
			}
			return result.join("/");
		},

		makeModuleInfo = function(pid, mid, pack, url){
			if( false )// removed by dead control flow
{ var xd; }else{
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
			}
		},

		getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){
			// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
			// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader
			var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = /^\./.test(mid);
			if(/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative && !referenceModule)){
				// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
				// whatever it is, it's not a module but just a URL of some sort
				// note: pid===0 indicates the routine is returning an unmodified mid

				return makeModuleInfo(0, mid, 0, mid);
			}else{
				// relative module ids are relative to the referenceModule; get rid of any dots
				mid = compactPath(isRelative ? (referenceModule.mid + "/../" + mid) : mid);
				if(/^\./.test(mid)){
					throw makeError("irrationalPath", mid);
				}
				// at this point, mid is an absolute mid

				// map the mid
				if(!fromPendingCache && !isRelative && mapProgs.star){
					mapItem = runMapProg(mid, mapProgs.star[1]);
				}
				if(!mapItem && referenceModule){
					mapItem = runMapProg(referenceModule.mid, mapProgs);
					mapItem = mapItem && runMapProg(mid, mapItem[1]);
				}

				if(mapItem){
					mid = mapItem[1] + mid.substring(mapItem[3]);
					}

				match = mid.match(/^([^\/]+)(\/(.+))?$/);
				pid = match ? match[1] : "";
				if((pack = packs[pid])){
					mid = pid + "/" + (midInPackage = (match[3] || pack.main));
				}else{
					pid = "";
				}

				// search aliases
				var candidateLength = 0,
					candidate = 0;
				forEach(aliases, function(pair){
					var match = mid.match(pair[0]);
					if(match && match.length>candidateLength){
						candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
					}
				});
				if(candidate){
					return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
				}

				result = modules[mid];
				if(result){
					return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}
			// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
			// fully resolved (i.e., all relative indicators and package mapping resolved) module id

			// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid
			mapItem = runMapProg(mid, pathsMapProg);
			if(mapItem){
				url = mapItem[1] + mid.substring(mapItem[3]);
			}else if(pid){
				url = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + "/" + midInPackage;
			}else if( false )// removed by dead control flow
{}else{
				url = mid;
			}
			// if result is not absolute, add baseUrl
			if(!(/(^\/)|(\:)/.test(url))){
				url = baseUrl + url;
			}
			url += ".js";
			return makeModuleInfo(pid, mid, pack, compactPath(url));
		},

		getModuleInfo = function(mid, referenceModule, fromPendingCache){
			return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);
		};

	if (false ) // removed by dead control flow
{ var resolvePluginResourceId, dynamicPluginUidGenerator, getModule; }

	var toAbsMid = req.toAbsMid = function(mid, referenceModule){
			return getModuleInfo(mid, referenceModule).mid;
		},

		toUrl = req.toUrl = function(name, referenceModule){
			var moduleInfo = getModuleInfo(name+"/x", referenceModule),
				url= moduleInfo.url;
			return fixupUrl(moduleInfo.pid===0 ?
				// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases
				name :
				// "/x.js" since getModuleInfo automatically appends ".js" and we appended "/x" to make name look like a module id
				url.substring(0, url.length-5)
			);
		};

	if (false ) // removed by dead control flow
{ var nonModuleProps, makeCjs, cjsRequireModule, cjsExportsModule, cjsModuleModule, runFactory, abortExec, defOrder, promoteModuleToPlugin, resolvePluginLoadQ, finishExec, circleTrace, execModule, checkCompleteGuard, guardCheckComplete, checkComplete; }

	var fixupUrl= typeof userConfig.fixupUrl == "function" ? userConfig.fixupUrl : function(url){
			url += ""; // make sure url is a Javascript string (some paths may be a Java string)
			return url + (cacheBust ? ((/\?/.test(url) ? "&" : "?") + cacheBust) : "");
		};



	if( false )// removed by dead control flow
{}

	if( false )// removed by dead control flow
{ var injectPlugin, cached, injectingModule, injectingCachedModule, evalModuleText, injectModule, defineModule, runDefQ; }

	var timerId = 0,
		clearTimer = noop,
		startTimer = noop;
	if( false )// removed by dead control flow
{}

	if ( false ) // removed by dead control flow
{}

	if( false)// removed by dead control flow
{ var scripts, i, script, domOn, windowOnLoadListener; }

	if( false )// removed by dead control flow
{}else{
		req.log = noop;
	}

	if( false )// removed by dead control flow
{ var trace; }else{
		req.trace = noop;
	}
	if (false ) // removed by dead control flow
{ var def; } else {
		var def = noop;
	}
	// allow config to override default implementation of named functions; this is useful for
	// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
	// also useful for testing and monkey patching loader
	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);

	// now that req is fully initialized and won't change, we can hook it up to the error signal
	on(error, function(arg){
		try{
			console.error(arg);
			if(arg instanceof Error){
				for(var p in arg){
					console.log(p + ":", arg[p]);
				}
				console.log(".");
			}
		}catch(e){}
	});

	// always publish these
	mix(req, {
		uid:uid,
		cache:cache,
		packs:packs
	});


	if( false )// removed by dead control flow
{}

	// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
	// *required* to define (as opposed to require, which is optional)
	if(global.define){
		if( false )// removed by dead control flow
{}
		return;
	}else{
		global.define = def;
		global.require = req;
		if( false )// removed by dead control flow
{}
	}

	if( false)// removed by dead control flow
{ var plugins, pluginName; }

	if( false )// removed by dead control flow
{ var bootDeps, bootCallback; }
	if(false )// removed by dead control flow
{}
})
.call(this, userConfig, defaultConfig);};

/***/ },

/***/ "./libraries/dojo/Deferred.js"
/*!************************************!*\
  !*** ./libraries/dojo/Deferred.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./has */ "./libraries/dojo/has.js"),
	__webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! ./errors/CancelError */ "./libraries/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ./promise/Promise */ "./libraries/dojo/promise/Promise.js"),
	__webpack_require__(/*! ./promise/instrumentation */ "./libraries/dojo/promise/instrumentation.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if(has("config-deferredInstrumentation")){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};

	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if(has("config-deferredInstrumentation") && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if(has("config-deferredInstrumentation") && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/Evented.js"
/*!***********************************!*\
  !*** ./libraries/dojo/Evented.js ***!
  \***********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./aspect */ "./libraries/dojo/aspect.js"), __webpack_require__(/*! ./on */ "./libraries/dojo/on.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/Stateful.js"
/*!************************************!*\
  !*** ./libraries/dojo/Stateful.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/declare */ "./libraries/dojo/_base/declare.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/array */ "./libraries/dojo/_base/array.js"), __webpack_require__(/*! ./when */ "./libraries/dojo/when.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/array.js"
/*!***************************************!*\
  !*** ./libraries/dojo/_base/array.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./lang */ "./libraries/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	has("extend-dojo") && lang.mixin(dojo, array);

	return array;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/config.js"
/*!****************************************!*\
  !*** ./libraries/dojo/_base/config.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ "./libraries/dojo/global.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__.dj.c(module)], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(global, has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if(has("dojo-config-api")){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		result = has("dojo-loader") ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);



/***/ },

/***/ "./libraries/dojo/_base/connect.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/_base/connect.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ../on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ../topic */ "./libraries/dojo/topic.js"), __webpack_require__(/*! ../aspect */ "./libraries/dojo/aspect.js"), __webpack_require__(/*! ./event */ "./libraries/dojo/_base/event.js"), __webpack_require__(/*! ../mouse */ "./libraries/dojo/mouse.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/_base/sniff.js"), __webpack_require__(/*! ./lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ../keys */ "./libraries/dojo/keys.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

has("extend-dojo") && lang.mixin(dojo, connect);
return connect;

}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);




/***/ },

/***/ "./libraries/dojo/_base/declare.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/_base/declare.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./lang */ "./libraries/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor, counter = 0, cname = "constructor";

	if(!has("csp-restrictions")){
		// 'new Function()' is preferable when available since it does not create a closure
		xtor = new Function;
	}else{
		xtor = function(){};
	}

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f, g){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args === "string"){
			name = args;
			args = a;
			a = f;
			f = g;
		}

		if(typeof args === "function"){
			// support strict mode
			caller = args;
			args = a;
			a = f;
		}else{
			try{
				caller = args.callee;
			}catch (e){
				if(e instanceof TypeError){
					// caller was defined in a strict-mode context
					err("strict mode inherited() requires the caller function to be passed before arguments", this.declaredClass);
				}else{
					throw e;
				}
			}
		}

		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}
		f = g = 0;

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args, a){
		if(typeof name === "string"){
			if (typeof args === "function") {
				return this.__inherited(name, args, a, true);
			}
			return this.__inherited(name, args, true);
		}
		else if (typeof name === "function") {
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2, a3){
		var f = this.getInherited(args, a1, a2);
		if(f){
			return f.apply(this, a3 || a2 || a1 || args);
		}
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed") && source){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

	function createSubclass(mixins, props){
		// crack parameters
		if(!(mixins instanceof Array || typeof mixins === 'function')){
			props = mixins;
			mixins = undefined;
		}

		props = props || {};
		mixins = mixins || [];

		return declare([this].concat(mixins), props);
	}

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				if (has("csp-restrictions")) {
					ctor = function () {};
				}
				else {
					ctor = new Function;
				}
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		if(superclass && superclass.prototype && superclass.prototype["-chains-"]) {
			chains = mix(chains || {}, superclass.prototype["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, caller, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The reference to the calling function. Required only if the
			//		call to "this.inherited" occurs from within strict-mode code.
			//		If the caller is omitted within strict-mode code, an error will
			//		be thrown.
			//		The best way to obtain a reference to the calling function is to
			//		use a named function expression (i.e. place a function name
			//		after the "function" keyword and before the open paren, as in
			//		"function fn(a, b)"). If the function is parsed as an expression
			//		and not a statement (i.e. it's not by itself on its own line),
			//		the function name will only be accessible as an identifier from
			//		within the body of the function.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict";
			//	|	// class is defined in strict-mode code,
			//	|	// so caller must be passed before arguments.
			//	|	var B = declare(A, {
			//	|		// using a named function expression with "fn" as the name.
			//	|		method: function fn(a, b) {
			//	|			this.inherited(fn, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, caller, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The caller function. This is required when running in
			//		strict-mode code. A reference to the caller function
			//		can be obtained by using a named function expression
			//		(e.g. function fn(a,b) {...}).
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict;" // first line of function or file
			//	|	//...
			//	|	var B = declare(A, {
			//	|		// Using a named function expression with "fn" as the name,
			//	|		// since we're in strict mode.
			//	|		method: function fn(a, b){
			//	|			var super = this.getInherited(fn, arguments);
			//	|			if(super){
			//	|				return super.apply(this, arguments);
			//	|			}
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},

		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/event.js"
/*!***************************************!*\
  !*** ./libraries/dojo/_base/event.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ../on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ../dom-geometry */ "./libraries/dojo/dom-geometry.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if(has("extend-dojo")){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/kernel.js"
/*!****************************************!*\
  !*** ./libraries/dojo/_base/kernel.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ "./libraries/dojo/global.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./config */ "./libraries/dojo/_base/config.js"), __webpack_require__.dj.c(module), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(global, has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:global,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			global[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = !has("dojo-loader") || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev:$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 16, patch: 5, flag: "",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	has.add("extend-dojo", 1);

	if(!has("csp-restrictions")){
		(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	}
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if(has("host-rhino")){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	if(!has("host-webworker")){
		// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100
		has.add("dojo-guarantee-console",
			// ensure that console.log, console.warn, etc. are defined
			1
		);
	}

	if(has("dojo-guarantee-console")){
		// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197
		has.add("console-as-object", function () {
			return Function.prototype.bind && console && typeof console.log === "object";
		});

		typeof console != "undefined" || (console = {});  // intentional assignment
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.prototype.slice.call(arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}else if(has("console-as-object")){
				console[tn] = Function.prototype.bind.call(console[tn], console);
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if(has("dojo-modulePaths")){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if(has("dojo-moduleUrl")){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lengthy relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/lang.js"
/*!**************************************!*\
  !*** ./libraries/dojo/_base/lang.js ***!
  \**************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ../sniff */ "./libraries/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			if(!context){
				if(parts[0] && dojo.scopeMap[parts[0]]) {
					// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
					// rather than just window.dojo
					context = dojo.scopeMap[parts.shift()][1];
				}else{
					context = dojo.global;
				}
			}

			try{
				for(var i = 0; i < parts.length; i++){
					var p = parts[i];
					// Fix for prototype pollution CVE-2021-23450
					if (p === '__proto__' || p === 'constructor') {
						return;
					}
					if(!(p in context)){
						if(create){
							context[p] = {};
						}else{
							return;		// return undefined
						}
					}
					context = context[p];
				}
				return context; // mixed
			}catch(e){
				// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
				// so in that corner case just return undefined (by having no return statement)
			}
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
				if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return !name ? context : getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: Array.isArray || function(it){
			// summary:
			//		Return true if it is an Array.
			// it: anything
			//		Item to test.
			return opts.call(it) == "[object Array]"; // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return !!it && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r[i] = lang.clone(src[i]);
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	has("extend-dojo") && lang.mixin(dojo, lang);

	return lang;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/sniff.js"
/*!***************************************!*\
  !*** ./libraries/dojo/_base/sniff.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ../sniff */ "./libraries/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(!has("host-browser")){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/url.js"
/*!*************************************!*\
  !*** ./libraries/dojo/_base/url.js ***!
  \*************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/_base/window.js"
/*!****************************************!*\
  !*** ./libraries/dojo/_base/window.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ../sniff */ "./libraries/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: dojo.global["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

has("extend-dojo") && lang.mixin(dojo, ret);

return ret;

}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/aspect.js"
/*!**********************************!*\
  !*** ./libraries/dojo/aspect.js ***!
  \**********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
							args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
							if(after.receiveArguments){
								var newResults = after.advice.apply(this, args);
								// change the return value only if a new value was returned
								results = newResults === undefined ? results : newResults;
							}else{
								results = after.advice.call(this, results, args);
							}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/cache.js"
/*!*********************************!*\
  !*** ./libraries/dojo/cache.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./text */ "./libraries/dojo/text.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/date/stamp.js"
/*!**************************************!*\
  !*** ./libraries/dojo/date/stamp.js ***!
  \**************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-attr.js"
/*!************************************!*\
  !*** ./libraries/dojo/dom-attr.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./libraries/dojo/dom-style.js"), __webpack_require__(/*! ./dom-prop */ "./libraries/dojo/dom-prop.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)
	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie") ? 1 : 0,
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}
	
	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return !!forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}
		
		if(propName == "textContent"){
			return prop.get(node, propName);
		}
		
		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-class.js"
/*!*************************************!*\
  !*** ./libraries/dojo/dom-class.js ***!
  \*************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/array */ "./libraries/dojo/_base/array.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling domClass.remove and domClass.add
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise domClass.contains(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-construct.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/dom-construct.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-attr */ "./libraries/dojo/dom-attr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(exports, dojo, has, win, dom, attr){
	// module:
	//		dojo/dom-construct
	// summary:
	//		This module defines the core dojo DOM construction API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// support stuff for toDom()
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + dojo._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		if(tagWrap.hasOwnProperty(param)){
			var tw = tagWrap[param];
			tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
			tw.post = "</" + tw.reverse().join("></") + ">";
			// the last line is destructive: it reverses the array,
			// but we don't care at this point
		}
	}

	var html5domfix;
	if(has("ie") <= 8){
		html5domfix = function(doc){
			doc.__dojo_html5_tested = "yes";
			var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
			if(div.childNodes.length !== 1){
				('abbr article aside audio canvas details figcaption figure footer header ' +
				'hgroup mark meter nav output progress section summary time video').replace(
					/\b\w+\b/g, function(n){
						doc.createElement(n);
					}
				);
			}
			destroy(div);
		}
	}

	function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
		// summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	exports.toDom = function toDom(frag, doc){
		// summary:
		//		instantiates an HTML fragment returning the corresponding DOM.
		// frag: String
		//		the HTML fragment
		// doc: DocumentNode?
		//		optional document to use when creating DOM nodes, defaults to
		//		dojo/_base/window.doc if not specified.
		// returns:
		//		Document fragment, unless it's a single node in which case it returns the node itself
		// example:
		//		Create a table row:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
		//	|	});

		doc = doc || win.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		if(has("ie") <= 8){
			if(!doc.__dojo_html5_tested && doc.body){
				html5domfix(doc);
			}
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}

		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while((fc = master.firstChild)){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DocumentFragment
	};

	exports.place = function place(node, refNode, position){
		// summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns the first argument resolved to a DOM node.
		// node: DOMNode|DocumentFragment|String
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		// refNode: DOMNode|String
		//		id or node reference to use as basis for placement
		// position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode.
		//		Accepted string values are:
		//
		//		- before
		//		- after
		//		- replace
		//		- only
		//		- first
		//		- last
		//
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		// returns: DOMNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
		// example:
		//		Place a node by string id as the last child of another node by string id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode");
		//	|	});
		// example:
		//		Place a node by string id before another node by string id
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode", "before");
		//	|	});
		// example:
		//		Create a Node, and place it in the body element (last child):
		//	|	require(["dojo/dom-construct", "dojo/_base/window"
		//	|	], function(domConstruct, win){
		//	|		domConstruct.place("<div></div>", win.body());
		//	|	});
		// example:
		//		Put a new LI as the first child of a list by id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("<li></li>", "someUl", "first");
		//	|	});

		refNode = dom.byId(refNode);
		if(typeof node == "string"){ // inline'd type check
			node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
		}
		if(typeof position == "number"){ // inline'd type check
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break;
				case "only":
					exports.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
					refNode.appendChild(node);
			}
		}
		return node; // DomNode
	};

	var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
		// summary:
		//		Create an element, allowing for optional attribute decoration
		//		and placement.
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step,
		//		as well as an optional DOM placement reference.
		//
		//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
		//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
		//
		//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
		//		the action node, passing along the optional reference node and position.
		// tag: DOMNode|String
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo/dom-attr.set` for a description of available attributes.
		// refNode: DOMNode|String?
		//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		// example:
		//		Create a DIV:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div");
		//	|	});
		//
		// example:
		//		Create a DIV with content:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
		//	|	});
		//
		// example:
		//		Place a new DIV in the BODY, with no attributes set
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		var n = domConstruct.create("div", null, win.body());
		//	|	});
		//
		// example:
		//		Create an UL, and populate it with LI's. Place the list as the first-child of a
		//		node with id="someId":
		//	|	require(["dojo/dom-construct", "dojo/_base/array"],
		//	|	function(domConstruct, arrayUtil){
		//	|		var ul = domConstruct.create("ul", null, "someId", "first");
		//	|		var items = ["one", "two", "three", "four"];
		//	|		arrayUtil.forEach(items, function(data){
		//	|			domConstruct.create("li", { innerHTML: data }, ul);
		//	|		});
		//	|	});
		//
		// example:
		//		Create an anchor, with an href. Place in BODY:
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
		//	|	});

		var doc = win.doc;
		if(refNode){
			refNode = dom.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(typeof tag == "string"){ // inline'd type check
			tag = doc.createElement(tag);
		}
		if(attrs){ attr.set(tag, attrs); }
		if(refNode){ exports.place(tag, refNode, pos); }
		return tag; // DomNode
	};

	function _empty(/*DomNode*/ node){
		// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
		// and then uncomment the emptyGrandchildren() test case from html.html.
		// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
		// see http://jsperf.com/clear-dom-node.
		if("innerHTML" in node){
			try{
				// fast path
				node.innerHTML = "";
				return;
			}catch(e){
				// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
				// Fall through (saves bytes)
			}
		}

		// SVG/strict elements don't support innerHTML
		for(var c; c = node.lastChild;){ // intentional assignment
			node.removeChild(c);
		}
	}

	exports.empty = function empty(/*DOMNode|String*/ node){
		// summary:
		//		safely removes all children of the node.
		// node: DOMNode|String
		//		a reference to a DOM node or an id.
		// example:
		//		Destroy node's children byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.empty("someId");
		//	|	});

		_empty(dom.byId(node));
	};


	function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
		// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
		if(node.firstChild){
			_empty(node);
		}
		if(parent){
			// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
			// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
			// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
			// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
			has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
		}
	}
	var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
		// summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		// description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//
		// node: DOMNode|String
		//		A String ID or DomNode reference of the element to be destroyed
		//
		// example:
		//		Destroy a node byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.destroy("someId");
		//	|	});

		node = dom.byId(node);
		if(!node){ return; }
		_destroy(node, node.parentNode);
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-geometry.js"
/*!****************************************!*\
  !*** ./libraries/dojo/dom-geometry.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js"),__webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./libraries/dojo/dom-style.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, win, dom, style){
	// module:
	//		dojo/dom-geometry

	// the result object
	var geom = {
		// summary:
		//		This module defines the core dojo DOM geometry API.
	};

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.

	// can be either:
	//	"border-box"
	//	"content-box" (default)
	geom.boxModel = "content-box";

	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

	if(has("ie") /*|| has("opera")*/){
		// client code may have to adjust if compatMode varies across iframes
		geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
	}

	geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with special values specifically useful for node
		//		fitting.
		// description:
		//		Returns an object with `w`, `h`, `l`, `t` properties:
		//	|		l/t/r/b = left/top/right/bottom padding (respectively)
		//	|		w = the total of the left and right padding
		//	|		h = the total of the top and bottom padding
		//		If 'node' has position, l/t forms the origin for child nodes.
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	var none = "none";

	geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right border
		//		- h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
			l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
			t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
			r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
			b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right padding and border
		//		- h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node),
			p = geom.getPadExtents(node, s),
			b = geom.getBorderExtents(node, s);
		return {
			l: p.l + b.l,
			t: p.t + b.t,
			r: p.r + b.r,
			b: p.b + b.b,
			w: p.w + b.w,
			h: p.h + b.h
		};
	};

	geom.getMarginExtents = function getMarginExtents(node, computedStyle){
		// summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		- l/t = marginLeft, marginTop, respectively
		//		- w = total width, margin inclusive
		//		- h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes

	geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
			l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}
		return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
	};

	geom.getContentBox = function getContentBox(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
			pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s), l = node.offsetLeft + pe.l + be.l,
			t = node.offsetTop + pe.t + be.t;
		if(!w){
			w = node.offsetWidth - be.w;
			h = node.offsetHeight - be.h;
		}else{
			h = node.clientHeight;
		}

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			var p = node.parentNode, px = style.toPixelValue, pcs;
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}

		return {l: l, t: t, w: w - pe.w, h: h - pe.h};
	};

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of boxModel is used to determine box context.
	// boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.
	//
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear
	// at all in computedStyle on Mozilla.

	function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
		// summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimensions. Uses the unit passed in u.
		// node:
		//		DOM Node reference. Id string not supported for performance
		//		reasons.
		// l:
		//		left offset from parent.
		// t:
		//		top offset from parent.
		// w:
		//		width in current box model.
		// h:
		//		width in current box model.
		// u:
		//		unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){
			s.left = l + u;
		}
		if(!isNaN(t)){
			s.top = t + u;
		}
		if(w >= 0){
			s.width = w + u;
		}
		if(h >= 0){
			s.height = h + u;
		}
	}

	function isButtonTag(/*DomNode*/ node){
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName.toLowerCase() == "button" ||
			node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
	}

	function usesBorderBox(/*DomNode*/ node){
		// summary:
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.

		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.

		return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
	}

	function getBoundingClientRect(/*DomNode*/ node) {
		// summary:
		//		Gets the bounding client rectangle for a dom node.
		// node: DOMNode

		// This will return the result of node.getBoundingClientRect if node is in the dom, and
		// {x:0, y:0, width:0, height:0, top:0, right:0, bottom:0, left:0} if it throws an error or the node is not on the dom
		// This will handle when IE throws an error or Edge returns an empty object when node is not on the dom

		var retEmpty = { x: 0, y: 0, width: 0, height: 0, top: 0, right: 0, bottom: 0, left: 0 },
			ret;

		try {
			ret = node.getBoundingClientRect();
		} catch (e) {
			// IE throws an Unspecified Error if the node is not in the dom. Handle this by returning an object with 0 values
			return retEmpty;
		}

		// Edge returns an empty object if the node is not in the dom. Handle this by returning an object with 0 values
		if (typeof ret.left === "undefined") { return retEmpty; }

		return ret;
	}

	geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		// node: DOMNode
		// box: Object
		//		hash with optional "w", and "h" properties for "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var w = box.w, h = box.h;
		if(usesBorderBox(node)){
			var pb = geom.getPadBorderExtents(node, computedStyle);
			if(w >= 0){
				w += pb.w;
			}
			if(h >= 0){
				h += pb.h;
			}
		}
		setBox(node, NaN, NaN, w, h);
	};

	var nilExtents = {l: 0, t: 0, w: 0, h: 0};

	geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to setBox that handles box-model vagaries for
		//		you.
		// node: DOMNode
		// box: Object
		//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
		// Some elements have special padding, margin, and box-model settings.
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
			pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
			mb = geom.getMarginExtents(node, s);
		if(has("webkit")){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(isButtonTag(node)){
				var ns = node.style;
				if(w >= 0 && !ns.width){
					ns.width = "4px";
				}
				if(h >= 0 && !ns.height){
					ns.height = "4px";
				}
			}
		}
		if(w >= 0){
			w = Math.max(w - pb.w - mb.w, 0);
		}
		if(h >= 0){
			h = Math.max(h - pb.h - mb.h, 0);
		}
		setBox(node, box.l, box.t, w, h);
	};

	// =============================
	// Positioning
	// =============================

	geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
		// summary:
		//		Returns true if the current language is left-to-right, and false otherwise.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Boolean

		doc = doc || win.doc;
		return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	};

	geom.docScroll = function docScroll(/*Document?*/ doc){
		// summary:
		//		Returns an object with {node, x, y} with corresponding offsets.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Object

		doc = doc || win.doc;
		var node = doc.parentWindow || doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
		return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
				{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
	};

	geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
		// summary:
		//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
		return {
			x: 0,
			y: 0
		};
	};

	geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
		// summary:
		//		In RTL direction, scrollLeft should be a negative value, but IE
		//		returns a positive one. All codes using documentElement.scrollLeft
		//		must call this function to fix this error, otherwise the position
		//		will offset to right when there is a horizontal scrollbar.
		// scrollLeft: Number
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Number

		// In RTL direction, scrollLeft should be a negative value, but IE
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

		doc = doc || win.doc;
		var ie = has("ie");
		if(ie && !geom.isBodyLtr(doc)){
			var qk = has("quirks"),
				de = qk ? win.body(doc) : doc.documentElement,
				pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
			if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
				scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
			}
			return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
		}
		return scrollLeft; // Integer
	};

	geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
		// summary:
		//		Gets the position and size of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		// description:
		//		Returns an object of the form:
		//		`{ x: 100, y: 300, w: 20, h: 15 }`.
		//		If includeScroll==true, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.
		//		Uses the border-box model (inclusive of border and padding but
		//		not margin).  Does not act as a setter.
		// node: DOMNode|String
		// includeScroll: Boolean?
		// returns: Object

		node = dom.byId(node);
		var	db = win.body(node.ownerDocument),
			ret= getBoundingClientRect(node);
		ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

		if(has("ie") < 9){
			// fixes the position in IE, quirks mode
			ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
			ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
		}

		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = geom.docScroll(node.ownerDocument);
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	};

	// random "private" functions wildly used throughout the toolkit

	geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width and height of
		//		the node's margin box
		// node: DOMNode|String
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
		var size = getBoundingClientRect(node);
		return {
			w: (size.right - size.left) + me.w,
			h: (size.bottom - size.top) + me.h
		};
	};

	geom.normalizeEvent = function(event){
		// summary:
		//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
		//		offsetX, offsetY, layerX, and layerX properties
		// event: Object
		if(!("layerX" in event)){
			event.layerX = event.offsetX;
			event.layerY = event.offsetY;
		}

		if(!("pageX" in event)){
			// FIXME: scroll position query is duped from dojo/_base/html to
			// avoid dependency on that entire module. Now that HTML is in
			// Base, we should convert back to something similar there.
			var se = event.target;
			var doc = (se && se.ownerDocument) || document;
			// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var docBody = has("quirks") ? doc.body : doc.documentElement;
			event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
			event.pageY = event.clientY + (docBody.scrollTop || 0);
		}
	};

	// TODO: evaluate separate getters/setters for position and sizes?

	return geom;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-prop.js"
/*!************************************!*\
  !*** ./libraries/dojo/dom-prop.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-style */ "./libraries/dojo/dom-style.js"), __webpack_require__(/*! ./dom-construct */ "./libraries/dojo/dom-construct.js"), __webpack_require__(/*! ./_base/connect */ "./libraries/dojo/_base/connect.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(exports, dojo, has, lang, dom, style, ctr, conn){
	// module:
	//		dojo/dom-prop
	// summary:
	//		This module defines the core dojo DOM properties API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element properties Functions
	// =============================

	// helper to connect events
	var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
	has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

	exports.names = {
		// properties renamed to avoid clashes with reserved words
		"class": "className",
		"for": "htmlFor",
		// properties written as camelCase
		tabindex: "tabIndex",
		readonly: "readOnly",
		colspan: "colSpan",
		frameborder: "frameBorder",
		rowspan: "rowSpan",
		textcontent: "textContent",
		valuetype: "valueType"
	};
	
	function getText(/*DOMNode*/node){
		// summary:
		//		recursion method for get('textContent') to use. Gets text value for a node.
		// description:
		//		Juse uses nodedValue so things like <br/> tags do not end up in
		//		the text as any sort of line return.
		var text = "", ch = node.childNodes;
		for(var i = 0, n; n = ch[i]; i++){
			//Skip comments.
			if(n.nodeType != 8){
				if(n.nodeType == 1){
					text += getText(n);
				}else{
					text += n.nodeValue;
				}
			}
		}
		return text;
	}

	exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets a property on an HTML element.
		// description:
		//		Handles normalized getting of properties on DOM nodes.
		//
		// node: DOMNode|String
		//		id or reference to the element to get the property on
		// name: String
		//		the name of the property to get.
		// returns:
		//		the value of the requested property or its default value
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
		//	|		domProp.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domProp.get("nodeId", "foo");
		//	|	});

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		
		if(propName == "textContent" && !has("dom-textContent")){
			return getText(node);
		}
		
		return node[propName];	// Anything
	};

	exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets a property on an HTML element.
		// description:
		//		Handles normalized setting of properties on DOM nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the property on
		// name: String|Object
		//		the name of the property to set, or a hash object to set
		//		multiple properties at once.
		// value: String?
		//		The value to set for the property
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST",
		//	|		});
		//	|	});

		node = dom.byId(node);
		var l = arguments.length;
		if(l == 2 && typeof name != "string"){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(propName == "innerHTML"){
			// special case: assigning HTML
			// the hash lists elements with read-only innerHTML on IE
			if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
				ctr.empty(node);
				node.appendChild(ctr.toDom(value, node.ownerDocument));
			}else{
				node[propName] = value;
			}
			return node; // DomNode
		}
		if(propName == "textContent" && !has("dom-textContent")) {
			ctr.empty(node);
			node.appendChild(node.ownerDocument.createTextNode(value));
			return node;
		}
		if(lang.isFunction(value)){
			// special case: assigning an event handler
			// clobber if we can
			var attrId = node[_attrId];
			if(!attrId){
				attrId = _ctr++;
				node[_attrId] = attrId;
			}
			if(!_evtHdlrMap[attrId]){
				_evtHdlrMap[attrId] = {};
			}
			var h = _evtHdlrMap[attrId][propName];
			if(h){
				//h.remove();
				conn.disconnect(h);
			}else{
				try{
					delete node[propName];
				}catch(e){}
			}
			// ensure that event objects are normalized, etc.
			if(value){
				//_evtHdlrMap[attrId][propName] = on(node, propName, value);
				_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
			}else{
				node[propName] = null;
			}
			return node; // DomNode
		}
		node[propName] = value;
		return node;	// DomNode
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom-style.js"
/*!*************************************!*\
  !*** ./libraries/dojo/dom-style.js ***!
  \*************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, dom, win){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			if(node.nodeType === 1 /* ELEMENT_NODE*/){
				var dv = node.ownerDocument.defaultView,
					w = dv.opener ? dv : win.global.window;
				return w.getComputedStyle(node, null);
			}
			return {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	style.getComputedStyle = function(node){
		// summary:
		//		Returns a "computed style" object.
		//
		// description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node.
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
		//		return values.
		//
		// node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		// example:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
		//	|	});
		//
		// example:
		//		Reusing the returned object, avoiding multiple lookups:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
		//	|		var w = cs.width, h = cs.height;
		//	|	});
		return; // CSS2Properties
	};
	=====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	style.toPixelValue = function(node, value){
		// summary:
		//		converts style value to pixels on IE or return a numeric value.
		// node: DOMNode
		// value: String
		// returns: Number
	};
	=====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
		function(node){
			return getComputedStyle(node).opacity;
		};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
		function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/dom.js"
/*!*******************************!*\
  !*** ./libraries/dojo/dom.js ***!
  \*******************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js"), __webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, win, kernel){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id || null;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
			return null;
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	// Test for DOMNode.contains() method, available everywhere except FF8-
	// and IE8-, where it's available in general, but not on document itself,
	// and also problems when either ancestor or node are text nodes.

	var doc = kernel.global["document"] || null;
	has.add("dom-contains", !!(doc && doc.contains));
	dom.isDescendant = has("dom-contains") ?
		// FF9+, IE9+, webkit, opera, iOS, Android, Edge, etc.
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			return !!( (ancestor = dom.byId(ancestor)) && ancestor.contains(dom.byId(node)) );
		} :
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			// summary:
			//		Returns true if node is a descendant of ancestor
			// node: DOMNode|String
			//		string id or node reference to test
			// ancestor: DOMNode|String
			//		string id or node reference of potential parent to test against
			//
			// example:
			//		Test is node id="bar" is a descendant of node id="foo"
			//	|	require(["dojo/dom"], function(dom){
			//	|		if(dom.isDescendant("bar", "foo")){ ... }
			//	|	});

			try{
				node = dom.byId(node);
				ancestor = dom.byId(ancestor);
				while(node){
					if(node == ancestor){
						return true; // Boolean
					}
					node = node.parentNode;
				}
			}catch(e){ /* squelch, return false */ }
			return false; // Boolean
		};

	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	// TODO: The user-select CSS property as of May 2014 is no longer part of
	// any CSS specification. In IE, -ms-user-select does not do the same thing
	// as the unselectable attribute on elements; namely, dijit Editor buttons
	// do not properly prevent the content of the editable content frame from
	// unblurring. As a result, the -ms- prefixed version is omitted here.
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }

		var style = element.style;
		var prefixes = ["Khtml", "O", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/domReady.js"
/*!************************************!*\
  !*** ./libraries/dojo/domReady.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ "./libraries/dojo/global.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(global, has){
	var doc = document,
		readyStates = { 'loaded': 1, 'complete': 1 },
		fixReadyState = typeof doc.readyState != "string",
		ready = !!readyStates[doc.readyState],
		readyQ = [],
		recursiveGuard;

	function domReady(callback){
		// summary:
		//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
		readyQ.push(callback);
		if(ready){ processQ(); }
	}
	domReady.load = function(id, req, load){
		domReady(load);
	};

	// Export queue so that ready() can check if it's empty or not.
	domReady._Q = readyQ;
	domReady._onQEmpty = function(){
		// summary:
		//		Private method overridden by dojo/ready, to notify when everything in the
		//		domReady queue has been processed.  Do not use directly.
		//		Will be removed in 2.0, along with domReady._Q.
	};

	// For FF <= 3.5
	if(fixReadyState){ doc.readyState = "loading"; }

	function processQ(){
		// Calls all functions in the queue in order, unless processQ() is already running, in which case just return

		if(recursiveGuard){ return; }
		recursiveGuard = true;

		while(readyQ.length){
			try{
				(readyQ.shift())(doc);
			}catch(err){
				console.error(err, "in domReady callback", err.stack);
			}
		}

		recursiveGuard = false;

		// Notification for dojo/ready.  Remove for 2.0.
		// Note that this could add more tasks to the ready queue.
		domReady._onQEmpty();
	}

	if(!ready){
		var tests = [],
			detectReady = function(evt){
				evt = evt || global.event;
				if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }

				// For FF <= 3.5
				if(fixReadyState){ doc.readyState = "complete"; }

				ready = 1;
				processQ();
			},
			on = function(node, event){
				node.addEventListener(event, detectReady, false);
				readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
			};

		if(!has("dom-addeventlistener")){
			on = function(node, event){
				event = "on" + event;
				node.attachEvent(event, detectReady);
				readyQ.push(function(){ node.detachEvent(event, detectReady); });
			};

			var div = doc.createElement("div");
			try{
				if(div.doScroll && global.frameElement === null){
					// the doScroll test is only useful if we're in the top-most frame
					tests.push(function(){
						// Derived with permission from Diego Perini's IEContentLoaded
						// http://javascript.nwbox.com/IEContentLoaded/
						try{
							div.doScroll("left");
							return 1;
						}catch(e){}
					});
				}
			}catch(e){}
		}

		on(doc, "DOMContentLoaded");
		on(global, "load");

		if("onreadystatechange" in doc){
			on(doc, "readystatechange");
		}else if(!fixReadyState){
			// if the ready state property exists and there's
			// no readystatechange event, poll for the state
			// to change
			tests.push(function(){
				return readyStates[doc.readyState];
			});
		}

		if(tests.length){
			var poller = function(){
				if(ready){ return; }
				var i = tests.length;
				while(i--){
					if(tests[i]()){
						detectReady("poller");
						return;
					}
				}
				setTimeout(poller, 30);
			};
			poller();
		}
	}

	return domReady;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/errors/CancelError.js"
/*!**********************************************!*\
  !*** ./libraries/dojo/errors/CancelError.js ***!
  \**********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./libraries/dojo/errors/create.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	return create("CancelError", null, null, { dojoType: "cancel", log: false });
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/errors/RequestError.js"
/*!***********************************************!*\
  !*** ./libraries/dojo/errors/RequestError.js ***!
  \***********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./libraries/dojo/errors/create.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/errors/RequestTimeoutError.js"
/*!******************************************************!*\
  !*** ./libraries/dojo/errors/RequestTimeoutError.js ***!
  \******************************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ "./libraries/dojo/errors/create.js"), __webpack_require__(/*! ./RequestError */ "./libraries/dojo/errors/RequestError.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/errors/create.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/errors/create.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/global.js"
/*!**********************************!*\
  !*** ./libraries/dojo/global.js ***!
  \**********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
    if (typeof global !== 'undefined' && typeof global !== 'function') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
    return this;
}).call(null, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },

/***/ "./libraries/dojo/has.js"
/*!*******************************!*\
  !*** ./libraries/dojo/has.js ***!
  \*******************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ "./libraries/dojo/global.js"), __webpack_require__.dj.c(module), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(global, require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(!has("dojo-has-api")){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		has.add("host-browser", isBrowser);
		has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
		has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
		has.add("dom", isBrowser);
		has.add("dojo-dom-ready-api", 1);
		has.add("dojo-sniff", 1);
	}

	if(has("host-browser")){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);

		// Do the device and browser have touch capability?
		has.add("touch", "ontouchstart" in document
			|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
			|| window.navigator.msMaxTouchPoints);

		// Touch events support
		has.add("touch-events", "ontouchstart" in document);

		// Test if pointer events are supported and enabled, with either standard names ("pointerdown" etc.) or
		// IE specific names ("MSPointerDown" etc.).  Tests are designed to work on embedded C# WebBrowser Controls
		// in addition to IE, Edge, and future versions of Firefox and Chrome.
		// Note that on IE11, has("pointer-events") and has("MSPointer") are both true.
		has.add("pointer-events", "pointerEnabled" in window.navigator ?
				window.navigator.pointerEnabled : "PointerEvent" in window);
		has.add("MSPointer", window.navigator.msPointerEnabled);
		// The "pointermove"" event is only continuously emitted in a touch environment if
		// the target node's "touch-action"" CSS property is set to "none"
		// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property
		has.add("touch-action", has("touch") && has("pointer-events"));

		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/io-query.js"
/*!************************************!*\
  !*** ./libraries/dojo/io-query.js ***!
  \************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang){

	// module:
	//		dojo/io-query

	var backstop = {};

	return {
		// summary:
		//		This module defines query string processing functions.

		objectToQuery: function objectToQuery(/*Object*/ map){
			// summary:
			//		takes a name/value mapping object and returns a string representing
			//		a URL-encoded version of that object.
			// example:
			//		this object:
			//
			//	|	{
			//	|		blah: "blah",
			//	|		multi: [
			//	|			"thud",
			//	|			"thonk"
			//	|		]
			//	|	};
			//
			//		yields the following query string:
			//
			//	|	"blah=blah&multi=thud&multi=thonk"

			// FIXME: need to implement encodeAscii!!
			var enc = encodeURIComponent, pairs = [];
			for(var name in map){
				var value = map[name];
				if(value != backstop[name]){
					var assign = enc(name) + "=";
					if(lang.isArray(value)){
						for(var i = 0, l = value.length; i < l; ++i){
							pairs.push(assign + enc(value[i]));
						}
					}else{
						pairs.push(assign + enc(value));
					}
				}
			}
			return pairs.join("&"); // String
		},

		queryToObject: function queryToObject(/*String*/ str){
			// summary:
			//		Create an object representing a de-serialized query section of a
			//		URL. Query keys with multiple values are returned in an array.
			//
			// example:
			//		This string:
			//
			//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
			//
			//		results in this object structure:
			//
			//	|		{
			//	|			foo: [ "bar", "baz" ],
			//	|			thinger: " spaces =blah",
			//	|			zonk: "blarg"
			//	|		}
			//
			//		Note that spaces and other urlencoded entities are correctly
			//		handled.

        	var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
			for(var i = 0, l = qp.length, item; i < l; ++i){
				item = qp[i];
				if(item.length){
					var s = item.indexOf("=");
					if(s < 0){
						name = dec(item);
						val = "";
					}else{
						name = dec(item.slice(0, s));
						val = dec(item.slice(s + 1));
					}
					if(typeof ret[name] == "string"){ // inline'd type check
						ret[name] = [ret[name]];
					}

					if(lang.isArray(ret[name])){
						ret[name].push(val);
					}else{
						ret[name] = val;
					}
				}
			}
			return ret; // Object
		}
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);

/***/ },

/***/ "./libraries/dojo/json.js"
/*!********************************!*\
  !*** ./libraries/dojo/json.js ***!
  \********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ "./libraries/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/keys.js"
/*!********************************!*\
  !*** ./libraries/dojo/keys.js ***!
  \********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/mouse.js"
/*!*********************************!*\
  !*** ./libraries/dojo/mouse.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/on.js"
/*!******************************!*\
  !*** ./libraries/dojo/on.js ***!
  \******************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__.dj.h(/*! ./has!dom-addeventlistener?:./aspect */"dom-addeventlistener?:./libraries/dojo/aspect.js"), __webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(aspect, dojo, has){

	"use strict";
	if(has("dom")){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			return 'onfocusin' in element;
		});

		if(has("touch")){
			has.add("touch-can-modify-event-delegate", function(){
				// This feature test checks whether deleting a property of an event delegate works
				// for a touch-enabled device. If it works, event delegation can be used as fallback
				// for browsers such as Safari in older iOS where deleting properties of the original
				// event does not work.
				var EventDelegate = function(){};
				EventDelegate.prototype =
					document.createEvent("MouseEvents"); // original event
				// Attempt to modify a property of an event delegate and check if
				// it succeeds. Depending on browsers and on whether dojo/on's
				// strict mode is stripped in a Dojo build, there are 3 known behaviors:
				// it may either succeed, or raise an error, or fail to set the property
				// without raising an error.
				try{
					var eventDelegate = new EventDelegate;
					eventDelegate.target = null;
					return eventDelegate.target === null;
				}catch(e){
					return false; // cannot use event delegation
				}
			});
		}
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(on){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(on, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		var events;
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type instanceof Array){
			// allow an array of event names (or event handler functions)
			events = type;
		}else if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			events = type.split(/\s*,\s*/);
		}
		if(events){
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){ // intentional assignment
				handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1,
				//but works through "resize" on window
				type = "resize";
				target = window;
				listener = fixTouchListener(listener);
			}
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}
	on.matches = function(node, selector, context, children, matchesTarget) {
		// summary:
		//		Check if a node match the current selector within the constraint of a context
		// node: DOMNode
		//		The node that originate the event
		// selector: String
		//		The selector to check against
		// context: DOMNode
		//		The context to search in.
		// children: Boolean
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// matchesTarget: Object|dojo/query?
		//		An object with a property "matches" as a function. Default is dojo/query.
		//		Matching DOMNodes will be done against this function
		//		The function must return a Boolean.
		//		It will have 3 arguments: "node", "selector" and "context"
		//		True is expected if "node" is matching the current "selector" in the passed "context"
		// returns: DOMNode?
		//		The matching node, if any. Else you get false

		// see if we have a valid matchesTarget or default to dojo/query
		matchesTarget = matchesTarget && (typeof matchesTarget.matches == "function") ? matchesTarget : dojo.query;
		children = children !== false;
		// there is a selector, so make sure it matches
		if(node.nodeType != 1){
			// text node will fail in native match selector
			node = node.parentNode;
		}
		while(!matchesTarget.matches(node, selector, context)){
			if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
				return false;
			}
		}
		return node;
	};
	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(on, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				return on.matches(eventTarget, selector, target, children, matchesTarget);
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				if (eventTarget) {
					// We save the matching target into the event, so it can be accessed even when hitching (see #18355)
					event.selectorTarget = eventTarget;
					return listener.call(eventTarget, event);
				}
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		};
	}
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event
				// we could create branch into the different types of event constructors, but
				// that would be a lot of extra code, with little benefit that I can see, seems
				// best to use the generic constructor and copy properties over, making it
				// easy to have events look like the ones created with specific initializers
				var ownerDocument = target.ownerDocument || document;
				var nativeEvent = ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||
						has("jscript") < 5.8) &&
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){
		var EventDelegate = function(){};
		var windowOrientation = window.orientation;
		var fixTouchListener = function(listener){
			return function(originalEvent){
				//Event normalization(for ontouchxxx and resize):
				//1.incorrect e.pageX|pageY in iOS
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
					}catch(e){}
					if(originalEvent.type){
						// Deleting the property of the original event did not work (this is the case of
						// browsers such as older Safari iOS), hence fallback:
						if(has("touch-can-modify-event-delegate")){
							// If deleting properties of delegated event works, use event delegation:
							EventDelegate.prototype = originalEvent;
							event = new EventDelegate;
						}else{
							// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
							// delegated properties, so we have to copy
							event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){
							return null;//double tap causes an unexpected 'resize' in Android
						}
						windowOrientation = window.orientation;
						event.type = "orientationchange";
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0;
						event.scale = 1;
					}
					if (window.TouchEvent && originalEvent instanceof TouchEvent) {
						// use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
						var firstChangeTouch = event.changedTouches[0];
						for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
							delete event[i]; // delete it first to make it mutable
							event[i] = firstChangeTouch[i];
						}
					}
				}
				return listener.call(this, event);
			};
		};
	}
	return on;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/parser.js"
/*!**********************************!*\
  !*** ./libraries/dojo/parser.js ***!
  \**********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__.dj.c(module), __webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./_base/array */ "./libraries/dojo/_base/array.js"), __webpack_require__(/*! ./_base/config */ "./libraries/dojo/_base/config.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js"),
		__webpack_require__(/*! ./_base/url */ "./libraries/dojo/_base/url.js"), __webpack_require__(/*! ./aspect */ "./libraries/dojo/aspect.js"), __webpack_require__(/*! ./promise/all */ "./libraries/dojo/promise/all.js"), __webpack_require__(/*! ./date/stamp */ "./libraries/dojo/date/stamp.js"), __webpack_require__(/*! ./Deferred */ "./libraries/dojo/Deferred.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./query */ "./libraries/dojo/query.js"), __webpack_require__(/*! ./on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ./ready */ "./libraries/dojo/ready.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval("(" + text + ")");
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		if(!contextRequire){
			contextRequire = require;
		}

		// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
		// Keep separate map for each requireContext to avoid false matches (ex: "./Foo" can mean different things
		// depending on context.)
		var ctorMap = contextRequire._dojoParserCtorMap || (contextRequire._dojoParserCtorMap = {});

		var ts = types.join();
		if(!ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (ctorMap[t] = ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					contextRequire(t))));
			}
			var ctor = mixins.shift();
			ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojotype";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			if(rootNode && typeof rootNode != "string" && !("nodeType" in rootNode)){
				// If called as parse(options) rather than parse(), parse(rootNode), or parse(rootNode, options)...
				options = rootNode;
				rootNode = options.rootNode;
			}
			var root = rootNode ? dom.byId(rootNode) : dwindow.body();
			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if(has("extend-dojo")){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/promise/Promise.js"
/*!*******************************************!*\
  !*** ./libraries/dojo/promise/Promise.js ***!
  \*******************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		"finally": function(callback) {
			// summary:
			//		Add a callback to the promise that will fire whether it
			//		resolves or rejects.
			// description:
			//		Conforms to ES2018's `Promise.prototype.finally`.
			//		Add a callback to the promise that will fire whether it
			//		resolves or rejects. No value is passed to the callback.
			//		Returns a promise that reflects the state of the original promise,
			//		with two exceptions:
			//		- If the callback return a promise, the outer promise will wait
			//		until the returned promise is resolved, then it will resolve
			//		with the original value.
			//		- If the callback throws an exception or returns a promise that
			//		is rejected (or rejects later), the outer promise will reject
			//		with the inner promise's rejection reason.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved
			//		or rejected. Doesn't receive any value.
			// returns: dojo/promise/Promise
			//		Returns a new promise that reflects the state of the original promise,
			//		with two small exceptions (see description).
			//

			return this.then(function (value){
				var valueOrPromise = callback();
				if (valueOrPromise && typeof valueOrPromise.then === "function"){
					return valueOrPromise.then(function (){
						return value;
					});
				}
				return value;
			}, function(reason) {
				var valueOrPromise = callback();
				if (valueOrPromise && typeof valueOrPromise.then === "function"){
					return valueOrPromise.then(function (){
						throw reason;
					});
				}
				throw reason;
			});
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		"catch": function(errback){
		    // summary:
		    //		Add new errbacks to the promise. Follows ECMA specification naming.
		    // errback: Function?
		    //		Callback to be invoked when the promise is rejected.
		    // returns: dojo/promise/Promise
		    //		Returns a new promise for the result of the errback.

		    return this.then(null, errback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/promise/all.js"
/*!***************************************!*\
  !*** ./libraries/dojo/promise/all.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js"),
	__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! ../Deferred */ "./libraries/dojo/Deferred.js"),
	__webpack_require__(/*! ../when */ "./libraries/dojo/when.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, lang, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(lang.isArray(objectOrArray)){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/promise/first.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/promise/first.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js"),
	__webpack_require__(/*! ../Deferred */ "./libraries/dojo/Deferred.js"),
	__webpack_require__(/*! ../when */ "./libraries/dojo/when.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/first

	var forEach = array.forEach;

	return function first(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when the first of these promises is fulfilled.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when the first of these promises is fulfilled. Canceling the returned
		//		promise will *not* cancel any passed promises. The promise will be
		//		fulfilled with the value of the first fulfilled promise.
		// objectOrArray: Object|Array?
		//		The promises are taken from the array or object values. If no value
		//		is passed, the returned promise is resolved with an undefined value.
		// returns: dojo/promise/Promise

		var array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			array = [];
			for(var key in objectOrArray){
				if(Object.hasOwnProperty.call(objectOrArray, key)){
					array.push(objectOrArray[key]);
				}
			}
		}

		if(!array || !array.length){
			return new Deferred().resolve();
		}

		var deferred = new Deferred();
		forEach(array, function(valueOrPromise){
			when(valueOrPromise, deferred.resolve, deferred.reject);
		});
		return deferred.promise;	// dojo/promise/Promise
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/promise/instrumentation.js"
/*!***************************************************!*\
  !*** ./libraries/dojo/promise/instrumentation.js ***!
  \***************************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./tracer */ "./libraries/dojo/promise/tracer.js"),
	__webpack_require__(/*! ../has */ "./libraries/dojo/has.js"),
	__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(tracer, has, lang, arrayUtil){
	has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");

	function logError(error, rejection, deferred){
		if(error && error.log === false){
			return;
		}
		var stack = "";
		if(error && error.stack){
			stack += error.stack;
		}
		if(rejection && rejection.stack){
			stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
		}
		if(deferred && deferred.stack){
			stack += "\n    ----------------------------------------\n" + deferred.stack;
		}
		console.error(error, stack);
	}

	function reportRejections(error, handled, rejection, deferred){
		if(!handled){
			logError(error, rejection, deferred);
		}
	}

	var errors = [];
	var activeTimeout = false;
	var unhandledWait = 1000;
	function trackUnhandledRejections(error, handled, rejection, deferred){
		// try to find the existing tracking object
		if(!arrayUtil.some(errors, function(obj){
			if(obj.error === error){
				// found the tracking object for this error
				if(handled){
					// if handled, update the state
					obj.handled = true;
				}
				return true;
			}
		})){
			// no tracking object has been setup, create one
			errors.push({
				error: error,
				rejection: rejection,
				handled: handled,
				deferred: deferred,
				timestamp: new Date().getTime()
			});
		}

		if(!activeTimeout){
			activeTimeout = setTimeout(logRejected, unhandledWait);
		}
	}

	function logRejected(){
		var now = new Date().getTime();
		var reportBefore = now - unhandledWait;
		errors = arrayUtil.filter(errors, function(obj){
			// only report the error if we have waited long enough and
			// it hasn't been handled
			if(obj.timestamp < reportBefore){
				if(!obj.handled){
					logError(obj.error, obj.rejection, obj.deferred);
				}
				return false;
			}
			return true;
		});

		if(errors.length){
			activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
		}else{
			activeTimeout = false;
		}
	}

	return function(Deferred){
		// summary:
		//		Initialize instrumentation for the Deferred class.
		// description:
		//		Initialize instrumentation for the Deferred class.
		//		Done automatically by `dojo/Deferred` if the
		//		`deferredInstrumentation` and `useDeferredInstrumentation`
		//		config options are set.
		//
		//		Sets up `dojo/promise/tracer` to log to the console.
		//
		//		Sets up instrumentation of rejected deferreds so unhandled
		//		errors are logged to the console.

		var usage = has("config-useDeferredInstrumentation");
		if(usage){
			tracer.on("resolved", lang.hitch(console, "log", "resolved"));
			tracer.on("rejected", lang.hitch(console, "log", "rejected"));
			tracer.on("progress", lang.hitch(console, "log", "progress"));

			var args = [];
			if(typeof usage === "string"){
				args = usage.split(",");
				usage = args.shift();
			}
			if(usage === "report-rejections"){
				Deferred.instrumentRejected = reportRejections;
			}else if(usage === "report-unhandled-rejections" || usage === true || usage === 1){
				Deferred.instrumentRejected = trackUnhandledRejections;
				unhandledWait = parseInt(args[0], 10) || unhandledWait;
			}else{
				throw new Error("Unsupported instrumentation usage <" + usage + ">");
			}
		}
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/promise/tracer.js"
/*!******************************************!*\
  !*** ./libraries/dojo/promise/tracer.js ***!
  \******************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! ./Promise */ "./libraries/dojo/promise/Promise.js"),
	__webpack_require__(/*! ../Evented */ "./libraries/dojo/Evented.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang, Promise, Evented){
	"use strict";

	// module:
	//		dojo/promise/tracer

	/*=====
	return {
		// summary:
		//		Trace promise fulfillment.
		// description:
		//		Trace promise fulfillment. Calling `.trace()` or `.traceError()` on a
		//		promise enables tracing. Will emit `resolved`, `rejected` or `progress`
		//		events.

		on: function(type, listener){
			// summary:
			//		Subscribe to traces.
			// description:
			//		See `dojo/Evented#on()`.
			// type: String
			//		`resolved`, `rejected`, or `progress`
			// listener: Function
			//		The listener is passed the traced value and any arguments
			//		that were used with the `.trace()` call.
		}
	};
	=====*/

	var evented = new Evented;
	var emit = evented.emit;
	evented.emit = null;
	// Emit events asynchronously since they should not change the promise state.
	function emitAsync(args){
		setTimeout(function(){
			emit.apply(evented, args);
		}, 0);
	}

	Promise.prototype.trace = function(){
		// summary:
		//		Trace the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `trace()` is called on.

		var args = lang._toArray(arguments);
		this.then(
			function(value){ emitAsync(["resolved", value].concat(args)); },
			function(error){ emitAsync(["rejected", error].concat(args)); },
			function(update){ emitAsync(["progress", update].concat(args)); }
		);
		return this;
	};

	Promise.prototype.traceRejected = function(){
		// summary:
		//		Trace rejection of the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `traceRejected()` is called on.

		var args = lang._toArray(arguments);
		this.otherwise(function(error){
			emitAsync(["rejected", error].concat(args));
		});
		return this;
	};

	return evented;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/query.js"
/*!*********************************!*\
  !*** ./libraries/dojo/query.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ./_base/array */ "./libraries/dojo/_base/array.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./selector/_loader */ "./libraries/dojo/selector/_loader.js"), __webpack_require__(/*! ./selector/_loader!default */ "./libraries/dojo/selector/lite.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/ready.js"
/*!*********************************!*\
  !*** ./libraries/dojo/ready.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__.dj.c(module), __webpack_require__(/*! ./domReady */ "./libraries/dojo/domReady.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, has, require, domReady, lang){
	// module:
	//		dojo/ready
	// note:
	//		This module should be unnecessary in dojo 2.0

	var
		// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
		isDomReady = 0,

		// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
		loadQ = [],

		// prevent recursion in onLoad
		onLoadRecursiveGuard = 0,

		handleDomReady = function(){
			isDomReady = 1;
			dojo._postLoad = dojo.config.afterOnLoad = true;
			onEvent();
		},

		onEvent = function(){
			// Called when some state changes:
			//		- dom ready
			//		- dojo/domReady has finished processing everything in its queue
			//		- task added to loadQ
			//		- require() has finished loading all currently requested modules
			//
			// Run the functions queued with dojo.ready if appropriate.


			//guard against recursions into this function
			if(onLoadRecursiveGuard){
				return;
			}
			onLoadRecursiveGuard = 1;

			// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
			// pending tasks registered via domReady().
			// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
			// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
			// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
			while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
				var f = loadQ.shift();
				try{
					f();
				}catch(e){
					// force the dojo.js on("error") handler do display the message
					e.info = e.message;
					if(require.signal){
						require.signal("error", e);
					}else{
						throw e;
					}
				}
			}

			onLoadRecursiveGuard = 0;
		};

	// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
	// finishes processing it's queue.
	require.on && require.on("idle", onEvent);
	if(domReady){
		domReady._onQEmpty = onEvent;
	}

	var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
		// summary:
		//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
		//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
		//
		//		When called in a non-browser environment, just checks that all requested modules have arrived and been
		//		evaluated.
		// priority: Integer?
		//		The order in which to exec this callback relative to other callbacks, defaults to 1000
		// context: Object?|Function
		//		The context in which to run execute callback, or a callback if not using context
		// callback: Function?
		//		The function to execute.
		//
		// example:
		//	Simple DOM and Modules ready syntax
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(function(){ alert("Dom ready!"); });
		//	|	});
		//
		// example:
		//	Using a priority
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(2, function(){ alert("low priority ready!"); })
		//	|	});
		//
		// example:
		//	Using context
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(foo, function(){
		//	|			// in here, this == foo
		//	|		});
		//	|	});
		//
		// example:
		//	Using dojo/hitch style args:
		//	|	require(["dojo/ready"], function(ready){
		//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		//	|		ready(foo, "dojoReady");
		//	|	});

		var hitchArgs = lang._toArray(arguments);
		if(typeof priority != "number"){
			callback = context;
			context = priority;
			priority = 1000;
		}else{
			hitchArgs.shift();
		}
		callback = callback ?
			lang.hitch.apply(dojo, hitchArgs) :
			function(){
				context();
			};
		callback.priority = priority;
		for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
		loadQ.splice(i, 0, callback);
		onEvent();
	};

	has.add("dojo-config-addOnLoad", 1);
	if(has("dojo-config-addOnLoad")){
		var dca = dojo.config.addOnLoad;
		if(dca){
			ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
		}
	}

	if(has("dojo-sync-loader") && dojo.config.parseOnLoad && !dojo.isAsync){
		ready(99, function(){
			if(!dojo.parser){
				dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
				Promise.resolve(/*! AMD require */).then(function() {[__webpack_require__(/*! dojo/parser */ "./libraries/dojo/parser.js")];})['catch'](__webpack_require__.oe);
			}
		});
	}

	if(domReady){
		domReady(handleDomReady);
	}else{
		handleDomReady();
	}

	return ready;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/request.js"
/*!***********************************!*\
  !*** ./libraries/dojo/request.js ***!
  \***********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./request/default! */ "./libraries/dojo/request/xhr.js")/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/request/handlers.js"
/*!********************************************!*\
  !*** ./libraries/dojo/request/handlers.js ***!
  \********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../json */ "./libraries/dojo/json.js"),
	__webpack_require__(/*! ../_base/kernel */ "./libraries/dojo/_base/kernel.js"),
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js"),
	__webpack_require__(/*! ../has */ "./libraries/dojo/has.js"),
	__webpack_require__(/*! ./node_modules/dojo-webpack-plugin/lib/NoModule.js */ "./node_modules/dojo-webpack-plugin/lib/NoModule.js") // only included for has() qsa tests
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];
		var lastParser;

		handleXML = function(response){
			var result = response.data;
			var text = response.text;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(text, 'application/xml');
			}

			function createDocument(p) {
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
						lastParser = p;
					}catch(e){ return false; }
					return true;
			}

			if(!result || !result.documentElement){
				// The creation of an ActiveX object is expensive, so we cache the
				// parser type to avoid trying all parser types each time we handle a
				// document. There is some concern that some parser types might fail
				// depending on the document being parsed. If parsing using the cached
				// parser type fails, we do the more expensive operation of finding one
				// that works for the given document.
				// https://bugs.dojotoolkit.org/ticket/15246
				if(!lastParser || !createDocument(lastParser)) {
					array.some(dp, createDocument);
				}
			}

			return result;
		};
	}

	var handleNativeResponse = function(response) {
		if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
			return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
		}

		return response.xhr.response;
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML,
		'blob': handleNativeResponse,
		'arraybuffer': handleNativeResponse,
		'document': handleNativeResponse
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/request/util.js"
/*!****************************************!*\
  !*** ./libraries/dojo/request/util.js ***!
  \****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	exports,
	__webpack_require__(/*! ../errors/RequestError */ "./libraries/dojo/errors/RequestError.js"),
	__webpack_require__(/*! ../errors/CancelError */ "./libraries/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ../Deferred */ "./libraries/dojo/Deferred.js"),
	__webpack_require__(/*! ../io-query */ "./libraries/dojo/io-query.js"),
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js"),
	__webpack_require__(/*! ../_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! ../promise/Promise */ "./libraries/dojo/promise/Promise.js"),
	__webpack_require__(/*! ../has */ "./libraries/dojo/has.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise, has){

	function isArrayBuffer(value) {
		return has('native-arraybuffer') && value instanceof ArrayBuffer
	}

	function isBlob(value) {
		return has('native-blob') && value instanceof Blob
	}
	
	function isElement(value) {
		if(typeof Element !== 'undefined') { //all other
			return value instanceof Element;
		}

		//IE<=7
		return value.nodeType === 1;
	}

	function isFormData(value) {
		return has('native-formdata') && value instanceof FormData;
	}

	function shouldDeepCopy(value) {
		return value &&
			typeof value === 'object' &&
			!isFormData(value) &&
			!isElement(value) &&
			!isBlob(value) &&
			!isArrayBuffer(value)
	}

	exports.deepCopy = function(target, source) {
		for (var name in source) {
			var tval = target[name],
  			    sval = source[name];
			if (name !== '__proto__' && tval !== sval) {
				if (shouldDeepCopy(sval)) {
					if (Object.prototype.toString.call(sval) === '[object Date]') { // use this date test to handle crossing frame boundaries
						target[name] = new Date(sval);
					} else if (lang.isArray(sval)) {
 						  target[name] = exports.deepCopyArray(sval);
					} else {
						if (tval && typeof tval === 'object') {
							exports.deepCopy(tval, sval);
						} else {
							target[name] = exports.deepCopy({}, sval);
						}
					}
				} else {
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCopyArray = function(source) {
		var clonedArray = [];
		for (var i = 0, l = source.length; i < l; i++) {
			var svalItem = source[i];
			if (typeof svalItem === 'object') {
				clonedArray.push(exports.deepCopy({}, svalItem));
			} else {
				clonedArray.push(svalItem);
			}
		}

		return clonedArray;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data !== undefined ? response.data : response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;

		if(data && !skipData){
			if(typeof data === 'object' && (!(has('native-xhr2')) || !(isArrayBuffer(data) || isBlob(data) ))){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/request/watch.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/request/watch.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./util */ "./libraries/dojo/request/util.js"),
	__webpack_require__(/*! ../errors/RequestTimeoutError */ "./libraries/dojo/errors/RequestTimeoutError.js"),
	__webpack_require__(/*! ../errors/CancelError */ "./libraries/dojo/errors/CancelError.js"),
	__webpack_require__(/*! ../_base/array */ "./libraries/dojo/_base/array.js"),
	__webpack_require__(/*! ../_base/window */ "./libraries/dojo/_base/window.js"),
	__webpack_require__.dj.h(/*! ../has!host-browser?dom-addeventlistener?:../on: */"dom-addeventlistener?:./libraries/dojo/on.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/request/xhr.js"
/*!***************************************!*\
  !*** ./libraries/dojo/request/xhr.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ../errors/RequestError */ "./libraries/dojo/errors/RequestError.js"),
	__webpack_require__(/*! ./watch */ "./libraries/dojo/request/watch.js"),
	__webpack_require__(/*! ./handlers */ "./libraries/dojo/request/handlers.js"),
	__webpack_require__(/*! ./util */ "./libraries/dojo/request/util.js"),
	__webpack_require__(/*! ../has */ "./libraries/dojo/has.js")/*=====,
	'../request',
	'../_base/declare' =====*/
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr') || has('dojo-force-activex-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData !== 'undefined';
	});

	has.add('native-blob', function(){
		// if true, the environment has a native Blob implementation
		return typeof Blob !== 'undefined';
	});

	has.add('native-arraybuffer', function(){
		// if true, the environment has a native ArrayBuffer implementation
		return typeof ArrayBuffer !== 'undefined';
	});

	has.add('native-response-type', function(){
		return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
	});

	has.add('native-xhr2-blob', function(){
		if(!has('native-response-type')){ return; }
		var x = new XMLHttpRequest();
		// The URL used here does not have to be reachable as the XHR's `send` method is never called.
		// It does need to be parsable/resolvable in all cases, so it should be an absolute URL.
		// XMLHttpRequest within a Worker created from a Blob does not support relative URL paths.
		x.open('GET', 'https://dojotoolkit.org/', true);
		x.responseType = 'blob';
		// will not be set if unsupported
		var responseType = x.responseType;
		x.abort();
		return responseType === 'blob';
	});

	// Google Chrome doesn't support "json" response type
	// up to version 30, so it's intentionally not included here
	var nativeResponseTypes = {
		'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
		'document': 'document',
		'arraybuffer': 'arraybuffer'
	};

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;

		try {
			// Firefox throws an error when trying to access
			// xhr.responseText if response isn't text
			response.text = _xhr.responseText;
		} catch (e) {}

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		var handleError;
		if(error){
			this.reject(error);
		}else{
			try{
				handlers(response);
			}catch(e){
				handleError = e;
			}
			if(util.checkStatus(_xhr.status)){
				if(!handleError){
					this.resolve(response);
				}else{
					this.reject(handleError);
				}
			}else{
				if(!handleError){
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
					this.reject(error);
				}else{
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status +
						' and an error in handleAs: transformation of response', response);
					this.reject(error);
				}
			}
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response, uploadProgress){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(transferType, evt){
				response.transferType = transferType;
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				} else if(response.xhr.readyState === 3){
					response.loaded = ('loaded' in evt) ? evt.loaded : evt.position;
					dfd.progress(response);
				}
			}

			function onDownloadProgress(evt) {
				return onProgress('download', evt);
			}

			function onUploadProgress(evt) {
				return onProgress('upload', evt);
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onDownloadProgress, false);

			if (uploadProgress && _xhr.upload) {
				_xhr.upload.addEventListener('progress', onUploadProgress, false);
			}

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onDownloadProgress, false);
				_xhr.upload.removeEventListener('progress', onUploadProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			isFormData
		);
		url = response.url;
		options = response.options;
		var hasNoData = !options.data && options.method !== 'POST' && options.method !== 'PUT';

		if(has('ie') <= 10){
			// older IE breaks point 9 in http://www.w3.org/TR/XMLHttpRequest/#the-open()-method and sends fragment, so strip it
			url = url.split('#')[0];
		}

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response, options.uploadProgress);
		}

		// IE11 treats data: undefined different than other browsers
		var data = typeof(options.data) === 'undefined' ? null : options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
				_xhr.responseType = nativeResponseTypes[options.handleAs];
			}

			var headers = options.headers,
				contentType = (isFormData || hasNoData) ? false : 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
		// uploadProgress: Boolean?
		//		Upload progress events cause preflighted requests. This
		//		option enables upload progress event support but also
		//		causes all requests to be preflighted.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/selector/_loader.js"
/*!********************************************!*\
  !*** ./libraries/dojo/selector/_loader.js ***!
  \********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__.dj.c(module)], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, require){

"use strict";
if (typeof document !== "undefined") {
	var testDiv = document.createElement("div");
	has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
	has.add("dom-qsa3", function(){
		// test to see if we have a reasonable native selector engine available
		try{
			testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
			// Safari can't handle uppercase or unicode characters when
			// in quirks mode, IE8 can't handle pseudos like :empty
			return testDiv.querySelectorAll(".TEST:empty").length == 1;
		}catch(e){}
	});
}

var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		if (config && config.isBuild) {
			//Indicate that the optimizer should not wait
			//for this resource any more and complete optimization.
			//This resource will be resolved dynamically during
			//run time in the web browser.
			loaded();
			return;
		}

		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/selector/lite.js"
/*!*****************************************!*\
  !*** ./libraries/dojo/selector/lite.js ***!
  \*****************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ../_base/kernel */ "./libraries/dojo/_base/kernel.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		var isInsideDomTree = has('ie') === 8 && has('quirks')?
			root.nodeType === doc.nodeType:
			root.parentNode !== null && root.nodeType !== 9 && root.parentNode === doc;

		// fast path regardless of whether or not querySelectorAll exists
		if(match[2] && isInsideDomTree){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/sniff.js"
/*!*********************************!*\
  !*** ./libraries/dojo/sniff.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ "./libraries/dojo/has.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(has){
	// module:
	//		dojo/sniff

	/*=====
	return function(){
		// summary:
		//		This module sets has() flags based on the current browser.
		//		It returns the has() function.
	};
	=====*/

	if(has("host-browser")){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
				&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
				&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
				&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
					&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/string.js"
/*!**********************************!*\
  !*** ./libraries/dojo/string.js ***!
  \**********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"),	// kernel.global
	__webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//		The special sequence `${}` can be used escape `$`.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			if (key == ''){
				return '$';
			}
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			var result = transform(value, key);

			if (typeof result === 'undefined') {
				throw new Error('string.substitute could not find key "' + key + '" in template');
			}

			return result.toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/text.js"
/*!********************************!*\
  !*** ./libraries/dojo/text.js ***!
  \********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__.dj.c(module), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./request */ "./libraries/dojo/request.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if(has("host-browser")){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);



/***/ },

/***/ "./libraries/dojo/topic.js"
/*!*********************************!*\
  !*** ./libraries/dojo/topic.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./Evented */ "./libraries/dojo/Evented.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/touch.js"
/*!*********************************!*\
  !*** ./libraries/dojo/touch.js ***!
  \*********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/kernel */ "./libraries/dojo/_base/kernel.js"), __webpack_require__(/*! ./aspect */ "./libraries/dojo/aspect.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-class */ "./libraries/dojo/dom-class.js"), __webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./on */ "./libraries/dojo/on.js"), __webpack_require__(/*! ./has */ "./libraries/dojo/has.js"), __webpack_require__(/*! ./mouse */ "./libraries/dojo/mouse.js"), __webpack_require__(/*! ./domReady */ "./libraries/dojo/domReady.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			};
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			};
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}

	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.

		if(mouse.isRight(e)){
			return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
		}

		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				}

				win.doc.addEventListener(moveType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						function createMouseEvent(type){
							//create the synthetic event.
							//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
							var evt = document.createEvent("MouseEvents");
							evt._dojo_click = true;
							evt.initMouseEvent(type,
								true, //bubbles
								true, //cancelable
								e.view,
								e.detail,
								src.screenX,
								src.screenY,
								src.clientX,
								src.clientY,
								e.ctrlKey,
								e.altKey,
								e.shiftKey,
								e.metaKey,
								0, //button
								null //related target
							);
							return evt;
						}
						var mouseDownEvt = createMouseEvent("mousedown");
						var mouseUpEvt = createMouseEvent("mouseup");
						var clickEvt = createMouseEvent("click");

						setTimeout(function(){
							on.emit(target, "mousedown", mouseDownEvt);
							on.emit(target, "mouseup", mouseUpEvt);
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						var target = e.target;
						if(clickTracker && !e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(target.tagName == "INPUT" && domClass.contains(target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" &&
								(target.tagName != "INPUT" ||
								(target.type == "radio" &&
									// #18352 Do not preventDefault for radios that are not dijit or
									// dojox/mobile widgets.
									// (The CSS class dijitCheckBoxInput holds for both checkboxes and radio buttons.)
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblRadioButton"))) ||
								(target.type == "checkbox" &&
									// #18352 Do not preventDefault for checkboxes that are not dijit or
									// dojox/mobile widgets.
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblCheckBox")))) &&
								target.tagName != "TEXTAREA" && target.tagName != "AUDIO" && target.tagName != "VIDEO"){
								// preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								// but it is still needed for checkboxes and radio buttons, otherwise in some cases
								// the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(has("touch")){
		if(hasPointer){
			// MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener(pointer.down, function(evt){
					doClicks(evt, pointer.move, pointer.up);
				}, true);
			});
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
						lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});

					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}

				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
						lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	has("extend-dojo") && (dojo.touch = touch);

	return touch;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/when.js"
/*!********************************!*\
  !*** ./libraries/dojo/when.js ***!
  \********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! ./Deferred */ "./libraries/dojo/Deferred.js"),
	__webpack_require__(/*! ./promise/Promise */ "./libraries/dojo/promise/Promise.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/dojo/window.js"
/*!**********************************!*\
  !*** ./libraries/dojo/window.js ***!
  \**********************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./_base/lang */ "./libraries/dojo/_base/lang.js"), __webpack_require__(/*! ./sniff */ "./libraries/dojo/sniff.js"), __webpack_require__(/*! ./_base/window */ "./libraries/dojo/_base/window.js"), __webpack_require__(/*! ./dom */ "./libraries/dojo/dom.js"), __webpack_require__(/*! ./dom-geometry */ "./libraries/dojo/dom-geometry.js"), __webpack_require__(/*! ./dom-style */ "./libraries/dojo/dom-style.js"), __webpack_require__(/*! ./dom-construct */ "./libraries/dojo/dom-construct.js")], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie") || has("trident"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
						&& ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){
							elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
						}
						elPos.x = 0;
						elPos.y = 0;
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	has("extend-dojo") && lang.setObject("dojo.window", window);

	return window;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./libraries/put-selector/put.js"
/*!***************************************!*\
  !*** ./libraries/put-selector/put.js ***!
  \***************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(define){
var forDocument, fragmentFasterHeuristic = /[-+,> ]/; // if it has any of these combinators, it is probably going to be faster with a document fragment 
define([], forDocument = function(doc, newFragmentFasterHeuristic){
"use strict";
	// module:
	//		put-selector/put
	// summary:
	//		This module defines a fast lightweight function for updating and creating new elements
	//		terse, CSS selector-based syntax. The single function from this module creates
	// 		new DOM elements and updates existing elements. See README.md for more information.
	//	examples:
	//		To create a simple div with a class name of "foo":
	//		|	put("div.foo");
	fragmentFasterHeuristic = newFragmentFasterHeuristic || fragmentFasterHeuristic;
	var selectorParse = /(?:\s*([-+ ,<>]))?\s*(\.|!\.?|#)?([-\w\u00A0-\uFFFF%$|]+)?(?:\[([^\]=]+)=?['"]?([^\]'"]*)['"]?\])?/g,
		undefined, namespaceIndex, namespaces = false,
		doc = doc || document,
		ieCreateElement = typeof doc.createElement == "object"; // telltale sign of the old IE behavior with createElement that does not support later addition of name 
	function insertTextNode(element, text){
		element.appendChild(doc.createTextNode(text));
	}
	function put(topReferenceElement){
		var fragment, lastSelectorArg, nextSibling, referenceElement, current,
			args = arguments,
			returnValue = args[0]; // use the first argument as the default return value in case only an element is passed in
		function insertLastElement(){
			// we perform insertBefore actions after the element is fully created to work properly with 
			// <input> tags in older versions of IE that require type attributes
			//	to be set before it is attached to a parent.
			// We also handle top level as a document fragment actions in a complex creation 
			// are done on a detached DOM which is much faster
			// Also if there is a parse error, we generally error out before doing any DOM operations (more atomic) 
			if(current && referenceElement && current != referenceElement){
				(referenceElement == topReferenceElement &&
					// top level, may use fragment for faster access 
					(fragment || 
						// fragment doesn't exist yet, check to see if we really want to create it 
						(fragment = fragmentFasterHeuristic.test(argument) && doc.createDocumentFragment()))
							// any of the above fails just use the referenceElement  
							 ? fragment : referenceElement).
								insertBefore(current, nextSibling || null); // do the actual insertion
			}
		}
		for(var i = 0; i < args.length; i++){
			var argument = args[i];
			if(typeof argument == "object"){
				lastSelectorArg = false;
				if(argument instanceof Array){
					// an array
					current = doc.createDocumentFragment();
					for(var key = 0; key < argument.length; key++){
						current.appendChild(put(argument[key]));
					}
					argument = current;
				}
				if(argument.nodeType){
					current = argument;
					insertLastElement();
					referenceElement = argument;
					nextSibling = 0;
				}else{
					// an object hash
					for(var key in argument){
						current[key] = argument[key];
					}				
				}
			}else if(lastSelectorArg){
				// a text node should be created
				// take a scalar value, use createTextNode so it is properly escaped
				// createTextNode is generally several times faster than doing an escaped innerHTML insertion: http://jsperf.com/createtextnode-vs-innerhtml/2
				lastSelectorArg = false;
				insertTextNode(current, argument);
			}else{
				if(i < 1){
					// if we are starting with a selector, there is no top element
					topReferenceElement = null;
				}
				lastSelectorArg = true;
				var leftoverCharacters = argument.replace(selectorParse, function(t, combinator, prefix, value, attrName, attrValue){
					if(combinator){
						// insert the last current object
						insertLastElement();
						if(combinator == '-' || combinator == '+'){
							// + or - combinator, 
							// TODO: add support for >- as a means of indicating before the first child?
							referenceElement = (nextSibling = (current || referenceElement)).parentNode;
							current = null;
							if(combinator == "+"){
								nextSibling = nextSibling.nextSibling;
							}// else a - operator, again not in CSS, but obvious in it's meaning (create next element before the current/referenceElement)
						}else{
							if(combinator == "<"){
								// parent combinator (not really in CSS, but theorized, and obvious in it's meaning)
								referenceElement = current = (current || referenceElement).parentNode;
							}else{
								if(combinator == ","){
									// comma combinator, start a new selector
									referenceElement = topReferenceElement;
								}else if(current){
									// else descendent or child selector (doesn't matter, treated the same),
									referenceElement = current;
								}
								current = null;
							}
							nextSibling = 0;
						}
						if(current){
							referenceElement = current;
						}
					}
					var tag = !prefix && value;
					if(tag || (!current && (prefix || attrName))){
						if(tag == "$"){
							// this is a variable to be replaced with a text node
							insertTextNode(referenceElement, args[++i]);
						}else{
							// Need to create an element
							tag = tag || put.defaultTag;
							var ieInputName = ieCreateElement && args[i +1] && args[i +1].name;
							if(ieInputName){
								// in IE, we have to use the crazy non-standard createElement to create input's that have a name 
								tag = '<' + tag + ' name="' + ieInputName + '">';
							}
							// we swtich between creation methods based on namespace usage
							current = namespaces && ~(namespaceIndex = tag.indexOf('|')) ?
								doc.createElementNS(namespaces[tag.slice(0, namespaceIndex)], tag.slice(namespaceIndex + 1)) : 
								doc.createElement(tag);
						}
					}
					if(prefix){
						if(value == "$"){
							value = args[++i];
						}
						if(prefix == "#"){
							// #id was specified
							current.id = value;
						}else{
							// we are in the className addition and removal branch
							var currentClassName = current.className;
							// remove the className (needed for addition or removal)
							// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this
							var removed = currentClassName && (" " + currentClassName + " ").replace(" " + value + " ", " ");
							if(prefix == "."){
								// addition, add the className
								current.className = currentClassName ? (removed + value).substring(1) : value;
							}else{
								// else a '!' class removal
								if(argument == "!"){
									var parentNode;
									// special signal to delete this element
									if(ieCreateElement){
										// use the ol' innerHTML trick to get IE to do some cleanup
										put("div", current, '<').innerHTML = "";
									}else if(parentNode = current.parentNode){ // intentional assigment
										// use a faster, and more correct (for namespaced elements) removal (http://jsperf.com/removechild-innerhtml)
										parentNode.removeChild(current);
									}
								}else{
									// we already have removed the class, just need to trim
									removed = removed.substring(1, removed.length - 1);
									// only assign if it changed, this can save a lot of time
									if(removed != currentClassName){
										current.className = removed;
									}
								}
							}
							// CSS class removal
						}
					}
					if(attrName){
						if(attrValue == "$"){
							attrValue = args[++i];
						}
						// [name=value]
						if(attrName == "style"){
							// handle the special case of setAttribute not working in old IE
							current.style.cssText = attrValue;
						}else{
							var method = attrName.charAt(0) == "!" ? (attrName = attrName.substring(1)) && 'removeAttribute' : 'setAttribute';
							attrValue = attrValue === '' ? attrName : attrValue;
							// determine if we need to use a namespace
							namespaces && ~(namespaceIndex = attrName.indexOf('|')) ?
								current[method + "NS"](namespaces[attrName.slice(0, namespaceIndex)], attrName.slice(namespaceIndex + 1), attrValue) :
								current[method](attrName, attrValue);
						}
					}
					return '';
				});
				if(leftoverCharacters){
					throw new SyntaxError("Unexpected char " + leftoverCharacters + " in " + argument);
				}
				insertLastElement();
				referenceElement = returnValue = current || referenceElement;
			}
		}
		if(topReferenceElement && fragment){
			// we now insert the top level elements for the fragment if it exists
			topReferenceElement.appendChild(fragment);
		}
		return returnValue;
	}
	put.addNamespace = function(name, uri){
		if(doc.createElementNS){
			(namespaces || (namespaces = {}))[name] = uri;
		}else{
			// for old IE
			doc.namespaces.add(name, uri);
		}
	};
	put.defaultTag = "div";
	put.forDocument = forDocument;
	return put;
});
})(function(id, deps, factory){
	factory = factory || deps;
	if(true){
		// AMD loader
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(){
			return factory();
		}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
	}else // removed by dead control flow
{}
});


/***/ },

/***/ "./node_modules/dojo-webpack-plugin/amd/dojoES6Promise.js"
/*!****************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/amd/dojoES6Promise.js ***!
  \****************************************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * (C) Copyright HCL Technologies Ltd. 2019
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * A thin wrapper that implements an ES6 Promise polyfill using Dojo promises.
 * Much smaller than other Promise polyfills if the Dojo modules are already
 * being used.
 */
 !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	__webpack_require__(/*! dojo/Deferred */ "./libraries/dojo/Deferred.js"),
	__webpack_require__(/*! dojo/promise/Promise */ "./libraries/dojo/promise/Promise.js"),
	__webpack_require__(/*! dojo/promise/all */ "./libraries/dojo/promise/all.js"),
	__webpack_require__(/*! dojo/promise/first */ "./libraries/dojo/promise/first.js"),
	__webpack_require__(/*! dojo/_base/lang */ "./libraries/dojo/_base/lang.js"),
	__webpack_require__(/*! dojo/_base/array */ "./libraries/dojo/_base/array.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function(
	Deferred,
	DojoPromise,
	all,
	first,
	lang,
	array
) {
	"use strict";

	var Promise;

	function wrap(dojoPromise) {
		return new Promise(dojoPromise);
	}

	/*
	 * Dojo promises can resolve synchronously but ES6 promises
	 * always resolve asynchronously.  Wrapping the callbacks
	 * with this function ensures that the ES6 behavior is
	 * adhered to.
	 */
	function newAsyncCallback(cb) {
		if (typeof cb !== 'function') return cb;
		return function() {
			var args = arguments;
			var dfd = new Deferred();
			setTimeout(function() {
				try {
					dfd.resolve(cb.apply(null, args));
				} catch (err) {
					dfd.reject(err);
				}
			}, 0);
			return dfd.promise;
		};
	}
	Promise = lang.extend(function PromiseWrapper(executor) {
		if (executor instanceof DojoPromise) {
			// wrapping an existing Dojo promise
			this.promise = executor;
		} else {
			// Create a new dojo/Deferred
			var dfd = new Deferred();
			this.promise = dfd.promise;
			executor(
				function(value) { dfd.resolve(value, false); },
				function (reason) { dfd.reject(reason, false); }
			);
		}
	}, {
		'catch': function(onRejected) {
			return wrap(this.promise.otherwise(
				newAsyncCallback(onRejected)
			));
		},
		then: function(onFullfilled, onRejected) {
			return wrap(this.promise.then(
				newAsyncCallback(onFullfilled),
				newAsyncCallback(onRejected)
			));
		},
		finally: function(onSettled) {
			return wrap(this.promise.always(
				newAsyncCallback(onSettled)
			));
		}
	});
	Promise.all = function(iterable) {
		return wrap(all(array.map(iterable, function(wrapped) {
			return wrapped instanceof Promise ? wrapped.promise : wrapped;
		})));
	};
	Promise.race = function(iterable) {
		return wrap(first(array.map(iterable, function(wrapped) {
			return wrapped instanceof Promise ? wrapped.promise : wrapped;
		})));
	};
	Promise.reject = function(reason) {
		return wrap((new Deferred()).reject(reason));
	};
	Promise.resolve = function(value) {
		return wrap((new Deferred()).resolve(value));
	};
	if (!window.Promise) {
		window.Promise = Promise;
	};
	return Promise;
}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ },

/***/ "./node_modules/dojo-webpack-plugin/lib/NoModule.js"
/*!**********************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/lib/NoModule.js ***!
  \**********************************************************/
(module) {

/*
 * (C) Copyright IBM Corp. 2012, 2016 All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = undefined;


/***/ },

/***/ "./themes/tachyons/js/index.js"
/*!*************************************!*\
  !*** ./themes/tachyons/js/index.js ***!
  \*************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
  __webpack_require__(/*! dbootstrap */ "./libraries/dbootstrap/main.js"),
  __webpack_require__(/*! sb */ "./core/app/public/js/sb/main.js"),
  __webpack_require__(/*! dojo/parser */ "./libraries/dojo/parser.js"),
  __webpack_require__.dj.h(/*! dojo/has!webpack?dojo-webpack-plugin/amd/dojoES6Promise */"webpack?./node_modules/dojo-webpack-plugin/amd/dojoES6Promise.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = __webpack_require__.dj.d(__WEBPACK_AMD_DEFINE_ARRAY__, (function() {

}), module, exports),
				module.exports = __WEBPACK_AMD_DEFINE_RESULT__);


/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/dojo-webpack-plugin */
/******/ 	(() => {
/******/ 		(function() { /* Start dojo-webpack-plugin extensions */
/******/ 				function mix(dest, src) { // eslint-disable-line no-unused-vars
/******/ 					for(var n in src) dest[n] = src[n];
/******/ 					return dest;
/******/ 				}
/******/ 		
/******/ 				function toUrl(name, referenceModule) {
/******/ 					return loaderScope.require.toUrl(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				function toAbsMid(name, referenceModule) {
/******/ 					return loaderScope.require.toAbsMid(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				// dojo require function.
/******/ 				function req(config, dependencies, callback) {
/******/ 					return contextRequire(config, dependencies, callback, 0, req);
/******/ 				};
/******/ 		
/******/ 				function createContextRequire(module) { // eslint-disable-line no-unused-vars
/******/ 					if (!module) return req;
/******/ 					var moduleId = module.absMid;
/******/ 					if (!moduleId && req.absMidsById[module.id]) {
/******/ 						moduleId = req.absMidsById[module.id];
/******/ 					}
/******/ 					if (!moduleId) return req;
/******/ 					var result = function(a1, a2, a3) {
/******/ 						return contextRequire(a1, a2, a3, moduleId, req);
/******/ 					};
/******/ 					for (var p in req) {
/******/ 						if (req.hasOwnProperty(p)) {
/******/ 							result[p] = req[p];
/******/ 						}
/******/ 					}
/******/ 					result.toUrl = function(name) {
/******/ 						return toUrl(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 					result.toAbsMid = function(name) {
/******/ 						return toAbsMid(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 		
/******/ 					if (req.undef) {
/******/ 						result.undef = function(mid) {
/******/ 							req.undef(mid, moduleId);
/******/ 						};
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function registerAbsMids(absMids) { // eslint-disable-line no-unused-vars
/******/ 					for (var s in absMids) {
/******/ 						req.absMids[s] = absMids[s];
/******/ 						if (!req.absMidsById[absMids[s]]) {
/******/ 							req.absMidsById[absMids[s]] = s;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				function resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars
/******/ 					// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are
/******/ 					// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression
/******/ 					// using the currently defined features returns a module id, or else undefined.
/******/ 		
/******/ 					var has = findModule("dojo/has", null, false);
/******/ 					var id = has.normalize(expr, function(arg){return arg;});
/******/ 					return id && __webpack_require__(id) || undefined;
/******/ 				}
/******/ 		
/******/ 				function findModule(mid, referenceModule, noInstall, asModuleObj) {
/******/ 					mid = mid.split("!").map(function(segment) {
/******/ 						var isRelative = segment.charAt(0) === '.';
/******/ 						if(isRelative && !referenceModule){
/******/ 							return segment;
/******/ 						}
/******/ 						return toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);
/******/ 					}).join("!");
/******/ 					var result;
/******/ 					if (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {
/******/ 						if (noInstall) {
/******/ 							var module = __webpack_module_cache__[req.absMids[mid]];
/******/ 							result = module && (asModuleObj ? module : module.exports);
/******/ 						} else {
/******/ 							result = __webpack_require__(req.absMids[mid]);
/******/ 						}
/******/ 					}
/******/ 					if (!result) {
/******/ 						throw new Error('Module not found: ' + mid);
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars
/******/ 					if (webpackModule.absMid) return webpackModule;  // Already converted
/******/ 					var result = {i:webpackModule.id};
/******/ 					var id = req.absMidsById[webpackModule.id];
/******/ 					if (id) {
/******/ 						result.id = result.absMid = id;
/******/ 					}
/******/ 					Object.defineProperty(result, "exports", {
/******/ 						get: function() { return webpackModule.exports;},
/******/ 						set: function(value) {webpackModule.exports = value;},
/******/ 						enumerable: true,
/******/ 						configurable: true
/******/ 					});
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow
/******/ 					var type = ({}.toString).call(a1);
/******/ 					if (type === '[object String]') {
/******/ 						// a3 is passed by require calls injected into dependency arrays for dependencies specified
/******/ 						// as identifiers (vs. string literals).
/******/ 						var noInstall = !(a3 === false);
/******/ 						var m = findModule(a1, referenceModule, noInstall);
/******/ 						if (typeof m === 'object' && m.__DOJO_WEBPACK_DEFINE_PROMISE__) {
/******/ 							throw new Error('Module not found: ' + a1);
/******/ 						}
/******/ 						return m;
/******/ 					} else if (type === '[object Object]') {
/******/ 						throw new Error('Require config is not supported by WebPack');
/******/ 					}
/******/ 					if (type === '[object Array]') {
/******/ 						var modules = [], callback = a2, errors = [];
/******/ 						a1.forEach(function (mid) {
/******/ 							try {
/******/ 								modules.push(findModule(mid, referenceModule));
/******/ 							} catch (e) {
/******/ 								errors.push({mid: mid, error: e});
/******/ 							}
/******/ 						});
/******/ 						if (errors.length === 0) {
/******/ 							if (callback) {
/******/ 								if (true && isDefinePromise(modules)) { // eslint-disable-line no-undef
/******/ 									Promise.all(wrapPromises(modules)).then(function(deps) { // eslint-disable-line no-undef
/******/ 										callback.apply(this, unwrapPromises(deps)); // eslint-disable-line no-undef
/******/ 									}.bind(this)).catch(function(err){console.error(err);});
/******/ 								} else {
/******/ 									callback.apply(this, modules);
/******/ 								}
/******/ 							}
/******/ 						} else {
/******/ 							var error = new Error("findModules");
/******/ 							error.src = "dojo-webpack-plugin";
/******/ 							error.info = errors;
/******/ 							req.signal("error", error);
/******/ 						}
/******/ 						return req;
/******/ 					} else {
/******/ 						throw new Error('Unsupported require call');
/******/ 					}
/******/ 				}
/******/ 				req.toUrl = toUrl;
/******/ 				req.toAbsMid = toAbsMid;
/******/ 				req.absMids = {};
/******/ 				req.absMidsById = [];
/******/ 				req.async = 1;
/******/ 				function wrapPromises(deps) {
/******/ 					var result = (Array.isArray(deps) ? deps : [deps]).map(function(m) {
/******/ 						return (m && typeof m.then === 'function' && !m.__DOJO_WEBPACK_DEFINE_PROMISE__) ? {__DOJO_WEBPACK_PROMISE_VALUE__: m} : m;
/******/ 					});
/******/ 					return Array.isArray(deps) ? result : result[0];
/******/ 				}
/******/ 		
/******/ 				function unwrapPromises(deps) {
/******/ 					var result = (Array.isArray(deps) ? deps : [deps]).map(function(m) {
/******/ 						return m && m.__DOJO_WEBPACK_PROMISE_VALUE__ || m;
/******/ 					});
/******/ 					return Array.isArray(deps) ? result : result[0];
/******/ 				}
/******/ 		
/******/ 				function isDefinePromise(values) {
/******/ 					return (Array.isArray(values) ? values : [values]).some(function(dep) {
/******/ 						return typeof dep === 'object' && dep.__DOJO_WEBPACK_DEFINE_PROMISE__;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				function asyncDefineModule(defArray, defFactory, module, exports) { // eslint-disable-line no-unused-vars
/******/ 		
/******/ 					function setDefinePromise(promise) {
/******/ 						promise.__DOJO_WEBPACK_DEFINE_PROMISE__ = true;
/******/ 						return promise;
/******/ 					}
/******/ 		
/******/ 					function defModule(deps) {
/******/ 						module && (module.exports = exports);
/******/ 						var result =  defFactory.apply(null, deps);
/******/ 						if (typeof module === 'function') {
/******/ 							// module is actually a callback function
/******/ 							module(result);
/******/ 						} else {
/******/ 							if (result !== undefined) {
/******/ 								module.exports = result;
/******/ 							} else {
/******/ 								result = module.exports;
/******/ 							}
/******/ 						}
/******/ 						return result;
/******/ 					}
/******/ 		
/******/ 					if (!isDefinePromise(defArray)) {
/******/ 						return defModule(defArray);
/******/ 					} else {
/******/ 						return setDefinePromise(Promise.all(defArray).then(function(deps) {
/******/ 							return wrapPromises(defModule(unwrapPromises(deps)));
/******/ 						}));
/******/ 					}
/******/ 				}
/******/ 			var globalObj = this||window;
/******/ 			registerAbsMids({
/******/ 				"themes/tachyons/js/index.js":"./themes/tachyons/js/index.js",
/******/ 				"dbootstrap/main":"./libraries/dbootstrap/main.js",
/******/ 				"dbootstrap/icon_support":"./libraries/dbootstrap/icon_support.js",
/******/ 				"dojo/_base/declare":"./libraries/dojo/_base/declare.js",
/******/ 				"dojo/_base/kernel":"./libraries/dojo/_base/kernel.js",
/******/ 				"dojo/global":"./libraries/dojo/global.js",
/******/ 				"dojo/has":"./libraries/dojo/has.js",
/******/ 				"dojo/_base/config":"./libraries/dojo/_base/config.js",
/******/ 				"dojo/_base/lang":"./libraries/dojo/_base/lang.js",
/******/ 				"dojo/sniff":"./libraries/dojo/sniff.js",
/******/ 				"dojo/_base/array":"./libraries/dojo/_base/array.js",
/******/ 				"dojo/dom-construct":"./libraries/dojo/dom-construct.js",
/******/ 				"dojo/_base/window":"./libraries/dojo/_base/window.js",
/******/ 				"dojo/dom":"./libraries/dojo/dom.js",
/******/ 				"dojo/dom-attr":"./libraries/dojo/dom-attr.js",
/******/ 				"dojo/dom-style":"./libraries/dojo/dom-style.js",
/******/ 				"dojo/dom-prop":"./libraries/dojo/dom-prop.js",
/******/ 				"dojo/_base/connect":"./libraries/dojo/_base/connect.js",
/******/ 				"dojo/on":"./libraries/dojo/on.js",
/******/ 				// "/home/ali/public_html/starbug/starbug/node_modules/dojo-webpack-plugin/lib/NoModule.js" = "./node_modules/dojo-webpack-plugin/lib/NoModule.js"
/******/ 				"dojo/aspect":"./libraries/dojo/aspect.js",
/******/ 				"dojo/topic":"./libraries/dojo/topic.js",
/******/ 				"dojo/Evented":"./libraries/dojo/Evented.js",
/******/ 				"dojo/_base/event":"./libraries/dojo/_base/event.js",
/******/ 				"dojo/dom-geometry":"./libraries/dojo/dom-geometry.js",
/******/ 				"dojo/mouse":"./libraries/dojo/mouse.js",
/******/ 				"dojo/_base/sniff":"./libraries/dojo/_base/sniff.js",
/******/ 				"dojo/keys":"./libraries/dojo/keys.js",
/******/ 				"dojo/dom-class":"./libraries/dojo/dom-class.js",
/******/ 				"dijit/_TemplatedMixin":"./libraries/dijit/_TemplatedMixin.js",
/******/ 				"dojo/cache":"./libraries/dojo/cache.js",
/******/ 				"dojo/text":"./libraries/dojo/text.js",
/******/ 				"dojo/request":"./libraries/dojo/request.js",
/******/ 				"dojo/request/xhr":"./libraries/dojo/request/xhr.js",
/******/ 				"dojo/request/default!":"./libraries/dojo/request/xhr.js",
/******/ 				"dojo/errors/RequestError":"./libraries/dojo/errors/RequestError.js",
/******/ 				"dojo/errors/create":"./libraries/dojo/errors/create.js",
/******/ 				"dojo/request/watch":"./libraries/dojo/request/watch.js",
/******/ 				"dojo/request/util":"./libraries/dojo/request/util.js",
/******/ 				"dojo/errors/CancelError":"./libraries/dojo/errors/CancelError.js",
/******/ 				"dojo/Deferred":"./libraries/dojo/Deferred.js",
/******/ 				"dojo/promise/Promise":"./libraries/dojo/promise/Promise.js",
/******/ 				"dojo/promise/instrumentation":"./libraries/dojo/promise/instrumentation.js",
/******/ 				"dojo/promise/tracer":"./libraries/dojo/promise/tracer.js",
/******/ 				"dojo/io-query":"./libraries/dojo/io-query.js",
/******/ 				"dojo/errors/RequestTimeoutError":"./libraries/dojo/errors/RequestTimeoutError.js",
/******/ 				"dojo/request/handlers":"./libraries/dojo/request/handlers.js",
/******/ 				"dojo/json":"./libraries/dojo/json.js",
/******/ 				"dojo/string":"./libraries/dojo/string.js",
/******/ 				"dijit/_AttachMixin":"./libraries/dijit/_AttachMixin.js",
/******/ 				"dojo/touch":"./libraries/dojo/touch.js",
/******/ 				"dojo/domReady":"./libraries/dojo/domReady.js",
/******/ 				"dijit/_WidgetBase":"./libraries/dijit/_WidgetBase.js",
/******/ 				"dojo/ready":"./libraries/dojo/ready.js",
/******/ 				"dojo/Stateful":"./libraries/dojo/Stateful.js",
/******/ 				"dojo/when":"./libraries/dojo/when.js",
/******/ 				"dijit/Destroyable":"./libraries/dijit/Destroyable.js",
/******/ 				"dijit/registry":"./libraries/dijit/registry.js",
/******/ 				"dijit/main":"./libraries/dijit/main.js",
/******/ 				"dijit/_BidiMixin":"./libraries/dijit/_BidiMixin.js",
/******/ 				"sb/main":"./core/app/public/js/sb/main.js",
/******/ 				"sb/kernel":"./core/app/public/js/sb/kernel.js",
/******/ 				"put-selector/put":"./libraries/put-selector/put.js",
/******/ 				"starbug/form/_FormWidget":"./core/app/public/js/starbug/form/_FormWidget.js",
/******/ 				"dijit/form/_FormWidgetMixin":"./libraries/dijit/form/_FormWidgetMixin.js",
/******/ 				"dojo/window":"./libraries/dojo/window.js",
/******/ 				"dijit/a11y":"./libraries/dijit/a11y.js",
/******/ 				"dojo/parser":"./libraries/dojo/parser.js",
/******/ 				"dojo/_base/url":"./libraries/dojo/_base/url.js",
/******/ 				"dojo/promise/all":"./libraries/dojo/promise/all.js",
/******/ 				"dojo/date/stamp":"./libraries/dojo/date/stamp.js",
/******/ 				"dojo/query":"./libraries/dojo/query.js",
/******/ 				"dojo/selector/_loader":"./libraries/dojo/selector/_loader.js",
/******/ 				"dojo/selector/lite":"./libraries/dojo/selector/lite.js",
/******/ 				"dojo/selector/_loader!default":"./libraries/dojo/selector/lite.js",
/******/ 				"dojo-webpack-plugin/amd/dojoES6Promise":"./node_modules/dojo-webpack-plugin/amd/dojoES6Promise.js",
/******/ 				"dojo/promise/first":"./libraries/dojo/promise/first.js"
/******/ 				// "/home/ali/public_html/starbug/starbug/libraries/dist/dojo.js" = "./libraries/dist/dojo.js"
/******/ 			});
/******/ 		
/******/ 			globalObj.require = req;
/******/ 				(self["webpackChunk"] = self["webpackChunk"] || []).registerAbsMids = registerAbsMids;
/******/ 		
/******/ 			// expose the Dojo compatibility functions as a properties of __webpack_require__
/******/ 			if (__webpack_require__.dj && __webpack_require__.dj.name !== 'dojo-webpack-plugin') throw new Error("__webpack_require__.dj name collision.")
/******/ 			__webpack_require__.dj = {
/******/ 				name: 'dojo-webpack-plugin',
/******/ 				r: req,
/******/ 				c: createContextRequire,
/******/ 				m: dojoModuleFromWebpackModule,
/******/ 				h: resolveTernaryHasExpression,
/******/ 				d: asyncDefineModule,
/******/ 				w: wrapPromises,
/******/ 				u: unwrapPromises
/******/ 			};
/******/ 			var loaderScope = Object.create(globalObj, {
/******/ 			   document:{value: globalObj.document},
/******/ 			});
/******/ 			Object.defineProperties(loaderScope, {
/******/ 			   window:{value:loaderScope},
/******/ 			   global:{value:loaderScope}
/******/ 			});
/******/ 			loaderScope.define = loaderScope.require = undefined
/******/ 			globalObj.dojoConfig = globalObj.dojoConfig || {}
/******/ 			var userConfig = mix(globalObj.dojoConfig, ({'baseUrl':'/','async':true,'map':({'*':({'sb/modal/theme/default':'sb/modal/theme/tachyons','sb/form/theme/dropdown/default':'sb/form/theme/dropdown/tachyons','sb/form/theme/uploadButton/default':'sb/form/theme/uploadButton/tachyons','sb/form/theme/MultipleSelect/default':'sb/form/theme/MultipleSelect/tachyons'})}),'packages':[({'name':'dojo','location':'libraries/dojo'}),({'name':'dijit','location':'libraries/dijit'}),({'name':'dstore','location':'libraries/dstore'}),({'name':'dgrid','location':'libraries/dgrid'}),({'name':'put-selector','location':'libraries/put-selector'}),({'name':'xstyle','location':'libraries/xstyle'}),({'name':'dbootstrap','location':'libraries/dbootstrap'}),({'name':'bootstrap','location':'libraries/dojo-bootstrap'}),({'name':'sb','location':'core/app/public/js/sb'}),({'name':'starbug','location':'core/app/public/js/starbug'}),({'name':'tachyons-amd','location':'themes/tachyons/public/js'})]}));
/******/ 			var defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1})});
/******/ 			var dojoLoader = __webpack_require__("./libraries/dist/dojo.js");
/******/ 			dojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);
/******/ 			Object.keys(loaderScope.require.packs).forEach(function(key) {
/******/ 				var pkg = loaderScope.require.packs[key];
/******/ 				if ((/(^\/)|(\:)/.test(pkg.main)	// main path is absolute
/******/ 				    || pkg.main.split('/').reduce(function(acc, pathComp) {
/******/ 							if (acc < 0 || pathComp === '.') return acc;
/******/ 							return (pathComp === '..' ? --acc : ++acc);
/******/ 						}, 0) <= 0) // main path is outside package
/******/ 						&& typeof pkg.realMain === 'undefined'	// hasn't already been adjusted
/******/ 				) {
/******/ 					pkg.realMain = pkg.main;
/******/ 					pkg.main = '';
/******/ 				}
/******/ 			});
/******/ 			function toAbsMid(name, referenceModule) {
/******/ 				var absMid = loaderScope.require.originalToAbsMid(name, referenceModule);
/******/ 				if (absMid.indexOf('/') === absMid.length-1) {
/******/ 					var pkgName = absMid.substring(0, absMid.length-1);
/******/ 					var pkg = loaderScope.require.packs[pkgName];
/******/ 					if (pkg && pkg.realMain) {
/******/ 						absMid = pkgName;
/******/ 					}
/******/ 				}
/******/ 				return absMid;
/******/ 			}
/******/ 			function toUrl(name, referenceModule) {
/******/ 				var url = loaderScope.require.originalToUrl(name, referenceModule);
/******/ 				var pkg = loaderScope.require.packs[name];
/******/ 				if (pkg && pkg.realMain) {
/******/ 					var parts = url.split('?');
/******/ 					if (/(^\/)|(\:)/.test(pkg.realMain)) {
/******/ 						// absolute URL
/******/ 						parts[0] = pkg.realMain;
/******/ 					} else {
/******/ 						// relative URL
/******/ 						parts[0] = parts[0] + '/' + pkg.realMain;
/******/ 					}
/******/ 					url = parts.join('?');
/******/ 				}
/******/ 				return url;
/******/ 			}
/******/ 			loaderScope.require.originalToAbsMid = loaderScope.require.toAbsMid;
/******/ 			loaderScope.require.originalToUrl = loaderScope.require.toUrl;
/******/ 			loaderScope.require.toAbsMid = toAbsMid;
/******/ 			loaderScope.require.toUrl = toUrl;
/******/ 			['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})
/******/ 			var absMidsWaiting = globalObj["webpackChunk"].absMidsWaiting;
/******/ 			if (absMidsWaiting) {
/******/ 			   absMidsWaiting.forEach(registerAbsMids);
/******/ 			   delete globalObj["webpackChunk"].absMidsWaiting;
/******/ 			}
/******/ 		})(); /* End dojo-webpack-plugin extensions */
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./themes/tachyons/js/index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFjaHlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsaUdBQU8sQ0FBQyx3RUFBZSxFQUFFLGtFQUFZLEVBQUUsOEVBQWtCLEVBQUUsZ0ZBQW1CLENBQUMsMEZBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RiwwQkFBMEI7QUFDdkg7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLGNBQWM7QUFDZCw2QkFBNkIsYUFBYTtBQUMxQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCLDBDQUEwQztBQUMxRix5QkFBeUIsd0JBQXdCLDJDQUEyQztBQUM1Rix5QkFBeUIsbURBQW1ELG1CQUFtQjtBQUMvRix5QkFBeUIsbURBQW1ELG1CQUFtQjtBQUMvRix5QkFBeUIsbURBQW1ELG1CQUFtQjtBQUMvRixzQkFBc0IsZ0RBQWdELG1CQUFtQjtBQUN6Rix5QkFBeUIsbURBQW1ELG1CQUFtQjtBQUMvRix3QkFBd0Isa0RBQWtEO0FBQzFFLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBNEM7QUFDN0QsaUJBQWlCLDRDQUE0QztBQUM3RCxpQkFBaUIsNENBQTRDO0FBQzdELGlCQUFpQixzQ0FBc0M7QUFDdkQsaUJBQWlCLDRDQUE0QztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQUEsbURBQUM7Ozs7Ozs7Ozs7O0FDNUhGLGlHQUFPO0FBQ1AsQ0FBQyx5RUFBVztBQUNaLENBQUMsdUVBQVk7QUFDYixDQUFDLHVHQUEwQjtBQUMzQixDQUFDLDBGQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUNWRixpR0FBTyxDQUFDLDRFQUFpQixFQUFFLG9HQUE2QixDQUFDLDBGQUFFO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7OztBQ0pGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUNBO0FBQ0EsSUFBSSxnQ0FBUztBQUNiLElBQUksa0ZBQW9CO0FBQ3hCLElBQUksNEVBQWlCO0FBQ3JCLElBQUksOEVBQWtCO0FBQ3RCLElBQUksa0ZBQW9CO0FBQ3hCLElBQUksMEVBQWdCO0FBQ3BCLElBQUksd0ZBQXVCO0FBQzNCLENBQUMsMEZBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBUSxxQ0FBQyxrRkFBb0IsQ0FBQyw4SEFBRTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxTQUFTLHdIQUFDO0FBQ1YsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7Ozs7QUNyR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFPO0FBQ1AsSUFBSSxtRkFBZ0I7QUFDcEIsQ0FBQywwRkFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7O0FDaEJGLGlHQUFPO0FBQ1AsQ0FBQyw4RUFBa0I7QUFDbkIsQ0FBQyxvRUFBYTtBQUNkLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsMEZBQUU7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUosc0JBQXNCO0FBQ3RCO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUNsRkYsaUdBQU87QUFDUCxDQUFDLGdDQUFTO0FBQ1YsQ0FBQyw4RUFBa0I7QUFDbkIsQ0FBQyxrRkFBb0I7QUFDckIsQ0FBQyxrRkFBb0I7QUFDckIsQ0FBQyw0RUFBaUI7QUFDbEIsQ0FBQyxrRUFBWTtBQUNiLENBQUMsNERBQVM7QUFDVixDQUFDLGtFQUFZO0FBQ2IsQ0FBQyw0RUFBZTtBQUNoQixDQUFDLDBGQUFFOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixHQUFHOztBQUVIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDO0FBQUEsbURBQUM7Ozs7Ozs7Ozs7O0FDN09GLGlHQUFPLEVBQUUsMEZBQUU7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUEsbURBQUM7Ozs7Ozs7Ozs7O0FDaEpGLGlHQUFPO0FBQ1AsQ0FBQyxrRUFBWTtBQUNiLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsNEVBQWlCO0FBQ2xCLENBQUMsNERBQVM7QUFDVixDQUFDLGtFQUFZO0FBQ2IsQ0FBQyxvRUFBYTtBQUNkLENBQUMsOEVBQWdCO0FBQ2pCLENBQUMsMEZBQUU7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixxQ0FBcUMsK0NBQStDO0FBQ3BGLHVCQUF1Qjs7QUFFdkI7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSwrQ0FBK0MsSUFBSTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsS0FBSztBQUNMLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksVUFBVSxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0QsS0FBSyxLQUFLO0FBQzVEO0FBQ0EsMENBQTBDO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUM1TUYsaUdBQU87QUFDUCxDQUFDLGdDQUFTO0FBQ1YsQ0FBQyw4RUFBa0I7QUFDbkIsQ0FBQyxvRUFBYTtBQUNkLENBQUMsZ0ZBQW1CO0FBQ3BCLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsOERBQVU7QUFDWCxDQUFDLHdFQUFlO0FBQ2hCLENBQUMsMEVBQWdCO0FBQ2pCLENBQUMsa0ZBQW9CO0FBQ3JCLENBQUMsZ0ZBQW1CO0FBQ3BCLENBQUMsMEVBQWdCO0FBQ2pCLENBQUMsOERBQVU7QUFDWCxDQUFDLGdGQUFtQjtBQUNwQixDQUFDLDRFQUFpQjtBQUNsQixDQUFDLDREQUFTO0FBQ1YsQ0FBQyxrRUFBWTtBQUNiLENBQUMsd0VBQWU7QUFDaEIsQ0FBQyxrRUFBWTtBQUNiLENBQUMsZ0ZBQW1CO0FBQ3BCLENBQUMsNEVBQWU7QUFDaEIsQ0FBQywyR0FBaUM7QUFDbEMsQ0FBQyxzRUFBWTtBQUNiLENBQUMsMEZBQUU7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0g7O0FBRUE7QUFDQSxTQUFTLFFBQVEsK0JBQStCLFlBQVk7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQzs7QUFFbkQ7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlDQUFpQztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQsNENBQTRDOztBQUU1QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1RkFBdUYsS0FBSztBQUM1RjtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsS0FBSztBQUNwRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7OztBQzdWRixpR0FBTyxDQUFDLGtFQUFXLEVBQUUsNERBQVEsRUFBRSxnQ0FBUyxDQUFDLDBGQUFFO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRCw2REFBNkQ7QUFDN0Q7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHNEQUFzRDtBQUN0RDtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7Ozs7QUN0TEYsaUdBQU8sQ0FBQyx1RUFBVSxFQUFFLDBEQUFPLEVBQUUsZ0VBQVUsRUFBRSxrRUFBVyxFQUFFLHFFQUFTLEVBQUUsZ0VBQVUsRUFBRSxxRUFBUyxFQUFFLG1FQUFRLEVBQUUsOERBQVMsQ0FBQywwRkFBRTtBQUM5RztBQUNBOztBQUVBLDZDQUE2QztBQUM3QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxNQUFNO0FBQ04sZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2YsTUFBTTtBQUNOLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxNQUFNO0FBQ2pDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtDQUFrQztBQUNwRztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkVBQTZFO0FBQzdFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQUEsbURBQUM7Ozs7Ozs7Ozs7Ozs7QUNuWEYsaUdBQU8sQ0FBQyx1RUFBVSxFQUFFLDREQUFRLEVBQUUsbUVBQVEsQ0FBQywwRkFBRTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQixlQUFlO0FBQzdEOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYyxZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixHQUFHLE1BQU07QUFDL0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsY0FBYztBQUNkLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ozs7Ozs7Ozs7OztBQ3JJRixpR0FBTyxFQUFFLDBGQUFFOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUNuT0YsaUdBQU8sQ0FBQyw2RUFBZ0IsRUFBRSw2REFBUSxDQUFDLDBGQUFFO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUNORixpR0FBTyxDQUFDLDBFQUFlLEVBQUUsNEVBQWdCLENBQUMsMEZBQUU7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxFQUFFO0FBQ3hHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLG1CQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7OztBQy9JRixpR0FBTyxDQUFDLE9BQVMsRUFBRSwrREFBUyxFQUFFLHlFQUFjLEVBQUUsMkRBQU8sRUFBRSx1RUFBYSxFQUFFLHFFQUFZLENBQUMsMEZBQ2pGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQSxDQUFDLFdBQVc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNHQUFzRztBQUN0Rzs7QUFFQSxDQUFDLFdBQVc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQSxDQUFDLFdBQVc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLENBQUMsY0FBYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7OztBQzNNRixpR0FBTyxDQUFDLHlFQUFjLEVBQUUsMkVBQWUsRUFBRSwyREFBTyxDQUFDLDBGQUFFO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Qsd0ZBQXdGO0FBQ3hGLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQztB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QUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0MsT0FBTztBQUNQLGtCQUFrQix3QkFBd0I7QUFDMUMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQiwwQ0FBMEM7QUFDL0QsTUFBTTtBQUNOLHFCQUFxQixzQkFBc0I7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUFBLG1EQUFDOzs7Ozs7Ozs7OztBQzlZRixpR0FBTyxDQUFDLDREQUFRLEVBQUUsZ0NBQVMsQ0FBQywwRkFDMUI7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFBQSxtREFBQzs7Ozs7Ozs7Ozs7QUMxREYsaUdBQU8sQ0FBQyw0REFBUSxFQUFFLDhFQUFpQixDQUFDLDBGQUFFO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBLDhCQUE4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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQXFEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBNEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLDRDQUE0QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sNkNBQTZDO0FBQzdDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFhLCtMQUErTCxFQUFFO1dBQ3JPO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EscUVBQXFFLHNDQUFzQztXQUMzRztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsQ0FBQyxLQUFLLHdDOzs7OztVRS9XTjtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NvcmUvYXBwL3B1YmxpYy9qcy9zYi9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS9hcHAvcHVibGljL2pzL3NiL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS9hcHAvcHVibGljL2pzL3N0YXJidWcvZm9ybS9fRm9ybVdpZGdldC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGJvb3RzdHJhcC9pY29uX3N1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rib290c3RyYXAvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlqaXQvRGVzdHJveWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rpaml0L19BdHRhY2hNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlqaXQvX0JpZGlNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlqaXQvX1RlbXBsYXRlZE1peGluLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kaWppdC9fV2lkZ2V0QmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlqaXQvYTExeS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlqaXQvZm9ybS9fRm9ybVdpZGdldE1peGluLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kaWppdC9tYWluLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kaWppdC9yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZGlzdC9kb2pvLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL0RlZmVycmVkLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL0V2ZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vU3RhdGVmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvY29uZmlnLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL19iYXNlL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvZGVjbGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9fYmFzZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9fYmFzZS9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvbGFuZy5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9fYmFzZS9zbmlmZi5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9fYmFzZS91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vX2Jhc2Uvd2luZG93LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2FzcGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9kYXRlL3N0YW1wLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2RvbS1hdHRyLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2RvbS1jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9kb20tY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2RvbS1nZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9kb20tcHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9kb20tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vZG9tLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2RvbVJlYWR5LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9DYW5jZWxFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9lcnJvcnMvUmVxdWVzdEVycm9yLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9SZXF1ZXN0VGltZW91dEVycm9yLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9pby1xdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9qc29uLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vbW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vb24uanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vcGFyc2VyLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9wcm9taXNlL2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9wcm9taXNlL2ZpcnN0LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvaW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvdHJhY2VyLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3F1ZXJ5LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3JlYWR5LmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vcmVxdWVzdC9oYW5kbGVycy5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9yZXF1ZXN0L3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vcmVxdWVzdC93YXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9yZXF1ZXN0L3hoci5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby9zZWxlY3Rvci9fbG9hZGVyLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3NlbGVjdG9yL2xpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vc25pZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vc3RyaW5nLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9kb2pvL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vdG9waWMuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vdG91Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Rvam8vd2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvZG9qby93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL3B1dC1zZWxlY3Rvci9wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rvam8td2VicGFjay1wbHVnaW4vYW1kL2Rvam9FUzZQcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb2pvLXdlYnBhY2stcGx1Z2luL2xpYi9Ob01vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi90aGVtZXMvdGFjaHlvbnMvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZG9qby13ZWJwYWNrLXBsdWdpbiIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFtcImRvam8vRGVmZXJyZWRcIiwgXCJkb2pvL3JlYWR5XCIsIFwicHV0LXNlbGVjdG9yL3B1dFwiLCBcImRvam8vX2Jhc2UvY29uZmlnXCJdLCBmdW5jdGlvbihEZWZlcnJlZCwgcmVhZHksIHB1dCwgY29uZmlnKSB7XG4gIGlmICghd2luZG93LnNiKSB7XG4gICAgd2luZG93LnNiID0ge1xuICAgICAgaGFzTG9hZGVkVGlueU1DRTpmYWxzZSxcbiAgICAgIHBvc3Q6IGZ1bmN0aW9uKHVybCwgYXJncywgb25zdWJtaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIG9uc3VibWl0ID0gYXJncztcbiAgICAgICAgICBhcmdzID0gdXJsO1xuICAgICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwuc3Vic3RyKDAsIDQpICE9ICdodHRwJykgdXJsID0gV0VCU0lURV9VUkwrdXJsO1xuICAgICAgICB2YXIgZm9ybSA9IHB1dCh3aW5kb3cuZG9jdW1lbnQuYm9keSwgJ2Zvcm1bbWV0aG9kPVwicG9zdFwiXScpO1xuICAgICAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY3Rpb24nLCB1cmwpO1xuICAgICAgICBpZiAob25zdWJtaXQpIGZvcm0uc2V0QXR0cmlidXRlKCdvbnN1Ym1pdCcsIG9uc3VibWl0KTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3MpIGlmIChhcmdzLmhhc093blByb3BlcnR5KGtleSkpIHB1dChmb3JtLCAnaW5wdXRbdHlwZT1oaWRkZW5dJywge25hbWU6a2V5LCB2YWx1ZTphcmdzW2tleV19KTtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHB1dChmb3JtLCAnYnV0dG9uW3R5cGU9c3VibWl0XScsICdzdWJtaXQnKTtcbiAgICAgICAgYnV0dG9uLmNsaWNrKCk7XG4gICAgICB9LFxuICAgICAgZWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2IgPSB0aGlzO1xuICAgICAgICB2YXIgcnQgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInJpY2gtdGV4dFwiKTtcbiAgICAgICAgdmFyIGVkID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlZGl0YWJsZVwiKTtcbiAgICAgICAgaWYgKHJ0Lmxlbmd0aCA+IDAgfHwgZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh0aGlzLmhhc0xvYWRlZFRpbnlNQ0UpIHtcbiAgICAgICAgICAgIHdpbmRvdy50aW55bWNlLnJlbW92ZSgpO1xuICAgICAgICAgICAgc2IuaW5pdFRpbnlNQ0UocnQsIGVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgIHNjcmlwdC5zcmMgPSBjb25maWcud2Vic2l0ZVVybCArICdsaWJyYXJpZXMvdGlueW1jZS90aW55bWNlLm1pbi5qcyc7XG4gICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCAhZG9uZSAmJiAoIXRoaXMucmVhZHlTdGF0ZSB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwibG9hZGVkXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpICkge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2IuaW5pdFRpbnlNQ0UocnQsIGVkKTtcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG4gICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgdGhpcy5oYXNMb2FkZWRUaW55TUNFID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXRUaW55TUNFOiBmdW5jdGlvbihydCwgZWQpIHtcbiAgICAgICAgdmFyIHRpbnlfbWNlX2Jyb3dzZXJfY2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgdmFsdWUsIG1ldGEpe1xuICAgICAgICAgIHdpbmRvdy5TZXRVcmw9ZnVuY3Rpb24odXJsLHdpZHRoLGhlaWdodCxjYXB0aW9uKXtcbiAgICAgICAgICAgIGlmIChtZXRhLmZpbGV0eXBlID09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHVybCwge3RleHQ6IGNhcHRpb259KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YS5maWxldHlwZSA9PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sodXJsLCB7YWx0OiBjYXB0aW9ufSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEuZmlsZXR5cGUgPT0gXCJtZWRpYVwiKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3aW5kb3cub3BlbihXRUJTSVRFX1VSTCsnYWRtaW4vbWVkaWE/bW9kYWw9dHJ1ZScsJ21lZGlhJywnbW9kYWwsd2lkdGg9MTAyMCxoZWlnaHQ9NjAwJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRpbnlfb3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBHZW5lcmFsIG9wdGlvbnNcbiAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgIFwiYWR2bGlzdCBhdXRvbGluayBhdXRvcmVzaXplIGxpc3RzIGxpbmsgaW1hZ2UgY2hhcm1hcCBwcmludCBwcmV2aWV3IGhyIGFuY2hvciBwYWdlYnJlYWtcIixcbiAgICAgICAgICAgICAgXCJzZWFyY2hyZXBsYWNlIHdvcmRjb3VudCB2aXN1YWxibG9ja3MgdmlzdWFsY2hhcnMgY29kZSBmdWxsc2NyZWVuIGNoYXJtYXBcIixcbiAgICAgICAgICAgICAgXCJpbnNlcnRkYXRldGltZSBtZWRpYSBub25icmVha2luZyBzYXZlIHRhYmxlIGRpcmVjdGlvbmFsaXR5XCIsXG4gICAgICAgICAgICAgIFwiZW1vdGljb25zIHRlbXBsYXRlIHBhc3RlIHNhdmVcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgcGFzdGVfYXV0b19jbGVhbnVwX29uX3Bhc3RlIDogdHJ1ZSxcbiAgICAgICAgICBhdXRvX2NsZWFudXBfd29yZDogdHJ1ZSxcbiAgICAgICAgICBjb252ZXJ0X3VybHM6IGZhbHNlLFxuICAgICAgICAgIHJlbGF0aXZlX3VybHM6IGZhbHNlLFxuICAgICAgICAgIHRvb2xiYXIxOiBcInVuZG8gcmVkbyB8IHN0eWxlc2VsZWN0IHwgYm9sZCBpdGFsaWMgfCBmb3JlY29sb3IgYmFja2NvbG9yIHwgYWxpZ25sZWZ0IGFsaWduY2VudGVyIGFsaWducmlnaHQgYWxpZ25qdXN0aWZ5IHwgYnVsbGlzdCBudW1saXN0IG91dGRlbnQgaW5kZW50IHwgbGluayBpbWFnZSBtZWRpYSB8IHByaW50IHByZXZpZXdcIixcbiAgICAgICAgICBpbWFnZV9hZHZ0YWI6IHRydWUsXG4gICAgICAgICAgZm9ybWF0czoge1xuICAgICAgICAgICAgYWxpZ25sZWZ0OiB7c2VsZWN0b3I6J2ltZycsIHN0eWxlczp7J21hcmdpbic6JzAgMTVweCAxNXB4IDAnLCAnZmxvYXQnOidsZWZ0J319LFxuICAgICAgICAgICAgYWxpZ25yaWdodDoge3NlbGVjdG9yOidpbWcnLCBzdHlsZXM6eydtYXJnaW4nOicwIDAgMTVweCAxNXB4JywgJ2Zsb2F0JzoncmlnaHQnfX0sXG4gICAgICAgICAgICBidG5kZWZhdWx0OiB7aW5saW5lOidhJywgY2xhc3NlczonYnRuIGJ0bi1kZWZhdWx0JywgYXR0cmlidXRlczp7aHJlZjonW3VyaTpob21lXSd9fSxcbiAgICAgICAgICAgIGJ0bnByaW1hcnk6IHtpbmxpbmU6J2EnLCBjbGFzc2VzOididG4gYnRuLXByaW1hcnknLCBhdHRyaWJ1dGVzOntocmVmOidbdXJpOmhvbWVdJ319LFxuICAgICAgICAgICAgYnRuc3VjY2Vzczoge2lubGluZTonYScsIGNsYXNzZXM6J2J0biBidG4tc3VjY2VzcycsIGF0dHJpYnV0ZXM6e2hyZWY6J1t1cmk6aG9tZV0nfX0sXG4gICAgICAgICAgICBidG5pbmZvOiB7aW5saW5lOidhJywgY2xhc3NlczonYnRuIGJ0bi1pbmZvJywgYXR0cmlidXRlczp7aHJlZjonW3VyaTpob21lXSd9fSxcbiAgICAgICAgICAgIGJ0bndhcm5pbmc6IHtpbmxpbmU6J2EnLCBjbGFzc2VzOididG4gYnRuLXdhcm5pbmcnLCBhdHRyaWJ1dGVzOntocmVmOidbdXJpOmhvbWVdJ319LFxuICAgICAgICAgICAgYnRuZGFuZ2VyOiB7aW5saW5lOidhJywgY2xhc3NlczonYnRuIGJ0bi1kYW5nZXInLCBhdHRyaWJ1dGVzOntocmVmOidbdXJpOmhvbWVdJ319XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZV9mb3JtYXRzX21lcmdlOnRydWUsXG4gICAgICAgICAgc3R5bGVfZm9ybWF0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aXRsZTpcIkJ1dHRvbnNcIiwgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICB7dGl0bGU6XCJEZWZhdWx0IEJ1dHRvblwiLCBmb3JtYXQ6XCJidG5kZWZhdWx0XCJ9LFxuICAgICAgICAgICAgICAgIHt0aXRsZTpcIlByaW1hcnkgQnV0dG9uXCIsIGZvcm1hdDpcImJ0bnByaW1hcnlcIn0sXG4gICAgICAgICAgICAgICAge3RpdGxlOlwiU3VjY2VzcyBCdXR0b25cIiwgZm9ybWF0OlwiYnRuc3VjY2Vzc1wifSxcbiAgICAgICAgICAgICAgICB7dGl0bGU6XCJJbmZvIEJ1dHRvblwiLCBmb3JtYXQ6XCJidG5pbmZvXCJ9LFxuICAgICAgICAgICAgICAgIHt0aXRsZTpcIldhcm5pbmcgQnV0dG9uXCIsIGZvcm1hdDpcImJ0bndhcm5pbmdcIn0sXG4gICAgICAgICAgICAgICAge3RpdGxlOlwiRGFuZ2VyIEJ1dHRvblwiLCBmb3JtYXQ6XCJidG5kYW5nZXJcIn1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZmlsZV9waWNrZXJfY2FsbGJhY2s6IHRpbnlfbWNlX2Jyb3dzZXJfY2FsbGJhY2tcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRpbnlfb3B0aW9ucy5zZWxlY3RvciA9IFwidGV4dGFyZWEucmljaC10ZXh0XCI7XG4gICAgICAgICAgd2luZG93LnRpbnltY2UuaW5pdCh0aW55X29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGlueV9vcHRpb25zLnNlbGVjdG9yID0gXCJkaXYuZWRpdGFibGVcIjtcbiAgICAgICAgICB0aW55X29wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICB0aW55X29wdGlvbnMuc2F2ZV9lbmFibGV3aGVuZGlydHkgPSB0cnVlO1xuICAgICAgICAgIHRpbnlfb3B0aW9ucy50b29sYmFyMSArPSBcIiBzYXZlIGNhbmNlbFwiO1xuICAgICAgICAgIHRpbnlfb3B0aW9ucy5zYXZlX29uc2F2ZWNhbGxiYWNrID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGVkaXRvci5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICB2YXIgYmxvY2tfaWQgPSBlZGl0b3IuYm9keUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJsb2NrLWlkJyk7XG4gICAgICAgICAgICBzYi5nZXQoJ2Jsb2NrcycpLnB1dCh7aWQ6YmxvY2tfaWQsIGNvbnRlbnQ6Y29udGVudH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5ib2R5RWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdpbmRvdy50aW55bWNlLmluaXQodGlueV9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LnNiLmVkaXRhYmxlKCk7XG4gIH0pO1xuICByZXR1cm4gd2luZG93LnNiO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcInNiL2tlcm5lbFwiLFxuXHRcImRib290c3RyYXBcIixcblx0XCJzdGFyYnVnL2Zvcm0vX0Zvcm1XaWRnZXRcIlxuXSwgZnVuY3Rpb24oc2Ipe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdHNiL21haW5cblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhlIHNiIHBhY2thZ2UgbWFpbiBtb2R1bGVcblx0cmV0dXJuIHNiO1xufSk7XG4iLCJkZWZpbmUoW1wiZG9qby9fYmFzZS9sYW5nXCIsIFwiZGlqaXQvZm9ybS9fRm9ybVdpZGdldE1peGluXCJdLCBmdW5jdGlvbihsYW5nLCBfRm9ybVdpZGdldCl7XG4gIGxhbmcuZXh0ZW5kKF9Gb3JtV2lkZ2V0LCB7XG4gICAgc2Nyb2xsT25Gb2N1czpmYWxzZVxuICB9KTtcbn0pO1xuIiwiLypcbiAgICA6Y29weXJpZ2h0OiBDb3B5cmlnaHQgMjAxMiBNYXJ0aW4gUGVuZ2VsbHktUGhpbGxpcHNcbiAgICA6bGljZW5zZTogU2VlIExJQ0VOU0UudHh0LlxuKi9cblxuZGVmaW5lKFxuW1xuICAgICdyZXF1aXJlJyxcbiAgICAnZG9qby9fYmFzZS9kZWNsYXJlJyxcbiAgICAnZG9qby9fYmFzZS9sYW5nJyxcbiAgICAnZG9qby9fYmFzZS9hcnJheScsXG4gICAgJ2Rvam8vZG9tLWNvbnN0cnVjdCcsXG4gICAgJ2Rvam8vZG9tLWNsYXNzJyxcbiAgICAnZGlqaXQvX1RlbXBsYXRlZE1peGluJ1xuXSxcblxuZnVuY3Rpb24ocmVxdWlyZSwgZGVjbGFyZSwgbGFuZywgYXJyYXksIGRvbUNvbnN0cnVjdCwgZG9tQ2xhc3MsIFRlbXBsYXRlZE1peGluKSB7XG4gICAgLy8gUGF0Y2ggdGVtcGxhdGVkIHdpZGdldHMgdG8gcmVwbGFjZSBpY29uIG5vZGVzIHRoYXQgZG8gbm8gc3VwcG9ydCBwc2V1ZG9cbiAgICAvLyBzdGF0ZXMgd2l0aCBub2RlcyB0aGF0IGRvLiBUaGlzIGVuYWJsZXMgRm9udC1Bd2Vzb21lIHRvIGJlIHVzZWRcbiAgICAvLyBldmVyeXdoZXJlIGZvciB0aGUgaWNvbnMuXG4gICAgLy9cbiAgICAvLyBUbyB1c2UsIHJlcXVpcmUgdGhpcyBtb2R1bGUgKmJlZm9yZSogRGlqaXQuXG4gICAgLy9cbiAgICB2YXIgX3JlcGxhY2VOb2Rlc0Zvckljb25TdXBwb3J0ID0gZnVuY3Rpb24ocm9vdE5vZGUpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBub2RlcyB0aGF0IGRvbid0IHN1cHBvcnQgOmJlZm9yZSB3aXRoIG5vZGVzIHRoYXQgZG8uXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZWZlcmVuY2VfdGFnX25hbWVzID0gWydJTUcnLCAnSU5QVVQnXTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZV9jbGFzc2VzID0gW1xuICAgICAgICAgICAgJ2Rpaml0SWNvbicsICdkaWppdFRhYlN0cmlwSWNvbicsICdkaWppdE1lbnVFeHBhbmQnLFxuICAgICAgICAgICAgJ2Rpaml0Q2FsZW5kYXJJbmNyZW1lbnRDb250cm9sJywgJ2Rpaml0QXJyb3dCdXR0b25Jbm5lcicsXG4gICAgICAgICAgICAnZGlqaXRUcmVlRXhwYW5kbycsICdkaWppdEFycm93Tm9kZSdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZV9hdHRyaWJ1dGVzID0gWydjbGFzcycsICdkYXRhLWRvam8tYXR0YWNoLXBvaW50J107XG5cbiAgICAgICAgdmFyIG5vZGVzID0gcm9vdE5vZGU7XG4gICAgICAgIGlmICghbGFuZy5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSAocm9vdE5vZGUuYWxsIHx8IHJvb3ROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IGxhbmcuaXNBcnJheShyb290Tm9kZSkgPyAwIDogLTE7XG4gICAgICAgIGZvciAoOyB4IDwgMCB8fCBub2Rlc1t4XTsgeCsrKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhY2Nlc3Mgbm9kZXMubGVuZ3RoIG9uIElFLCBzZWUgIzE0MzQ2XG4gICAgICAgICAgICB2YXIgbm9kZSA9ICh4ID09IC0xKSA/IHJvb3ROb2RlIDogbm9kZXNbeF07XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIGtub3duIHByb2JsZW0gbm9kZSB0eXBlcy5cbiAgICAgICAgICAgIGlmIChhcnJheS5pbmRleE9mKHJlZmVyZW5jZV90YWdfbmFtZXMsIG5vZGUudGFnTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vZGUgY29udGFpbnMgb25lIG9mIHRoZSByZWZlcmVuY2UgY2xhc3NlcyB0aGVuIHJlcGxhY2VcbiAgICAgICAgICAgIC8vIGl0IHdpdGggYSBzdWl0YWJsZSBwc2V1ZG8gc3RhdGUgZnJpZW5kbHkgbm9kZSwgY29weWluZ1xuICAgICAgICAgICAgLy8gcmVsZXZhbnQgYXR0cmlidXRlcyB0byB0aGUgbmV3IG5vZGUuXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9cmVmZXJlbmNlX2NsYXNzZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkb21DbGFzcy5jb250YWlucyhub2RlLCByZWZlcmVuY2VfY2xhc3Nlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChyZWZlcmVuY2VfYXR0cmlidXRlcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZG9tQ29uc3RydWN0LmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJywgYXR0cmlidXRlcywgbm9kZSwgJ3JlcGxhY2UnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChUZW1wbGF0ZWRNaXhpbi5wcm90b3R5cGUuX2F0dGFjaFRlbXBsYXRlTm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBEb2pvIDEuOSsgaW50cm9kdWNlZCBuZXcgX0F0dGFjaE1peGluIG1vZHVsZSB0aGF0IGNvbnRhaW5zIGNvZGVcbiAgICAgICAgLy8gdG8gcGF0Y2guXG4gICAgICAgIHJlcXVpcmUoWydkaWppdC9fQXR0YWNoTWl4aW4nXSwgZnVuY3Rpb24oQXR0YWNoTWl4aW4pIHtcbiAgICAgICAgICAgIHZhciBfb3JpZ2luYWwgPSBBdHRhY2hNaXhpbi5wcm90b3R5cGUuX2F0dGFjaFRlbXBsYXRlTm9kZXM7XG5cbiAgICAgICAgICAgIEF0dGFjaE1peGluLnByb3RvdHlwZS5fYXR0YWNoVGVtcGxhdGVOb2RlcyA9IGZ1bmN0aW9uKHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBub2Rlcy5cbiAgICAgICAgICAgICAgICBfcmVwbGFjZU5vZGVzRm9ySWNvblN1cHBvcnQocm9vdE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBub3JtYWwgcGFyZW50IG1ldGhvZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gX29yaWdpbmFsLmNhbGwodGhpcywgcm9vdE5vZGUpO1xuXG5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfb3JpZ2luYWwgPSBUZW1wbGF0ZWRNaXhpbi5wcm90b3R5cGUuX2F0dGFjaFRlbXBsYXRlTm9kZXM7XG5cbiAgICAgICAgVGVtcGxhdGVkTWl4aW4ucHJvdG90eXBlLl9hdHRhY2hUZW1wbGF0ZU5vZGVzID0gZnVuY3Rpb24ocm9vdE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJGdW5jKSB7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIG5vZGVzLlxuICAgICAgICAgICAgX3JlcGxhY2VOb2Rlc0Zvckljb25TdXBwb3J0KHJvb3ROb2RlKTtcblxuICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBub3JtYWwgcGFyZW50IG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiBfb3JpZ2luYWwuY2FsbCh0aGlzLCByb290Tm9kZSwgZ2V0QXR0ckZ1bmMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFRlbXBsYXRlZE1peGluO1xufSk7XG5cbiIsIi8qXG4gICAgOmNvcHlyaWdodDogQ29weXJpZ2h0IDIwMTIgTWFydGluIFBlbmdlbGx5LVBoaWxsaXBzXG4gICAgOmxpY2Vuc2U6IFNlZSBMSUNFTlNFLnR4dC5cbiovXG4vLyd4c3R5bGUvY3NzIS4vdGhlbWUvZGJvb3RzdHJhcC9kYm9vdHN0cmFwLmNzcycsXG5kZWZpbmUoW1xuICAgICcuL2ljb25fc3VwcG9ydCdcbl0sXG5cbmZ1bmN0aW9uIChUZW1wbGF0ZWRNaXhpbikge1xuXHRyZXR1cm4ge307XG5cdC8qXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ1RlbXBsYXRlZE1peGluJzogVGVtcGxhdGVkTWl4aW5cbiAgICB9O1xuICAgICovXG59KTtcblxuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2ggYXJyYXkubWFwXG5cdFwiZG9qby9hc3BlY3RcIixcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIlxuXSwgZnVuY3Rpb24oYXJyYXksIGFzcGVjdCwgZGVjbGFyZSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9EZXN0cm95YWJsZVxuXG5cdHJldHVybiBkZWNsYXJlKFwiZGlqaXQuRGVzdHJveWFibGVcIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4aW4gdG8gdHJhY2sgaGFuZGxlcyBhbmQgcmVsZWFzZSB0aGVtIHdoZW4gaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdENhbGwgdGhpcy5vd24oLi4uKSBvbiBsaXN0IG9mIGhhbmRsZXMgKHJldHVybmVkIGZyb20gZG9qby9hc3BlY3QsIGRvam8vb24sXG5cdFx0Ly9cdFx0ZG9qby9TdGF0ZWZ1bDo6d2F0Y2gsIG9yIGFueSBjbGFzcyAoaW5jbHVkaW5nIHdpZGdldHMpIHdpdGggYSBkZXN0cm95UmVjdXJzaXZlKCkgb3IgZGVzdHJveSgpIG1ldGhvZC5cblx0XHQvL1x0XHRUaGVuIGNhbGwgZGVzdHJveSgpIGxhdGVyIHRvIGRlc3Ryb3kgdGhpcyBpbnN0YW5jZSBhbmQgcmVsZWFzZSB0aGUgcmVzb3VyY2VzLlxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oLypCb29sZWFuKi8gcHJlc2VydmVEb20pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3Ryb3kgdGhpcyBjbGFzcywgcmVsZWFzaW5nIGFueSByZXNvdXJjZXMgcmVnaXN0ZXJlZCB2aWEgb3duKCkuXG5cdFx0XHR0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRvd246IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VHJhY2sgc3BlY2lmaWVkIGhhbmRsZXMgYW5kIHJlbW92ZS9kZXN0cm95IHRoZW0gd2hlbiB0aGlzIGluc3RhbmNlIGlzIGRlc3Ryb3llZCwgdW5sZXNzIHRoZXkgd2VyZVxuXHRcdFx0Ly9cdFx0YWxyZWFkeSByZW1vdmVkL2Rlc3Ryb3llZCBtYW51YWxseS5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRUaGUgYXJyYXkgb2Ygc3BlY2lmaWVkIGhhbmRsZXMsIHNvIHlvdSBjYW4gZG8gZm9yIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0XHR2YXIgaGFuZGxlID0gdGhpcy5vd24ob24oLi4uKSlbMF07XG5cblx0XHRcdHZhciBjbGVhbnVwTWV0aG9kcyA9IFtcblx0XHRcdFx0XCJkZXN0cm95UmVjdXJzaXZlXCIsXG5cdFx0XHRcdFwiZGVzdHJveVwiLFxuXHRcdFx0XHRcInJlbW92ZVwiXG5cdFx0XHRdO1xuXG5cdFx0XHRhcnJheS5mb3JFYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oaGFuZGxlKXtcblx0XHRcdFx0Ly8gV2hlbiB0aGlzLmRlc3Ryb3koKSBpcyBjYWxsZWQsIGRlc3Ryb3kgaGFuZGxlLiAgU2luY2UgSSdtIHVzaW5nIGFzcGVjdC5iZWZvcmUoKSxcblx0XHRcdFx0Ly8gdGhlIGhhbmRsZSB3aWxsIGJlIGRlc3Ryb3llZCBiZWZvcmUgYSBzdWJjbGFzcydzIGRlc3Ryb3koKSBtZXRob2Qgc3RhcnRzIHJ1bm5pbmcsIGJlZm9yZSBpdCBjYWxsc1xuXHRcdFx0XHQvLyB0aGlzLmluaGVyaXRlZCgpIG9yIGV2ZW4gaWYgaXQgZG9lc24ndCBjYWxsIHRoaXMuaW5oZXJpdGVkKCkgYXQgYWxsLiAgSWYgdGhhdCdzIGFuIGlzc3VlLCBtYWtlIGFuXG5cdFx0XHRcdC8vIG9uRGVzdHJveSgpIG1ldGhvZCBhbmQgY29ubmVjdCB0byB0aGF0IGluc3RlYWQuXG5cdFx0XHRcdHZhciBkZXN0cm95TWV0aG9kTmFtZTtcblx0XHRcdFx0dmFyIG9kaCA9IGFzcGVjdC5iZWZvcmUodGhpcywgXCJkZXN0cm95XCIsIGZ1bmN0aW9uIChwcmVzZXJ2ZURvbSl7XG5cdFx0XHRcdFx0aGFuZGxlW2Rlc3Ryb3lNZXRob2ROYW1lXShwcmVzZXJ2ZURvbSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGhhbmRsZSBpcyBtYW51YWxseSBkZXN0cm95ZWQuXG5cdFx0XHRcdHZhciBoZGhzID0gW107XG5cdFx0XHRcdGZ1bmN0aW9uIG9uTWFudWFsRGVzdHJveSgpe1xuXHRcdFx0XHRcdG9kaC5yZW1vdmUoKTtcblx0XHRcdFx0XHRhcnJheS5mb3JFYWNoKGhkaHMsIGZ1bmN0aW9uKGhkaCl7XG5cdFx0XHRcdFx0XHRoZGgucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXR1cCBsaXN0ZW5lcnMgZm9yIG1hbnVhbCBkZXN0cm95IG9mIGhhbmRsZS5cblx0XHRcdFx0Ly8gQWxzbyBjb21wdXRlcyBkZXN0cm95TWV0aG9kTmFtZSwgdXNlZCBpbiBsaXN0ZW5lciBhYm92ZS5cblx0XHRcdFx0aWYoaGFuZGxlLnRoZW4pe1xuXHRcdFx0XHRcdC8vIFNwZWNpYWwgcGF0aCBmb3IgUHJvbWlzZXMuICBEZXRlY3Qgd2hlbiBQcm9taXNlIGlzIHJlc29sdmVkLCByZWplY3RlZCwgb3Jcblx0XHRcdFx0XHQvLyBjYW5jZWxlZCAobmI6IGNhbmNlbGxpbmcgYSBQcm9taXNlIGNhdXNlcyBpdCB0byBiZSByZWplY3RlZCkuXG5cdFx0XHRcdFx0ZGVzdHJveU1ldGhvZE5hbWUgPSBcImNhbmNlbFwiO1xuXHRcdFx0XHRcdGhhbmRsZS50aGVuKG9uTWFudWFsRGVzdHJveSwgb25NYW51YWxEZXN0cm95KTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Ly8gUGF0aCBmb3Igb3RoZXIgaGFuZGxlcy4gIEp1c3QgdXNlIEFPUCB0byBkZXRlY3Qgd2hlbiBoYW5kbGUgaXMgbWFudWFsbHkgZGVzdHJveWVkLlxuXHRcdFx0XHRcdGFycmF5LmZvckVhY2goY2xlYW51cE1ldGhvZHMsIGZ1bmN0aW9uKGNsZWFudXBNZXRob2Qpe1xuXHRcdFx0XHRcdFx0aWYodHlwZW9mIGhhbmRsZVtjbGVhbnVwTWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRcdFx0aWYoIWRlc3Ryb3lNZXRob2ROYW1lKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgZmlyc3QgbWF0Y2hpbmcgbWV0aG9kIG5hbWUgaW4gYWJvdmUgbGlzdGVuZXIgKHByZWZlciBkZXN0cm95UmVjdXJzaXZlKCkgdG8gZGVzdHJveSgpKVxuXHRcdFx0XHRcdFx0XHRcdGRlc3Ryb3lNZXRob2ROYW1lID0gY2xlYW51cE1ldGhvZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRoZGhzLnB1c2goYXNwZWN0LmFmdGVyKGhhbmRsZSwgY2xlYW51cE1ldGhvZCwgb25NYW51YWxEZXN0cm95LCB0cnVlKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzO1x0XHQvLyBoYW5kbGVcblx0XHR9XG5cdH0pO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcInJlcXVpcmVcIixcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2hcblx0XCJkb2pvL19iYXNlL2Nvbm5lY3RcIixcdC8vIHJlbW92ZSBmb3IgMi4wXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL19iYXNlL2xhbmdcIiwgLy8gbGFuZy5nZXRPYmplY3Rcblx0XCJkb2pvL21vdXNlXCIsXG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vdG91Y2hcIixcblx0XCIuL19XaWRnZXRCYXNlXCJcbl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGFycmF5LCBjb25uZWN0LCBkZWNsYXJlLCBsYW5nLCBtb3VzZSwgb24sIHRvdWNoLCBfV2lkZ2V0QmFzZSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fQXR0YWNoTWl4aW5cblxuXHQvLyBNYXAgZnJvbSBzdHJpbmcgbmFtZSBsaWtlIFwibW91c2VlbnRlclwiIHRvIHN5bnRoZXRpYyBldmVudCBsaWtlIG1vdXNlLmVudGVyXG5cdHZhciBzeW50aEV2ZW50cyA9IGxhbmcuZGVsZWdhdGUodG91Y2gsIHtcblx0XHRcIm1vdXNlZW50ZXJcIjogbW91c2UuZW50ZXIsXG5cdFx0XCJtb3VzZWxlYXZlXCI6IG1vdXNlLmxlYXZlLFxuXHRcdFwia2V5cHJlc3NcIjogY29ubmVjdC5fa2V5cHJlc3NcdC8vIHJlbW92ZSBmb3IgMi4wXG5cdH0pO1xuXG5cdC8vIFRvIGJlIGxpZ2h0d2VpZ2h0LCBfQXR0YWNoTWl4aW4gZG9lc24ndCByZXF1aXJlKCkgZGlqaXQvYTExeWNsaWNrLlxuXHQvLyBJZiB0aGUgc3ViY2xhc3MgaGFzIGEgdGVtcGxhdGUgdXNpbmcgXCJvbmRpaml0Y2xpY2tcIiwgaXQgbXVzdCBsb2FkIGRpaml0L2ExMXljbGljayBpdHNlbGYuXG5cdC8vIEluIHRoYXQgY2FzZSwgdGhlIGExMXljbGljayB2YXJpYWJsZSBiZWxvdyB3aWxsIGdldCBzZXQgdG8gcG9pbnQgdG8gdGhhdCBzeW50aGV0aWMgZXZlbnQuXG5cdHZhciBhMTF5Y2xpY2s7XG5cblx0dmFyIF9BdHRhY2hNaXhpbiA9IGRlY2xhcmUoXCJkaWppdC5fQXR0YWNoTWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4aW4gZm9yIHdpZGdldHMgdG8gYXR0YWNoIHRvIGRvbSBub2RlcyBhbmQgc2V0dXAgZXZlbnRzIHZpYVxuXHRcdC8vXHRcdGNvbnZlbmllbnQgZGF0YS1kb2pvLWF0dGFjaC1wb2ludCBhbmQgZGF0YS1kb2pvLWF0dGFjaC1ldmVudCBET00gYXR0cmlidXRlcy5cblx0XHQvL1xuXHRcdC8vXHRcdFN1cGVyY2xhc3Mgb2YgX1RlbXBsYXRlZE1peGluLCBhbmQgY2FuIGFsc28gYmUgdXNlZCBzdGFuZGFsb25lIHdoZW4gdGVtcGxhdGVzIGFyZSBwcmUtcmVuZGVyZWQgb24gdGhlXG5cdFx0Ly9cdFx0c2VydmVyLlxuXHRcdC8vXG5cdFx0Ly9cdFx0RG9lcyBub3QgW3lldF0gaGFuZGxlIHdpZGdldHMgbGlrZSBDb250ZW50UGFuZSB3aXRoIHRoaXMuY29udGFpbmVyTm9kZSBzZXQuICAgSXQgc2hvdWxkIHNraXBcblx0XHQvL1x0XHRzY2FubmluZyBmb3IgZGF0YS1kb2pvLWF0dGFjaC1wb2ludCBhbmQgZGF0YS1kb2pvLWF0dGFjaC1ldmVudCBpbnNpZGUgdGhpcy5jb250YWluZXJOb2RlLCBidXQgaXRcblx0XHQvL1x0XHRkb2Vzbid0LlxuXG4vKj09PT09XG5cdFx0Ly8gX2F0dGFjaFBvaW50czogW3ByaXZhdGVdIFN0cmluZ1tdXG5cdFx0Ly9cdFx0TGlzdCBvZiB3aWRnZXQgYXR0cmlidXRlIG5hbWVzIGFzc29jaWF0ZWQgd2l0aCBkYXRhLWRvam8tYXR0YWNoLXBvaW50PS4uLiBpbiB0aGVcblx0XHQvL1x0XHR0ZW1wbGF0ZSwgZXg6IFtcImNvbnRhaW5lck5vZGVcIiwgXCJsYWJlbE5vZGVcIl1cblx0XHRfYXR0YWNoUG9pbnRzOiBbXSxcblxuXHRcdC8vIF9hdHRhY2hFdmVudHM6IFtwcml2YXRlXSBIYW5kbGVbXVxuXHRcdC8vXHRcdExpc3Qgb2YgY29ubmVjdGlvbnMgYXNzb2NpYXRlZCB3aXRoIGRhdGEtZG9qby1hdHRhY2gtZXZlbnQ9Li4uIGluIHRoZVxuXHRcdC8vXHRcdHRlbXBsYXRlXG5cdFx0X2F0dGFjaEV2ZW50czogW10sXG5cblx0XHQvLyBhdHRhY2hTY29wZTogW3B1YmxpY10gT2JqZWN0XG5cdFx0Ly9cdFx0T2JqZWN0IHRvIHdoaWNoIGF0dGFjaCBwb2ludHMgYW5kIGV2ZW50cyB3aWxsIGJlIHNjb3BlZC4gIERlZmF1bHRzXG5cdFx0Ly9cdFx0dG8gJ3RoaXMnLlxuXHRcdGF0dGFjaFNjb3BlOiB1bmRlZmluZWQsXG5cblx0XHQvLyBzZWFyY2hDb250YWluZXJOb2RlOiBbcHJvdGVjdGVkXSBCb29sZWFuXG5cdFx0Ly9cdFx0U2VhcmNoIGRlc2NlbmRhbnRzIG9mIHRoaXMuY29udGFpbmVyTm9kZSBmb3IgZGF0YS1kb2pvLWF0dGFjaC1wb2ludCBhbmQgZGF0YS1kb2pvLWF0dGFjaC1ldmVudC5cblx0XHQvL1x0XHRTaG91bGQgZ2VuZXJhbGx5IGJlIGxlZnQgZmFsc2UgKHRoZSBkZWZhdWx0IHZhbHVlKSBib3RoIGZvciBwZXJmb3JtYW5jZSBhbmQgdG8gYXZvaWQgZmFpbHVyZXMgd2hlblxuXHRcdC8vXHRcdHRoaXMuY29udGFpbmVyTm9kZSBob2xkcyBvdGhlciBfQXR0YWNoTWl4aW4gaW5zdGFuY2VzIHdpdGggdGhlaXIgb3duIGF0dGFjaCBwb2ludHMgYW5kIGV2ZW50cy5cbiBcdFx0c2VhcmNoQ29udGFpbmVyTm9kZTogZmFsc2UsXG4gPT09PT0qL1xuXG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKC8qPT09PT0gcGFyYW1zLCBzcmNOb2RlUmVmID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENyZWF0ZSB0aGUgd2lkZ2V0LlxuXHRcdFx0Ly8gcGFyYW1zOiBPYmplY3R8bnVsbFxuXHRcdFx0Ly9cdFx0SGFzaCBvZiBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzIGZvciB3aWRnZXQsIGluY2x1ZGluZyBzY2FsYXIgdmFsdWVzIChsaWtlIHRpdGxlLCBkdXJhdGlvbiBldGMuKVxuXHRcdFx0Ly9cdFx0YW5kIGZ1bmN0aW9ucywgdHlwaWNhbGx5IGNhbGxiYWNrcyBsaWtlIG9uQ2xpY2suXG5cdFx0XHQvL1x0XHRUaGUgaGFzaCBjYW4gY29udGFpbiBhbnkgb2YgdGhlIHdpZGdldCdzIHByb3BlcnRpZXMsIGV4Y2x1ZGluZyByZWFkLW9ubHkgcHJvcGVydGllcy5cblx0XHRcdC8vIHNyY05vZGVSZWY6IERPTU5vZGV8U3RyaW5nP1xuXHRcdFx0Ly9cdFx0SWYgYSBzcmNOb2RlUmVmIChET00gbm9kZSkgaXMgc3BlY2lmaWVkLCByZXBsYWNlIHNyY05vZGVSZWYgd2l0aCBteSBnZW5lcmF0ZWQgRE9NIHRyZWUuXG5cblx0XHRcdHRoaXMuX2F0dGFjaFBvaW50cyA9IFtdO1xuXHRcdFx0dGhpcy5fYXR0YWNoRXZlbnRzID0gW107XG5cdFx0fSxcblxuXG5cdFx0YnVpbGRSZW5kZXJpbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QXR0YWNoIHRvIERPTSBub2RlcyBtYXJrZWQgd2l0aCBzcGVjaWFsIGF0dHJpYnV0ZXMuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIHJlY3Vyc2UgdGhyb3VnaCB0aGUgbm9kZSwgbG9va2luZyBmb3IsIGFuZCBhdHRhY2hpbmcgdG8sIG91clxuXHRcdFx0Ly8gYXR0YWNobWVudCBwb2ludHMgYW5kIGV2ZW50cywgd2hpY2ggc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIHRlbXBsYXRlIG5vZGUuXG5cdFx0XHR0aGlzLl9hdHRhY2hUZW1wbGF0ZU5vZGVzKHRoaXMuZG9tTm9kZSk7XG5cblx0XHRcdHRoaXMuX2JlZm9yZUZpbGxDb250ZW50KCk7XHRcdC8vIGhvb2sgZm9yIF9XaWRnZXRzSW5UZW1wbGF0ZU1peGluXG5cdFx0fSxcblxuXHRcdF9iZWZvcmVGaWxsQ29udGVudDogZnVuY3Rpb24oKXtcblx0XHR9LFxuXG5cdFx0X2F0dGFjaFRlbXBsYXRlTm9kZXM6IGZ1bmN0aW9uKHJvb3ROb2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRJdGVyYXRlIHRocm91Z2ggdGhlIGRvbSBub2RlcyBhbmQgYXR0YWNoIGZ1bmN0aW9ucyBhbmQgbm9kZXMgYWNjb3JkaW5nbHkuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdE1hcCB3aWRnZXQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zIHRvIHRoZSBoYW5kbGVycyBzcGVjaWZpZWQgaW5cblx0XHRcdC8vXHRcdHRoZSBkb20gbm9kZSBhbmQgaXQncyBkZXNjZW5kYW50cy4gVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyBvdmVyIGFsbFxuXHRcdFx0Ly9cdFx0bm9kZXMgYW5kIGxvb2tzIGZvciB0aGVzZSBwcm9wZXJ0aWVzOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gZG9qb0F0dGFjaFBvaW50L2RhdGEtZG9qby1hdHRhY2gtcG9pbnRcblx0XHRcdC8vXHRcdC0gZG9qb0F0dGFjaEV2ZW50L2RhdGEtZG9qby1hdHRhY2gtZXZlbnRcblx0XHRcdC8vIHJvb3ROb2RlOiBEb21Ob2RlXG5cdFx0XHQvL1x0XHRUaGUgbm9kZSB0byBzZWFyY2ggZm9yIHByb3BlcnRpZXMuIEFsbCBkZXNjZW5kYW50cyB3aWxsIGJlIHNlYXJjaGVkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Ly8gREZTIHRvIHByb2Nlc3MgYWxsIG5vZGVzIGV4Y2VwdCB0aG9zZSBpbnNpZGUgb2YgdGhpcy5jb250YWluZXJOb2RlXG5cdFx0XHR2YXIgbm9kZSA9IHJvb3ROb2RlO1xuXHRcdFx0d2hpbGUodHJ1ZSl7XG5cdFx0XHRcdGlmKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAodGhpcy5fcHJvY2Vzc1RlbXBsYXRlTm9kZShub2RlLCBmdW5jdGlvbihuLHApeyByZXR1cm4gbi5nZXRBdHRyaWJ1dGUocCk7IH0sXG5cdFx0XHRcdFx0XHR0aGlzLl9hdHRhY2gpIHx8IHRoaXMuc2VhcmNoQ29udGFpbmVyTm9kZSkgJiYgbm9kZS5maXJzdENoaWxkKXtcblx0XHRcdFx0XHRub2RlID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZihub2RlID09IHJvb3ROb2RlKXsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0d2hpbGUoIW5vZGUubmV4dFNpYmxpbmcpe1xuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdGlmKG5vZGUgPT0gcm9vdE5vZGUpeyByZXR1cm47IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3Byb2Nlc3NUZW1wbGF0ZU5vZGU6IGZ1bmN0aW9uKC8qRE9NTm9kZXxXaWRnZXQqLyBiYXNlTm9kZSwgZ2V0QXR0ckZ1bmMsIGF0dGFjaEZ1bmMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFByb2Nlc3MgZGF0YS1kb2pvLWF0dGFjaC1wb2ludCBhbmQgZGF0YS1kb2pvLWF0dGFjaC1ldmVudCBmb3IgZ2l2ZW4gbm9kZSBvciB3aWRnZXQuXG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRydWUgaWYgY2FsbGVyIHNob3VsZCBwcm9jZXNzIGJhc2VOb2RlJ3MgY2hpbGRyZW4gdG9vLlxuXG5cdFx0XHR2YXIgcmV0ID0gdHJ1ZTtcblxuXHRcdFx0Ly8gUHJvY2VzcyBkYXRhLWRvam8tYXR0YWNoLXBvaW50XG5cdFx0XHR2YXIgX2F0dGFjaFNjb3BlID0gdGhpcy5hdHRhY2hTY29wZSB8fCB0aGlzLFxuXHRcdFx0XHRhdHRhY2hQb2ludCA9IGdldEF0dHJGdW5jKGJhc2VOb2RlLCBcImRvam9BdHRhY2hQb2ludFwiKSB8fCBnZXRBdHRyRnVuYyhiYXNlTm9kZSwgXCJkYXRhLWRvam8tYXR0YWNoLXBvaW50XCIpO1xuXHRcdFx0aWYoYXR0YWNoUG9pbnQpe1xuXHRcdFx0XHR2YXIgcG9pbnQsIHBvaW50cyA9IGF0dGFjaFBvaW50LnNwbGl0KC9cXHMqLFxccyovKTtcblx0XHRcdFx0d2hpbGUoKHBvaW50ID0gcG9pbnRzLnNoaWZ0KCkpKXtcblx0XHRcdFx0XHRpZihsYW5nLmlzQXJyYXkoX2F0dGFjaFNjb3BlW3BvaW50XSkpe1xuXHRcdFx0XHRcdFx0X2F0dGFjaFNjb3BlW3BvaW50XS5wdXNoKGJhc2VOb2RlKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdF9hdHRhY2hTY29wZVtwb2ludF0gPSBiYXNlTm9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0ID0gKHBvaW50ICE9IFwiY29udGFpbmVyTm9kZVwiKTtcblx0XHRcdFx0XHR0aGlzLl9hdHRhY2hQb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvY2VzcyBkYXRhLWRvam8tYXR0YWNoLWV2ZW50XG5cdFx0XHR2YXIgYXR0YWNoRXZlbnQgPSBnZXRBdHRyRnVuYyhiYXNlTm9kZSwgXCJkb2pvQXR0YWNoRXZlbnRcIikgfHwgZ2V0QXR0ckZ1bmMoYmFzZU5vZGUsIFwiZGF0YS1kb2pvLWF0dGFjaC1ldmVudFwiKTtcblx0XHRcdGlmKGF0dGFjaEV2ZW50KXtcblx0XHRcdFx0Ly8gTk9URTogd2Ugd2FudCB0byBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhhdCBoYXZlIHRoZSBmb3JtXG5cdFx0XHRcdC8vIFwiZG9tRXZlbnQ6IG5hdGl2ZUV2ZW50LCAuLi5cIlxuXHRcdFx0XHR2YXIgZXZlbnQsIGV2ZW50cyA9IGF0dGFjaEV2ZW50LnNwbGl0KC9cXHMqLFxccyovKTtcblx0XHRcdFx0dmFyIHRyaW0gPSBsYW5nLnRyaW07XG5cdFx0XHRcdHdoaWxlKChldmVudCA9IGV2ZW50cy5zaGlmdCgpKSl7XG5cdFx0XHRcdFx0aWYoZXZlbnQpe1xuXHRcdFx0XHRcdFx0dmFyIHRoaXNGdW5jID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmKGV2ZW50LmluZGV4T2YoXCI6XCIpICE9IC0xKXtcblx0XHRcdFx0XHRcdFx0Ly8gb2gsIGlmIG9ubHkgSlMgaGFkIHR1cGxlIGFzc2lnbm1lbnRcblx0XHRcdFx0XHRcdFx0dmFyIGZ1bmNOYW1lQXJyID0gZXZlbnQuc3BsaXQoXCI6XCIpO1xuXHRcdFx0XHRcdFx0XHRldmVudCA9IHRyaW0oZnVuY05hbWVBcnJbMF0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzRnVuYyA9IHRyaW0oZnVuY05hbWVBcnJbMV0pO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGV2ZW50ID0gdHJpbShldmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighdGhpc0Z1bmMpe1xuXHRcdFx0XHRcdFx0XHR0aGlzRnVuYyA9IGV2ZW50O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9hdHRhY2hFdmVudHMucHVzaChhdHRhY2hGdW5jKGJhc2VOb2RlLCBldmVudCwgbGFuZy5oaXRjaChfYXR0YWNoU2NvcGUsIHRoaXNGdW5jKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHRfYXR0YWNoOiBmdW5jdGlvbihub2RlLCB0eXBlLCBmdW5jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSb3VnaGx5IGNvcnJlc3BvbmRpbmcgdG8gZG9qby9vbiwgdGhpcyBpcyB0aGUgZGVmYXVsdCBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhXG5cdFx0XHQvL1x0XHRkYXRhLWRvam8tYXR0YWNoLWV2ZW50LiAgTWVhbnQgdG8gYXR0YWNoIHRvIERPTU5vZGVzLCBub3QgdG8gd2lkZ2V0cy5cblx0XHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHRcdC8vXHRcdFRoZSBub2RlIHRvIHNldHVwIGEgbGlzdGVuZXIgb24uXG5cdFx0XHQvLyB0eXBlOiBTdHJpbmdcblx0XHRcdC8vXHRcdEV2ZW50IG5hbWUgbGlrZSBcImNsaWNrXCIuXG5cdFx0XHQvLyBnZXRBdHRyRnVuYzogRnVuY3Rpb25cblx0XHRcdC8vXHRcdEZ1bmN0aW9uIHRvIGdldCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciBhIGdpdmVuIERvbU5vZGUvV2lkZ2V0LlxuXHRcdFx0Ly8gYXR0YWNoRnVuYzogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIGZyb20gdGhlIHNwZWNpZmllZCBub2RlL3dpZGdldCB0byBzcGVjaWZpZWQgZnVuY3Rpb24uXG5cblx0XHRcdC8vIE1hcCBzcGVjaWFsIHR5cGUgbmFtZXMgbGlrZSBcIm1vdXNlZW50ZXJcIiB0byBzeW50aGV0aWMgZXZlbnRzLlxuXHRcdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgdG8gcmVxdWlyZSgpIGRpaml0L2ExMXljbGljayBpZiB0aGV5IHdhbnQgdG8gdXNlIGl0LlxuXHRcdFx0dHlwZSA9IHR5cGUucmVwbGFjZSgvXm9uLywgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmKHR5cGUgPT0gXCJkaWppdGNsaWNrXCIpe1xuXHRcdFx0XHR0eXBlID0gYTExeWNsaWNrIHx8IChhMTF5Y2xpY2sgPSByZXF1aXJlKFwiLi9hMTF5Y2xpY2tcIikpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHR5cGUgPSBzeW50aEV2ZW50c1t0eXBlXSB8fCB0eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb24obm9kZSwgdHlwZSwgZnVuYyk7XG5cdFx0fSxcblxuXHRcdF9kZXRhY2hUZW1wbGF0ZU5vZGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXRhY2ggYW5kIGNsZWFuIHVwIHRoZSBhdHRhY2htZW50cyBtYWRlIGluIF9hdHRhY2h0ZW1wYWx0ZU5vZGVzLlxuXG5cdFx0XHQvLyBEZWxldGUgYWxsIGF0dGFjaCBwb2ludHMgdG8gcHJldmVudCBJRTYgbWVtb3J5IGxlYWtzLlxuXHRcdFx0dmFyIF9hdHRhY2hTY29wZSA9IHRoaXMuYXR0YWNoU2NvcGUgfHwgdGhpcztcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fYXR0YWNoUG9pbnRzLCBmdW5jdGlvbihwb2ludCl7XG5cdFx0XHRcdGRlbGV0ZSBfYXR0YWNoU2NvcGVbcG9pbnRdO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9hdHRhY2hQb2ludHMgPSBbXTtcblxuXHRcdFx0Ly8gQW5kIHNhbWUgZm9yIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuX2F0dGFjaEV2ZW50cywgZnVuY3Rpb24oaGFuZGxlKXsgaGFuZGxlLnJlbW92ZSgpOyB9KTtcblx0XHRcdHRoaXMuX2F0dGFjaEV2ZW50cyA9IFtdO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95UmVuZGVyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoVGVtcGxhdGVOb2RlcygpO1xuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFRoZXNlIGFyZ3VtZW50cyBjYW4gYmUgc3BlY2lmaWVkIGZvciB3aWRnZXRzIHdoaWNoIGFyZSB1c2VkIGluIHRlbXBsYXRlcy5cblx0Ly8gU2luY2UgYW55IHdpZGdldCBjYW4gYmUgc3BlY2lmaWVkIGFzIHN1YiB3aWRnZXRzIGluIHRlbXBsYXRlLCBtaXggaXRcblx0Ly8gaW50byB0aGUgYmFzZSB3aWRnZXQgY2xhc3MuICAoVGhpcyBpcyBhIGhhY2ssIGJ1dCBpdCdzIGVmZmVjdGl2ZS4pLlxuXHQvLyBSZW1vdmUgZm9yIDIuMC4gICBBbHNvLCBoaWRlIGZyb20gQVBJIGRvYyBwYXJzZXIuXG5cdGxhbmcuZXh0ZW5kKF9XaWRnZXRCYXNlLCAvKj09PT09IHt9IHx8ID09PT09Ki8ge1xuXHRcdGRvam9BdHRhY2hFdmVudDogXCJcIixcblx0XHRkb2pvQXR0YWNoUG9pbnQ6IFwiXCJcblx0fSk7XG5cdFxuXHRyZXR1cm4gX0F0dGFjaE1peGluO1xufSk7XG4iLCJkZWZpbmUoW10sIGZ1bmN0aW9uKCl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fQmlkaU1peGluXG5cblx0Ly8gVUNDIC0gY29uc3RhbnRzIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGJpZGkgc3VwcG9ydC5cblx0dmFyIGJpZGlfY29uc3QgPSB7XG5cdFx0TFJNIDogJ1xcdTIwMEUnLFxuXHRcdExSRSA6ICdcXHUyMDJBJyxcblx0XHRQREYgOiAnXFx1MjAyQycsXG5cdFx0UkxNIDogJ1xcdTIwMGYnLFxuXHRcdFJMRSA6ICdcXHUyMDJCJ1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRXaGVuIGhhcyhcImRvam8tYmlkaVwiKSBpcyB0cnVlLCBfV2lkZ2V0QmFzZSB3aWxsIG1peGluIHRoaXMgY2xhc3MuICAgSXQgZW5hYmxlcyBzdXBwb3J0IGZvciB0aGUgdGV4dGRpclxuXHRcdC8vXHRcdHByb3BlcnR5IHRvIGNvbnRyb2wgdGV4dCBkaXJlY3Rpb24gaW5kZXBlbmRlbnRseSBmcm9tIHRoZSBHVUkgZGlyZWN0aW9uLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFRoZXJlJ3MgYSBzcGVjaWFsIG5lZWQgZm9yIGRpc3BsYXlpbmcgQklESSB0ZXh0IGluIHJ0bCBkaXJlY3Rpb25cblx0XHQvL1x0XHRpbiBsdHIgR1VJLCBzb21ldGltZXMgbmVlZGVkIGF1dG8gc3VwcG9ydC5cblx0XHQvL1x0XHRJbiBjcmVhdGlvbiBvZiB3aWRnZXQsIGlmIGl0J3Mgd2FudCB0byBhY3RpdmF0ZSB0aGlzIGNsYXNzLFxuXHRcdC8vXHRcdHRoZSB3aWRnZXQgc2hvdWxkIGRlZmluZSB0aGUgXCJ0ZXh0RGlyXCIuXG5cblx0XHRnZXRUZXh0RGlyOiBmdW5jdGlvbigvKlN0cmluZyovIHRleHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEdldHMgdGhlIHJpZ2h0IGRpcmVjdGlvbiBvZiB0ZXh0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRJZiB0ZXh0RGlyIGlzIGx0ciBvciBydGwgcmV0dXJucyB0aGUgdmFsdWUuXG5cdFx0XHQvL1x0XHRJZiBpdCdzIGF1dG8sIGNhbGxzIHRvIGFub3RoZXIgZnVuY3Rpb24gdGhhdCByZXNwb25zaWJsZVxuXHRcdFx0Ly9cdFx0Zm9yIGNoZWNraW5nIHRoZSB2YWx1ZSwgYW5kIGRlZmluaW5nIHRoZSBkaXJlY3Rpb24uXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkLlxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dERpciA9PSBcImF1dG9cIiA/IHRoaXMuX2NoZWNrQ29udGV4dHVhbCh0ZXh0KSA6IHRoaXMudGV4dERpcjtcblx0XHR9LFxuXG5cdFx0X2NoZWNrQ29udGV4dHVhbDogZnVuY3Rpb24odGV4dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZHMgdGhlIGZpcnN0IHN0cm9uZyAoZGlyZWN0aW9uYWwpIGNoYXJhY3RlciwgcmV0dXJuIGx0ciBpZiBpc0xhdGluXG5cdFx0XHQvL1x0XHRvciBydGwgaWYgaXNCaWRpQ2hhci5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlLlxuXG5cdFx0XHQvLyBsb29rIGZvciBzdHJvbmcgKGRpcmVjdGlvbmFsKSBjaGFyYWN0ZXJzXG5cdFx0XHR2YXIgZmRjID0gL1tBLVphLXpcXHUwNWQwLVxcdTA2NWZcXHUwNjZhLVxcdTA2ZWZcXHUwNmZhLVxcdTA3ZmZcXHVmYjFkLVxcdWZkZmZcXHVmZTcwLVxcdWZlZmNdLy5leGVjKHRleHQpO1xuXHRcdFx0Ly8gaWYgZm91bmQgcmV0dXJuIHRoZSBkaXJlY3Rpb24gdGhhdCBkZWZpbmVkIGJ5IHRoZSBjaGFyYWN0ZXIsIGVsc2UgcmV0dXJuIHdpZGdldHMgZGlyIGFzIGRlZnVsdC5cblx0XHRcdHJldHVybiBmZGMgPyAoIGZkY1swXSA8PSAneicgPyBcImx0clwiIDogXCJydGxcIiApIDogdGhpcy5kaXIgPyB0aGlzLmRpciA6IHRoaXMuaXNMZWZ0VG9SaWdodCgpID8gXCJsdHJcIiA6IFwicnRsXCI7XG5cdFx0fSxcblxuXHRcdGFwcGx5VGV4dERpcjogZnVuY3Rpb24oLypET01Ob2RlKi8gZWxlbWVudCwgLypTdHJpbmc/Ki8gdGV4dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0U2V0IGVsZW1lbnQuZGlyIGFjY29yZGluZyB0byB0aGlzLnRleHREaXIsIGFzc3VtaW5nIHRoaXMudGV4dERpciBoYXMgYSB2YWx1ZS5cblx0XHRcdC8vIGVsZW1lbnQ6XG5cdFx0XHQvL1x0XHRUaGUgdGV4dCBlbGVtZW50IHRvIGJlIHNldC4gU2hvdWxkIGhhdmUgZGlyIHByb3BlcnR5LlxuXHRcdFx0Ly8gdGV4dDpcblx0XHRcdC8vXHRcdElmIHNwZWNpZmllZCwgYW5kIHRoaXMudGV4dERpciBpcyBcImF1dG9cIiwgZm9yIGNhbGN1bGF0aW5nIHRoZSByaWdodCB0cmFuc2Zvcm1hdGlvblxuXHRcdFx0Ly9cdFx0T3RoZXJ3aXNlIHRleHQgcmVhZCBmcm9tIGVsZW1lbnQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdElmIHRleHREaXIgaXMgbHRyIG9yIHJ0bCByZXR1cm5zIHRoZSB2YWx1ZS5cblx0XHRcdC8vXHRcdElmIGl0J3MgYXV0bywgY2FsbHMgdG8gYW5vdGhlciBmdW5jdGlvbiB0aGF0IHJlc3BvbnNpYmxlXG5cdFx0XHQvL1x0XHRmb3IgY2hlY2tpbmcgdGhlIHZhbHVlLCBhbmQgZGVmaW5pbmcgdGhlIGRpcmVjdGlvbi5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWQuXG5cblx0XHRcdGlmKHRoaXMudGV4dERpcil7XG5cdFx0XHRcdHZhciB0ZXh0RGlyID0gdGhpcy50ZXh0RGlyO1xuXHRcdFx0XHRpZih0ZXh0RGlyID09IFwiYXV0b1wiKXtcblx0XHRcdFx0XHQvLyBjb252ZXJ0IFwiYXV0b1wiIHRvIGVpdGhlciBcImx0clwiIG9yIFwicnRsXCJcblx0XHRcdFx0XHRpZih0eXBlb2YgdGV4dCA9PT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdFx0XHQvLyB0ZXh0IG5vdCBzcGVjaWZpZWQsIGdldCB0ZXh0IGZyb20gZWxlbWVudFxuXHRcdFx0XHRcdFx0dmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHRleHQgPSAodGFnTmFtZSA9PSBcImlucHV0XCIgfHwgdGFnTmFtZSA9PSBcInRleHRhcmVhXCIpID8gZWxlbWVudC52YWx1ZSA6XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuaW5uZXJUZXh0IHx8IGVsZW1lbnQudGV4dENvbnRlbnQgfHwgXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGV4dERpciA9IHRoaXMuX2NoZWNrQ29udGV4dHVhbCh0ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGVsZW1lbnQuZGlyICE9IHRleHREaXIpe1xuXHRcdFx0XHRcdC8vIHNldCBlbGVtZW50J3MgZGlyIHRvIG1hdGNoIHRleHREaXIsIGJ1dCBub3Qgd2hlbiB0ZXh0RGlyIGlzIG51bGwgYW5kIG5vdCB3aGVuIGl0IGFscmVhZHkgbWF0Y2hlc1xuXHRcdFx0XHRcdGVsZW1lbnQuZGlyID0gdGV4dERpcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRlbmZvcmNlVGV4dERpcldpdGhVY2M6IGZ1bmN0aW9uKG9wdGlvbiwgdGV4dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0V3JhcHMgYnkgVUNDIChVbmljb2RlIGNvbnRyb2wgY2hhcmFjdGVycykgb3B0aW9uJ3MgdGV4dCBhY2NvcmRpbmcgdG8gdGhpcy50ZXh0RGlyXG5cdFx0XHQvLyBvcHRpb246XG5cdFx0XHQvL1x0XHRUaGUgZWxlbWVudCAoYDxvcHRpb24+YCkgd2Ugd3JhcHBpbmcgdGhlIHRleHQgZm9yLlxuXHRcdFx0Ly8gdGV4dDpcblx0XHRcdC8vXHRcdFRoZSB0ZXh0IHRvIGJlIHdyYXBwZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoZXJlJ3MgYSBkaXIgcHJvYmxlbSB3aXRoIHNvbWUgSFRNTCBlbGVtZW50cy4gRm9yIHNvbWUgZWxlbWVudHMgKGUuZy4gYDxvcHRpb24+YCwgYDxzZWxlY3Q+YClcblx0XHRcdC8vXHRcdGRlZmluaW5nIHRoZSBkaXIgaW4gZGlmZmVyZW50IGRpcmVjdGlvbiB0aGVuIHRoZSBHVUkgb3JpZW50YXRpb24sIHdvbid0IGRpc3BsYXkgY29ycmVjdGx5LlxuXHRcdFx0Ly9cdFx0RkYgMy42IHdpbGwgY2hhbmdlIHRoZSBhbGlnbm1lbnQgb2YgdGhlIHRleHQgaW4gb3B0aW9uIC0gdGhpcyBkb2Vzbid0IGZvbGxvdyB0aGUgYmlkaSBzdGFuZGFyZHMgKHN0YXRpYyB0ZXh0XG5cdFx0XHQvL1x0XHRzaG91bGQgYmUgYWxpZ25lZCBmb2xsb3dpbmcgR1VJIGRpcmVjdGlvbikuIElFOCBhbmQgT3BlcmExMS4xMCBjb21wbGV0ZWx5IGlnbm9yZSBkaXIgc2V0dGluZyBmb3IgYDxvcHRpb24+YC5cblx0XHRcdC8vXHRcdFRoZXJlZm9yZSB0aGUgb25seSBzb2x1dGlvbiBpcyB0byB1c2UgVUNDIChVbmljb2RlICBjb250cm9sIGNoYXJhY3RlcnMpIHRvIGRpc3BsYXkgdGhlIHRleHQgaW4gY29ycmVjdCBvcmllbnRhdGlvbi5cblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gc2F2ZXMgdGhlIG9yaWdpbmFsIHRleHQgdmFsdWUgZm9yIGxhdGVyIHJlc3RvcmF0aW9uIGlmIG5lZWRlZCwgZm9yIGV4YW1wbGUgaWYgdGhlIHRleHREaXIgd2lsbCBjaGFuZ2UgZXRjLlxuXHRcdFx0aWYodGhpcy50ZXh0RGlyKXtcblx0XHRcdFx0aWYob3B0aW9uKXtcblx0XHRcdFx0XHRvcHRpb24ub3JpZ2luYWxUZXh0ID0gdGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZGlyID0gdGhpcy50ZXh0RGlyID09IFwiYXV0b1wiID8gdGhpcy5fY2hlY2tDb250ZXh0dWFsKHRleHQpIDogdGhpcy50ZXh0RGlyO1xuXHRcdFx0XHRyZXR1cm4gKGRpciA9PSBcImx0clwiID8gYmlkaV9jb25zdC5MUkUgOiBiaWRpX2NvbnN0LlJMRSApICsgdGV4dCArIGJpZGlfY29uc3QuUERGO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fSxcblxuXHRcdHJlc3RvcmVPcmlnaW5hbFRleHQ6IGZ1bmN0aW9uKG9yaWdPYmope1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc3RvcmVzIHRoZSB0ZXh0IG9mIG9yaWdPYmosIGlmIG5lZWRlZCwgYWZ0ZXIgZW5mb3JjZVRleHREaXJXaXRoVWNjLCBlLmcuIHNldChcInRleHREaXJcIiwgdGV4dERpcikuXG5cdFx0XHQvLyBvcmlnT2JqOlxuXHRcdFx0Ly9cdFx0VGhlIGVsZW1lbnQgKGA8b3B0aW9uPmApIHRvIHJlc3RvcmUuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNldHMgdGhlIHRleHQgb2Ygb3JpZ09iaiB0byBvcmlnT2JqLm9yaWdpbmFsVGV4dCwgd2hpY2ggaXMgdGhlIG9yaWdpbmFsIHRleHQsIHdpdGhvdXQgdGhlIFVDQ3MuXG5cdFx0XHQvL1x0XHRUaGUgZnVuY3Rpb24gdGhhbiByZW1vdmVzIHRoZSBvcmlnaW5hbFRleHQgZnJvbSBvcmlnT2JqIVxuXHRcdFx0aWYob3JpZ09iai5vcmlnaW5hbFRleHQpe1xuXHRcdFx0XHRvcmlnT2JqLnRleHQgPSBvcmlnT2JqLm9yaWdpbmFsVGV4dDtcblx0XHRcdFx0ZGVsZXRlIG9yaWdPYmoub3JpZ2luYWxUZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9yaWdPYmo7XG5cdFx0fSxcblxuXHRcdF9zZXRUZXh0RGlyQXR0cjogZnVuY3Rpb24oLypTdHJpbmcqLyB0ZXh0RGlyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZXR0ZXIgZm9yIHRleHREaXIuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFVzZXJzIHNob3VsZG4ndCBjYWxsIHRoaXMgZnVuY3Rpb247IHRoZXkgc2hvdWxkIGJlIGNhbGxpbmdcblx0XHRcdC8vXHRcdHNldCgndGV4dERpcicsIHZhbHVlKVxuXHRcdFx0aWYoIXRoaXMuX2NyZWF0ZWQgfHwgdGhpcy50ZXh0RGlyICE9IHRleHREaXIpe1xuXHRcdFx0XHR0aGlzLl9zZXQoXCJ0ZXh0RGlyXCIsIHRleHREaXIpO1xuXHRcdFx0XHR2YXIgbm9kZSA9IG51bGw7XG5cdFx0XHRcdGlmKHRoaXMuZGlzcGxheU5vZGUpe1xuXHRcdFx0XHRcdG5vZGUgPSB0aGlzLmRpc3BsYXlOb2RlO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheU5vZGUuYWxpZ24gPSB0aGlzLmRpciA9PSBcInJ0bFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdG5vZGUgPSB0aGlzLnRleHREaXJOb2RlIHx8IHRoaXMuZm9jdXNOb2RlIHx8IHRoaXMudGV4dGJveDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihub2RlKXtcblx0XHRcdFx0XHR0aGlzLmFwcGx5VGV4dERpcihub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL2NhY2hlXCIsXHQvLyBkb2pvLmNhY2hlXG5cdFwiZG9qby9fYmFzZS9kZWNsYXJlXCIsIC8vIGRlY2xhcmVcblx0XCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgLy8gZG9tQ29uc3RydWN0LmRlc3Ryb3ksIGRvbUNvbnN0cnVjdC50b0RvbVxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLmdldE9iamVjdFxuXHRcImRvam8vb25cIixcblx0XCJkb2pvL3NuaWZmXCIsIC8vIGhhcyhcImllXCIpXG5cdFwiZG9qby9zdHJpbmdcIiwgLy8gc3RyaW5nLnN1YnN0aXR1dGUgc3RyaW5nLnRyaW1cblx0XCIuL19BdHRhY2hNaXhpblwiXG5dLCBmdW5jdGlvbihjYWNoZSwgZGVjbGFyZSwgZG9tQ29uc3RydWN0LCBsYW5nLCBvbiwgaGFzLCBzdHJpbmcsIF9BdHRhY2hNaXhpbil7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fVGVtcGxhdGVkTWl4aW5cblxuXHR2YXIgX1RlbXBsYXRlZE1peGluID0gZGVjbGFyZShcImRpaml0Ll9UZW1wbGF0ZWRNaXhpblwiLCBfQXR0YWNoTWl4aW4sIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdE1peGluIGZvciB3aWRnZXRzIHRoYXQgYXJlIGluc3RhbnRpYXRlZCBmcm9tIGEgdGVtcGxhdGVcblxuXHRcdC8vIHRlbXBsYXRlU3RyaW5nOiBbcHJvdGVjdGVkXSBTdHJpbmdcblx0XHQvL1x0XHRBIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHdpZGdldCB0ZW1wbGF0ZS5cblx0XHQvL1x0XHRVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBkb2pvLmNhY2hlKCkgdG8gbG9hZCBmcm9tIGEgZmlsZS5cblx0XHR0ZW1wbGF0ZVN0cmluZzogbnVsbCxcblxuXHRcdC8vIHRlbXBsYXRlUGF0aDogW3Byb3RlY3RlZCBkZXByZWNhdGVkXSBTdHJpbmdcblx0XHQvL1x0XHRQYXRoIHRvIHRlbXBsYXRlIChIVE1MIGZpbGUpIGZvciB0aGlzIHdpZGdldCByZWxhdGl2ZSB0byBkb2pvLmJhc2VVcmwuXG5cdFx0Ly9cdFx0RGVwcmVjYXRlZDogdXNlIHRlbXBsYXRlU3RyaW5nIHdpdGggcmVxdWlyZShbLi4uIFwiZG9qby90ZXh0IS4uLlwiXSwgLi4uKSBpbnN0ZWFkXG5cdFx0dGVtcGxhdGVQYXRoOiBudWxsLFxuXG5cdFx0Ly8gc2tpcE5vZGVDYWNoZTogW3Byb3RlY3RlZF0gQm9vbGVhblxuXHRcdC8vXHRcdElmIHVzaW5nIGEgY2FjaGVkIHdpZGdldCB0ZW1wbGF0ZSBub2RlcyBwb3NlcyBpc3N1ZXMgZm9yIGFcblx0XHQvL1x0XHRwYXJ0aWN1bGFyIHdpZGdldCBjbGFzcywgaXQgY2FuIHNldCB0aGlzIHByb3BlcnR5IHRvIGVuc3VyZVxuXHRcdC8vXHRcdHRoYXQgaXRzIHRlbXBsYXRlIGlzIGFsd2F5cyByZS1idWlsdCBmcm9tIGEgc3RyaW5nXG5cdFx0X3NraXBOb2RlQ2FjaGU6IGZhbHNlLFxuXG4vKj09PT09XG5cdFx0Ly8gX3JlbmRlcmVkOiBCb29sZWFuXG5cdFx0Ly9cdFx0Tm90IG5vcm1hbGx5IHVzZSwgYnV0IHRoaXMgZmxhZyBjYW4gYmUgc2V0IGJ5IHRoZSBhcHAgaWYgdGhlIHNlcnZlciBoYXMgYWxyZWFkeSByZW5kZXJlZCB0aGUgdGVtcGxhdGUsXG5cdFx0Ly9cdFx0aS5lLiBhbHJlYWR5IGlubGluaW5nIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdpZGdldCBpbnRvIHRoZSBtYWluIHBhZ2UuICAgUmVkdWNlcyBfVGVtcGxhdGVkTWl4aW4gdG9cblx0XHQvL1x0XHRqdXN0IGZ1bmN0aW9uIGxpa2UgX0F0dGFjaE1peGluLlxuXHRcdF9yZW5kZXJlZDogZmFsc2UsXG49PT09PSovXG5cblx0XHQvLyBTZXQgX0F0dGFjaE1peGluLnNlYXJjaENvbnRhaW5lck5vZGUgdG8gdHJ1ZSBmb3IgYmFjay1jb21wYXQgZm9yIHdpZGdldHMgdGhhdCBoYXZlIGRhdGEtZG9qby1hdHRhY2gtcG9pbnQnc1xuXHRcdC8vIGFuZCBldmVudHMgaW5zaWRlIHRoaXMuY29udGFpbmVyTm9kZS4gICBSZW1vdmUgZm9yIDIuMC5cblx0XHRzZWFyY2hDb250YWluZXJOb2RlOiB0cnVlLFxuXG5cdFx0X3N0cmluZ1JlcGw6IGZ1bmN0aW9uKHRtcGwpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERvZXMgc3Vic3RpdHV0aW9uIG9mICR7Zm9vfSB0eXBlIHByb3BlcnRpZXMgaW4gdGVtcGxhdGUgc3RyaW5nXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJpdmF0ZVxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuZGVjbGFyZWRDbGFzcywgX3RoaXMgPSB0aGlzO1xuXHRcdFx0Ly8gQ2FjaGUgY29udGFpbnMgYSBzdHJpbmcgYmVjYXVzZSB3ZSBuZWVkIHRvIGRvIHByb3BlcnR5IHJlcGxhY2VtZW50XG5cdFx0XHQvLyBkbyB0aGUgcHJvcGVydHkgcmVwbGFjZW1lbnRcblx0XHRcdHJldHVybiBzdHJpbmcuc3Vic3RpdHV0ZSh0bXBsLCB0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcblx0XHRcdFx0aWYoa2V5LmNoYXJBdCgwKSA9PSAnIScpeyB2YWx1ZSA9IGxhbmcuZ2V0T2JqZWN0KGtleS5zdWJzdHIoMSksIGZhbHNlLCBfdGhpcyk7IH1cblx0XHRcdFx0aWYodHlwZW9mIHZhbHVlID09IFwidW5kZWZpbmVkXCIpeyB0aHJvdyBuZXcgRXJyb3IoY2xhc3NOYW1lK1wiIHRlbXBsYXRlOlwiK2tleSk7IH0gLy8gYSBkZWJ1Z2dpbmcgYWlkZVxuXHRcdFx0XHRpZih2YWx1ZSA9PSBudWxsKXsgcmV0dXJuIFwiXCI7IH1cblxuXHRcdFx0XHQvLyBTdWJzdGl0dXRpb24ga2V5cyBiZWdpbm5pbmcgd2l0aCAhIHdpbGwgc2tpcCB0aGUgdHJhbnNmb3JtIHN0ZXAsXG5cdFx0XHRcdC8vIGluIGNhc2UgYSB1c2VyIHdpc2hlcyB0byBpbnNlcnQgdW5lc2NhcGVkIG1hcmt1cCwgZS5nLiAkeyFmb299XG5cdFx0XHRcdHJldHVybiBrZXkuY2hhckF0KDApID09IFwiIVwiID8gdmFsdWUgOiB0aGlzLl9lc2NhcGVWYWx1ZShcIlwiICsgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdF9lc2NhcGVWYWx1ZTogZnVuY3Rpb24oLypTdHJpbmcqLyB2YWwpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEVzY2FwZSBhIHZhbHVlIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHRlbXBsYXRlLCBlaXRoZXIgaW50byBhbiBhdHRyaWJ1dGUgdmFsdWVcblx0XHRcdC8vXHRcdChleDogZm9vPVwiJHtiYXJ9XCIpIG9yIGFzIGlubmVyIHRleHQgb2YgYW4gZWxlbWVudCAoZXg6IDxzcGFuPiR7Zm9vfTwvc3Bhbj4pXG5cblx0XHRcdC8vIFNhZmVyIHN1YnN0aXR1dGlvbiwgc2VlIGhlYWRpbmcgXCJBdHRyaWJ1dGUgdmFsdWVzXCIgaW5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvYXBwZW5kaXgvbm90ZXMuaHRtbCNoLUIuMy4yXG5cdFx0XHQvLyBhbmQgYWxzbyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU18lMjhDcm9zc19TaXRlX1NjcmlwdGluZyUyOV9QcmV2ZW50aW9uX0NoZWF0X1NoZWV0I1JVTEVfLjIzMV8tX0hUTUxfRXNjYXBlX0JlZm9yZV9JbnNlcnRpbmdfVW50cnVzdGVkX0RhdGFfaW50b19IVE1MX0VsZW1lbnRfQ29udGVudFxuXHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKC9bXCInPD4mXS9nLCBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFwiJlwiOiBcIiZhbXA7XCIsXG5cdFx0XHRcdFx0XCI8XCI6IFwiJmx0O1wiLFxuXHRcdFx0XHRcdFwiPlwiOiBcIiZndDtcIixcblx0XHRcdFx0XHRcIlxcXCJcIjogXCImcXVvdDtcIixcblx0XHRcdFx0XHRcIidcIjogXCImI3gyNztcIlxuXHRcdFx0XHR9W3ZhbF07XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0YnVpbGRSZW5kZXJpbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29uc3RydWN0IHRoZSBVSSBmb3IgdGhpcyB3aWRnZXQgZnJvbSBhIHRlbXBsYXRlLCBzZXR0aW5nIHRoaXMuZG9tTm9kZS5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0aWYoIXRoaXMuX3JlbmRlcmVkKXtcblx0XHRcdFx0aWYoIXRoaXMudGVtcGxhdGVTdHJpbmcpe1xuXHRcdFx0XHRcdHRoaXMudGVtcGxhdGVTdHJpbmcgPSBjYWNoZSh0aGlzLnRlbXBsYXRlUGF0aCwge3Nhbml0aXplOiB0cnVlfSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29rdXAgY2FjaGVkIHZlcnNpb24gb2YgdGVtcGxhdGUsIGFuZCBkb3dubG9hZCB0byBjYWNoZSBpZiBpdFxuXHRcdFx0XHQvLyBpc24ndCB0aGVyZSBhbHJlYWR5LiAgUmV0dXJucyBlaXRoZXIgYSBEb21Ob2RlIG9yIGEgc3RyaW5nLCBkZXBlbmRpbmcgb25cblx0XHRcdFx0Ly8gd2hldGhlciBvciBub3QgdGhlIHRlbXBsYXRlIGNvbnRhaW5zICR7Zm9vfSByZXBsYWNlbWVudCBwYXJhbWV0ZXJzLlxuXHRcdFx0XHR2YXIgY2FjaGVkID0gX1RlbXBsYXRlZE1peGluLmdldENhY2hlZFRlbXBsYXRlKHRoaXMudGVtcGxhdGVTdHJpbmcsIHRoaXMuX3NraXBOb2RlQ2FjaGUsIHRoaXMub3duZXJEb2N1bWVudCk7XG5cblx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdGlmKGxhbmcuaXNTdHJpbmcoY2FjaGVkKSl7XG5cdFx0XHRcdFx0bm9kZSA9IGRvbUNvbnN0cnVjdC50b0RvbSh0aGlzLl9zdHJpbmdSZXBsKGNhY2hlZCksIHRoaXMub3duZXJEb2N1bWVudCk7XG5cdFx0XHRcdFx0aWYobm9kZS5ub2RlVHlwZSAhPSAxKXtcblx0XHRcdFx0XHRcdC8vIEZsYWcgY29tbW9uIHByb2JsZW1zIHN1Y2ggYXMgdGVtcGxhdGVzIHdpdGggbXVsdGlwbGUgdG9wIGxldmVsIG5vZGVzIChub2RlVHlwZSA9PSAxMSlcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGVtcGxhdGU6IFwiICsgY2FjaGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdC8vIGlmIGl0J3MgYSBub2RlLCBhbGwgd2UgaGF2ZSB0byBkbyBpcyBjbG9uZSBpdFxuXHRcdFx0XHRcdG5vZGUgPSBjYWNoZWQuY2xvbmVOb2RlKHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5kb21Ob2RlID0gbm9kZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBkb3duIHRvIF9XaWRnZXRCYXNlLmJ1aWxkUmVuZGVyaW5nKCkgdG8gZ2V0IGJhc2UgY2xhc3NlcyBhc3NpZ25lZFxuXHRcdFx0Ly8gVE9ETzogY2hhbmdlIHRoZSBiYXNlQ2xhc3MgYXNzaWdubWVudCB0byBfc2V0QmFzZUNsYXNzQXR0clxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblxuXHRcdFx0aWYoIXRoaXMuX3JlbmRlcmVkKXtcblx0XHRcdFx0dGhpcy5fZmlsbENvbnRlbnQodGhpcy5zcmNOb2RlUmVmKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRfZmlsbENvbnRlbnQ6IGZ1bmN0aW9uKC8qRG9tTm9kZSovIHNvdXJjZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVsb2NhdGUgc291cmNlIGNvbnRlbnRzIHRvIHRlbXBsYXRlZCBjb250YWluZXIgbm9kZS5cblx0XHRcdC8vXHRcdHRoaXMuY29udGFpbmVyTm9kZSBtdXN0IGJlIGFibGUgdG8gcmVjZWl2ZSBjaGlsZHJlbiwgb3IgZXhjZXB0aW9ucyB3aWxsIGJlIHRocm93bi5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdHZhciBkZXN0ID0gdGhpcy5jb250YWluZXJOb2RlO1xuXHRcdFx0aWYoc291cmNlICYmIGRlc3Qpe1xuXHRcdFx0XHR3aGlsZShzb3VyY2UuaGFzQ2hpbGROb2RlcygpKXtcblx0XHRcdFx0XHRkZXN0LmFwcGVuZENoaWxkKHNvdXJjZS5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9KTtcblxuXHQvLyBrZXkgaXMgdGVtcGxhdGVTdHJpbmc7IG9iamVjdCBpcyBlaXRoZXIgc3RyaW5nIG9yIERPTSB0cmVlXG5cdF9UZW1wbGF0ZWRNaXhpbi5fdGVtcGxhdGVDYWNoZSA9IHt9O1xuXG5cdF9UZW1wbGF0ZWRNaXhpbi5nZXRDYWNoZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRlbXBsYXRlU3RyaW5nLCBhbHdheXNVc2VTdHJpbmcsIGRvYyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTdGF0aWMgbWV0aG9kIHRvIGdldCBhIHRlbXBsYXRlIGJhc2VkIG9uIHRoZSB0ZW1wbGF0ZVBhdGggb3Jcblx0XHQvL1x0XHR0ZW1wbGF0ZVN0cmluZyBrZXlcblx0XHQvLyB0ZW1wbGF0ZVN0cmluZzogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIHRlbXBsYXRlXG5cdFx0Ly8gYWx3YXlzVXNlU3RyaW5nOiBCb29sZWFuXG5cdFx0Ly9cdFx0RG9uJ3QgY2FjaGUgdGhlIERPTSB0cmVlIGZvciB0aGlzIHRlbXBsYXRlLCBldmVuIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgdmFyaWFibGVzXG5cdFx0Ly8gZG9jOiBEb2N1bWVudD9cblx0XHQvL1x0XHRUaGUgdGFyZ2V0IGRvY3VtZW50LiAgIERlZmF1bHRzIHRvIGRvY3VtZW50IGdsb2JhbCBpZiB1bnNwZWNpZmllZC5cblx0XHQvLyByZXR1cm5zOiBNaXhlZFxuXHRcdC8vXHRcdEVpdGhlciBzdHJpbmcgKGlmIHRoZXJlIGFyZSAke30gdmFyaWFibGVzIHRoYXQgbmVlZCB0byBiZSByZXBsYWNlZCkgb3IganVzdFxuXHRcdC8vXHRcdGEgRE9NIHRyZWUgKGlmIHRoZSBub2RlIGNhbiBiZSBjbG9uZWQgZGlyZWN0bHkpXG5cblx0XHQvLyBpcyBpdCBhbHJlYWR5IGNhY2hlZD9cblx0XHR2YXIgdG1wbHRzID0gX1RlbXBsYXRlZE1peGluLl90ZW1wbGF0ZUNhY2hlO1xuXHRcdHZhciBrZXkgPSB0ZW1wbGF0ZVN0cmluZztcblx0XHR2YXIgY2FjaGVkID0gdG1wbHRzW2tleV07XG5cdFx0aWYoY2FjaGVkKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0Ly8gaWYgdGhlIGNhY2hlZCB2YWx1ZSBpcyBhbiBpbm5lckhUTUwgc3RyaW5nIChubyBvd25lckRvY3VtZW50KSBvciBhIERPTSB0cmVlIGNyZWF0ZWQgd2l0aGluIHRoZVxuXHRcdFx0XHQvLyBjdXJyZW50IGRvY3VtZW50LCB0aGVuIHVzZSB0aGUgY3VycmVudCBjYWNoZWQgdmFsdWVcblx0XHRcdFx0aWYoIWNhY2hlZC5vd25lckRvY3VtZW50IHx8IGNhY2hlZC5vd25lckRvY3VtZW50ID09IChkb2MgfHwgZG9jdW1lbnQpKXtcblx0XHRcdFx0XHQvLyBzdHJpbmcgb3Igbm9kZSBvZiB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXsgLyogc3F1ZWxjaCAqLyB9IC8vIElFIGNhbiB0aHJvdyBhbiBleGNlcHRpb24gaWYgY2FjaGVkLm93bmVyRG9jdW1lbnQgd2FzIHJlbG9hZGVkXG5cdFx0XHRkb21Db25zdHJ1Y3QuZGVzdHJveShjYWNoZWQpO1xuXHRcdH1cblxuXHRcdHRlbXBsYXRlU3RyaW5nID0gc3RyaW5nLnRyaW0odGVtcGxhdGVTdHJpbmcpO1xuXG5cdFx0aWYoYWx3YXlzVXNlU3RyaW5nIHx8IHRlbXBsYXRlU3RyaW5nLm1hdGNoKC9cXCRcXHsoW15cXH1dKylcXH0vZykpe1xuXHRcdFx0Ly8gdGhlcmUgYXJlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUgc28gYWxsIHdlIGNhbiBkbyBpcyBjYWNoZSB0aGUgc3RyaW5nXG5cdFx0XHRyZXR1cm4gKHRtcGx0c1trZXldID0gdGVtcGxhdGVTdHJpbmcpOyAvL1N0cmluZ1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUgc28gd2UgY2FuIGNhY2hlIHRoZSBET00gdHJlZVxuXHRcdFx0dmFyIG5vZGUgPSBkb21Db25zdHJ1Y3QudG9Eb20odGVtcGxhdGVTdHJpbmcsIGRvYyk7XG5cdFx0XHRpZihub2RlLm5vZGVUeXBlICE9IDEpe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRlbXBsYXRlOiBcIiArIHRlbXBsYXRlU3RyaW5nKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodG1wbHRzW2tleV0gPSBub2RlKTsgLy9Ob2RlXG5cdFx0fVxuXHR9O1xuXG5cdGlmKGhhcyhcImllXCIpKXtcblx0XHRvbih3aW5kb3csIFwidW5sb2FkXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgY2FjaGUgPSBfVGVtcGxhdGVkTWl4aW4uX3RlbXBsYXRlQ2FjaGU7XG5cdFx0XHRmb3IodmFyIGtleSBpbiBjYWNoZSl7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGNhY2hlW2tleV07XG5cdFx0XHRcdGlmKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKXsgLy8gdmFsdWUgaXMgZWl0aGVyIGEgc3RyaW5nIG9yIGEgRE9NIG5vZGUgdGVtcGxhdGVcblx0XHRcdFx0XHRkb21Db25zdHJ1Y3QuZGVzdHJveSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIGNhY2hlW2tleV07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gX1RlbXBsYXRlZE1peGluO1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcInJlcXVpcmVcIiwgLy8gcmVxdWlyZS50b1VybFxuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZm9yRWFjaCBhcnJheS5tYXBcblx0XCJkb2pvL2FzcGVjdFwiLFxuXHRcImRvam8vX2Jhc2UvY29uZmlnXCIsIC8vIGNvbmZpZy5ibGFua0dpZlxuXHRcImRvam8vX2Jhc2UvY29ubmVjdFwiLCAvLyBjb25uZWN0LmNvbm5lY3Rcblx0XCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgLy8gZGVjbGFyZVxuXHRcImRvam8vZG9tXCIsIC8vIGRvbS5ieUlkXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLnNldCBkb21BdHRyLnJlbW92ZVxuXHRcImRvam8vZG9tLWNsYXNzXCIsIC8vIGRvbUNsYXNzLmFkZCBkb21DbGFzcy5yZXBsYWNlXG5cdFwiZG9qby9kb20tY29uc3RydWN0XCIsIC8vIGRvbUNvbnN0cnVjdC5kZXN0cm95IGRvbUNvbnN0cnVjdC5wbGFjZVxuXHRcImRvam8vZG9tLWdlb21ldHJ5XCIsIC8vIGlzQm9keUx0clxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLnNldCwgZG9tU3R5bGUuZ2V0XG5cdFwiZG9qby9oYXNcIixcblx0XCJkb2pvL19iYXNlL2tlcm5lbFwiLFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBtaXhpbigpLCBpc0FycmF5KCksIGV0Yy5cblx0XCJkb2pvL29uXCIsXG5cdFwiZG9qby9yZWFkeVwiLFxuXHRcImRvam8vU3RhdGVmdWxcIiwgLy8gU3RhdGVmdWxcblx0XCJkb2pvL3RvcGljXCIsXG5cdFwiZG9qby9fYmFzZS93aW5kb3dcIiwgLy8gd2luLmJvZHkoKVxuXHRcIi4vRGVzdHJveWFibGVcIixcblx0XCJkb2pvL2hhcyFkb2pvLWJpZGk/Li9fQmlkaU1peGluXCIsXG5cdFwiLi9yZWdpc3RyeVwiICAgIC8vIHJlZ2lzdHJ5LmdldFVuaXF1ZUlkKCksIHJlZ2lzdHJ5LmZpbmRXaWRnZXRzKClcbl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGFycmF5LCBhc3BlY3QsIGNvbmZpZywgY29ubmVjdCwgZGVjbGFyZSxcblx0XHRcdGRvbSwgZG9tQXR0ciwgZG9tQ2xhc3MsIGRvbUNvbnN0cnVjdCwgZG9tR2VvbWV0cnksIGRvbVN0eWxlLCBoYXMsIGtlcm5lbCxcblx0XHRcdGxhbmcsIG9uLCByZWFkeSwgU3RhdGVmdWwsIHRvcGljLCB3aW4sIERlc3Ryb3lhYmxlLCBfQmlkaU1peGluLCByZWdpc3RyeSl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9fV2lkZ2V0QmFzZVxuXG5cdC8vIEZsYWcgdG8gbWFrZSBkaWppdCBsb2FkIG1vZHVsZXMgdGhlIGFwcCBkaWRuJ3QgZXhwbGljaXRseSByZXF1ZXN0LCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aGFzLmFkZChcImRpaml0LWxlZ2FjeS1yZXF1aXJlc1wiLCAha2VybmVsLmlzQXN5bmMpO1xuXG5cdC8vIEZsYWcgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHRleHRkaXIgYXR0cmlidXRlXG5cdGhhcy5hZGQoXCJkb2pvLWJpZGlcIiwgZmFsc2UpO1xuXG5cblx0Ly8gRm9yIGJhY2stY29tcGF0LCByZW1vdmUgaW4gMi4wLlxuXHRpZihoYXMoXCJkaWppdC1sZWdhY3ktcmVxdWlyZXNcIikpe1xuXHRcdHJlYWR5KDAsIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVxdWlyZXMgPSBbXCJkaWppdC9fYmFzZS9tYW5hZ2VyXCJdO1xuXHRcdFx0cmVxdWlyZShyZXF1aXJlcyk7XHQvLyB1c2UgaW5kaXJlY3Rpb24gc28gbW9kdWxlcyBub3Qgcm9sbGVkIGludG8gYSBidWlsZFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTmVzdGVkIGhhc2ggbGlzdGluZyBhdHRyaWJ1dGVzIGZvciBlYWNoIHRhZywgYWxsIHN0cmluZ3MgaW4gbG93ZXJjYXNlLlxuXHQvLyBleDoge1wiZGl2XCI6IHtcInN0eWxlXCI6IHRydWUsIFwidGFiaW5kZXhcIiB0cnVlfSwgXCJmb3JtXCI6IHsgLi4uXG5cdHZhciB0YWdBdHRycyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJzKG9iail7XG5cdFx0dmFyIHJldCA9IHt9O1xuXHRcdGZvcih2YXIgYXR0ciBpbiBvYmope1xuXHRcdFx0cmV0W2F0dHIudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbm9uRW1wdHlBdHRyVG9Eb20oYXR0cil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgY29waWVzIHRoZSBhdHRyaWJ1dGUgdG8gdGhpcy5kb21Ob2RlLFxuXHRcdC8vXHRcdG9yIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZSBmcm9tIHRoaXMuZG9tTm9kZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG5cdFx0Ly9cdFx0dmFsdWUgaXMgZGVmaW5lZCBvciBub3QuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHRkb21BdHRyW3ZhbCA/IFwic2V0XCIgOiBcInJlbW92ZVwiXSh0aGlzLmRvbU5vZGUsIGF0dHIsIHZhbCk7XG5cdFx0XHR0aGlzLl9zZXQoYXR0ciwgdmFsKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNFcXVhbChhLCBiKXtcblx0XHQvL1x0c3VtbWFyeTpcblx0XHQvL1x0XHRGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0d28gdmFsdWVzIGFyZSBpZGVudGljYWwsXG5cdFx0Ly9cdFx0dGFraW5nIGludG8gYWNjb3VudCB0aGF0IE5hTiBpcyBub3Qgbm9ybWFsbHkgZXF1YWwgdG8gaXRzZWxmXG5cdFx0Ly9cdFx0aW4gSlMuXG5cblx0XHRyZXR1cm4gYSA9PT0gYiB8fCAoLyogYSBpcyBOYU4gKi8gYSAhPT0gYSAmJiAvKiBiIGlzIE5hTiAqLyBiICE9PSBiKTtcblx0fVxuXG5cdHZhciBfV2lkZ2V0QmFzZSA9IGRlY2xhcmUoXCJkaWppdC5fV2lkZ2V0QmFzZVwiLCBbU3RhdGVmdWwsIERlc3Ryb3lhYmxlXSwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RnV0dXJlIGJhc2UgY2xhc3MgZm9yIGFsbCBEaWppdCB3aWRnZXRzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEZ1dHVyZSBiYXNlIGNsYXNzIGZvciBhbGwgRGlqaXQgd2lkZ2V0cy5cblx0XHQvL1x0XHRfV2lkZ2V0IGV4dGVuZHMgdGhpcyBjbGFzcyBhZGRpbmcgc3VwcG9ydCBmb3IgdmFyaW91cyBmZWF0dXJlcyBuZWVkZWQgYnkgZGVza3RvcC5cblx0XHQvL1xuXHRcdC8vXHRcdFByb3ZpZGVzIHN0dWJzIGZvciB3aWRnZXQgbGlmZWN5Y2xlIG1ldGhvZHMgZm9yIHN1YmNsYXNzZXMgdG8gZXh0ZW5kLCBsaWtlIHBvc3RNaXhJblByb3BlcnRpZXMoKSwgYnVpbGRSZW5kZXJpbmcoKSxcblx0XHQvL1x0XHRwb3N0Q3JlYXRlKCksIHN0YXJ0dXAoKSwgYW5kIGRlc3Ryb3koKSwgYW5kIGFsc28gcHVibGljIEFQSSBtZXRob2RzIGxpa2Ugc2V0KCksIGdldCgpLCBhbmQgd2F0Y2goKS5cblx0XHQvL1xuXHRcdC8vXHRcdFdpZGdldHMgY2FuIHByb3ZpZGUgY3VzdG9tIHNldHRlcnMvZ2V0dGVycyBmb3Igd2lkZ2V0IGF0dHJpYnV0ZXMsIHdoaWNoIGFyZSBjYWxsZWQgYXV0b21hdGljYWxseSBieSBzZXQobmFtZSwgdmFsdWUpLlxuXHRcdC8vXHRcdEZvciBhbiBhdHRyaWJ1dGUgWFhYLCBkZWZpbmUgbWV0aG9kcyBfc2V0WFhYQXR0cigpIGFuZC9vciBfZ2V0WFhYQXR0cigpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0X3NldFhYWEF0dHIgY2FuIGFsc28gYmUgYSBzdHJpbmcvaGFzaC9hcnJheSBtYXBwaW5nIGZyb20gYSB3aWRnZXQgYXR0cmlidXRlIFhYWCB0byB0aGUgd2lkZ2V0J3MgRE9NTm9kZXM6XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGF0dHJpYnV0ZVxuXHRcdC8vIHxcdFx0X3NldEZvY3VzQXR0cjoge25vZGU6IFwiZm9jdXNOb2RlXCIsIHR5cGU6IFwiYXR0cmlidXRlXCJ9XG5cdFx0Ly8gfFx0XHRfc2V0Rm9jdXNBdHRyOiBcImZvY3VzTm9kZVwiXHQoc2hvcnRoYW5kKVxuXHRcdC8vIHxcdFx0X3NldEZvY3VzQXR0cjogXCJcIlx0XHQoc2hvcnRoYW5kLCBtYXBzIHRvIHRoaXMuZG9tTm9kZSlcblx0XHQvL1x0XHRNYXBzIHRoaXMuZm9jdXMgdG8gdGhpcy5mb2N1c05vZGUuZm9jdXMsIG9yIChsYXN0IGV4YW1wbGUpIHRoaXMuZG9tTm9kZS5mb2N1c1xuXHRcdC8vXG5cdFx0Ly9cdFx0LSBET00gbm9kZSBpbm5lckhUTUxcblx0XHQvL1x0fFx0XHRfc2V0VGl0bGVBdHRyOiB7IG5vZGU6IFwidGl0bGVOb2RlXCIsIHR5cGU6IFwiaW5uZXJIVE1MXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy50aXRsZSB0byB0aGlzLnRpdGxlTm9kZS5pbm5lckhUTUxcblx0XHQvL1xuXHRcdC8vXHRcdC0gRE9NIG5vZGUgaW5uZXJUZXh0XG5cdFx0Ly9cdHxcdFx0X3NldFRpdGxlQXR0cjogeyBub2RlOiBcInRpdGxlTm9kZVwiLCB0eXBlOiBcImlubmVyVGV4dFwiIH1cblx0XHQvL1x0XHRNYXBzIHRoaXMudGl0bGUgdG8gdGhpcy50aXRsZU5vZGUuaW5uZXJUZXh0XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIENTUyBjbGFzc1xuXHRcdC8vIHxcdFx0X3NldE15Q2xhc3NBdHRyOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImNsYXNzXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5teUNsYXNzIHRvIHRoaXMuZG9tTm9kZS5jbGFzc05hbWVcblx0XHQvL1xuXHRcdC8vXHRcdC0gVG9nZ2xlIERPTSBub2RlIENTUyBjbGFzc1xuXHRcdC8vIHxcdFx0X3NldE15Q2xhc3NBdHRyOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcInRvZ2dsZUNsYXNzXCIgfVxuXHRcdC8vXHRcdFRvZ2dsZXMgbXlDbGFzcyBvbiB0aGlzLmRvbU5vZGUgYnkgdGhpcy5teUNsYXNzXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiB0aGUgdmFsdWUgb2YgX3NldFhYWEF0dHIgaXMgYW4gYXJyYXksIHRoZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBtYXRjaGVzIG9uZSBvZiB0aGVcblx0XHQvL1x0XHRmb3JtYXRzIG9mIHRoZSBhYm92ZSBsaXN0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgdGhlIGN1c3RvbSBzZXR0ZXIgaXMgbnVsbCwgbm8gYWN0aW9uIGlzIHBlcmZvcm1lZCBvdGhlciB0aGFuIHNhdmluZyB0aGUgbmV3IHZhbHVlXG5cdFx0Ly9cdFx0aW4gdGhlIHdpZGdldCAoaW4gdGhpcykuXG5cdFx0Ly9cblx0XHQvL1x0XHRJZiBubyBjdXN0b20gc2V0dGVyIGlzIGRlZmluZWQgZm9yIGFuIGF0dHJpYnV0ZSwgdGhlbiBpdCB3aWxsIGJlIGNvcGllZFxuXHRcdC8vXHRcdHRvIHRoaXMuZm9jdXNOb2RlIChpZiB0aGUgd2lkZ2V0IGRlZmluZXMgYSBmb2N1c05vZGUpLCBvciB0aGlzLmRvbU5vZGUgb3RoZXJ3aXNlLlxuXHRcdC8vXHRcdFRoYXQncyBvbmx5IGRvbmUgdGhvdWdoIGZvciBhdHRyaWJ1dGVzIHRoYXQgbWF0Y2ggRE9NTm9kZSBhdHRyaWJ1dGVzICh0aXRsZSxcblx0XHQvL1x0XHRhbHQsIGFyaWEtbGFiZWxsZWRieSwgZXRjLilcblxuXHRcdC8vIGlkOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdEEgdW5pcXVlLCBvcGFxdWUgSUQgc3RyaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkIGJ5IHVzZXJzIG9yIGJ5IHRoZVxuXHRcdC8vXHRcdHN5c3RlbS4gSWYgdGhlIGRldmVsb3BlciBwYXNzZXMgYW4gSUQgd2hpY2ggaXMga25vd24gbm90IHRvIGJlXG5cdFx0Ly9cdFx0dW5pcXVlLCB0aGUgc3BlY2lmaWVkIElEIGlzIGlnbm9yZWQgYW5kIHRoZSBzeXN0ZW0tZ2VuZXJhdGVkIElEIGlzXG5cdFx0Ly9cdFx0dXNlZCBpbnN0ZWFkLlxuXHRcdGlkOiBcIlwiLFxuXHRcdF9zZXRJZEF0dHI6IFwiZG9tTm9kZVwiLCAvLyB0byBjb3B5IHRvIHRoaXMuZG9tTm9kZSBldmVuIGZvciBhdXRvLWdlbmVyYXRlZCBpZCdzXG5cblx0XHQvLyBsYW5nOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdFJhcmVseSB1c2VkLiAgT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IERvam8gbG9jYWxlIHVzZWQgdG8gcmVuZGVyIHRoaXMgd2lkZ2V0LFxuXHRcdC8vXHRcdGFzIGRlZmluZWQgYnkgdGhlIFtIVE1MIExBTkddKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvc3RydWN0L2RpcmxhbmcuaHRtbCNhZGVmLWxhbmcpIGF0dHJpYnV0ZS5cblx0XHQvL1x0XHRWYWx1ZSBtdXN0IGJlIGFtb25nIHRoZSBsaXN0IG9mIGxvY2FsZXMgc3BlY2lmaWVkIGR1cmluZyBieSB0aGUgRG9qbyBib290c3RyYXAsXG5cdFx0Ly9cdFx0Zm9ybWF0dGVkIGFjY29yZGluZyB0byBbUkZDIDMwNjZdKGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMwNjYudHh0KSAobGlrZSBlbi11cykuXG5cdFx0bGFuZzogXCJcIixcblx0XHQvLyBzZXQgb24gZG9tTm9kZSBldmVuIHdoZW4gdGhlcmUncyBhIGZvY3VzIG5vZGUuXHRidXQgZG9uJ3Qgc2V0IGxhbmc9XCJcIiwgc2luY2UgdGhhdCdzIGludmFsaWQuXG5cdFx0X3NldExhbmdBdHRyOiBub25FbXB0eUF0dHJUb0RvbShcImxhbmdcIiksXG5cblx0XHQvLyBkaXI6IFtjb25zdF0gU3RyaW5nXG5cdFx0Ly9cdFx0QmktZGlyZWN0aW9uYWwgc3VwcG9ydCwgYXMgZGVmaW5lZCBieSB0aGUgW0hUTUwgRElSXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL3N0cnVjdC9kaXJsYW5nLmh0bWwjYWRlZi1kaXIpXG5cdFx0Ly9cdFx0YXR0cmlidXRlLiBFaXRoZXIgbGVmdC10by1yaWdodCBcImx0clwiIG9yIHJpZ2h0LXRvLWxlZnQgXCJydGxcIi4gIElmIHVuZGVmaW5lZCwgd2lkZ2V0cyByZW5kZXJzIGluIHBhZ2Unc1xuXHRcdC8vXHRcdGRlZmF1bHQgZGlyZWN0aW9uLlxuXHRcdGRpcjogXCJcIixcblx0XHQvLyBzZXQgb24gZG9tTm9kZSBldmVuIHdoZW4gdGhlcmUncyBhIGZvY3VzIG5vZGUuXHRidXQgZG9uJ3Qgc2V0IGRpcj1cIlwiLCBzaW5jZSB0aGF0J3MgaW52YWxpZC5cblx0XHRfc2V0RGlyQXR0cjogbm9uRW1wdHlBdHRyVG9Eb20oXCJkaXJcIiksIC8vIHRvIHNldCBvbiBkb21Ob2RlIGV2ZW4gd2hlbiB0aGVyZSdzIGEgZm9jdXMgbm9kZVxuXG5cdFx0Ly8gY2xhc3M6IFN0cmluZ1xuXHRcdC8vXHRcdEhUTUwgY2xhc3MgYXR0cmlidXRlXG5cdFx0XCJjbGFzc1wiOiBcIlwiLFxuXHRcdF9zZXRDbGFzc0F0dHI6IHsgbm9kZTogXCJkb21Ob2RlXCIsIHR5cGU6IFwiY2xhc3NcIiB9LFxuXG5cdFx0Ly8gT3ZlcnJpZGUgYXV0b21hdGljIGFzc2lnbmluZyB0eXBlIC0tPiBmb2N1c05vZGUsIGl0IGNhdXNlcyBleGNlcHRpb24gb24gSUU2LTguXG5cdFx0Ly8gSW5zdGVhZCwgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCBhcyAke3R5cGV9IGluIHRoZSB0ZW1wbGF0ZSwgYXMgcGFydCBvZiB0aGUgb3JpZ2luYWwgRE9NLlxuXHRcdF9zZXRUeXBlQXR0cjogbnVsbCxcblxuXHRcdC8vIHN0eWxlOiBTdHJpbmd8fE9iamVjdFxuXHRcdC8vXHRcdEhUTUwgc3R5bGUgYXR0cmlidXRlcyBhcyBjc3NUZXh0IHN0cmluZyBvciBuYW1lL3ZhbHVlIGhhc2hcblx0XHRzdHlsZTogXCJcIixcblxuXHRcdC8vIHRpdGxlOiBTdHJpbmdcblx0XHQvL1x0XHRIVE1MIHRpdGxlIGF0dHJpYnV0ZS5cblx0XHQvL1xuXHRcdC8vXHRcdEZvciBmb3JtIHdpZGdldHMgdGhpcyBzcGVjaWZpZXMgYSB0b29sdGlwIHRvIGRpc3BsYXkgd2hlbiBob3ZlcmluZyBvdmVyXG5cdFx0Ly9cdFx0dGhlIHdpZGdldCAoanVzdCBsaWtlIHRoZSBuYXRpdmUgSFRNTCB0aXRsZSBhdHRyaWJ1dGUpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Rm9yIFRpdGxlUGFuZSBvciBmb3Igd2hlbiB0aGlzIHdpZGdldCBpcyBhIGNoaWxkIG9mIGEgVGFiQ29udGFpbmVyLCBBY2NvcmRpb25Db250YWluZXIsXG5cdFx0Ly9cdFx0ZXRjLiwgaXQncyB1c2VkIHRvIHNwZWNpZnkgdGhlIHRhYiBsYWJlbCwgYWNjb3JkaW9uIHBhbmUgdGl0bGUsIGV0Yy4gIEluIHRoaXMgY2FzZSBpdCdzXG5cdFx0Ly9cdFx0aW50ZXJwcmV0ZWQgYXMgSFRNTC5cblx0XHR0aXRsZTogXCJcIixcblxuXHRcdC8vIHRvb2x0aXA6IFN0cmluZ1xuXHRcdC8vXHRcdFdoZW4gdGhpcyB3aWRnZXQncyB0aXRsZSBhdHRyaWJ1dGUgaXMgdXNlZCB0byBmb3IgYSB0YWIgbGFiZWwsIGFjY29yZGlvbiBwYW5lIHRpdGxlLCBldGMuLFxuXHRcdC8vXHRcdHRoaXMgc3BlY2lmaWVzIHRoZSB0b29sdGlwIHRvIGFwcGVhciB3aGVuIHRoZSBtb3VzZSBpcyBob3ZlcmVkIG92ZXIgdGhhdCB0ZXh0LlxuXHRcdHRvb2x0aXA6IFwiXCIsXG5cblx0XHQvLyBiYXNlQ2xhc3M6IFtwcm90ZWN0ZWRdIFN0cmluZ1xuXHRcdC8vXHRcdFJvb3QgQ1NTIGNsYXNzIG9mIHRoZSB3aWRnZXQgKGV4OiBkaWppdFRleHRCb3gpLCB1c2VkIHRvIGNvbnN0cnVjdCBDU1MgY2xhc3NlcyB0byBpbmRpY2F0ZVxuXHRcdC8vXHRcdHdpZGdldCBzdGF0ZS5cblx0XHRiYXNlQ2xhc3M6IFwiXCIsXG5cblx0XHQvLyBzcmNOb2RlUmVmOiBbcmVhZG9ubHldIERvbU5vZGVcblx0XHQvL1x0XHRwb2ludGVyIHRvIG9yaWdpbmFsIERPTSBub2RlXG5cdFx0c3JjTm9kZVJlZjogbnVsbCxcblxuXHRcdC8vIGRvbU5vZGU6IFtyZWFkb25seV0gRG9tTm9kZVxuXHRcdC8vXHRcdFRoaXMgaXMgb3VyIHZpc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHdpZGdldCEgT3RoZXIgRE9NXG5cdFx0Ly9cdFx0Tm9kZXMgbWF5IGJ5IGFzc2lnbmVkIHRvIG90aGVyIHByb3BlcnRpZXMsIHVzdWFsbHkgdGhyb3VnaCB0aGVcblx0XHQvL1x0XHR0ZW1wbGF0ZSBzeXN0ZW0ncyBkYXRhLWRvam8tYXR0YWNoLXBvaW50IHN5bnRheCwgYnV0IHRoZSBkb21Ob2RlXG5cdFx0Ly9cdFx0cHJvcGVydHkgaXMgdGhlIGNhbm9uaWNhbCBcInRvcCBsZXZlbFwiIG5vZGUgaW4gd2lkZ2V0IFVJLlxuXHRcdGRvbU5vZGU6IG51bGwsXG5cblx0XHQvLyBjb250YWluZXJOb2RlOiBbcmVhZG9ubHldIERvbU5vZGVcblx0XHQvL1x0XHREZXNpZ25hdGVzIHdoZXJlIGNoaWxkcmVuIG9mIHRoZSBzb3VyY2UgRE9NIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG5cdFx0Ly9cdFx0XCJDaGlsZHJlblwiIGluIHRoaXMgY2FzZSByZWZlcnMgdG8gYm90aCBET00gbm9kZXMgYW5kIHdpZGdldHMuXG5cdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGZvciBteVdpZGdldDpcblx0XHQvL1xuXHRcdC8vXHRcdHxcdDxkaXYgZGF0YS1kb2pvLXR5cGU9bXlXaWRnZXQ+XG5cdFx0Ly9cdFx0fFx0XHQ8Yj4gaGVyZSdzIGEgcGxhaW4gRE9NIG5vZGVcblx0XHQvL1x0XHR8XHRcdDxzcGFuIGRhdGEtZG9qby10eXBlPXN1YldpZGdldD5hbmQgYSB3aWRnZXQ8L3NwYW4+XG5cdFx0Ly9cdFx0fFx0XHQ8aT4gYW5kIGFub3RoZXIgcGxhaW4gRE9NIG5vZGUgPC9pPlxuXHRcdC8vXHRcdHxcdDwvZGl2PlxuXHRcdC8vXG5cdFx0Ly9cdFx0Y29udGFpbmVyTm9kZSB3b3VsZCBwb2ludCB0bzpcblx0XHQvL1xuXHRcdC8vXHRcdHxcdFx0PGI+IGhlcmUncyBhIHBsYWluIERPTSBub2RlXG5cdFx0Ly9cdFx0fFx0XHQ8c3BhbiBkYXRhLWRvam8tdHlwZT1zdWJXaWRnZXQ+YW5kIGEgd2lkZ2V0PC9zcGFuPlxuXHRcdC8vXHRcdHxcdFx0PGk+IGFuZCBhbm90aGVyIHBsYWluIERPTSBub2RlIDwvaT5cblx0XHQvL1xuXHRcdC8vXHRcdEluIHRlbXBsYXRlZCB3aWRnZXRzLCBcImNvbnRhaW5lck5vZGVcIiBpcyBzZXQgdmlhIGFcblx0XHQvL1x0XHRkYXRhLWRvam8tYXR0YWNoLXBvaW50IGFzc2lnbm1lbnQuXG5cdFx0Ly9cblx0XHQvL1x0XHRjb250YWluZXJOb2RlIG11c3QgYmUgZGVmaW5lZCBmb3IgYW55IHdpZGdldCB0aGF0IGFjY2VwdHMgaW5uZXJIVE1MXG5cdFx0Ly9cdFx0KGxpa2UgQ29udGVudFBhbmUgb3IgQm9yZGVyQ29udGFpbmVyIG9yIGV2ZW4gQnV0dG9uKSwgYW5kIGNvbnZlcnNlbHlcblx0XHQvL1x0XHRpcyBudWxsIGZvciB3aWRnZXRzIHRoYXQgZG9uJ3QsIGxpa2UgVGV4dEJveC5cblx0XHRjb250YWluZXJOb2RlOiBudWxsLFxuXG5cdFx0Ly8gb3duZXJEb2N1bWVudDogW2NvbnN0XSBEb2N1bWVudD9cblx0XHQvL1x0XHRUaGUgZG9jdW1lbnQgdGhpcyB3aWRnZXQgYmVsb25ncyB0by4gIElmIG5vdCBzcGVjaWZpZWQgdG8gY29uc3RydWN0b3IsIHdpbGwgZGVmYXVsdCB0b1xuXHRcdC8vXHRcdHNyY05vZGVSZWYub3duZXJEb2N1bWVudCwgb3IgaWYgbm8gc291cmNlUmVmIHNwZWNpZmllZCwgdGhlbiB0byB0aGUgZG9jdW1lbnQgZ2xvYmFsXG5cdFx0b3duZXJEb2N1bWVudDogbnVsbCxcblx0XHRfc2V0T3duZXJEb2N1bWVudEF0dHI6IGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHQvLyB0aGlzIHNldHRlciBpcyBtZXJlbHkgdG8gYXZvaWQgYXV0b21hdGljYWxseSB0cnlpbmcgdG8gc2V0IHRoaXMuZG9tTm9kZS5vd25lckRvY3VtZW50XG5cdFx0XHR0aGlzLl9zZXQoXCJvd25lckRvY3VtZW50XCIsIHZhbCk7XG5cdFx0fSxcblxuXHRcdC8qPT09PT1cblx0XHQvLyBfc3RhcnRlZDogW3JlYWRvbmx5XSBCb29sZWFuXG5cdFx0Ly9cdFx0c3RhcnR1cCgpIGhhcyBjb21wbGV0ZWQuXG5cdFx0X3N0YXJ0ZWQ6IGZhbHNlLFxuXHRcdD09PT09Ki9cblxuXHRcdC8vIGF0dHJpYnV0ZU1hcDogW3Byb3RlY3RlZF0gT2JqZWN0XG5cdFx0Ly9cdFx0RGVwcmVjYXRlZC5cdEluc3RlYWQgb2YgYXR0cmlidXRlTWFwLCB3aWRnZXQgc2hvdWxkIGhhdmUgYSBfc2V0WFhYQXR0ciBhdHRyaWJ1dGVcblx0XHQvL1x0XHRmb3IgZWFjaCBYWFggYXR0cmlidXRlIHRvIGJlIG1hcHBlZCB0byB0aGUgRE9NLlxuXHRcdC8vXG5cdFx0Ly9cdFx0YXR0cmlidXRlTWFwIHNldHMgdXAgYSBcImJpbmRpbmdcIiBiZXR3ZWVuIGF0dHJpYnV0ZXMgKGFrYSBwcm9wZXJ0aWVzKVxuXHRcdC8vXHRcdG9mIHRoZSB3aWRnZXQgYW5kIHRoZSB3aWRnZXQncyBET00uXG5cdFx0Ly9cdFx0Q2hhbmdlcyB0byB3aWRnZXQgYXR0cmlidXRlcyBsaXN0ZWQgaW4gYXR0cmlidXRlTWFwIHdpbGwgYmVcblx0XHQvL1x0XHRyZWZsZWN0ZWQgaW50byB0aGUgRE9NLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGNhbGxpbmcgc2V0KCd0aXRsZScsICdoZWxsbycpXG5cdFx0Ly9cdFx0b24gYSBUaXRsZVBhbmUgd2lsbCBhdXRvbWF0aWNhbGx5IGNhdXNlIHRoZSBUaXRsZVBhbmUncyBET00gdG8gdXBkYXRlXG5cdFx0Ly9cdFx0d2l0aCB0aGUgbmV3IHRpdGxlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0YXR0cmlidXRlTWFwIGlzIGEgaGFzaCB3aGVyZSB0aGUga2V5IGlzIGFuIGF0dHJpYnV0ZSBvZiB0aGUgd2lkZ2V0LFxuXHRcdC8vXHRcdGFuZCB0aGUgdmFsdWUgcmVmbGVjdHMgYSBiaW5kaW5nIHRvIGE6XG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGF0dHJpYnV0ZVxuXHRcdC8vIHxcdFx0Zm9jdXM6IHtub2RlOiBcImZvY3VzTm9kZVwiLCB0eXBlOiBcImF0dHJpYnV0ZVwifVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5mb2N1cyB0byB0aGlzLmZvY3VzTm9kZS5mb2N1c1xuXHRcdC8vXG5cdFx0Ly9cdFx0LSBET00gbm9kZSBpbm5lckhUTUxcblx0XHQvL1x0fFx0XHR0aXRsZTogeyBub2RlOiBcInRpdGxlTm9kZVwiLCB0eXBlOiBcImlubmVySFRNTFwiIH1cblx0XHQvL1x0XHRNYXBzIHRoaXMudGl0bGUgdG8gdGhpcy50aXRsZU5vZGUuaW5uZXJIVE1MXG5cdFx0Ly9cblx0XHQvL1x0XHQtIERPTSBub2RlIGlubmVyVGV4dFxuXHRcdC8vXHR8XHRcdHRpdGxlOiB7IG5vZGU6IFwidGl0bGVOb2RlXCIsIHR5cGU6IFwiaW5uZXJUZXh0XCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy50aXRsZSB0byB0aGlzLnRpdGxlTm9kZS5pbm5lclRleHRcblx0XHQvL1xuXHRcdC8vXHRcdC0gRE9NIG5vZGUgQ1NTIGNsYXNzXG5cdFx0Ly8gfFx0XHRteUNsYXNzOiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImNsYXNzXCIgfVxuXHRcdC8vXHRcdE1hcHMgdGhpcy5teUNsYXNzIHRvIHRoaXMuZG9tTm9kZS5jbGFzc05hbWVcblx0XHQvL1xuXHRcdC8vXHRcdElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IG1hdGNoZXMgb25lIG9mIHRoZVxuXHRcdC8vXHRcdGZvcm1hdHMgb2YgdGhlIGFib3ZlIGxpc3QuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGVyZSBhcmUgYWxzbyBzb21lIHNob3J0aGFuZHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBzdHJpbmcgLS0+IHsgbm9kZTogc3RyaW5nLCB0eXBlOiBcImF0dHJpYnV0ZVwiIH0sIGZvciBleGFtcGxlOlxuXHRcdC8vXG5cdFx0Ly9cdHxcdFwiZm9jdXNOb2RlXCIgLS0tPiB7IG5vZGU6IFwiZm9jdXNOb2RlXCIsIHR5cGU6IFwiYXR0cmlidXRlXCIgfVxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBcIlwiIC0tPiB7IG5vZGU6IFwiZG9tTm9kZVwiLCB0eXBlOiBcImF0dHJpYnV0ZVwiIH1cblx0XHRhdHRyaWJ1dGVNYXA6IHt9LFxuXG5cdFx0Ly8gX2JsYW5rR2lmOiBbcHJvdGVjdGVkXSBTdHJpbmdcblx0XHQvL1x0XHRQYXRoIHRvIGEgYmxhbmsgMXgxIGltYWdlLlxuXHRcdC8vXHRcdFVzZWQgYnkgYDxpbWc+YCBub2RlcyBpbiB0ZW1wbGF0ZXMgdGhhdCByZWFsbHkgZ2V0IHRoZWlyIGltYWdlIHZpYSBDU1MgYmFja2dyb3VuZC1pbWFnZS5cblx0XHRfYmxhbmtHaWY6IGNvbmZpZy5ibGFua0dpZiB8fCByZXF1aXJlLnRvVXJsKFwiZG9qby9yZXNvdXJjZXMvYmxhbmsuZ2lmXCIpLFxuXG5cdFx0Ly8gdGV4dERpcjogU3RyaW5nXG5cdFx0Ly9cdFx0QmktZGlyZWN0aW9uYWwgc3VwcG9ydCxcdHRoZSBtYWluIHZhcmlhYmxlIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0LlxuXHRcdC8vXHRcdFRoZSB0ZXh0IGRpcmVjdGlvbiBjYW4gYmUgZGlmZmVyZW50IHRoYW4gdGhlIEdVSSBkaXJlY3Rpb24gYnkgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaW4gY3JlYXRpb25cblx0XHQvL1x0XHRvZiBhIHdpZGdldC5cblx0XHQvL1xuXHRcdC8vXHRcdFRoaXMgcHJvcGVydHkgaXMgb25seSBlZmZlY3RpdmUgd2hlbiBgaGFzKFwiZG9qby1iaWRpXCIpYCBpcyBkZWZpbmVkIHRvIGJlIHRydWUuXG5cdFx0Ly9cblx0XHQvL1x0XHRBbGxvd2VkIHZhbHVlczpcblx0XHQvL1xuXHRcdC8vXHRcdDEuIFwiXCIgLSBkZWZhdWx0IHZhbHVlOyB0ZXh0IGlzIHNhbWUgZGlyZWN0aW9uIGFzIHdpZGdldFxuXHRcdC8vXHRcdDIuIFwibHRyXCJcblx0XHQvL1x0XHQzLiBcInJ0bFwiXG5cdFx0Ly9cdFx0NC4gXCJhdXRvXCIgLSBjb250ZXh0dWFsIHRoZSBkaXJlY3Rpb24gb2YgYSB0ZXh0IGRlZmluZWQgYnkgZmlyc3Qgc3Ryb25nIGxldHRlci5cblx0XHR0ZXh0RGlyOiBcIlwiLFxuXG5cdFx0Ly8vLy8vLy8vLy8vIElOSVRJQUxJWkFUSU9OIE1FVEhPRFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHQvKj09PT09XG5cdFx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmFtcywgc3JjTm9kZVJlZil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIHRoZSB3aWRnZXQuXG5cdFx0XHQvLyBwYXJhbXM6IE9iamVjdHxudWxsXG5cdFx0XHQvL1x0XHRIYXNoIG9mIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnMgZm9yIHdpZGdldCwgaW5jbHVkaW5nIHNjYWxhciB2YWx1ZXMgKGxpa2UgdGl0bGUsIGR1cmF0aW9uIGV0Yy4pXG5cdFx0XHQvL1x0XHRhbmQgZnVuY3Rpb25zLCB0eXBpY2FsbHkgY2FsbGJhY2tzIGxpa2Ugb25DbGljay5cblx0XHRcdC8vXHRcdFRoZSBoYXNoIGNhbiBjb250YWluIGFueSBvZiB0aGUgd2lkZ2V0J3MgcHJvcGVydGllcywgZXhjbHVkaW5nIHJlYWQtb25seSBwcm9wZXJ0aWVzLlxuXHRcdFx0Ly8gc3JjTm9kZVJlZjogRE9NTm9kZXxTdHJpbmc/XG5cdFx0XHQvL1x0XHRJZiBhIHNyY05vZGVSZWYgKERPTSBub2RlKSBpcyBzcGVjaWZpZWQ6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0LSB1c2Ugc3JjTm9kZVJlZi5pbm5lckhUTUwgYXMgbXkgY29udGVudHNcblx0XHRcdC8vXHRcdC0gaWYgdGhpcyBpcyBhIGJlaGF2aW9yYWwgd2lkZ2V0IHRoZW4gYXBwbHkgYmVoYXZpb3IgdG8gdGhhdCBzcmNOb2RlUmVmXG5cdFx0XHQvL1x0XHQtIG90aGVyd2lzZSwgcmVwbGFjZSBzcmNOb2RlUmVmIHdpdGggbXkgZ2VuZXJhdGVkIERPTSB0cmVlXG5cdFx0fSxcblx0XHQ9PT09PSovXG5cblx0XHRfaW50cm9zcGVjdDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb2xsZWN0IG1ldGFkYXRhIGFib3V0IHRoaXMgd2lkZ2V0IChvbmx5IG9uY2UgcGVyIGNsYXNzLCBub3Qgb25jZSBwZXIgaW5zdGFuY2UpOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFx0LSBsaXN0IG9mIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVycywgc3RvcmluZyBpbiB0aGlzLmNvbnN0cnVjdG9yLl9zZXR0ZXJBdHRyc1xuXHRcdFx0Ly9cdFx0XHQtIGdlbmVyYXRlIHRoaXMuY29uc3RydWN0b3IuX29uTWFwLCBtYXBwaW5nIG5hbWVzIGxpa2UgXCJtb3VzZWRvd25cIiB0byBmdW5jdGlvbnMgbGlrZSBvbk1vdXNlRG93blxuXG5cdFx0XHR2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0XHRpZighY3Rvci5fc2V0dGVyQXR0cnMpe1xuXHRcdFx0XHR2YXIgcHJvdG8gPSBjdG9yLnByb3RvdHlwZSxcblx0XHRcdFx0XHRhdHRycyA9IGN0b3IuX3NldHRlckF0dHJzID0gW10sIC8vIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVyc1xuXHRcdFx0XHRcdG9uTWFwID0gKGN0b3IuX29uTWFwID0ge30pO1xuXG5cdFx0XHRcdC8vIEl0ZW1zIGluIHRoaXMuYXR0cmlidXRlTWFwIGFyZSBsaWtlIGN1c3RvbSBzZXR0ZXJzLiAgRm9yIGJhY2stY29tcGF0LCByZW1vdmUgZm9yIDIuMC5cblx0XHRcdFx0Zm9yKHZhciBuYW1lIGluIHByb3RvLmF0dHJpYnV0ZU1hcCl7XG5cdFx0XHRcdFx0YXR0cnMucHVzaChuYW1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3Agb3ZlciB3aWRnZXQgcHJvcGVydGllcywgY29sbGVjdGluZyBwcm9wZXJ0aWVzIHdpdGggY3VzdG9tIHNldHRlcnMgYW5kIGZpbGxpbmcgaW4gY3Rvci5fb25NYXAuXG5cdFx0XHRcdGZvcihuYW1lIGluIHByb3RvKXtcblx0XHRcdFx0XHRpZigvXm9uLy50ZXN0KG5hbWUpKXtcblx0XHRcdFx0XHRcdG9uTWFwW25hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCldID0gbmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZigvXl9zZXRbQS1aXSguKilBdHRyJC8udGVzdChuYW1lKSl7XG5cdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5jaGFyQXQoNCkudG9Mb3dlckNhc2UoKSArIG5hbWUuc3Vic3RyKDUsIG5hbWUubGVuZ3RoIC0gOSk7XG5cdFx0XHRcdFx0XHRpZighcHJvdG8uYXR0cmlidXRlTWFwIHx8ICEobmFtZSBpbiBwcm90by5hdHRyaWJ1dGVNYXApKXtcblx0XHRcdFx0XHRcdFx0YXR0cnMucHVzaChuYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBOb3RlOiB0aGlzIGlzbid0IHBpY2tpbmcgdXAgaW5mbyBvbiBwcm9wZXJ0aWVzIGxpa2UgYXJpYS1sYWJlbCBhbmQgcm9sZSwgdGhhdCBkb24ndCBoYXZlIGN1c3RvbSBzZXR0ZXJzXG5cdFx0XHRcdC8vIGJ1dCB0aGF0IHNldCgpIG1hcHMgdG8gYXR0cmlidXRlcyBvbiB0aGlzLmRvbU5vZGUgb3IgdGhpcy5mb2N1c05vZGVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdHNjcmlwdDogZnVuY3Rpb24oLypPYmplY3Q/Ki9wYXJhbXMsIC8qRG9tTm9kZXxTdHJpbmcqL3NyY05vZGVSZWYpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEtpY2tzIG9mZiB3aWRnZXQgaW5zdGFudGlhdGlvbi4gIFNlZSBjcmVhdGUoKSBmb3IgZGV0YWlscy5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHRcdC8vIE5vdGUgdGhhdCB3ZSBza2lwIGNhbGxpbmcgdGhpcy5pbmhlcml0ZWQoKSwgaS5lLiBkb2pvL1N0YXRlZnVsOjpwb3N0c2NyaXB0KCksIGJlY2F1c2UgMS54IHdpZGdldHMgZG9uJ3Rcblx0XHRcdC8vIGV4cGVjdCB0aGVpciBjdXN0b20gc2V0dGVycyB0byBnZXQgY2FsbGVkIHVudGlsIGFmdGVyIGJ1aWxkUmVuZGVyaW5nKCkuICBDb25zaWRlciBjaGFuZ2luZyBmb3IgMi4wLlxuXG5cdFx0XHR0aGlzLmNyZWF0ZShwYXJhbXMsIHNyY05vZGVSZWYpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHBhcmFtcywgc3JjTm9kZVJlZil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0S2ljayBvZmYgdGhlIGxpZmUtY3ljbGUgb2YgYSB3aWRnZXRcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIGNhbGxzIGEgbnVtYmVyIG9mIHdpZGdldCBtZXRob2RzIChwb3N0TWl4SW5Qcm9wZXJ0aWVzLCBidWlsZFJlbmRlcmluZywgcG9zdENyZWF0ZSxcblx0XHRcdC8vXHRcdGV0Yy4pLCBzb21lIG9mIHdoaWNoIG9mIHlvdSdsbCB3YW50IHRvIG92ZXJyaWRlLiBTZWUgaHR0cDovL2Rvam90b29sa2l0Lm9yZy9yZWZlcmVuY2UtZ3VpZGUvZGlqaXQvX1dpZGdldEJhc2UuaHRtbFxuXHRcdFx0Ly9cdFx0Zm9yIGEgZGlzY3Vzc2lvbiBvZiB0aGUgd2lkZ2V0IGNyZWF0aW9uIGxpZmVjeWNsZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRPZiBjb3Vyc2UsIGFkdmVudHVyb3VzIGRldmVsb3BlcnMgY291bGQgb3ZlcnJpZGUgY3JlYXRlIGVudGlyZWx5LCBidXQgdGhpcyBzaG91bGRcblx0XHRcdC8vXHRcdG9ubHkgYmUgZG9uZSBhcyBhIGxhc3QgcmVzb3J0LlxuXHRcdFx0Ly8gcGFyYW1zOiBPYmplY3R8bnVsbFxuXHRcdFx0Ly9cdFx0SGFzaCBvZiBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzIGZvciB3aWRnZXQsIGluY2x1ZGluZyBzY2FsYXIgdmFsdWVzIChsaWtlIHRpdGxlLCBkdXJhdGlvbiBldGMuKVxuXHRcdFx0Ly9cdFx0YW5kIGZ1bmN0aW9ucywgdHlwaWNhbGx5IGNhbGxiYWNrcyBsaWtlIG9uQ2xpY2suXG5cdFx0XHQvL1x0XHRUaGUgaGFzaCBjYW4gY29udGFpbiBhbnkgb2YgdGhlIHdpZGdldCdzIHByb3BlcnRpZXMsIGV4Y2x1ZGluZyByZWFkLW9ubHkgcHJvcGVydGllcy5cblx0XHRcdC8vIHNyY05vZGVSZWY6IERPTU5vZGV8U3RyaW5nP1xuXHRcdFx0Ly9cdFx0SWYgYSBzcmNOb2RlUmVmIChET00gbm9kZSkgaXMgc3BlY2lmaWVkOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdC0gdXNlIHNyY05vZGVSZWYuaW5uZXJIVE1MIGFzIG15IGNvbnRlbnRzXG5cdFx0XHQvL1x0XHQtIGlmIHRoaXMgaXMgYSBiZWhhdmlvcmFsIHdpZGdldCB0aGVuIGFwcGx5IGJlaGF2aW9yIHRvIHRoYXQgc3JjTm9kZVJlZlxuXHRcdFx0Ly9cdFx0LSBvdGhlcndpc2UsIHJlcGxhY2Ugc3JjTm9kZVJlZiB3aXRoIG15IGdlbmVyYXRlZCBET00gdHJlZVxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Ly8gRmlyc3QgdGltZSB3aWRnZXQgaXMgaW5zdGFudGlhdGVkLCBzY2FuIHByb3RvdHlwZSB0byBmaWd1cmUgb3V0IGluZm8gYWJvdXQgY3VzdG9tIHNldHRlcnMgZXRjLlxuXHRcdFx0dGhpcy5faW50cm9zcGVjdCgpO1xuXG5cdFx0XHQvLyBzdG9yZSBwb2ludGVyIHRvIG9yaWdpbmFsIERPTSB0cmVlXG5cdFx0XHR0aGlzLnNyY05vZGVSZWYgPSBkb20uYnlJZChzcmNOb2RlUmVmKTtcblxuXHRcdFx0Ly8gTm8gbG9uZ2VyIHVzZWQsIHJlbW92ZSBmb3IgMi4wLlxuXHRcdFx0dGhpcy5fY29ubmVjdHMgPSBbXTtcblx0XHRcdHRoaXMuX3N1cHBvcnRpbmdXaWRnZXRzID0gW107XG5cblx0XHRcdC8vIHRoaXMgaXMgaGVyZSBmb3IgYmFjay1jb21wYXQsIHJlbW92ZSBpbiAyLjAgKGJ1dCBjaGVjayBOb2RlTGlzdC1pbnN0YW50aWF0ZS5odG1sIHRlc3QpXG5cdFx0XHRpZih0aGlzLnNyY05vZGVSZWYgJiYgdGhpcy5zcmNOb2RlUmVmLmlkICAmJiAodHlwZW9mIHRoaXMuc3JjTm9kZVJlZi5pZCA9PSBcInN0cmluZ1wiKSl7XG5cdFx0XHRcdHRoaXMuaWQgPSB0aGlzLnNyY05vZGVSZWYuaWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1peCBpbiBvdXIgcGFzc2VkIHBhcmFtZXRlcnNcblx0XHRcdGlmKHBhcmFtcyl7XG5cdFx0XHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXHRcdFx0XHRsYW5nLm1peGluKHRoaXMsIHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc3RNaXhJblByb3BlcnRpZXMoKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgYW4gaWQgZm9yIHRoZSB3aWRnZXQgaWYgb25lIHdhc24ndCBzcGVjaWZpZWQsIG9yIGl0IHdhcyBzcGVjaWZpZWQgYXMgaWQ6IHVuZGVmaW5lZC5cblx0XHRcdC8vIERvIHRoaXMgYmVmb3JlIGJ1aWxkUmVuZGVyaW5nKCkgYmVjYXVzZSBpdCBtaWdodCBleHBlY3QgdGhlIGlkIHRvIGJlIHRoZXJlLlxuXHRcdFx0aWYoIXRoaXMuaWQpe1xuXHRcdFx0XHR0aGlzLmlkID0gcmVnaXN0cnkuZ2V0VW5pcXVlSWQodGhpcy5kZWNsYXJlZENsYXNzLnJlcGxhY2UoL1xcLi9nLCBcIl9cIikpO1xuXHRcdFx0XHRpZih0aGlzLnBhcmFtcyl7XG5cdFx0XHRcdFx0Ly8gaWYgcGFyYW1zIGNvbnRhaW5zIHtpZDogdW5kZWZpbmVkfSwgcHJldmVudCBfYXBwbHlBdHRyaWJ1dGVzKCkgZnJvbSBwcm9jZXNzaW5nIGl0XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucGFyYW1zLmlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBkb2N1bWVudCBhbmQgPGJvZHk+IG5vZGUgdGhpcyB3aWRnZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG5cdFx0XHR0aGlzLm93bmVyRG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgKHRoaXMuc3JjTm9kZVJlZiA/IHRoaXMuc3JjTm9kZVJlZi5vd25lckRvY3VtZW50IDogZG9jdW1lbnQpO1xuXHRcdFx0dGhpcy5vd25lckRvY3VtZW50Qm9keSA9IHdpbi5ib2R5KHRoaXMub3duZXJEb2N1bWVudCk7XG5cblx0XHRcdHJlZ2lzdHJ5LmFkZCh0aGlzKTtcblxuXHRcdFx0dGhpcy5idWlsZFJlbmRlcmluZygpO1xuXG5cdFx0XHR2YXIgZGVsZXRlU3JjTm9kZVJlZjtcblxuXHRcdFx0aWYodGhpcy5kb21Ob2RlKXtcblx0XHRcdFx0Ly8gQ29weSBhdHRyaWJ1dGVzIGxpc3RlZCBpbiBhdHRyaWJ1dGVNYXAgaW50byB0aGUgW25ld2x5IGNyZWF0ZWRdIERPTSBmb3IgdGhlIHdpZGdldC5cblx0XHRcdFx0Ly8gQWxzbyBjYWxscyBjdXN0b20gc2V0dGVycyBmb3IgYWxsIGF0dHJpYnV0ZXMgd2l0aCBjdXN0b20gc2V0dGVycy5cblx0XHRcdFx0dGhpcy5fYXBwbHlBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdFx0Ly8gSWYgc3JjTm9kZVJlZiB3YXMgc3BlY2lmaWVkLCB0aGVuIHN3YXAgb3V0IG9yaWdpbmFsIHNyY05vZGUgZm9yIHRoaXMgd2lkZ2V0J3MgRE9NIHRyZWUuXG5cdFx0XHRcdC8vIEZvciAyLjAsIG1vdmUgdGhpcyBhZnRlciBwb3N0Q3JlYXRlKCkuICBwb3N0Q3JlYXRlKCkgc2hvdWxkbid0IGRlcGVuZCBvbiB0aGVcblx0XHRcdFx0Ly8gd2lkZ2V0IGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBET00gc2luY2UgaXQgaXNuJ3Qgd2hlbiBhIHdpZGdldCBpcyBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHkgbGlrZVxuXHRcdFx0XHQvLyBuZXcgTXlXaWRnZXQoe30pLlx0U2VlICMxMTYzNS5cblx0XHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMuc3JjTm9kZVJlZjtcblx0XHRcdFx0aWYoc291cmNlICYmIHNvdXJjZS5wYXJlbnROb2RlICYmIHRoaXMuZG9tTm9kZSAhPT0gc291cmNlKXtcblx0XHRcdFx0XHRzb3VyY2UucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5kb21Ob2RlLCBzb3VyY2UpO1xuXHRcdFx0XHRcdGRlbGV0ZVNyY05vZGVSZWYgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTm90ZTogZm9yIDIuMCBtYXkgd2FudCB0byByZW5hbWUgd2lkZ2V0SWQgdG8gZG9qby5fc2NvcGVOYW1lICsgXCJfd2lkZ2V0SWRcIixcblx0XHRcdFx0Ly8gYXNzdW1pbmcgdGhhdCBkb2pvLl9zY29wZU5hbWUgZXZlbiBleGlzdHMgaW4gMi4wXG5cdFx0XHRcdHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWRnZXRJZFwiLCB0aGlzLmlkKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucG9zdENyZWF0ZSgpO1xuXG5cdFx0XHQvLyBJZiBzcmNOb2RlUmVmIGhhcyBiZWVuIHByb2Nlc3NlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBET00gKGUuZy4gVGVtcGxhdGVkV2lkZ2V0KSB0aGVuIGRlbGV0ZSBpdCB0byBhbGxvdyBHQy5cblx0XHRcdC8vIEkgdGhpbmsgZm9yIGJhY2stY29tcGF0aWJpbGl0eSBpdCBpc24ndCBkZWxldGluZyBzcmNOb2RlUmVmIHVudGlsIGFmdGVyIHBvc3RDcmVhdGUoKSBoYXMgcnVuLlxuXHRcdFx0aWYoZGVsZXRlU3JjTm9kZVJlZil7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnNyY05vZGVSZWY7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NyZWF0ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRfYXBwbHlBdHRyaWJ1dGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN0ZXAgZHVyaW5nIHdpZGdldCBjcmVhdGlvbiB0byBjb3B5ICB3aWRnZXQgYXR0cmlidXRlcyB0byB0aGVcblx0XHRcdC8vXHRcdERPTSBhY2NvcmRpbmcgdG8gYXR0cmlidXRlTWFwIGFuZCBfc2V0WFhYQXR0ciBvYmplY3RzLCBhbmQgYWxzbyB0byBjYWxsXG5cdFx0XHQvL1x0XHRjdXN0b20gX3NldFhYWEF0dHIoKSBtZXRob2RzLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFNraXBzIG92ZXIgYmxhbmsvZmFsc2UgYXR0cmlidXRlIHZhbHVlcywgdW5sZXNzIHRoZXkgd2VyZSBleHBsaWNpdGx5IHNwZWNpZmllZFxuXHRcdFx0Ly9cdFx0YXMgcGFyYW1ldGVycyB0byB0aGUgd2lkZ2V0LCBzaW5jZSB0aG9zZSBhcmUgdGhlIGRlZmF1bHQgYW55d2F5LFxuXHRcdFx0Ly9cdFx0YW5kIHNldHRpbmcgdGFiSW5kZXg9XCJcIiBpcyBkaWZmZXJlbnQgdGhhbiBub3Qgc2V0dGluZyB0YWJJbmRleCBhdCBhbGwuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHJlYXNvbnMgYXR0cmlidXRlTWFwIG92ZXJyaWRlcyBfc2V0WFhYQXR0ciB3aGVuXG5cdFx0XHQvL1x0XHRfc2V0WFhYQXR0ciBpcyBhIGhhc2gvc3RyaW5nL2FycmF5LCBidXQgX3NldFhYWEF0dHIgYXMgYSBmdW5jdGlvbnMgb3ZlcnJpZGUgYXR0cmlidXRlTWFwLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Ly8gQ2FsbCB0aGlzLnNldCgpIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgd2FzIGVpdGhlciBzcGVjaWZpZWQgYXMgcGFyYW1ldGVyIHRvIGNvbnN0cnVjdG9yLFxuXHRcdFx0Ly8gb3IgaXMgaW4gdGhlIGxpc3QgZm91bmQgYWJvdmUuXHRGb3IgY29ycmVsYXRlZCBwcm9wZXJ0aWVzIGxpa2UgdmFsdWUgYW5kIGRpc3BsYXllZFZhbHVlLCB0aGUgb25lXG5cdFx0XHQvLyBzcGVjaWZpZWQgYXMgYSBwYXJhbWV0ZXIgc2hvdWxkIHRha2UgcHJlY2VkZW5jZS5cblx0XHRcdC8vIFBhcnRpY3VsYXJseSBpbXBvcnRhbnQgZm9yIG5ldyBEYXRlVGV4dEJveCh7ZGlzcGxheWVkVmFsdWU6IC4uLn0pIHNpbmNlIERhdGVUZXh0Qm94J3MgZGVmYXVsdCB2YWx1ZSBpc1xuXHRcdFx0Ly8gTmFOIGFuZCB0aHVzIGlzIG5vdCBpZ25vcmVkIGxpa2UgYSBkZWZhdWx0IHZhbHVlIG9mIFwiXCIuXG5cblx0XHRcdC8vIFN0ZXAgMTogU2F2ZSB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIHdpZGdldCBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBzcGVjaWZpZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IuXG5cdFx0XHQvLyBHZW5lcmFsbHkgdGhpcy5mb28gPT0gdGhpcy5wYXJhbXMuZm9vLCBleGNlcHQgaWYgcG9zdE1peEluUHJvcGVydGllcygpIGNoYW5nZWQgdGhlIHZhbHVlIG9mIHRoaXMuZm9vLlxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9O1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gdGhpcy5wYXJhbXMgfHwge30pe1xuXHRcdFx0XHRwYXJhbXNba2V5XSA9IHRoaXMuX2dldChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGVwIDI6IENhbGwgc2V0KCkgZm9yIGVhY2ggcHJvcGVydHkgd2l0aCBhIG5vbi1mYWxzeSB2YWx1ZSB0aGF0IHdhc24ndCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuY29uc3RydWN0b3IuX3NldHRlckF0dHJzLCBmdW5jdGlvbihrZXkpe1xuXHRcdFx0XHRpZighKGtleSBpbiBwYXJhbXMpKXtcblx0XHRcdFx0XHR2YXIgdmFsID0gdGhpcy5fZ2V0KGtleSk7XG5cdFx0XHRcdFx0aWYodmFsKXtcblx0XHRcdFx0XHRcdHRoaXMuc2V0KGtleSwgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHQvLyBTdGVwIDM6IENhbGwgc2V0KCkgZm9yIGVhY2ggcHJvcGVydHkgdGhhdCB3YXMgc3BlY2lmaWVkIGFzIHBhcmFtZXRlciB0byBjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIFVzZSBwYXJhbXMgaGFzaCBjcmVhdGVkIGFib3ZlIHRvIGlnbm9yZSBzaWRlIGVmZmVjdHMgZnJvbSBzdGVwICMyIGFib3ZlLlxuXHRcdFx0Zm9yKGtleSBpbiBwYXJhbXMpe1xuXHRcdFx0XHR0aGlzLnNldChrZXksIHBhcmFtc1trZXldKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdE1peEluUHJvcGVydGllczogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxsZWQgYWZ0ZXIgdGhlIHBhcmFtZXRlcnMgdG8gdGhlIHdpZGdldCBoYXZlIGJlZW4gcmVhZC1pbixcblx0XHRcdC8vXHRcdGJ1dCBiZWZvcmUgdGhlIHdpZGdldCB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQuIEVzcGVjaWFsbHlcblx0XHRcdC8vXHRcdHVzZWZ1bCB0byBzZXQgcHJvcGVydGllcyB0aGF0IGFyZSByZWZlcmVuY2VkIGluIHRoZSB3aWRnZXRcblx0XHRcdC8vXHRcdHRlbXBsYXRlLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdH0sXG5cblx0XHRidWlsZFJlbmRlcmluZzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb25zdHJ1Y3QgdGhlIFVJIGZvciB0aGlzIHdpZGdldCwgc2V0dGluZyB0aGlzLmRvbU5vZGUuXG5cdFx0XHQvL1x0XHRNb3N0IHdpZGdldHMgd2lsbCBtaXhpbiBgZGlqaXQuX1RlbXBsYXRlZE1peGluYCwgd2hpY2ggaW1wbGVtZW50cyB0aGlzIG1ldGhvZC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0aWYoIXRoaXMuZG9tTm9kZSl7XG5cdFx0XHRcdC8vIENyZWF0ZSByb290IG5vZGUgaWYgaXQgd2Fzbid0IGNyZWF0ZWQgYnkgX1RlbXBsYXRlZE1peGluXG5cdFx0XHRcdHRoaXMuZG9tTm9kZSA9IHRoaXMuc3JjTm9kZVJlZiB8fCB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFzZUNsYXNzIGlzIGEgc2luZ2xlIGNsYXNzIG5hbWUgb3Igb2NjYXNpb25hbGx5IGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgbmFtZXMuXG5cdFx0XHQvLyBBZGQgdGhvc2UgY2xhc3NlcyB0byB0aGUgRE9NTm9kZS4gIElmIFJUTCBtb2RlIHRoZW4gYWxzbyBhZGQgd2l0aCBSdGwgc3VmZml4LlxuXHRcdFx0Ly8gVE9ETzogbWFrZSBiYXNlQ2xhc3MgY3VzdG9tIHNldHRlclxuXHRcdFx0aWYodGhpcy5iYXNlQ2xhc3Mpe1xuXHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuYmFzZUNsYXNzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0aWYoIXRoaXMuaXNMZWZ0VG9SaWdodCgpKXtcblx0XHRcdFx0XHRjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoYXJyYXkubWFwKGNsYXNzZXMsIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5hbWUgKyBcIlJ0bFwiO1xuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb21DbGFzcy5hZGQodGhpcy5kb21Ob2RlLCBjbGFzc2VzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cG9zdENyZWF0ZTogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQcm9jZXNzaW5nIGFmdGVyIHRoZSBET00gZnJhZ21lbnQgaXMgY3JlYXRlZFxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRDYWxsZWQgYWZ0ZXIgdGhlIERPTSBmcmFnbWVudCBoYXMgYmVlbiBjcmVhdGVkLCBidXQgbm90IG5lY2Vzc2FyaWx5XG5cdFx0XHQvL1x0XHRhZGRlZCB0byB0aGUgZG9jdW1lbnQuICBEbyBub3QgaW5jbHVkZSBhbnkgb3BlcmF0aW9ucyB3aGljaCByZWx5IG9uXG5cdFx0XHQvL1x0XHRub2RlIGRpbWVuc2lvbnMgb3IgcGxhY2VtZW50LlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdH0sXG5cblx0XHRzdGFydHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFByb2Nlc3NpbmcgYWZ0ZXIgdGhlIERPTSBmcmFnbWVudCBpcyBhZGRlZCB0byB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q2FsbGVkIGFmdGVyIGEgd2lkZ2V0IGFuZCBpdHMgY2hpbGRyZW4gaGF2ZSBiZWVuIGNyZWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBwYWdlLFxuXHRcdFx0Ly9cdFx0YW5kIGFsbCByZWxhdGVkIHdpZGdldHMgaGF2ZSBmaW5pc2hlZCB0aGVpciBjcmVhdGUoKSBjeWNsZSwgdXAgdGhyb3VnaCBwb3N0Q3JlYXRlKCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHN0YXJ0dXAoKSBtYXkgYmUgY2FsbGVkIHdoaWxlIHRoZSB3aWRnZXQgaXMgc3RpbGwgaGlkZGVuLCBmb3IgZXhhbXBsZSBpZiB0aGUgd2lkZ2V0IGlzXG5cdFx0XHQvL1x0XHRpbnNpZGUgYSBoaWRkZW4gZGlqaXQvRGlhbG9nIG9yIGFuIHVuc2VsZWN0ZWQgdGFiIG9mIGEgZGlqaXQvbGF5b3V0L1RhYkNvbnRhaW5lci5cblx0XHRcdC8vXHRcdEZvciB3aWRnZXRzIHRoYXQgbmVlZCB0byBkbyBsYXlvdXQsIGl0J3MgYmVzdCB0byBwdXQgdGhhdCBsYXlvdXQgY29kZSBpbnNpZGUgcmVzaXplKCksIGFuZCB0aGVuXG5cdFx0XHQvL1x0XHRleHRlbmQgZGlqaXQvbGF5b3V0L19MYXlvdXRXaWRnZXQgc28gdGhhdCByZXNpemUoKSBpcyBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIHZpc2libGUuXG5cdFx0XHRpZih0aGlzLl9zdGFydGVkKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cdFx0XHRhcnJheS5mb3JFYWNoKHRoaXMuZ2V0Q2hpbGRyZW4oKSwgZnVuY3Rpb24ob2JqKXtcblx0XHRcdFx0aWYoIW9iai5fc3RhcnRlZCAmJiAhb2JqLl9kZXN0cm95ZWQgJiYgbGFuZy5pc0Z1bmN0aW9uKG9iai5zdGFydHVwKSl7XG5cdFx0XHRcdFx0b2JqLnN0YXJ0dXAoKTtcblx0XHRcdFx0XHRvYmouX3N0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly8vLy8vLy8vLy8vIERFU1RST1kgRlVOQ1RJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHRkZXN0cm95UmVjdXJzaXZlOiBmdW5jdGlvbigvKkJvb2xlYW4/Ki8gcHJlc2VydmVEb20pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3Ryb3kgdGhpcyB3aWRnZXQgYW5kIGl0cyBkZXNjZW5kYW50c1xuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGlzIHRoZSBnZW5lcmljIFwiZGVzdHJ1Y3RvclwiIGZ1bmN0aW9uIHRoYXQgYWxsIHdpZGdldCB1c2Vyc1xuXHRcdFx0Ly9cdFx0c2hvdWxkIGNhbGwgdG8gY2xlYW5seSBkaXNjYXJkIHdpdGggYSB3aWRnZXQuIE9uY2UgYSB3aWRnZXQgaXNcblx0XHRcdC8vXHRcdGRlc3Ryb3llZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYW5hZ2VyIG9iamVjdC5cblx0XHRcdC8vIHByZXNlcnZlRG9tOlxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhpcyBtZXRob2Qgd2lsbCBsZWF2ZSB0aGUgb3JpZ2luYWwgRE9NIHN0cnVjdHVyZVxuXHRcdFx0Ly9cdFx0YWxvbmUgb2YgZGVzY2VuZGFudCBXaWRnZXRzLiBOb3RlOiBUaGlzIHdpbGwgTk9UIHdvcmsgd2l0aFxuXHRcdFx0Ly9cdFx0ZGlqaXQuX1RlbXBsYXRlZE1peGluIHdpZGdldHMuXG5cblx0XHRcdHRoaXMuX2JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGVzdHJveURlc2NlbmRhbnRzKHByZXNlcnZlRG9tKTtcblx0XHRcdHRoaXMuZGVzdHJveShwcmVzZXJ2ZURvbSk7XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKC8qQm9vbGVhbiovIHByZXNlcnZlRG9tKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXN0cm95IHRoaXMgd2lkZ2V0LCBidXQgbm90IGl0cyBkZXNjZW5kYW50cy4gIERlc2NlbmRhbnRzIG1lYW5zIHdpZGdldHMgaW5zaWRlIG9mXG5cdFx0XHQvL1x0XHR0aGlzLmNvbnRhaW5lck5vZGUuICAgV2lsbCBhbHNvIGRlc3Ryb3kgYW55IHJlc291cmNlcyAoaW5jbHVkaW5nIHdpZGdldHMpIHJlZ2lzdGVyZWQgdmlhIHRoaXMub3duKCkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2Qgd2lsbCBhbHNvIGRlc3Ryb3kgaW50ZXJuYWwgd2lkZ2V0cyBzdWNoIGFzIHRob3NlIGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlLFxuXHRcdFx0Ly9cdFx0YXNzdW1pbmcgdGhvc2Ugd2lkZ2V0cyBleGlzdCBpbnNpZGUgb2YgdGhpcy5kb21Ob2RlIGJ1dCBvdXRzaWRlIG9mIHRoaXMuY29udGFpbmVyTm9kZS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRGb3IgMi4wIGl0J3MgcGxhbm5lZCB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgYWxzbyBkZXN0cm95IGRlc2NlbmRhbnQgd2lkZ2V0cywgc28gYXBwcyBzaG91bGQgbm90XG5cdFx0XHQvL1x0XHRkZXBlbmQgb24gdGhlIGN1cnJlbnQgYWJpbGl0eSB0byBkZXN0cm95IGEgd2lkZ2V0IHdpdGhvdXQgZGVzdHJveWluZyBpdHMgZGVzY2VuZGFudHMuICAgR2VuZXJhbGx5XG5cdFx0XHQvL1x0XHR0aGV5IHNob3VsZCB1c2UgZGVzdHJveVJlY3Vyc2l2ZSgpIGZvciB3aWRnZXRzIHdpdGggY2hpbGRyZW4uXG5cdFx0XHQvLyBwcmVzZXJ2ZURvbTogQm9vbGVhblxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhpcyBtZXRob2Qgd2lsbCBsZWF2ZSB0aGUgb3JpZ2luYWwgRE9NIHN0cnVjdHVyZSBhbG9uZS5cblx0XHRcdC8vXHRcdE5vdGU6IFRoaXMgd2lsbCBub3QgeWV0IHdvcmsgd2l0aCBfVGVtcGxhdGVkTWl4aW4gd2lkZ2V0c1xuXG5cdFx0XHR0aGlzLl9iZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG5cdFx0XHR0aGlzLnVuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0XHRmdW5jdGlvbiBkZXN0cm95KHcpe1xuXHRcdFx0XHRpZih3LmRlc3Ryb3lSZWN1cnNpdmUpe1xuXHRcdFx0XHRcdHcuZGVzdHJveVJlY3Vyc2l2ZShwcmVzZXJ2ZURvbSk7XG5cdFx0XHRcdH1lbHNlIGlmKHcuZGVzdHJveSl7XG5cdFx0XHRcdFx0dy5kZXN0cm95KHByZXNlcnZlRG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBCYWNrLWNvbXBhdCwgcmVtb3ZlIGZvciAyLjBcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fY29ubmVjdHMsIGxhbmcuaGl0Y2godGhpcywgXCJkaXNjb25uZWN0XCIpKTtcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5fc3VwcG9ydGluZ1dpZGdldHMsIGRlc3Ryb3kpO1xuXG5cdFx0XHQvLyBEZXN0cm95IHN1cHBvcnRpbmcgd2lkZ2V0cywgYnV0IG5vdCBjaGlsZCB3aWRnZXRzIHVuZGVyIHRoaXMuY29udGFpbmVyTm9kZSAoZm9yIDIuMCwgZGVzdHJveSBjaGlsZCB3aWRnZXRzXG5cdFx0XHQvLyBoZXJlIHRvbykuICAgaWYoKSBzdGF0ZW1lbnQgaXMgdG8gZ3VhcmQgYWdhaW5zdCBleGNlcHRpb24gaWYgZGVzdHJveSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyAoc2VlICMxNTgxNSkuXG5cdFx0XHRpZih0aGlzLmRvbU5vZGUpe1xuXHRcdFx0XHRhcnJheS5mb3JFYWNoKHJlZ2lzdHJ5LmZpbmRXaWRnZXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5jb250YWluZXJOb2RlKSwgZGVzdHJveSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVzdHJveVJlbmRlcmluZyhwcmVzZXJ2ZURvbSk7XG5cdFx0XHRyZWdpc3RyeS5yZW1vdmUodGhpcy5pZCk7XG5cdFx0XHR0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95UmVuZGVyaW5nOiBmdW5jdGlvbigvKkJvb2xlYW4/Ki8gcHJlc2VydmVEb20pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlc3Ryb3lzIHRoZSBET00gbm9kZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgd2lkZ2V0LlxuXHRcdFx0Ly8gcHJlc2VydmVEb206XG5cdFx0XHQvL1x0XHRJZiB0cnVlLCB0aGlzIG1ldGhvZCB3aWxsIGxlYXZlIHRoZSBvcmlnaW5hbCBET00gc3RydWN0dXJlIGFsb25lXG5cdFx0XHQvL1x0XHRkdXJpbmcgdGVhci1kb3duLiBOb3RlOiB0aGlzIHdpbGwgbm90IHdvcmsgd2l0aCBfVGVtcGxhdGVkXG5cdFx0XHQvL1x0XHR3aWRnZXRzIHlldC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0aWYodGhpcy5iZ0lmcmFtZSl7XG5cdFx0XHRcdHRoaXMuYmdJZnJhbWUuZGVzdHJveShwcmVzZXJ2ZURvbSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmJnSWZyYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmRvbU5vZGUpe1xuXHRcdFx0XHRpZihwcmVzZXJ2ZURvbSl7XG5cdFx0XHRcdFx0ZG9tQXR0ci5yZW1vdmUodGhpcy5kb21Ob2RlLCBcIndpZGdldElkXCIpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRkb21Db25zdHJ1Y3QuZGVzdHJveSh0aGlzLmRvbU5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmRvbU5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuc3JjTm9kZVJlZil7XG5cdFx0XHRcdGlmKCFwcmVzZXJ2ZURvbSl7XG5cdFx0XHRcdFx0ZG9tQ29uc3RydWN0LmRlc3Ryb3kodGhpcy5zcmNOb2RlUmVmKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdGhpcy5zcmNOb2RlUmVmO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkZXN0cm95RGVzY2VuZGFudHM6IGZ1bmN0aW9uKC8qQm9vbGVhbj8qLyBwcmVzZXJ2ZURvbSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVjdXJzaXZlbHkgZGVzdHJveSB0aGUgY2hpbGRyZW4gb2YgdGhpcyB3aWRnZXQgYW5kIHRoZWlyXG5cdFx0XHQvL1x0XHRkZXNjZW5kYW50cy5cblx0XHRcdC8vIHByZXNlcnZlRG9tOlxuXHRcdFx0Ly9cdFx0SWYgdHJ1ZSwgdGhlIHByZXNlcnZlRG9tIGF0dHJpYnV0ZSBpcyBwYXNzZWQgdG8gYWxsIGRlc2NlbmRhbnRcblx0XHRcdC8vXHRcdHdpZGdldCdzIC5kZXN0cm95KCkgbWV0aG9kLiBOb3QgZm9yIHVzZSB3aXRoIF9UZW1wbGF0ZWRcblx0XHRcdC8vXHRcdHdpZGdldHMuXG5cblx0XHRcdC8vIGdldCBhbGwgZGlyZWN0IGRlc2NlbmRhbnRzIGFuZCBkZXN0cm95IHRoZW0gcmVjdXJzaXZlbHlcblx0XHRcdGFycmF5LmZvckVhY2godGhpcy5nZXRDaGlsZHJlbigpLCBmdW5jdGlvbih3aWRnZXQpe1xuXHRcdFx0XHRpZih3aWRnZXQuZGVzdHJveVJlY3Vyc2l2ZSl7XG5cdFx0XHRcdFx0d2lkZ2V0LmRlc3Ryb3lSZWN1cnNpdmUocHJlc2VydmVEb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dW5pbml0aWFsaXplOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQuIE92ZXJyaWRlIGRlc3Ryb3koKSBpbnN0ZWFkIHRvIGltcGxlbWVudCBjdXN0b20gd2lkZ2V0IHRlYXItZG93blxuXHRcdFx0Ly9cdFx0YmVoYXZpb3IuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8vLy8vLy8vLy8vLy8vLy8vLyBHRVQvU0VULCBDVVNUT00gU0VUVEVSUywgRVRDLiAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHRfc2V0U3R5bGVBdHRyOiBmdW5jdGlvbigvKlN0cmluZ3x8T2JqZWN0Ki8gdmFsdWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldHMgdGhlIHN0eWxlIGF0dHJpYnV0ZSBvZiB0aGUgd2lkZ2V0IGFjY29yZGluZyB0byB2YWx1ZSxcblx0XHRcdC8vXHRcdHdoaWNoIGlzIGVpdGhlciBhIGhhc2ggbGlrZSB7aGVpZ2h0OiBcIjVweFwiLCB3aWR0aDogXCIzcHhcIn1cblx0XHRcdC8vXHRcdG9yIGEgcGxhaW4gc3RyaW5nXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdERldGVybWluZXMgd2hpY2ggbm9kZSB0byBzZXQgdGhlIHN0eWxlIG9uIGJhc2VkIG9uIHN0eWxlIHNldHRpbmdcblx0XHRcdC8vXHRcdGluIGF0dHJpYnV0ZU1hcC5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblxuXHRcdFx0dmFyIG1hcE5vZGUgPSB0aGlzLmRvbU5vZGU7XG5cblx0XHRcdC8vIE5vdGU6IHRlY2huaWNhbGx5IHdlIHNob3VsZCByZXZlcnQgYW55IHN0eWxlIHNldHRpbmcgbWFkZSBpbiBhIHByZXZpb3VzIGNhbGxcblx0XHRcdC8vIHRvIGhpcyBtZXRob2QsIGJ1dCB0aGF0J3MgZGlmZmljdWx0IHRvIGtlZXAgdHJhY2sgb2YuXG5cblx0XHRcdGlmKGxhbmcuaXNPYmplY3QodmFsdWUpKXtcblx0XHRcdFx0ZG9tU3R5bGUuc2V0KG1hcE5vZGUsIHZhbHVlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZihtYXBOb2RlLnN0eWxlLmNzc1RleHQpe1xuXHRcdFx0XHRcdG1hcE5vZGUuc3R5bGUuY3NzVGV4dCArPSBcIjsgXCIgKyB2YWx1ZTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0bWFwTm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2V0KFwic3R5bGVcIiwgdmFsdWUpO1xuXHRcdH0sXG5cblx0XHRfYXR0clRvRG9tOiBmdW5jdGlvbigvKlN0cmluZyovIGF0dHIsIC8qU3RyaW5nKi8gdmFsdWUsIC8qT2JqZWN0PyovIGNvbW1hbmRzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWZsZWN0IGEgd2lkZ2V0IGF0dHJpYnV0ZSAodGl0bGUsIHRhYkluZGV4LCBkdXJhdGlvbiBldGMuKSB0b1xuXHRcdFx0Ly9cdFx0dGhlIHdpZGdldCBET00sIGFzIHNwZWNpZmllZCBieSBjb21tYW5kcyBwYXJhbWV0ZXIuXG5cdFx0XHQvL1x0XHRJZiBjb21tYW5kcyBpc24ndCBzcGVjaWZpZWQgdGhlbiBpdCdzIGxvb2tlZCB1cCBmcm9tIGF0dHJpYnV0ZU1hcC5cblx0XHRcdC8vXHRcdE5vdGUgc29tZSBhdHRyaWJ1dGVzIGxpa2UgXCJ0eXBlXCJcblx0XHRcdC8vXHRcdGNhbm5vdCBiZSBwcm9jZXNzZWQgdGhpcyB3YXkgYXMgdGhleSBhcmUgbm90IG11dGFibGUuXG5cdFx0XHQvLyBhdHRyOlxuXHRcdFx0Ly9cdFx0TmFtZSBvZiBtZW1iZXIgdmFyaWFibGUgKGV4OiBcImZvY3VzTm9kZVwiIG1hcHMgdG8gdGhpcy5mb2N1c05vZGUpIHBvaW50aW5nXG5cdFx0XHQvL1x0XHR0byBET01Ob2RlIGluc2lkZSB0aGUgd2lkZ2V0LCBvciBhbHRlcm5hdGVseSBwb2ludGluZyB0byBhIHN1YndpZGdldFxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0Y29tbWFuZHMgPSBhcmd1bWVudHMubGVuZ3RoID49IDMgPyBjb21tYW5kcyA6IHRoaXMuYXR0cmlidXRlTWFwW2F0dHJdO1xuXG5cdFx0XHRhcnJheS5mb3JFYWNoKGxhbmcuaXNBcnJheShjb21tYW5kcykgPyBjb21tYW5kcyA6IFtjb21tYW5kc10sIGZ1bmN0aW9uKGNvbW1hbmQpe1xuXG5cdFx0XHRcdC8vIEdldCB0YXJnZXQgbm9kZSBhbmQgd2hhdCB3ZSBhcmUgZG9pbmcgdG8gdGhhdCBub2RlXG5cdFx0XHRcdHZhciBtYXBOb2RlID0gdGhpc1tjb21tYW5kLm5vZGUgfHwgY29tbWFuZCB8fCBcImRvbU5vZGVcIl07XHQvLyBET00gbm9kZVxuXHRcdFx0XHR2YXIgdHlwZSA9IGNvbW1hbmQudHlwZSB8fCBcImF0dHJpYnV0ZVwiO1x0Ly8gY2xhc3MsIGlubmVySFRNTCwgaW5uZXJUZXh0LCBvciBhdHRyaWJ1dGVcblxuXHRcdFx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRcdFx0Y2FzZSBcImF0dHJpYnV0ZVwiOlxuXHRcdFx0XHRcdFx0aWYobGFuZy5pc0Z1bmN0aW9uKHZhbHVlKSl7IC8vIGZ1bmN0aW9ucyBleGVjdXRlIGluIHRoZSBjb250ZXh0IG9mIHRoZSB3aWRnZXRcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBsYW5nLmhpdGNoKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBuYW1lIG9mIHRoZSBET00gbm9kZSBhdHRyaWJ1dGU7IHVzdWFsbHkgaXQncyB0aGUgc2FtZVxuXHRcdFx0XHRcdFx0Ly8gYXMgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBpbiB0aGUgd2lkZ2V0IChhdHRyKSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuLlxuXHRcdFx0XHRcdFx0Ly8gQWxzbyBtYXBzIGhhbmRsZXIgbmFtZXMgdG8gbG93ZXJjYXNlLCBsaWtlIG9uU3VibWl0IC0tPiBvbnN1Ym1pdFxuXHRcdFx0XHRcdFx0dmFyIGF0dHJOYW1lID0gY29tbWFuZC5hdHRyaWJ1dGUgPyBjb21tYW5kLmF0dHJpYnV0ZSA6XG5cdFx0XHRcdFx0XHRcdCgvXm9uW0EtWl1bYS16QS1aXSokLy50ZXN0KGF0dHIpID8gYXR0ci50b0xvd2VyQ2FzZSgpIDogYXR0cik7XG5cblx0XHRcdFx0XHRcdGlmKG1hcE5vZGUudGFnTmFtZSl7XG5cdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBjYXNlLCBtYXBwaW5nIHRvIGEgRE9NTm9kZS4gIE5vdGUgdGhhdCBtb2Rlcm4gYnJvd3NlcnMgd2lsbCBoYXZlIGEgbWFwTm9kZS5zZXQoKVxuXHRcdFx0XHRcdFx0XHQvLyBtZXRob2QsIGJ1dCBmb3IgY29uc2lzdGVuY3kgd2Ugc3RpbGwgY2FsbCBkb21BdHRyXG5cdFx0XHRcdFx0XHRcdGRvbUF0dHIuc2V0KG1hcE5vZGUsIGF0dHJOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gbWFwcGluZyB0byBhIHN1Yi13aWRnZXRcblx0XHRcdFx0XHRcdFx0bWFwTm9kZS5zZXQoYXR0ck5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbm5lclRleHRcIjpcblx0XHRcdFx0XHRcdC8vIERlcHJlY2F0ZWQsIHVzZSBcInRleHRDb250ZW50XCIgaW5zdGVhZC5cblx0XHRcdFx0XHRcdG1hcE5vZGUuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdFx0XHRcdG1hcE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwidGV4dENvbnRlbnRcIjpcblx0XHRcdFx0XHRcdG1hcE5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbm5lckhUTUxcIjpcblx0XHRcdFx0XHRcdG1hcE5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiY2xhc3NcIjpcblx0XHRcdFx0XHRcdGRvbUNsYXNzLnJlcGxhY2UobWFwTm9kZSwgdmFsdWUsIHRoaXNbYXR0cl0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInRvZ2dsZUNsYXNzXCI6XG5cdFx0XHRcdFx0XHRkb21DbGFzcy50b2dnbGUobWFwTm9kZSwgY29tbWFuZC5jbGFzc05hbWUgfHwgYXR0ciwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEdldCBhIHByb3BlcnR5IGZyb20gYSB3aWRnZXQuXG5cdFx0XHQvLyBuYW1lOlxuXHRcdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIGdldC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0R2V0IGEgbmFtZWQgcHJvcGVydHkgZnJvbSBhIHdpZGdldC4gVGhlIHByb3BlcnR5IG1heVxuXHRcdFx0Ly9cdFx0cG90ZW50aWFsbHkgYmUgcmV0cmlldmVkIHZpYSBhIGdldHRlciBtZXRob2QuIElmIG5vIGdldHRlciBpcyBkZWZpbmVkLCB0aGlzXG5cdFx0XHQvL1x0XHRqdXN0IHJldHJpZXZlcyB0aGUgb2JqZWN0J3MgcHJvcGVydHkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIGlmIHRoZSB3aWRnZXQgaGFzIHByb3BlcnRpZXMgYGZvb2AgYW5kIGBiYXJgXG5cdFx0XHQvL1x0XHRhbmQgYSBtZXRob2QgbmFtZWQgYF9nZXRGb29BdHRyKClgLCBjYWxsaW5nOlxuXHRcdFx0Ly9cdFx0YG15V2lkZ2V0LmdldChcImZvb1wiKWAgd291bGQgYmUgZXF1aXZhbGVudCB0byBjYWxsaW5nXG5cdFx0XHQvL1x0XHRgd2lkZ2V0Ll9nZXRGb29BdHRyKClgIGFuZCBgbXlXaWRnZXQuZ2V0KFwiYmFyXCIpYFxuXHRcdFx0Ly9cdFx0d291bGQgYmUgZXF1aXZhbGVudCB0byB0aGUgZXhwcmVzc2lvblxuXHRcdFx0Ly9cdFx0YHdpZGdldC5iYXIyYFxuXHRcdFx0dmFyIG5hbWVzID0gdGhpcy5fZ2V0QXR0ck5hbWVzKG5hbWUpO1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZXMuZ10gPyB0aGlzW25hbWVzLmddKCkgOiB0aGlzLl9nZXQobmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldCBhIHByb3BlcnR5IG9uIGEgd2lkZ2V0XG5cdFx0XHQvLyBuYW1lOlxuXHRcdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIHNldC5cblx0XHRcdC8vIHZhbHVlOlxuXHRcdFx0Ly9cdFx0VGhlIHZhbHVlIHRvIHNldCBpbiB0aGUgcHJvcGVydHkuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNldHMgbmFtZWQgcHJvcGVydGllcyBvbiBhIHdpZGdldCB3aGljaCBtYXkgcG90ZW50aWFsbHkgYmUgaGFuZGxlZCBieSBhXG5cdFx0XHQvL1x0XHRzZXR0ZXIgaW4gdGhlIHdpZGdldC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRGb3IgZXhhbXBsZSwgaWYgdGhlIHdpZGdldCBoYXMgcHJvcGVydGllcyBgZm9vYCBhbmQgYGJhcmBcblx0XHRcdC8vXHRcdGFuZCBhIG1ldGhvZCBuYW1lZCBgX3NldEZvb0F0dHIoKWAsIGNhbGxpbmdcblx0XHRcdC8vXHRcdGBteVdpZGdldC5zZXQoXCJmb29cIiwgXCJIb3dkeSFcIilgIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gY2FsbGluZ1xuXHRcdFx0Ly9cdFx0YHdpZGdldC5fc2V0Rm9vQXR0cihcIkhvd2R5IVwiKWAgYW5kIGBteVdpZGdldC5zZXQoXCJiYXJcIiwgMylgXG5cdFx0XHQvL1x0XHR3b3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBzdGF0ZW1lbnQgYHdpZGdldC5iYXIgPSAzO2Bcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRzZXQoKSBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aCBhIGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycywgZXg6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdHxcdG15V2lkZ2V0LnNldCh7XG5cdFx0XHQvL1x0fFx0XHRmb286IFwiSG93ZHlcIixcblx0XHRcdC8vXHR8XHRcdGJhcjogM1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vXHRUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgc2V0KGZvbywgXCJIb3dkeVwiKWAgYW5kIGBzZXQoYmFyLCAzKWBcblxuXHRcdFx0aWYodHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpe1xuXHRcdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdFx0dGhpcy5zZXQoeCwgbmFtZVt4XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLl9nZXRBdHRyTmFtZXMobmFtZSksXG5cdFx0XHRcdHNldHRlciA9IHRoaXNbbmFtZXMuc107XG5cdFx0XHRpZihsYW5nLmlzRnVuY3Rpb24oc2V0dGVyKSl7XG5cdFx0XHRcdC8vIHVzZSB0aGUgZXhwbGljaXQgc2V0dGVyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBzZXR0ZXIuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gTWFwcGluZyBmcm9tIHdpZGdldCBhdHRyaWJ1dGUgdG8gRE9NTm9kZS9zdWJ3aWRnZXQgYXR0cmlidXRlL3ZhbHVlL2V0Yy5cblx0XHRcdFx0Ly8gTWFwIGFjY29yZGluZyB0bzpcblx0XHRcdFx0Ly9cdFx0MS4gYXR0cmlidXRlTWFwIHNldHRpbmcsIGlmIG9uZSBleGlzdHMgKFRPRE86IGF0dHJpYnV0ZU1hcCBkZXByZWNhdGVkLCByZW1vdmUgaW4gMi4wKVxuXHRcdFx0XHQvL1x0XHQyLiBfc2V0Rm9vQXR0cjogey4uLn0gdHlwZSBhdHRyaWJ1dGUgaW4gdGhlIHdpZGdldCAoaWYgb25lIGV4aXN0cylcblx0XHRcdFx0Ly9cdFx0My4gYXBwbHkgdG8gZm9jdXNOb2RlIG9yIGRvbU5vZGUgaWYgc3RhbmRhcmQgYXR0cmlidXRlIG5hbWUsIGV4Y2x1ZGluZyBmdW5jcyBsaWtlIG9uQ2xpY2suXG5cdFx0XHRcdC8vIENoZWNrcyBpZiBhbiBhdHRyaWJ1dGUgaXMgYSBcInN0YW5kYXJkIGF0dHJpYnV0ZVwiIGJ5IHdoZXRoZXIgdGhlIERPTU5vZGUgSlMgb2JqZWN0IGhhcyBhIHNpbWlsYXJcblx0XHRcdFx0Ly8gYXR0cmlidXRlIG5hbWUgKGV4OiBhY2NlcHQtY2hhcnNldCBhdHRyaWJ1dGUgbWF0Y2hlcyBqc09iamVjdC5hY2NlcHRDaGFyc2V0KS5cblx0XHRcdFx0Ly8gTm90ZSBhbHNvIHRoYXQgVHJlZS5mb2N1c05vZGUoKSBpcyBhIGZ1bmN0aW9uIG5vdCBhIERPTU5vZGUsIHNvIHRlc3QgZm9yIHRoYXQuXG5cdFx0XHRcdHZhciBkZWZhdWx0Tm9kZSA9IHRoaXMuZm9jdXNOb2RlICYmICFsYW5nLmlzRnVuY3Rpb24odGhpcy5mb2N1c05vZGUpID8gXCJmb2N1c05vZGVcIiA6IFwiZG9tTm9kZVwiLFxuXHRcdFx0XHRcdHRhZyA9IHRoaXNbZGVmYXVsdE5vZGVdICYmIHRoaXNbZGVmYXVsdE5vZGVdLnRhZ05hbWUsXG5cdFx0XHRcdFx0YXR0cnNGb3JUYWcgPSB0YWcgJiYgKHRhZ0F0dHJzW3RhZ10gfHwgKHRhZ0F0dHJzW3RhZ10gPSBnZXRBdHRycyh0aGlzW2RlZmF1bHROb2RlXSkpKSxcblx0XHRcdFx0XHRtYXAgPSBuYW1lIGluIHRoaXMuYXR0cmlidXRlTWFwID8gdGhpcy5hdHRyaWJ1dGVNYXBbbmFtZV0gOlxuXHRcdFx0XHRcdFx0bmFtZXMucyBpbiB0aGlzID8gdGhpc1tuYW1lcy5zXSA6XG5cdFx0XHRcdFx0XHRcdCgoYXR0cnNGb3JUYWcgJiYgbmFtZXMubCBpbiBhdHRyc0ZvclRhZyAmJiB0eXBlb2YgdmFsdWUgIT0gXCJmdW5jdGlvblwiKSB8fFxuXHRcdFx0XHRcdFx0XHRcdC9eYXJpYS18XmRhdGEtfF5yb2xlJC8udGVzdChuYW1lKSkgPyBkZWZhdWx0Tm9kZSA6IG51bGw7XG5cdFx0XHRcdGlmKG1hcCAhPSBudWxsKXtcblx0XHRcdFx0XHR0aGlzLl9hdHRyVG9Eb20obmFtZSwgdmFsdWUsIG1hcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQgfHwgdGhpcztcblx0XHR9LFxuXG5cdFx0X2F0dHJQYWlyTmFtZXM6IHt9LCAvLyBzaGFyZWQgYmV0d2VlbiBhbGwgd2lkZ2V0c1xuXHRcdF9nZXRBdHRyTmFtZXM6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0KCkgYW5kIHNldCgpLlxuXHRcdFx0Ly9cdFx0Q2FjaGVzIGF0dHJpYnV0ZSBuYW1lIHZhbHVlcyBzbyB3ZSBkb24ndCBkbyB0aGUgc3RyaW5nIG9wcyBldmVyeSB0aW1lLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByaXZhdGVcblxuXHRcdFx0dmFyIGFwbiA9IHRoaXMuX2F0dHJQYWlyTmFtZXM7XG5cdFx0XHRpZihhcG5bbmFtZV0pe1xuXHRcdFx0XHRyZXR1cm4gYXBuW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHVjID0gbmFtZS5yZXBsYWNlKC9eW2Etel18LVthLXpBLVpdL2csIGZ1bmN0aW9uKGMpe1xuXHRcdFx0XHRyZXR1cm4gYy5jaGFyQXQoYy5sZW5ndGggLSAxKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gKGFwbltuYW1lXSA9IHtcblx0XHRcdFx0bjogbmFtZSArIFwiTm9kZVwiLFxuXHRcdFx0XHRzOiBcIl9zZXRcIiArIHVjICsgXCJBdHRyXCIsIC8vIGNvbnZlcnRzIGRhc2hlcyB0byBjYW1lbCBjYXNlLCBleDogYWNjZXB0LWNoYXJzZXQgLS0+IF9zZXRBY2NlcHRDaGFyc2V0QXR0clxuXHRcdFx0XHRnOiBcIl9nZXRcIiArIHVjICsgXCJBdHRyXCIsXG5cdFx0XHRcdGw6IHVjLnRvTG93ZXJDYXNlKCkgICAgICAgIC8vIGxvd2VyY2FzZSBuYW1lIHcvb3V0IGRhc2hlcywgZXg6IGFjY2VwdGNoYXJzZXRcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRfc2V0OiBmdW5jdGlvbigvKlN0cmluZyovIG5hbWUsIC8qYW55dGhpbmcqLyB2YWx1ZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SGVscGVyIGZ1bmN0aW9uIHRvIHNldCBuZXcgdmFsdWUgZm9yIHNwZWNpZmllZCBwcm9wZXJ0eSwgYW5kIGNhbGwgaGFuZGxlcnNcblx0XHRcdC8vXHRcdHJlZ2lzdGVyZWQgd2l0aCB3YXRjaCgpIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cblx0XHRcdHZhciBvbGRWYWx1ZSA9IHRoaXNbbmFtZV07XG5cdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0XHRpZih0aGlzLl9jcmVhdGVkICYmICFpc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpe1xuXHRcdFx0XHRpZih0aGlzLl93YXRjaENhbGxiYWNrcyl7XG5cdFx0XHRcdFx0dGhpcy5fd2F0Y2hDYWxsYmFja3MobmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmVtaXQoXCJhdHRybW9kaWZpZWQtXCIgKyBuYW1lLCB7XG5cdFx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRwcmV2VmFsdWU6IG9sZFZhbHVlLFxuXHRcdFx0XHRcdFx0bmV3VmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2dldDogZnVuY3Rpb24oLypTdHJpbmcqLyBuYW1lKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHZhbHVlIGZvciBzcGVjaWZpZWQgcHJvcGVydHkgc3RvcmVkIGJ5IHRoaXMuX3NldCgpLFxuXHRcdFx0Ly9cdFx0aS5lLiBmb3IgcHJvcGVydGllcyB3aXRoIGN1c3RvbSBzZXR0ZXJzLiAgVXNlZCBtYWlubHkgYnkgY3VzdG9tIGdldHRlcnMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGV4YW1wbGUsIENoZWNrQm94Ll9nZXRWYWx1ZUF0dHIoKSBjYWxscyB0aGlzLl9nZXQoXCJ2YWx1ZVwiKS5cblxuXHRcdFx0Ly8gZnV0dXJlOiByZXR1cm4gbmFtZSBpbiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1tuYW1lXSA6IHRoaXNbbmFtZV07XG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHR9LFxuXG5cdFx0ZW1pdDogZnVuY3Rpb24oLypTdHJpbmcqLyB0eXBlLCAvKk9iamVjdD8qLyBldmVudE9iaiwgLypBcnJheT8qLyBjYWxsYmFja0FyZ3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFVzZWQgYnkgd2lkZ2V0cyB0byBzaWduYWwgdGhhdCBhIHN5bnRoZXRpYyBldmVudCBvY2N1cnJlZCwgZXg6XG5cdFx0XHQvL1x0fFx0bXlXaWRnZXQuZW1pdChcImF0dHJtb2RpZmllZC1zZWxlY3RlZENoaWxkV2lkZ2V0XCIsIHt9KS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRFbWl0cyBhbiBldmVudCBvbiB0aGlzLmRvbU5vZGUgbmFtZWQgdHlwZS50b0xvd2VyQ2FzZSgpLCBiYXNlZCBvbiBldmVudE9iai5cblx0XHRcdC8vXHRcdEFsc28gY2FsbHMgb25UeXBlKCkgbWV0aG9kLCBpZiBwcmVzZW50LCBhbmQgcmV0dXJucyB2YWx1ZSBmcm9tIHRoYXQgbWV0aG9kLlxuXHRcdFx0Ly9cdFx0QnkgZGVmYXVsdCBwYXNzZXMgZXZlbnRPYmogdG8gY2FsbGJhY2ssIGJ1dCB3aWxsIHBhc3MgY2FsbGJhY2tBcmdzIGluc3RlYWQsIGlmIHNwZWNpZmllZC5cblx0XHRcdC8vXHRcdE1vZGlmaWVzIGV2ZW50T2JqIGJ5IGFkZGluZyBtaXNzaW5nIHBhcmFtZXRlcnMgKGJ1YmJsZXMsIGNhbmNlbGFibGUsIHdpZGdldCkuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdC8vIFNwZWNpZnkgZmFsbGJhY2sgdmFsdWVzIGZvciBidWJibGVzLCBjYW5jZWxhYmxlIGluIGNhc2UgdGhleSBhcmUgbm90IHNldCBpbiBldmVudE9iai5cblx0XHRcdC8vIEFsc28gc2V0IHBvaW50ZXIgdG8gd2lkZ2V0LCBhbHRob3VnaCBzaW5jZSB3ZSBjYW4ndCBhZGQgYSBwb2ludGVyIHRvIHRoZSB3aWRnZXQgZm9yIG5hdGl2ZSBldmVudHNcblx0XHRcdC8vIChzZWUgIzE0NzI5KSwgbWF5YmUgd2Ugc2hvdWxkbid0IGRvIGl0IGhlcmU/XG5cdFx0XHRldmVudE9iaiA9IGV2ZW50T2JqIHx8IHt9O1xuXHRcdFx0aWYoZXZlbnRPYmouYnViYmxlcyA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0ZXZlbnRPYmouYnViYmxlcyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZihldmVudE9iai5jYW5jZWxhYmxlID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRldmVudE9iai5jYW5jZWxhYmxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKCFldmVudE9iai5kZXRhaWwpe1xuXHRcdFx0XHRldmVudE9iai5kZXRhaWwgPSB7fTtcblx0XHRcdH1cblx0XHRcdGV2ZW50T2JqLmRldGFpbC53aWRnZXQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmV0LCBjYWxsYmFjayA9IHRoaXNbXCJvblwiICsgdHlwZV07XG5cdFx0XHRpZihjYWxsYmFjayl7XG5cdFx0XHRcdHJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGNhbGxiYWNrQXJncyA/IGNhbGxiYWNrQXJncyA6IFtldmVudE9ial0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbWl0IGV2ZW50LCBidXQgYXZvaWQgc3B1cmlvdXMgZW1pdCgpJ3MgYXMgcGFyZW50IHNldHMgcHJvcGVydGllcyBvbiBjaGlsZCBkdXJpbmcgc3RhcnR1cC9kZXN0cm95XG5cdFx0XHRpZih0aGlzLl9zdGFydGVkICYmICF0aGlzLl9iZWluZ0Rlc3Ryb3llZCl7XG5cdFx0XHRcdG9uLmVtaXQodGhpcy5kb21Ob2RlLCB0eXBlLnRvTG93ZXJDYXNlKCksIGV2ZW50T2JqKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0b246IGZ1bmN0aW9uKC8qU3RyaW5nfEZ1bmN0aW9uKi8gdHlwZSwgLypGdW5jdGlvbiovIGZ1bmMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGwgc3BlY2lmaWVkIGZ1bmN0aW9uIHdoZW4gZXZlbnQgb2NjdXJzLCBleDogbXlXaWRnZXQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpeyAuLi4gfSkuXG5cdFx0XHQvLyB0eXBlOlxuXHRcdFx0Ly9cdFx0TmFtZSBvZiBldmVudCAoZXg6IFwiY2xpY2tcIikgb3IgZXh0ZW5zaW9uIGV2ZW50IGxpa2UgdG91Y2gucHJlc3MuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdENhbGwgc3BlY2lmaWVkIGZ1bmN0aW9uIHdoZW4gZXZlbnQgYHR5cGVgIG9jY3VycywgZXg6IGBteVdpZGdldC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7IC4uLiB9KWAuXG5cdFx0XHQvL1x0XHROb3RlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIG5vdCBydW4gaW4gYW55IHBhcnRpY3VsYXIgc2NvcGUsIHNvIGlmIChmb3IgZXhhbXBsZSkgeW91IHdhbnQgaXQgdG8gcnVuIGluIHRoZVxuXHRcdFx0Ly9cdFx0d2lkZ2V0J3Mgc2NvcGUgeW91IG11c3QgZG8gYG15V2lkZ2V0Lm9uKFwiY2xpY2tcIiwgbGFuZy5oaXRjaChteVdpZGdldCwgZnVuYykpYC5cblxuXHRcdFx0Ly8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBpZiB0aGVyZSdzIGFuIG9uVHlwZSgpIG1ldGhvZCBpbiB0aGUgd2lkZ2V0IHRoZW4gY29ubmVjdCB0byB0aGF0LlxuXHRcdFx0Ly8gUmVtb3ZlIGluIDIuMC5cblx0XHRcdHZhciB3aWRnZXRNZXRob2QgPSB0aGlzLl9vbk1hcCh0eXBlKTtcblx0XHRcdGlmKHdpZGdldE1ldGhvZCl7XG5cdFx0XHRcdHJldHVybiBhc3BlY3QuYWZ0ZXIodGhpcywgd2lkZ2V0TWV0aG9kLCBmdW5jLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBqdXN0IGxpc3RlbiBmb3IgdGhlIGV2ZW50IG9uIHRoaXMuZG9tTm9kZS5cblx0XHRcdHJldHVybiB0aGlzLm93bihvbih0aGlzLmRvbU5vZGUsIHR5cGUsIGZ1bmMpKVswXTtcblx0XHR9LFxuXG5cdFx0X29uTWFwOiBmdW5jdGlvbigvKlN0cmluZ3xGdW5jdGlvbiovIHR5cGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdE1hcHMgb24oKSB0eXBlIHBhcmFtZXRlciAoZXg6IFwibW91c2Vtb3ZlXCIpIHRvIG1ldGhvZCBuYW1lIChleDogXCJvbk1vdXNlTW92ZVwiKS5cblx0XHRcdC8vXHRcdElmIHR5cGUgaXMgYSBzeW50aGV0aWMgZXZlbnQgbGlrZSB0b3VjaC5wcmVzcyB0aGVuIHJldHVybnMgdW5kZWZpbmVkLlxuXHRcdFx0dmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yLCBtYXAgPSBjdG9yLl9vbk1hcDtcblx0XHRcdGlmKCFtYXApe1xuXHRcdFx0XHRtYXAgPSAoY3Rvci5fb25NYXAgPSB7fSk7XG5cdFx0XHRcdGZvcih2YXIgYXR0ciBpbiBjdG9yLnByb3RvdHlwZSl7XG5cdFx0XHRcdFx0aWYoL15vbi8udGVzdChhdHRyKSl7XG5cdFx0XHRcdFx0XHRtYXBbYXR0ci5yZXBsYWNlKC9eb24vLCBcIlwiKS50b0xvd2VyQ2FzZSgpXSA9IGF0dHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwW3R5cGVvZiB0eXBlID09IFwic3RyaW5nXCIgJiYgdHlwZS50b0xvd2VyQ2FzZSgpXTtcdC8vIFN0cmluZ1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgd2lkZ2V0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRXaGVuIGEgd2lkZ2V0IGlzIGNhc3QgdG8gYSBzdHJpbmcsIHRoaXMgbWV0aG9kIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGVcblx0XHRcdC8vXHRcdG91dHB1dC4gQ3VycmVudGx5LCBpdCBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IHNvcnQgb2YgcmV2ZXJzaWJsZVxuXHRcdFx0Ly9cdFx0c2VyaWFsaXphdGlvbi5cblx0XHRcdHJldHVybiAnW1dpZGdldCAnICsgdGhpcy5kZWNsYXJlZENsYXNzICsgJywgJyArICh0aGlzLmlkIHx8ICdOTyBJRCcpICsgJ10nOyAvLyBTdHJpbmdcblx0XHR9LFxuXG5cdFx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhbGwgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgd2lkZ2V0LCBpLmUuIGFsbCB3aWRnZXRzIHVuZGVybmVhdGggdGhpcy5jb250YWluZXJOb2RlIHdob3NlIHBhcmVudFxuXHRcdFx0Ly9cdFx0aXMgdGhpcyB3aWRnZXQuICAgTm90ZSB0aGF0IGl0IGRvZXMgbm90IHJldHVybiBhbGwgZGVzY2VuZGFudHMsIGJ1dCByYXRoZXIganVzdCBkaXJlY3QgY2hpbGRyZW4uXG5cdFx0XHQvL1x0XHRBbmFsb2dvdXMgdG8gW05vZGUuY2hpbGROb2Rlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vTm9kZS5jaGlsZE5vZGVzKSxcblx0XHRcdC8vXHRcdGV4Y2VwdCBjb250YWluaW5nIHdpZGdldHMgcmF0aGVyIHRoYW4gRE9NTm9kZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VGhlIHJlc3VsdCBpbnRlbnRpb25hbGx5IGV4Y2x1ZGVzIGludGVybmFsbHkgY3JlYXRlZCB3aWRnZXRzIChhLmsuYS4gc3VwcG9ydGluZyB3aWRnZXRzKVxuXHRcdFx0Ly9cdFx0b3V0c2lkZSBvZiB0aGlzLmNvbnRhaW5lck5vZGUuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoZSBhcnJheSByZXR1cm5lZCBpcyBhIHNpbXBsZSBhcnJheS4gIEFwcGxpY2F0aW9uIGNvZGUgc2hvdWxkIG5vdCBhc3N1bWVcblx0XHRcdC8vXHRcdGV4aXN0ZW5jZSBvZiBtZXRob2RzIGxpa2UgZm9yRWFjaCgpLlxuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJOb2RlID8gcmVnaXN0cnkuZmluZFdpZGdldHModGhpcy5jb250YWluZXJOb2RlKSA6IFtdOyAvLyBkaWppdC9fV2lkZ2V0QmFzZVtdXG5cdFx0fSxcblxuXHRcdGdldFBhcmVudDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBwYXJlbnQgd2lkZ2V0IG9mIHRoaXMgd2lkZ2V0LlxuXG5cdFx0XHRyZXR1cm4gcmVnaXN0cnkuZ2V0RW5jbG9zaW5nV2lkZ2V0KHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlKTtcblx0XHR9LFxuXG5cdFx0Y29ubmVjdDogZnVuY3Rpb24oLypPYmplY3R8bnVsbCovIG9iaiwgLypTdHJpbmd8RnVuY3Rpb24qLyBldmVudCwgLypTdHJpbmd8RnVuY3Rpb24qLyBtZXRob2Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdERlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiAyLjAsIHVzZSB0aGlzLm93bihvbiguLi4pKSBvciB0aGlzLm93bihhc3BlY3QuYWZ0ZXIoLi4uKSkgaW5zdGVhZC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRDb25uZWN0cyBzcGVjaWZpZWQgb2JqL2V2ZW50IHRvIHNwZWNpZmllZCBtZXRob2Qgb2YgdGhpcyBvYmplY3Rcblx0XHRcdC8vXHRcdGFuZCByZWdpc3RlcnMgZm9yIGRpc2Nvbm5lY3QoKSBvbiB3aWRnZXQgZGVzdHJveS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRQcm92aWRlIHdpZGdldC1zcGVjaWZpYyBhbmFsb2cgdG8gZG9qby5jb25uZWN0LCBleGNlcHQgd2l0aCB0aGVcblx0XHRcdC8vXHRcdGltcGxpY2l0IHVzZSBvZiB0aGlzIHdpZGdldCBhcyB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdC8vXHRcdEV2ZW50cyBjb25uZWN0ZWQgd2l0aCBgdGhpcy5jb25uZWN0YCBhcmUgZGlzY29ubmVjdGVkIHVwb25cblx0XHRcdC8vXHRcdGRlc3RydWN0aW9uLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBgZGlzY29ubmVjdGAgaW4gb3JkZXIgdG8gZGlzY29ubmVjdCBiZWZvcmVcblx0XHRcdC8vXHRcdHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgYnRuID0gbmV3IEJ1dHRvbigpO1xuXHRcdFx0Ly9cdHxcdC8vIHdoZW4gZm9vLmJhcigpIGlzIGNhbGxlZCwgY2FsbCB0aGUgbGlzdGVuZXIgd2UncmUgZ29pbmcgdG9cblx0XHRcdC8vXHR8XHQvLyBwcm92aWRlIGluIHRoZSBzY29wZSBvZiBidG5cblx0XHRcdC8vXHR8XHRidG4uY29ubmVjdChmb28sIFwiYmFyXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHQvL1x0fFx0XHRjb25zb2xlLmRlYnVnKHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdHJldHVybiB0aGlzLm93bihjb25uZWN0LmNvbm5lY3Qob2JqLCBldmVudCwgdGhpcywgbWV0aG9kKSlbMF07XHQvLyBoYW5kbGVcblx0XHR9LFxuXG5cdFx0ZGlzY29ubmVjdDogZnVuY3Rpb24oaGFuZGxlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgaGFuZGxlLnJlbW92ZSgpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0RGlzY29ubmVjdHMgaGFuZGxlIGNyZWF0ZWQgYnkgYGNvbm5lY3RgLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXG5cdFx0XHRoYW5kbGUucmVtb3ZlKCk7XG5cdFx0fSxcblxuXHRcdHN1YnNjcmliZTogZnVuY3Rpb24odCwgbWV0aG9kKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgdGhpcy5vd24odG9waWMuc3Vic2NyaWJlKCkpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0U3Vic2NyaWJlcyB0byB0aGUgc3BlY2lmaWVkIHRvcGljIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIG1ldGhvZFxuXHRcdFx0Ly9cdFx0b2YgdGhpcyBvYmplY3QgYW5kIHJlZ2lzdGVycyBmb3IgdW5zdWJzY3JpYmUoKSBvbiB3aWRnZXQgZGVzdHJveS5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRQcm92aWRlIHdpZGdldC1zcGVjaWZpYyBhbmFsb2cgdG8gZG9qby5zdWJzY3JpYmUsIGV4Y2VwdCB3aXRoIHRoZVxuXHRcdFx0Ly9cdFx0aW1wbGljaXQgdXNlIG9mIHRoaXMgd2lkZ2V0IGFzIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHRcdFx0Ly8gdDogU3RyaW5nXG5cdFx0XHQvL1x0XHRUaGUgdG9waWNcblx0XHRcdC8vIG1ldGhvZDogRnVuY3Rpb25cblx0XHRcdC8vXHRcdFRoZSBjYWxsYmFja1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgYnRuID0gbmV3IEJ1dHRvbigpO1xuXHRcdFx0Ly9cdHxcdC8vIHdoZW4gL215L3RvcGljIGlzIHB1Ymxpc2hlZCwgdGhpcyBidXR0b24gY2hhbmdlcyBpdHMgbGFiZWwgdG9cblx0XHRcdC8vXHR8XHQvLyBiZSB0aGUgcGFyYW1ldGVyIG9mIHRoZSB0b3BpYy5cblx0XHRcdC8vXHR8XHRidG4uc3Vic2NyaWJlKFwiL215L3RvcGljXCIsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0Ly9cdHxcdFx0dGhpcy5zZXQoXCJsYWJlbFwiLCB2KTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcm90ZWN0ZWRcblx0XHRcdHJldHVybiB0aGlzLm93bih0b3BpYy5zdWJzY3JpYmUodCwgbGFuZy5oaXRjaCh0aGlzLCBtZXRob2QpKSlbMF07XHQvLyBoYW5kbGVcblx0XHR9LFxuXG5cdFx0dW5zdWJzY3JpYmU6IGZ1bmN0aW9uKC8qT2JqZWN0Ki8gaGFuZGxlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLCB1c2UgaGFuZGxlLnJlbW92ZSgpIGluc3RlYWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VW5zdWJzY3JpYmVzIGhhbmRsZSBjcmVhdGVkIGJ5IHRoaXMuc3Vic2NyaWJlLlxuXHRcdFx0Ly9cdFx0QWxzbyByZW1vdmVzIGhhbmRsZSBmcm9tIHRoaXMgd2lkZ2V0J3MgbGlzdCBvZiBzdWJzY3JpcHRpb25zXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdGhhbmRsZS5yZW1vdmUoKTtcblx0XHR9LFxuXG5cdFx0aXNMZWZ0VG9SaWdodDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdGhpcyB3aWRnZXQncyBleHBsaWNpdCBvciBpbXBsaWNpdCBvcmllbnRhdGlvbiAodHJ1ZSBmb3IgTFRSLCBmYWxzZSBmb3IgUlRMKVxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0cmV0dXJuIHRoaXMuZGlyID8gKHRoaXMuZGlyLnRvTG93ZXJDYXNlKCkgPT0gXCJsdHJcIikgOiBkb21HZW9tZXRyeS5pc0JvZHlMdHIodGhpcy5vd25lckRvY3VtZW50KTsgLy9Cb29sZWFuXG5cdFx0fSxcblxuXHRcdGlzRm9jdXNhYmxlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0cnVlIGlmIHRoaXMgd2lkZ2V0IGNhbiBjdXJyZW50bHkgYmUgZm9jdXNlZFxuXHRcdFx0Ly9cdFx0YW5kIGZhbHNlIGlmIG5vdFxuXHRcdFx0cmV0dXJuIHRoaXMuZm9jdXMgJiYgKGRvbVN0eWxlLmdldCh0aGlzLmRvbU5vZGUsIFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIik7XG5cdFx0fSxcblxuXHRcdHBsYWNlQXQ6IGZ1bmN0aW9uKC8qU3RyaW5nfERvbU5vZGV8RG9jdW1lbnRGcmFnbWVudHxkaWppdC9fV2lkZ2V0QmFzZSovIHJlZmVyZW5jZSwgLypTdHJpbmd8SW50PyovIHBvc2l0aW9uKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRQbGFjZSB0aGlzIHdpZGdldCBzb21ld2hlcmUgaW4gdGhlIERPTSBiYXNlZFxuXHRcdFx0Ly9cdFx0b24gc3RhbmRhcmQgZG9tQ29uc3RydWN0LnBsYWNlKCkgY29udmVudGlvbnMuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEEgY29udmVuaWVuY2UgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYWxsIF9XaWRnZXRzLCBwcm92aWRpbmcgYSBzaW1wbGVcblx0XHRcdC8vXHRcdHNob3J0aGFuZCBtZWNoYW5pc20gdG8gcHV0IGFuIGV4aXN0aW5nIChvciBuZXdseSBjcmVhdGVkKSBXaWRnZXRcblx0XHRcdC8vXHRcdHNvbWV3aGVyZSBpbiB0aGUgZG9tLCBhbmQgYWxsb3cgY2hhaW5pbmcuXG5cdFx0XHQvLyByZWZlcmVuY2U6XG5cdFx0XHQvL1x0XHRXaWRnZXQsIERPTU5vZGUsIERvY3VtZW50RnJhZ21lbnQsIG9yIGlkIG9mIHdpZGdldCBvciBET01Ob2RlXG5cdFx0XHQvLyBwb3NpdGlvbjpcblx0XHRcdC8vXHRcdElmIHJlZmVyZW5jZSBpcyBhIHdpZGdldCAob3IgaWQgb2Ygd2lkZ2V0KSwgYW5kIHRoYXQgd2lkZ2V0IGhhcyBhbiBcIi5hZGRDaGlsZFwiIG1ldGhvZCxcblx0XHRcdC8vXHRcdGl0IHdpbGwgYmUgY2FsbGVkIHBhc3NpbmcgdGhpcyB3aWRnZXQgaW5zdGFuY2UgaW50byB0aGF0IG1ldGhvZCwgc3VwcGx5aW5nIHRoZSBvcHRpb25hbFxuXHRcdFx0Ly9cdFx0cG9zaXRpb24gaW5kZXggcGFzc2VkLiAgSW4gdGhpcyBjYXNlIHBvc2l0aW9uIChpZiBzcGVjaWZpZWQpIHNob3VsZCBiZSBhbiBpbnRlZ2VyLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdElmIHJlZmVyZW5jZSBpcyBhIERPTU5vZGUgKG9yIGlkIG1hdGNoaW5nIGEgRE9NTm9kZSBidXQgbm90IGEgd2lkZ2V0KSxcblx0XHRcdC8vXHRcdHRoZSBwb3NpdGlvbiBhcmd1bWVudCBjYW4gYmUgYSBudW1lcmljIGluZGV4IG9yIGEgc3RyaW5nXG5cdFx0XHQvL1x0XHRcImZpcnN0XCIsIFwibGFzdFwiLCBcImJlZm9yZVwiLCBvciBcImFmdGVyXCIsIHNhbWUgYXMgZG9qby9kb20tY29uc3RydWN0OjpwbGFjZSgpLlxuXHRcdFx0Ly8gcmV0dXJuczogZGlqaXQvX1dpZGdldEJhc2Vcblx0XHRcdC8vXHRcdFByb3ZpZGVzIGEgdXNlZnVsIHJldHVybiBvZiB0aGUgbmV3bHkgY3JlYXRlZCBkaWppdC5fV2lkZ2V0IGluc3RhbmNlIHNvIHlvdVxuXHRcdFx0Ly9cdFx0Y2FuIFwiY2hhaW5cIiB0aGlzIGZ1bmN0aW9uIGJ5IGluc3RhbnRpYXRpbmcsIHBsYWNpbmcsIHRoZW4gc2F2aW5nIHRoZSByZXR1cm4gdmFsdWVcblx0XHRcdC8vXHRcdHRvIGEgdmFyaWFibGUuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIEJ1dHRvbiB3aXRoIG5vIHNyY05vZGVSZWYsIGFuZCBwbGFjZSBpdCBpbiB0aGUgYm9keTpcblx0XHRcdC8vXHR8XHR2YXIgYnV0dG9uID0gbmV3IEJ1dHRvbih7IGxhYmVsOlwiY2xpY2tcIiB9KS5wbGFjZUF0KHdpbi5ib2R5KCkpO1xuXHRcdFx0Ly9cdHxcdC8vIG5vdywgJ2J1dHRvbicgaXMgc3RpbGwgdGhlIHdpZGdldCByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgYnV0dG9uXG5cdFx0XHQvL1x0fFx0YnV0dG9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSl7IGNvbnNvbGUubG9nKCdjbGljaycpOyB9KSk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIGJ1dHRvbiBvdXQgb2YgYSBub2RlIHdpdGggaWQ9XCJzcmNcIiBhbmQgYXBwZW5kIGl0IHRvIGlkPVwid3JhcHBlclwiOlxuXHRcdFx0Ly9cdHxcdHZhciBidXR0b24gPSBuZXcgQnV0dG9uKHt9LFwic3JjXCIpLnBsYWNlQXQoXCJ3cmFwcGVyXCIpO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyBwbGFjZSBhIG5ldyBidXR0b24gYXMgdGhlIGZpcnN0IGVsZW1lbnQgb2Ygc29tZSBkaXZcblx0XHRcdC8vXHR8XHR2YXIgYnV0dG9uID0gbmV3IEJ1dHRvbih7IGxhYmVsOlwiY2xpY2tcIiB9KS5wbGFjZUF0KFwid3JhcHBlclwiLFwiZmlyc3RcIik7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhIGNvbnRlbnRwYW5lIGFuZCBhZGQgaXQgdG8gYSBUYWJDb250YWluZXJcblx0XHRcdC8vXHR8XHR2YXIgdGMgPSBkaWppdC5ieUlkKFwibXlUYWJzXCIpO1xuXHRcdFx0Ly9cdHxcdG5ldyBDb250ZW50UGFuZSh7IGhyZWY6XCJmb28uaHRtbFwiLCB0aXRsZTpcIldvdyFcIiB9KS5wbGFjZUF0KHRjKVxuXG5cdFx0XHR2YXIgcmVmV2lkZ2V0ID0gIXJlZmVyZW5jZS50YWdOYW1lICYmIHJlZ2lzdHJ5LmJ5SWQocmVmZXJlbmNlKTtcblx0XHRcdGlmKHJlZldpZGdldCAmJiByZWZXaWRnZXQuYWRkQ2hpbGQgJiYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIpKXtcblx0XHRcdFx0Ly8gQWRkaW5nIHRoaXMgdG8gcmVmV2lkZ2V0IGFuZCBjYW4gdXNlIHJlZldpZGdldC5hZGRDaGlsZCgpIHRvIGhhbmRsZSBldmVyeXRoaW5nLlxuXHRcdFx0XHRyZWZXaWRnZXQuYWRkQ2hpbGQodGhpcywgcG9zaXRpb24pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIFwicmVmZXJlbmNlXCIgaXMgYSBwbGFpbiBET01Ob2RlLCBvciB3ZSBjYW4ndCB1c2UgcmVmV2lkZ2V0LmFkZENoaWxkKCkuICAgVXNlIGRvbUNvbnN0cnVjdC5wbGFjZSgpIGFuZFxuXHRcdFx0XHQvLyB0YXJnZXQgcmVmV2lkZ2V0LmNvbnRhaW5lck5vZGUgZm9yIG5lc3RlZCBwbGFjZW1lbnQgKHBvc2l0aW9uPT1udW1iZXIsIFwiZmlyc3RcIiwgXCJsYXN0XCIsIFwib25seVwiKSwgYW5kXG5cdFx0XHRcdC8vIHJlZldpZGdldC5kb21Ob2RlIG90aGVyd2lzZSAoXCJhZnRlclwiL1wiYmVmb3JlXCIvXCJyZXBsYWNlXCIpLiAgKEJ1dCBub3Qgc3VwcG9ydGVkIG9mZmljaWFsbHksIHNlZSAjMTQ5NDYuKVxuXHRcdFx0XHR2YXIgcmVmID0gcmVmV2lkZ2V0ICYmIChcImRvbU5vZGVcIiBpbiByZWZXaWRnZXQpID9cblx0XHRcdFx0XHQocmVmV2lkZ2V0LmNvbnRhaW5lck5vZGUgJiYgIS9hZnRlcnxiZWZvcmV8cmVwbGFjZS8udGVzdChwb3NpdGlvbiB8fCBcIlwiKSA/XG5cdFx0XHRcdFx0XHRyZWZXaWRnZXQuY29udGFpbmVyTm9kZSA6IHJlZldpZGdldC5kb21Ob2RlKSA6IGRvbS5ieUlkKHJlZmVyZW5jZSwgdGhpcy5vd25lckRvY3VtZW50KTtcblx0XHRcdFx0ZG9tQ29uc3RydWN0LnBsYWNlKHRoaXMuZG9tTm9kZSwgcmVmLCBwb3NpdGlvbik7XG5cblx0XHRcdFx0Ly8gU3RhcnQgdGhpcyBpZmYgaXQgaGFzIGEgcGFyZW50IHdpZGdldCB0aGF0J3MgYWxyZWFkeSBzdGFydGVkLlxuXHRcdFx0XHQvLyBUT0RPOiBmb3IgMi4wIG1heWJlIGl0IHNob3VsZCBhbHNvIHN0YXJ0IHRoZSB3aWRnZXQgd2hlbiB0aGlzLmdldFBhcmVudCgpIHJldHVybnMgbnVsbD8/XG5cdFx0XHRcdGlmKCF0aGlzLl9zdGFydGVkICYmICh0aGlzLmdldFBhcmVudCgpIHx8IHt9KS5fc3RhcnRlZCl7XG5cdFx0XHRcdFx0dGhpcy5zdGFydHVwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRkZWZlcjogZnVuY3Rpb24oZmNuLCBkZWxheSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0V3JhcHBlciB0byBzZXRUaW1lb3V0IHRvIGF2b2lkIGRlZmVycmVkIGZ1bmN0aW9ucyBleGVjdXRpbmdcblx0XHRcdC8vXHRcdGFmdGVyIHRoZSBvcmlnaW5hdGluZyB3aWRnZXQgaGFzIGJlZW4gZGVzdHJveWVkLlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhbiBvYmplY3QgaGFuZGxlIHdpdGggYSByZW1vdmUgbWV0aG9kICh0aGF0IHJldHVybnMgbnVsbCkgKHJlcGxhY2VzIGNsZWFyVGltZW91dCkuXG5cdFx0XHQvLyBmY246IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRGdW5jdGlvbiByZWZlcmVuY2UuXG5cdFx0XHQvLyBkZWxheTogTnVtYmVyP1xuXHRcdFx0Ly9cdFx0RGVsYXksIGRlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cblx0XHRcdHZhciB0aW1lciA9IHNldFRpbWVvdXQobGFuZy5oaXRjaCh0aGlzLFxuXHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKCF0aW1lcil7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0XHRpZighdGhpcy5fZGVzdHJveWVkKXtcblx0XHRcdFx0XHRcdGxhbmcuaGl0Y2godGhpcywgZmNuKSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSksXG5cdFx0XHRcdGRlbGF5IHx8IDBcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYodGltZXIpe1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIHNvIHRoaXMgd29ya3Mgd2VsbDogaGFuZGxlID0gaGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSk7XG5cblx0aWYoaGFzKFwiZG9qby1iaWRpXCIpKXtcblx0XHRfV2lkZ2V0QmFzZS5leHRlbmQoX0JpZGlNaXhpbik7XG5cdH1cblxuXHRyZXR1cm4gX1dpZGdldEJhc2U7XG59KTtcbiIsImRlZmluZShbXG5cdFwiZG9qby9fYmFzZS9hcnJheVwiLCAvLyBhcnJheS5mb3JFYWNoIGFycmF5Lm1hcFxuXHRcImRvam8vZG9tXCIsXHRcdFx0Ly8gZG9tLmJ5SWRcblx0XCJkb2pvL2RvbS1hdHRyXCIsIC8vIGRvbUF0dHIuYXR0ciBkb21BdHRyLmhhc1xuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLnN0eWxlXG5cdFwiZG9qby9fYmFzZS9sYW5nXCIsIC8vIGxhbmcubWl4aW4oKVxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwiaWVcIikgaGFzKFwiZXh0ZW5kLWRvam9cIilcblx0XCIuL21haW5cIlx0Ly8gZm9yIGV4cG9ydGluZyBtZXRob2RzIHRvIGRpaml0IG5hbWVzcGFjZVxuXSwgZnVuY3Rpb24oYXJyYXksIGRvbSwgZG9tQXR0ciwgZG9tU3R5bGUsIGxhbmcsIGhhcywgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvYTExeVxuXG5cdHZhciB1bmRlZmluZWQ7XG5cblx0dmFyIGExMXkgPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBY2Nlc3NpYmlsaXR5IHV0aWxpdHkgZnVuY3Rpb25zIChrZXlib2FyZCwgdGFiIHN0b3BzLCBldGMuKVxuXG5cdFx0X2lzRWxlbWVudFNob3duOiBmdW5jdGlvbigvKkVsZW1lbnQqLyBlbGVtKXtcblx0XHRcdHZhciBzID0gZG9tU3R5bGUuZ2V0KGVsZW0pO1xuXHRcdFx0cmV0dXJuIChzLnZpc2liaWxpdHkgIT0gXCJoaWRkZW5cIilcblx0XHRcdFx0JiYgKHMudmlzaWJpbGl0eSAhPSBcImNvbGxhcHNlZFwiKVxuXHRcdFx0XHQmJiAocy5kaXNwbGF5ICE9IFwibm9uZVwiKVxuXHRcdFx0XHQmJiAoZG9tQXR0ci5nZXQoZWxlbSwgXCJ0eXBlXCIpICE9IFwiaGlkZGVuXCIpO1xuXHRcdH0sXG5cblx0XHRoYXNEZWZhdWx0VGFiU3RvcDogZnVuY3Rpb24oLypFbGVtZW50Ki8gZWxlbSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGVzdHMgaWYgZWxlbWVudCBpcyB0YWItbmF2aWdhYmxlIGV2ZW4gd2l0aG91dCBhbiBleHBsaWNpdCB0YWJJbmRleCBzZXR0aW5nXG5cblx0XHRcdC8vIE5vIGV4cGxpY2l0IHRhYkluZGV4IHNldHRpbmcsIG5lZWQgdG8gaW52ZXN0aWdhdGUgbm9kZSB0eXBlXG5cdFx0XHRzd2l0Y2goZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXtcblx0XHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0XHQvLyBBbiA8YT4gdy9vdXQgYSB0YWJpbmRleCBpcyBvbmx5IG5hdmlnYWJsZSBpZiBpdCBoYXMgYW4gaHJlZlxuXHRcdFx0XHRcdHJldHVybiBkb21BdHRyLmhhcyhlbGVtLCBcImhyZWZcIik7XG5cdFx0XHRcdGNhc2UgXCJhcmVhXCI6XG5cdFx0XHRcdGNhc2UgXCJidXR0b25cIjpcblx0XHRcdFx0Y2FzZSBcImlucHV0XCI6XG5cdFx0XHRcdGNhc2UgXCJvYmplY3RcIjpcblx0XHRcdFx0Y2FzZSBcInNlbGVjdFwiOlxuXHRcdFx0XHRjYXNlIFwidGV4dGFyZWFcIjpcblx0XHRcdFx0XHQvLyBUaGVzZSBhcmUgbmF2aWdhYmxlIGJ5IGRlZmF1bHRcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0Y2FzZSBcImlmcmFtZVwiOlxuXHRcdFx0XHRcdC8vIElmIGl0J3MgYW4gZWRpdG9yIDxpZnJhbWU+IHRoZW4gaXQncyB0YWIgbmF2aWdhYmxlLlxuXHRcdFx0XHRcdHZhciBib2R5O1xuXHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdC8vIG5vbi1JRVxuXHRcdFx0XHRcdFx0dmFyIGNvbnRlbnREb2N1bWVudCA9IGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdFx0XHRcdFx0aWYoXCJkZXNpZ25Nb2RlXCIgaW4gY29udGVudERvY3VtZW50ICYmIGNvbnRlbnREb2N1bWVudC5kZXNpZ25Nb2RlID09IFwib25cIil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ym9keSA9IGNvbnRlbnREb2N1bWVudC5ib2R5O1xuXHRcdFx0XHRcdH1jYXRjaChlMSl7XG5cdFx0XHRcdFx0XHQvLyBjb250ZW50V2luZG93LmRvY3VtZW50IGlzbid0IGFjY2Vzc2libGUgd2l0aGluIElFNy84XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgaWZyYW1lLnNyYyBwb2ludHMgdG8gYSBmb3JlaWduIHVybCBhbmQgdGhpc1xuXHRcdFx0XHRcdFx0Ly8gcGFnZSBjb250YWlucyBhbiBlbGVtZW50LCB0aGF0IGNvdWxkIGdldCBmb2N1c1xuXHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRib2R5ID0gZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHk7XG5cdFx0XHRcdFx0XHR9Y2F0Y2goZTIpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBib2R5ICYmIChib2R5LmNvbnRlbnRFZGl0YWJsZSA9PSAndHJ1ZScgfHxcblx0XHRcdFx0XHRcdChib2R5LmZpcnN0Q2hpbGQgJiYgYm9keS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSAndHJ1ZScpKTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RWRpdGFibGUgPT0gJ3RydWUnO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRlZmZlY3RpdmVUYWJJbmRleDogZnVuY3Rpb24oLypFbGVtZW50Ki8gZWxlbSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBlZmZlY3RpdmUgdGFiSW5kZXggb2YgYW4gZWxlbWVudCwgZWl0aGVyIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgZWxlbWVudCBpc24ndCBmb2N1c2FibGUuXG5cblx0XHRcdGlmKGRvbUF0dHIuZ2V0KGVsZW0sIFwiZGlzYWJsZWRcIikpe1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fWVsc2UgaWYoZG9tQXR0ci5oYXMoZWxlbSwgXCJ0YWJJbmRleFwiKSl7XG5cdFx0XHRcdC8vIEV4cGxpY2l0IHRhYiBpbmRleCBzZXR0aW5nXG5cdFx0XHRcdHJldHVybiArZG9tQXR0ci5nZXQoZWxlbSwgXCJ0YWJJbmRleFwiKTsvLyArIHRvIGNvbnZlcnQgc3RyaW5nIC0tPiBudW1iZXJcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBObyBleHBsaWNpdCB0YWJJbmRleCBzZXR0aW5nLCBzbyBkZXBlbmRzIG9uIG5vZGUgdHlwZVxuXHRcdFx0XHRyZXR1cm4gYTExeS5oYXNEZWZhdWx0VGFiU3RvcChlbGVtKSA/IDAgOiB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGlzVGFiTmF2aWdhYmxlOiBmdW5jdGlvbigvKkVsZW1lbnQqLyBlbGVtKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRUZXN0cyBpZiBhbiBlbGVtZW50IGlzIHRhYi1uYXZpZ2FibGVcblxuXHRcdFx0cmV0dXJuIGExMXkuZWZmZWN0aXZlVGFiSW5kZXgoZWxlbSkgPj0gMDtcblx0XHR9LFxuXG5cdFx0aXNGb2N1c2FibGU6IGZ1bmN0aW9uKC8qRWxlbWVudCovIGVsZW0pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3RzIGlmIGFuIGVsZW1lbnQgaXMgZm9jdXNhYmxlIGJ5IHRhYmJpbmcgdG8gaXQsIG9yIGNsaWNraW5nIGl0IHdpdGggdGhlIG1vdXNlLlxuXG5cdFx0XHRyZXR1cm4gYTExeS5lZmZlY3RpdmVUYWJJbmRleChlbGVtKSA+PSAtMTtcblx0XHR9LFxuXG5cdFx0X2dldFRhYk5hdmlnYWJsZTogZnVuY3Rpb24oLypET01Ob2RlKi8gcm9vdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZHMgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCByb290IG5vZGUuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEZpbmRzIHRoZSBmb2xsb3dpbmcgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCByb290IG5vZGU6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0LSB0aGUgZmlyc3QgdGFiLW5hdmlnYWJsZSBlbGVtZW50IGluIGRvY3VtZW50IG9yZGVyXG5cdFx0XHQvL1x0XHQgIHdpdGhvdXQgYSB0YWJJbmRleCBvciB3aXRoIHRhYkluZGV4PVwiMFwiXG5cdFx0XHQvL1x0XHQtIHRoZSBsYXN0IHRhYi1uYXZpZ2FibGUgZWxlbWVudCBpbiBkb2N1bWVudCBvcmRlclxuXHRcdFx0Ly9cdFx0ICB3aXRob3V0IGEgdGFiSW5kZXggb3Igd2l0aCB0YWJJbmRleD1cIjBcIlxuXHRcdFx0Ly9cdFx0LSB0aGUgZmlyc3QgZWxlbWVudCBpbiBkb2N1bWVudCBvcmRlciB3aXRoIHRoZSBsb3dlc3Rcblx0XHRcdC8vXHRcdCAgcG9zaXRpdmUgdGFiSW5kZXggdmFsdWVcblx0XHRcdC8vXHRcdC0gdGhlIGxhc3QgZWxlbWVudCBpbiBkb2N1bWVudCBvcmRlciB3aXRoIHRoZSBoaWdoZXN0XG5cdFx0XHQvL1x0XHQgIHBvc2l0aXZlIHRhYkluZGV4IHZhbHVlXG5cdFx0XHR2YXIgZmlyc3QsIGxhc3QsIGxvd2VzdCwgbG93ZXN0VGFiaW5kZXgsIGhpZ2hlc3QsIGhpZ2hlc3RUYWJpbmRleCwgcmFkaW9TZWxlY3RlZCA9IHt9O1xuXG5cdFx0XHRmdW5jdGlvbiByYWRpb05hbWUobm9kZSl7XG5cdFx0XHRcdC8vIElmIHRoaXMgZWxlbWVudCBpcyBwYXJ0IG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwLCByZXR1cm4gdGhlIG5hbWUgZm9yIHRoYXQgZ3JvdXAuXG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRcdG5vZGUudHlwZSAmJiBub2RlLnR5cGUudG9Mb3dlckNhc2UoKSA9PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlLm5hbWUgJiYgbm9kZS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaG93biA9IGExMXkuX2lzRWxlbWVudFNob3duLCBlZmZlY3RpdmVUYWJJbmRleCA9IGExMXkuZWZmZWN0aXZlVGFiSW5kZXg7XG5cdFx0XHR2YXIgd2Fsa1RyZWUgPSBmdW5jdGlvbigvKkRPTU5vZGUqLyBwYXJlbnQpe1xuXHRcdFx0XHRmb3IodmFyIGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0XHQvLyBTa2lwIHRleHQgZWxlbWVudHMsIGhpZGRlbiBlbGVtZW50cywgYW5kIGFsc28gbm9uLUhUTUwgZWxlbWVudHMgKHRob3NlIGluIGN1c3RvbSBuYW1lc3BhY2VzKSBpbiBJRSxcblx0XHRcdFx0XHQvLyBzaW5jZSBzaG93KCkgaW52b2tlcyBnZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLCB3aGljaCBjcmFzaCBvbiBWTUwgbm9kZXMgaW4gSUUuXG5cdFx0XHRcdFx0aWYoY2hpbGQubm9kZVR5cGUgIT0gMSB8fCAoaGFzKFwiaWVcIikgPD0gOSAmJiBjaGlsZC5zY29wZU5hbWUgIT09IFwiSFRNTFwiKSB8fCAhc2hvd24oY2hpbGQpKXtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciB0YWJpbmRleCA9IGVmZmVjdGl2ZVRhYkluZGV4KGNoaWxkKTtcblx0XHRcdFx0XHRpZih0YWJpbmRleCA+PSAwKXtcblx0XHRcdFx0XHRcdGlmKHRhYmluZGV4ID09IDApe1xuXHRcdFx0XHRcdFx0XHRpZighZmlyc3Qpe1xuXHRcdFx0XHRcdFx0XHRcdGZpcnN0ID0gY2hpbGQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bGFzdCA9IGNoaWxkO1xuXHRcdFx0XHRcdFx0fWVsc2UgaWYodGFiaW5kZXggPiAwKXtcblx0XHRcdFx0XHRcdFx0aWYoIWxvd2VzdCB8fCB0YWJpbmRleCA8IGxvd2VzdFRhYmluZGV4KXtcblx0XHRcdFx0XHRcdFx0XHRsb3dlc3RUYWJpbmRleCA9IHRhYmluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdGxvd2VzdCA9IGNoaWxkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKCFoaWdoZXN0IHx8IHRhYmluZGV4ID49IGhpZ2hlc3RUYWJpbmRleCl7XG5cdFx0XHRcdFx0XHRcdFx0aGlnaGVzdFRhYmluZGV4ID0gdGFiaW5kZXg7XG5cdFx0XHRcdFx0XHRcdFx0aGlnaGVzdCA9IGNoaWxkO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcm4gPSByYWRpb05hbWUoY2hpbGQpO1xuXHRcdFx0XHRcdFx0aWYoZG9tQXR0ci5nZXQoY2hpbGQsIFwiY2hlY2tlZFwiKSAmJiBybil7XG5cdFx0XHRcdFx0XHRcdHJhZGlvU2VsZWN0ZWRbcm5dID0gY2hpbGQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT0gJ1NFTEVDVCcpe1xuXHRcdFx0XHRcdFx0d2Fsa1RyZWUoY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGlmKHNob3duKHJvb3QpKXtcblx0XHRcdFx0d2Fsa1RyZWUocm9vdCk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBycyhub2RlKXtcblx0XHRcdFx0Ly8gc3Vic3RpdHV0ZSBjaGVja2VkIHJhZGlvIGJ1dHRvbiBmb3IgdW5jaGVja2VkIG9uZSwgaWYgdGhlcmUgaXMgYSBjaGVja2VkIG9uZSB3aXRoIHRoZSBzYW1lIG5hbWUuXG5cdFx0XHRcdHJldHVybiByYWRpb1NlbGVjdGVkW3JhZGlvTmFtZShub2RlKV0gfHwgbm9kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgZmlyc3Q6IHJzKGZpcnN0KSwgbGFzdDogcnMobGFzdCksIGxvd2VzdDogcnMobG93ZXN0KSwgaGlnaGVzdDogcnMoaGlnaGVzdCkgfTtcblx0XHR9LFxuXG5cdFx0Z2V0Rmlyc3RJblRhYmJpbmdPcmRlcjogZnVuY3Rpb24oLypTdHJpbmd8RE9NTm9kZSovIHJvb3QsIC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRGaW5kcyB0aGUgZGVzY2VuZGFudCBvZiB0aGUgc3BlY2lmaWVkIHJvb3Qgbm9kZVxuXHRcdFx0Ly9cdFx0dGhhdCBpcyBmaXJzdCBpbiB0aGUgdGFiYmluZyBvcmRlclxuXHRcdFx0dmFyIGVsZW1zID0gYTExeS5fZ2V0VGFiTmF2aWdhYmxlKGRvbS5ieUlkKHJvb3QsIGRvYykpO1xuXHRcdFx0cmV0dXJuIGVsZW1zLmxvd2VzdCA/IGVsZW1zLmxvd2VzdCA6IGVsZW1zLmZpcnN0OyAvLyBEb21Ob2RlXG5cdFx0fSxcblxuXHRcdGdldExhc3RJblRhYmJpbmdPcmRlcjogZnVuY3Rpb24oLypTdHJpbmd8RE9NTm9kZSovIHJvb3QsIC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRGaW5kcyB0aGUgZGVzY2VuZGFudCBvZiB0aGUgc3BlY2lmaWVkIHJvb3Qgbm9kZVxuXHRcdFx0Ly9cdFx0dGhhdCBpcyBsYXN0IGluIHRoZSB0YWJiaW5nIG9yZGVyXG5cdFx0XHR2YXIgZWxlbXMgPSBhMTF5Ll9nZXRUYWJOYXZpZ2FibGUoZG9tLmJ5SWQocm9vdCwgZG9jKSk7XG5cdFx0XHRyZXR1cm4gZWxlbXMubGFzdCA/IGVsZW1zLmxhc3QgOiBlbGVtcy5oaWdoZXN0OyAvLyBEb21Ob2RlXG5cdFx0fVxuXHR9O1xuXG5cdGhhcyhcImV4dGVuZC1kb2pvXCIpICYmIGxhbmcubWl4aW4oZGlqaXQsIGExMXkpO1xuXG5cdHJldHVybiBhMTF5O1xufSk7XG4iLCJkZWZpbmUoW1xuXHRcImRvam8vX2Jhc2UvYXJyYXlcIiwgLy8gYXJyYXkuZm9yRWFjaFxuXHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiLCAvLyBkZWNsYXJlXG5cdFwiZG9qby9kb20tYXR0clwiLCAvLyBkb21BdHRyLnNldFxuXHRcImRvam8vZG9tLXN0eWxlXCIsIC8vIGRvbVN0eWxlLmdldFxuXHRcImRvam8vX2Jhc2UvbGFuZ1wiLCAvLyBsYW5nLmhpdGNoIGxhbmcuaXNBcnJheVxuXHRcImRvam8vbW91c2VcIiwgLy8gbW91c2UuaXNMZWZ0XG5cdFwiZG9qby9vblwiLFxuXHRcImRvam8vc25pZmZcIiwgLy8gaGFzKFwid2Via2l0XCIpXG5cdFwiZG9qby93aW5kb3dcIiwgLy8gd2luVXRpbHMuc2Nyb2xsSW50b1ZpZXdcblx0XCIuLi9hMTF5XCIgICAgLy8gYTExeS5oYXNEZWZhdWx0VGFiU3RvcFxuXSwgZnVuY3Rpb24oYXJyYXksIGRlY2xhcmUsIGRvbUF0dHIsIGRvbVN0eWxlLCBsYW5nLCBtb3VzZSwgb24sIGhhcywgd2luVXRpbHMsIGExMXkpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvZm9ybS9fRm9ybVdpZGdldE1peGluXG5cblx0cmV0dXJuIGRlY2xhcmUoXCJkaWppdC5mb3JtLl9Gb3JtV2lkZ2V0TWl4aW5cIiwgbnVsbCwge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4aW4gZm9yIHdpZGdldHMgY29ycmVzcG9uZGluZyB0byBuYXRpdmUgSFRNTCBlbGVtZW50cyBzdWNoIGFzIGA8Y2hlY2tib3g+YCBvciBgPGJ1dHRvbj5gLFxuXHRcdC8vXHRcdHdoaWNoIGNhbiBiZSBjaGlsZHJlbiBvZiBhIGA8Zm9ybT5gIG5vZGUgb3IgYSBgZGlqaXQvZm9ybS9Gb3JtYCB3aWRnZXQuXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZXByZXNlbnRzIGEgc2luZ2xlIEhUTUwgZWxlbWVudC5cblx0XHQvL1x0XHRBbGwgdGhlc2Ugd2lkZ2V0cyBzaG91bGQgaGF2ZSB0aGVzZSBhdHRyaWJ1dGVzIGp1c3QgbGlrZSBuYXRpdmUgSFRNTCBpbnB1dCBlbGVtZW50cy5cblx0XHQvL1x0XHRZb3UgY2FuIHNldCB0aGVtIGR1cmluZyB3aWRnZXQgY29uc3RydWN0aW9uIG9yIGFmdGVyd2FyZHMsIHZpYSBgZGlqaXQvX1dpZGdldEJhc2Uuc2V0KClgLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhleSBhbHNvIHNoYXJlIHNvbWUgY29tbW9uIG1ldGhvZHMuXG5cblx0XHQvLyBuYW1lOiBbY29uc3RdIFN0cmluZ1xuXHRcdC8vXHRcdE5hbWUgdXNlZCB3aGVuIHN1Ym1pdHRpbmcgZm9ybTsgc2FtZSBhcyBcIm5hbWVcIiBhdHRyaWJ1dGUgb3IgcGxhaW4gSFRNTCBlbGVtZW50c1xuXHRcdG5hbWU6IFwiXCIsXG5cblx0XHQvLyBhbHQ6IFN0cmluZ1xuXHRcdC8vXHRcdENvcnJlc3BvbmRzIHRvIHRoZSBuYXRpdmUgSFRNTCBgPGlucHV0PmAgZWxlbWVudCdzIGF0dHJpYnV0ZS5cblx0XHRhbHQ6IFwiXCIsXG5cblx0XHQvLyB2YWx1ZTogU3RyaW5nXG5cdFx0Ly9cdFx0Q29ycmVzcG9uZHMgdG8gdGhlIG5hdGl2ZSBIVE1MIGA8aW5wdXQ+YCBlbGVtZW50J3MgYXR0cmlidXRlLlxuXHRcdHZhbHVlOiBcIlwiLFxuXG5cdFx0Ly8gdHlwZTogW2NvbnN0XSBTdHJpbmdcblx0XHQvL1x0XHRDb3JyZXNwb25kcyB0byB0aGUgbmF0aXZlIEhUTUwgYDxpbnB1dD5gIGVsZW1lbnQncyBhdHRyaWJ1dGUuXG5cdFx0dHlwZTogXCJ0ZXh0XCIsXG5cblx0XHQvLyB0eXBlOiBTdHJpbmdcblx0XHQvL1x0XHRBcHBseSBhcmlhLWxhYmVsIGluIG1hcmt1cCB0byB0aGUgd2lkZ2V0J3MgZm9jdXNOb2RlXG5cdFx0XCJhcmlhLWxhYmVsXCI6IFwiZm9jdXNOb2RlXCIsXG5cblx0XHQvLyB0YWJJbmRleDogU3RyaW5nXG5cdFx0Ly9cdFx0T3JkZXIgZmllbGRzIGFyZSB0cmF2ZXJzZWQgd2hlbiB1c2VyIGhpdHMgdGhlIHRhYiBrZXlcblx0XHR0YWJJbmRleDogXCIwXCIsXG5cdFx0X3NldFRhYkluZGV4QXR0cjogXCJmb2N1c05vZGVcIiwgLy8gZm9yY2UgY29weSBldmVuIHdoZW4gdGFiSW5kZXggZGVmYXVsdCB2YWx1ZSwgbmVlZGVkIHNpbmNlIEJ1dHRvbiBpcyA8c3Bhbj5cblxuXHRcdC8vIGRpc2FibGVkOiBCb29sZWFuXG5cdFx0Ly9cdFx0U2hvdWxkIHRoaXMgd2lkZ2V0IHJlc3BvbmQgdG8gdXNlciBpbnB1dD9cblx0XHQvL1x0XHRJbiBtYXJrdXAsIHRoaXMgaXMgc3BlY2lmaWVkIGFzIFwiZGlzYWJsZWQ9J2Rpc2FibGVkJ1wiLCBvciBqdXN0IFwiZGlzYWJsZWRcIi5cblx0XHRkaXNhYmxlZDogZmFsc2UsXG5cblx0XHQvLyBpbnRlcm1lZGlhdGVDaGFuZ2VzOiBCb29sZWFuXG5cdFx0Ly9cdFx0RmlyZXMgb25DaGFuZ2UgZm9yIGVhY2ggdmFsdWUgY2hhbmdlIG9yIG9ubHkgb24gZGVtYW5kXG5cdFx0aW50ZXJtZWRpYXRlQ2hhbmdlczogZmFsc2UsXG5cblx0XHQvLyBzY3JvbGxPbkZvY3VzOiBCb29sZWFuXG5cdFx0Ly9cdFx0T24gZm9jdXMsIHNob3VsZCB0aGlzIHdpZGdldCBzY3JvbGwgaW50byB2aWV3P1xuXHRcdHNjcm9sbE9uRm9jdXM6IHRydWUsXG5cblx0XHQvLyBPdmVycmlkZSBfV2lkZ2V0QmFzZSBtYXBwaW5nIGlkIHRvIHRoaXMuZG9tTm9kZSwgbmVlZHMgdG8gYmUgb24gZm9jdXNOb2RlIHNvIDxsYWJlbD4gZXRjLlxuXHRcdC8vIHdvcmtzIHdpdGggc2NyZWVuIHJlYWRlclxuXHRcdF9zZXRJZEF0dHI6IFwiZm9jdXNOb2RlXCIsXG5cblx0XHRfc2V0RGlzYWJsZWRBdHRyOiBmdW5jdGlvbigvKkJvb2xlYW4qLyB2YWx1ZSl7XG5cdFx0XHR0aGlzLl9zZXQoXCJkaXNhYmxlZFwiLCB2YWx1ZSk7XG5cblx0XHRcdC8vIFNldCBkaXNhYmxlZCBwcm9wZXJ0eSBpZiBmb2N1c05vZGUgaXMgYW4gPGlucHV0PiwgYnV0IGFyaWEtZGlzYWJsZWQgYXR0cmlidXRlIGlmIGZvY3VzTm9kZSBpcyBhIDxzcGFuPi5cblx0XHRcdC8vIENhbid0IHVzZSBcImRpc2FibGVkXCIgaW4gdGhpcy5mb2N1c05vZGUgYXMgYSB0ZXN0IGJlY2F1c2Ugb24gSUUsIHRoYXQncyB0cnVlIGZvciBhbGwgbm9kZXMuXG5cdFx0XHRpZigvXihidXR0b258aW5wdXR8c2VsZWN0fHRleHRhcmVhfG9wdGdyb3VwfG9wdGlvbnxmaWVsZHNldCkkL2kudGVzdCh0aGlzLmZvY3VzTm9kZS50YWdOYW1lKSl7XG5cdFx0XHRcdGRvbUF0dHIuc2V0KHRoaXMuZm9jdXNOb2RlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG5cdFx0XHRcdC8vIElFIGhhcyBhIENhcmV0IEJyb3dzaW5nIG1vZGUgKGhpdCBGNyB0byBhY3RpdmF0ZSkgd2hlcmUgZGlzYWJsZWQgdGV4dGJveGVzIGNhbiBiZSBtb2RpZmllZFxuXHRcdFx0XHQvLyB0ZXh0Ym94ZXMgbWFya2VkIHJlYWRvbmx5IGlmIGRpc2FibGVkIHRvIGF2b2lkIHRoaXMgaXNzdWUuXG5cdFx0XHRcdGlmIChoYXMoJ3RyaWRlbnQnKSAmJiAncmVhZE9ubHknIGluIHRoaXMpIHtcblx0XHRcdFx0XHRkb21BdHRyLnNldCh0aGlzLmZvY3VzTm9kZSwgJ3JlYWRvbmx5JywgdmFsdWUgfHwgdGhpcy5yZWFkT25seSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0aGlzLmZvY3VzTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbmQgYWxzbyBzZXQgZGlzYWJsZWQgb24gdGhlIGhpZGRlbiA8aW5wdXQ+IG5vZGVcblx0XHRcdGlmKHRoaXMudmFsdWVOb2RlKXtcblx0XHRcdFx0ZG9tQXR0ci5zZXQodGhpcy52YWx1ZU5vZGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodmFsdWUpe1xuXHRcdFx0XHQvLyByZXNldCB0aGVzZSwgYmVjYXVzZSBhZnRlciB0aGUgZG9tTm9kZSBpcyBkaXNhYmxlZCwgd2UgY2FuIG5vIGxvbmdlciByZWNlaXZlXG5cdFx0XHRcdC8vIG1vdXNlIHJlbGF0ZWQgZXZlbnRzLCBzZWUgIzQyMDBcblx0XHRcdFx0dGhpcy5fc2V0KFwiaG92ZXJpbmdcIiwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLl9zZXQoXCJhY3RpdmVcIiwgZmFsc2UpO1xuXG5cdFx0XHRcdC8vIGNsZWFyIHRhYiBzdG9wKHMpIG9uIHRoaXMgd2lkZ2V0J3MgZm9jdXNhYmxlIG5vZGUocykgIChDb21ib0JveCBoYXMgdHdvIGZvY3VzYWJsZSBub2Rlcylcblx0XHRcdFx0dmFyIGF0dGFjaFBvaW50TmFtZXMgPSBcInRhYkluZGV4XCIgaW4gdGhpcy5hdHRyaWJ1dGVNYXAgPyB0aGlzLmF0dHJpYnV0ZU1hcC50YWJJbmRleCA6XG5cdFx0XHRcdFx0KFwiX3NldFRhYkluZGV4QXR0clwiIGluIHRoaXMpID8gdGhpcy5fc2V0VGFiSW5kZXhBdHRyIDogXCJmb2N1c05vZGVcIjtcblx0XHRcdFx0YXJyYXkuZm9yRWFjaChsYW5nLmlzQXJyYXkoYXR0YWNoUG9pbnROYW1lcykgPyBhdHRhY2hQb2ludE5hbWVzIDogW2F0dGFjaFBvaW50TmFtZXNdLCBmdW5jdGlvbihhdHRhY2hQb2ludE5hbWUpe1xuXHRcdFx0XHRcdHZhciBub2RlID0gdGhpc1thdHRhY2hQb2ludE5hbWVdO1xuXHRcdFx0XHRcdC8vIGNvbXBsZXggY29kZSBiZWNhdXNlIHRhYkluZGV4PS0xIG9uIGEgPGRpdj4gZG9lc24ndCB3b3JrIG9uIEZGXG5cdFx0XHRcdFx0aWYoaGFzKFwid2Via2l0XCIpIHx8IGExMXkuaGFzRGVmYXVsdFRhYlN0b3Aobm9kZSkpeyAgICAvLyBzZWUgIzExMDY0IGFib3V0IHdlYmtpdCBidWdcblx0XHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIFwiLTFcIik7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGlmKHRoaXMudGFiSW5kZXggIT0gXCJcIil7XG5cdFx0XHRcdFx0dGhpcy5zZXQoJ3RhYkluZGV4JywgdGhpcy50YWJJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X29uRm9jdXM6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gYnkpe1xuXHRcdFx0Ly8gSWYgdXNlciBjbGlja3Mgb24gdGhlIHdpZGdldCwgZXZlbiBpZiB0aGUgbW91c2UgaXMgcmVsZWFzZWQgb3V0c2lkZSBvZiBpdCxcblx0XHRcdC8vIHRoaXMgd2lkZ2V0J3MgZm9jdXNOb2RlIHNob3VsZCBnZXQgZm9jdXMgKHRvIG1pbWljIG5hdGl2ZSBicm93c2VyIGJlaGF2aW9yKS5cblx0XHRcdC8vIEJyb3dzZXJzIG9mdGVuIG5lZWQgaGVscCB0byBtYWtlIHN1cmUgdGhlIGZvY3VzIHZpYSBtb3VzZSBhY3R1YWxseSBnZXRzIHRvIHRoZSBmb2N1c05vZGUuXG5cdFx0XHQvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyBhbGwgb2YgdGhpcyBmb3IgMi4wIG9yIHNvb25lciwgc2VlICMxNjYyMiBldGMuXG5cdFx0XHRpZihieSA9PSBcIm1vdXNlXCIgJiYgdGhpcy5pc0ZvY3VzYWJsZSgpKXtcblx0XHRcdFx0Ly8gSUUgZXhoaWJpdHMgc3RyYW5nZSBzY3JvbGxpbmcgYmVoYXZpb3Igd2hlbiByZWZvY3VzaW5nIGEgbm9kZSBzbyBvbmx5IGRvIGl0IHdoZW4gIWZvY3VzZWQuXG5cdFx0XHRcdHZhciBmb2N1c0hhbmRsZSA9IHRoaXMub3duKG9uKHRoaXMuZm9jdXNOb2RlLCBcImZvY3VzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0bW91c2VVcEhhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0XHRmb2N1c0hhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0fSkpWzBdO1xuXHRcdFx0XHQvLyBTZXQgYSBnbG9iYWwgZXZlbnQgdG8gaGFuZGxlIG1vdXNldXAsIHNvIGl0IGZpcmVzIHByb3Blcmx5XG5cdFx0XHRcdC8vIGV2ZW4gaWYgdGhlIGN1cnNvciBsZWF2ZXMgdGhpcy5kb21Ob2RlIGJlZm9yZSB0aGUgbW91c2UgdXAgZXZlbnQuXG5cdFx0XHRcdHZhciBldmVudCA9IGhhcyhcInBvaW50ZXItZXZlbnRzXCIpID8gXCJwb2ludGVydXBcIiA6IGhhcyhcIk1TUG9pbnRlclwiKSA/IFwiTVNQb2ludGVyVXBcIiA6XG5cdFx0XHRcdFx0aGFzKFwidG91Y2gtZXZlbnRzXCIpID8gXCJ0b3VjaGVuZCwgbW91c2V1cFwiIDpcdFx0Ly8gc2VlbXMgbGlrZSBvdmVya2lsbCBidXQgc2VlICMxNjYyMiwgIzE2NzI1XG5cdFx0XHRcdFx0XCJtb3VzZXVwXCI7XG5cdFx0XHRcdHZhciBtb3VzZVVwSGFuZGxlID0gdGhpcy5vd24ob24odGhpcy5vd25lckRvY3VtZW50Qm9keSwgZXZlbnQsIGxhbmcuaGl0Y2godGhpcywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRtb3VzZVVwSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGZvY3VzSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHRcdC8vIGlmIGhlcmUsIHRoZW4gdGhlIG1vdXNlZG93biBkaWQgbm90IGZvY3VzIHRoZSBmb2N1c05vZGUgYXMgdGhlIGRlZmF1bHQgYWN0aW9uXG5cdFx0XHRcdFx0aWYodGhpcy5mb2N1c2VkKXtcblx0XHRcdFx0XHRcdGlmKGV2dC50eXBlID09IFwidG91Y2hlbmRcIil7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmZXIoXCJmb2N1c1wiKTsgLy8gbmF0aXZlIGZvY3VzIGhhc24ndCBvY2N1cnJlZCB5ZXRcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7IC8vIG5hdGl2ZSBmb2N1cyBhbHJlYWR5IG9jY3VycmVkIG9uIG1vdXNlZG93blxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpKVswXTtcblx0XHRcdH1cblx0XHRcdGlmKHRoaXMuc2Nyb2xsT25Gb2N1cyl7XG5cdFx0XHRcdHRoaXMuZGVmZXIoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR3aW5VdGlscy5zY3JvbGxJbnRvVmlldyh0aGlzLmRvbU5vZGUpO1xuXHRcdFx0XHR9KTsgLy8gd2l0aG91dCBkZWZlciwgdGhlIGlucHV0IGNhcmV0IHBvc2l0aW9uIGNhbiBjaGFuZ2Ugb24gbW91c2UgY2xpY2tcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGlzRm9jdXNhYmxlOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlbGxzIGlmIHRoaXMgd2lkZ2V0IGlzIGZvY3VzYWJsZSBvciBub3QuICBVc2VkIGludGVybmFsbHkgYnkgZGlqaXQuXG5cdFx0XHQvLyB0YWdzOlxuXHRcdFx0Ly9cdFx0cHJvdGVjdGVkXG5cdFx0XHRyZXR1cm4gIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5mb2N1c05vZGUgJiYgKGRvbVN0eWxlLmdldCh0aGlzLmRvbU5vZGUsIFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIik7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFB1dCBmb2N1cyBvbiB0aGlzIHdpZGdldFxuXHRcdFx0aWYoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5mb2N1c05vZGUuZm9jdXMpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0dGhpcy5mb2N1c05vZGUuZm9jdXMoKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qc3F1ZWxjaCBlcnJvcnMgZnJvbSBoaWRkZW4gbm9kZXMqL1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjb21wYXJlOiBmdW5jdGlvbigvKmFueXRoaW5nKi8gdmFsMSwgLyphbnl0aGluZyovIHZhbDIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvbXBhcmUgMiB2YWx1ZXMgKGFzIHJldHVybmVkIGJ5IGdldCgndmFsdWUnKSBmb3IgdGhpcyB3aWRnZXQpLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdHByb3RlY3RlZFxuXHRcdFx0aWYodHlwZW9mIHZhbDEgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsMiA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0cmV0dXJuIChpc05hTih2YWwxKSAmJiBpc05hTih2YWwyKSkgPyAwIDogdmFsMSAtIHZhbDI7XG5cdFx0XHR9ZWxzZSBpZih2YWwxID4gdmFsMil7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fWVsc2UgaWYodmFsMSA8IHZhbDIpe1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2hhbmdlOiBmdW5jdGlvbigvKj09PT09IG5ld1ZhbHVlID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxiYWNrIHdoZW4gdGhpcyB3aWRnZXQncyB2YWx1ZSBpcyBjaGFuZ2VkLlxuXHRcdFx0Ly8gdGFnczpcblx0XHRcdC8vXHRcdGNhbGxiYWNrXG5cdFx0fSxcblxuXHRcdC8vIF9vbkNoYW5nZUFjdGl2ZTogW3ByaXZhdGVdIEJvb2xlYW5cblx0XHQvL1x0XHRJbmRpY2F0ZXMgdGhhdCBjaGFuZ2VzIHRvIHRoZSB2YWx1ZSBzaG91bGQgY2FsbCBvbkNoYW5nZSgpIGNhbGxiYWNrLlxuXHRcdC8vXHRcdFRoaXMgaXMgZmFsc2UgZHVyaW5nIHdpZGdldCBpbml0aWFsaXphdGlvbiwgdG8gYXZvaWQgY2FsbGluZyBvbkNoYW5nZSgpXG5cdFx0Ly9cdFx0d2hlbiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBzZXQuXG5cdFx0X29uQ2hhbmdlQWN0aXZlOiBmYWxzZSxcblxuXHRcdF9oYW5kbGVPbkNoYW5nZTogZnVuY3Rpb24oLyphbnl0aGluZyovIG5ld1ZhbHVlLCAvKkJvb2xlYW4/Ki8gcHJpb3JpdHlDaGFuZ2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgd2lkZ2V0IGlzIHNldC4gIENhbGxzIG9uQ2hhbmdlKCkgaWYgYXBwcm9wcmlhdGVcblx0XHRcdC8vIG5ld1ZhbHVlOlxuXHRcdFx0Ly9cdFx0dGhlIG5ldyB2YWx1ZVxuXHRcdFx0Ly8gcHJpb3JpdHlDaGFuZ2U6XG5cdFx0XHQvL1x0XHRGb3IgYSBzbGlkZXIsIGZvciBleGFtcGxlLCBkcmFnZ2luZyB0aGUgc2xpZGVyIGlzIHByaW9yaXR5Q2hhbmdlPT1mYWxzZSxcblx0XHRcdC8vXHRcdGJ1dCBvbiBtb3VzZSB1cCwgaXQncyBwcmlvcml0eUNoYW5nZT09dHJ1ZS4gIElmIGludGVybWVkaWF0ZUNoYW5nZXM9PWZhbHNlLFxuXHRcdFx0Ly9cdFx0b25DaGFuZ2UgaXMgb25seSBjYWxsZWQgZm9ybSBwcmlvcml0eUNoYW5nZT10cnVlIGV2ZW50cy5cblx0XHRcdC8vIHRhZ3M6XG5cdFx0XHQvL1x0XHRwcml2YXRlXG5cdFx0XHRpZih0aGlzLl9sYXN0VmFsdWVSZXBvcnRlZCA9PSB1bmRlZmluZWQgJiYgKHByaW9yaXR5Q2hhbmdlID09PSBudWxsIHx8ICF0aGlzLl9vbkNoYW5nZUFjdGl2ZSkpe1xuXHRcdFx0XHQvLyB0aGlzIGJsb2NrIGV4ZWN1dGVzIG5vdCBmb3IgYSBjaGFuZ2UsIGJ1dCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sXG5cdFx0XHRcdC8vIGFuZCBpcyB1c2VkIHRvIHN0b3JlIGF3YXkgdGhlIG9yaWdpbmFsIHZhbHVlIChvciBmb3IgVG9nZ2xlQnV0dG9uLCB0aGUgb3JpZ2luYWwgY2hlY2tlZCBzdGF0ZSlcblx0XHRcdFx0dGhpcy5fcmVzZXRWYWx1ZSA9IHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkID0gbmV3VmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wZW5kaW5nT25DaGFuZ2UgPSB0aGlzLl9wZW5kaW5nT25DaGFuZ2Vcblx0XHRcdFx0fHwgKHR5cGVvZiBuZXdWYWx1ZSAhPSB0eXBlb2YgdGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQpXG5cdFx0XHRcdHx8ICh0aGlzLmNvbXBhcmUobmV3VmFsdWUsIHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkKSAhPSAwKTtcblx0XHRcdGlmKCh0aGlzLmludGVybWVkaWF0ZUNoYW5nZXMgfHwgcHJpb3JpdHlDaGFuZ2UgfHwgcHJpb3JpdHlDaGFuZ2UgPT09IHVuZGVmaW5lZCkgJiYgdGhpcy5fcGVuZGluZ09uQ2hhbmdlKXtcblx0XHRcdFx0dGhpcy5fbGFzdFZhbHVlUmVwb3J0ZWQgPSBuZXdWYWx1ZTtcblx0XHRcdFx0dGhpcy5fcGVuZGluZ09uQ2hhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGlmKHRoaXMuX29uQ2hhbmdlQWN0aXZlKXtcblx0XHRcdFx0XHRpZih0aGlzLl9vbkNoYW5nZUhhbmRsZSl7XG5cdFx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZS5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZGVmZXIgYWxsb3dzIGhpZGRlbiB2YWx1ZSBwcm9jZXNzaW5nIHRvIHJ1biBhbmRcblx0XHRcdFx0XHQvLyBhbHNvIHRoZSBvbkNoYW5nZSBoYW5kbGVyIGNhbiBzYWZlbHkgYWRqdXN0IGZvY3VzLCBldGNcblx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZSA9IHRoaXMuZGVmZXIoXG5cdFx0XHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vbkNoYW5nZUhhbmRsZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMub25DaGFuZ2UobmV3VmFsdWUpO1xuXHRcdFx0XHRcdFx0fSk7IC8vIHRyeSB0byBjb2xsYXBzZSBtdWx0aXBsZSBvbkNoYW5nZSdzIGZpcmVkIGZhc3RlciB0aGFuIGNhbiBiZSBwcm9jZXNzZWRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBPdmVycmlkZXMgX1dpZGdldC5jcmVhdGUoKVxuXHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQWN0aXZlID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHRcdGlmKHRoaXMuX29uQ2hhbmdlSGFuZGxlKXsgLy8gZGVzdHJveSBjYWxsZWQgYmVmb3JlIGxhc3Qgb25DaGFuZ2UgaGFzIGZpcmVkXG5cdFx0XHRcdHRoaXMuX29uQ2hhbmdlSGFuZGxlLnJlbW92ZSgpO1xuXHRcdFx0XHR0aGlzLm9uQ2hhbmdlKHRoaXMuX2xhc3RWYWx1ZVJlcG9ydGVkKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2tlcm5lbFwiXG5dLCBmdW5jdGlvbihkb2pvKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkaWppdC9tYWluXG5cbi8qPT09PT1cbnJldHVybiB7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoZSBkaWppdCBwYWNrYWdlIG1haW4gbW9kdWxlLlxuXHQvL1x0XHREZXByZWNhdGVkLiAgIFVzZXJzIHNob3VsZCBhY2Nlc3MgaW5kaXZpZHVhbCBtb2R1bGVzIChleDogZGlqaXQvcmVnaXN0cnkpIGRpcmVjdGx5LlxufTtcbj09PT09Ki9cblxuXHRyZXR1cm4gZG9qby5kaWppdDtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCJkb2pvL19iYXNlL2FycmF5XCIsIC8vIGFycmF5LmZvckVhY2ggYXJyYXkubWFwXG5cdFwiZG9qby9fYmFzZS93aW5kb3dcIiwgLy8gd2luLmJvZHlcblx0XCIuL21haW5cIlx0Ly8gZGlqaXQuX3Njb3BlTmFtZVxuXSwgZnVuY3Rpb24oYXJyYXksIHdpbiwgZGlqaXQpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZGlqaXQvcmVnaXN0cnlcblxuXHR2YXIgX3dpZGdldFR5cGVDdHIgPSB7fSwgaGFzaCA9IHt9O1xuXG5cdHZhciByZWdpc3RyeSA9ICB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZWdpc3RyeSBvZiBleGlzdGluZyB3aWRnZXQgb24gcGFnZSwgcGx1cyBzb21lIHV0aWxpdHkgbWV0aG9kcy5cblxuXHRcdC8vIGxlbmd0aDogTnVtYmVyXG5cdFx0Ly9cdFx0TnVtYmVyIG9mIHJlZ2lzdGVyZWQgd2lkZ2V0c1xuXHRcdGxlbmd0aDogMCxcblxuXHRcdGFkZDogZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgYSB3aWRnZXQgdG8gdGhlIHJlZ2lzdHJ5LiBJZiBhIGR1cGxpY2F0ZSBJRCBpcyBkZXRlY3RlZCwgYSBlcnJvciBpcyB0aHJvd24uXG5cdFx0XHQvLyB3aWRnZXQ6IGRpaml0L19XaWRnZXRCYXNlXG5cdFx0XHQvL1x0XHRBbnkgZGlqaXQvX1dpZGdldEJhc2Ugc3ViY2xhc3MuXG5cdFx0XHRpZihoYXNoW3dpZGdldC5pZF0pe1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byByZWdpc3RlciB3aWRnZXQgd2l0aCBpZD09XCIgKyB3aWRnZXQuaWQgKyBcIiBidXQgdGhhdCBpZCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG5cdFx0XHR9XG5cdFx0XHRoYXNoW3dpZGdldC5pZF0gPSB3aWRnZXQ7XG5cdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKC8qU3RyaW5nKi8gaWQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlbW92ZSBhIHdpZGdldCBmcm9tIHRoZSByZWdpc3RyeS4gRG9lcyBub3QgZGVzdHJveSB0aGUgd2lkZ2V0OyBzaW1wbHlcblx0XHRcdC8vXHRcdHJlbW92ZXMgdGhlIHJlZmVyZW5jZS5cblx0XHRcdGlmKGhhc2hbaWRdKXtcblx0XHRcdFx0ZGVsZXRlIGhhc2hbaWRdO1xuXHRcdFx0XHR0aGlzLmxlbmd0aC0tO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRieUlkOiBmdW5jdGlvbigvKlN0cmluZ3xXaWRnZXQqLyBpZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmluZCBhIHdpZGdldCBieSBpdCdzIGlkLlxuXHRcdFx0Ly9cdFx0SWYgcGFzc2VkIGEgd2lkZ2V0IHRoZW4ganVzdCByZXR1cm5zIHRoZSB3aWRnZXQuXG5cdFx0XHRyZXR1cm4gdHlwZW9mIGlkID09IFwic3RyaW5nXCIgPyBoYXNoW2lkXSA6IGlkO1x0Ly8gZGlqaXQvX1dpZGdldEJhc2Vcblx0XHR9LFxuXG5cdFx0YnlOb2RlOiBmdW5jdGlvbigvKkRPTU5vZGUqLyBub2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSB3aWRnZXQgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gRE9NTm9kZVxuXHRcdFx0cmV0dXJuIGhhc2hbbm9kZS5nZXRBdHRyaWJ1dGUoXCJ3aWRnZXRJZFwiKV07IC8vIGRpaml0L19XaWRnZXRCYXNlXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29udmVydCByZWdpc3RyeSBpbnRvIGEgdHJ1ZSBBcnJheVxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRXb3JrIHdpdGggdGhlIHdpZGdldCAuZG9tTm9kZXMgaW4gYSByZWFsIEFycmF5XG5cdFx0XHQvL1x0XHR8XHRhcnJheS5tYXAocmVnaXN0cnkudG9BcnJheSgpLCBmdW5jdGlvbih3KXsgcmV0dXJuIHcuZG9tTm9kZTsgfSk7XG5cblx0XHRcdHZhciBhciA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpZCBpbiBoYXNoKXtcblx0XHRcdFx0YXIucHVzaChoYXNoW2lkXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXI7XHQvLyBkaWppdC9fV2lkZ2V0QmFzZVtdXG5cdFx0fSxcblxuXHRcdGdldFVuaXF1ZUlkOiBmdW5jdGlvbigvKlN0cmluZyovd2lkZ2V0VHlwZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0R2VuZXJhdGVzIGEgdW5pcXVlIGlkIGZvciBhIGdpdmVuIHdpZGdldFR5cGVcblxuXHRcdFx0dmFyIGlkO1xuXHRcdFx0ZG97XG5cdFx0XHRcdGlkID0gd2lkZ2V0VHlwZSArIFwiX1wiICtcblx0XHRcdFx0XHQod2lkZ2V0VHlwZSBpbiBfd2lkZ2V0VHlwZUN0ciA/XG5cdFx0XHRcdFx0XHQrK193aWRnZXRUeXBlQ3RyW3dpZGdldFR5cGVdIDogX3dpZGdldFR5cGVDdHJbd2lkZ2V0VHlwZV0gPSAwKTtcblx0XHRcdH13aGlsZShoYXNoW2lkXSk7XG5cdFx0XHRyZXR1cm4gZGlqaXQuX3Njb3BlTmFtZSA9PSBcImRpaml0XCIgPyBpZCA6IGRpaml0Ll9zY29wZU5hbWUgKyBcIl9cIiArIGlkOyAvLyBTdHJpbmdcblx0XHR9LFxuXG5cdFx0ZmluZFdpZGdldHM6IGZ1bmN0aW9uKHJvb3QsIHNraXBOb2RlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTZWFyY2ggc3VidHJlZSB1bmRlciByb290IHJldHVybmluZyB3aWRnZXRzIGZvdW5kLlxuXHRcdFx0Ly9cdFx0RG9lc24ndCBzZWFyY2ggZm9yIG5lc3RlZCB3aWRnZXRzIChpZSwgd2lkZ2V0cyBpbnNpZGUgb3RoZXIgd2lkZ2V0cykuXG5cdFx0XHQvLyByb290OiBET01Ob2RlXG5cdFx0XHQvL1x0XHROb2RlIHRvIHNlYXJjaCB1bmRlci5cblx0XHRcdC8vIHNraXBOb2RlOiBET01Ob2RlXG5cdFx0XHQvL1x0XHRJZiBzcGVjaWZpZWQsIGRvbid0IHNlYXJjaCBiZW5lYXRoIHRoaXMgbm9kZSAodXN1YWxseSBjb250YWluZXJOb2RlKS5cblxuXHRcdFx0dmFyIG91dEFyeSA9IFtdO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRDaGlsZHJlbkhlbHBlcihyb290KXtcblx0XHRcdFx0Zm9yKHZhciBub2RlID0gcm9vdC5maXJzdENoaWxkOyBub2RlOyBub2RlID0gbm9kZS5uZXh0U2libGluZyl7XG5cdFx0XHRcdFx0aWYobm9kZS5ub2RlVHlwZSA9PSAxKXtcblx0XHRcdFx0XHRcdHZhciB3aWRnZXRJZCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkZ2V0SWRcIik7XG5cdFx0XHRcdFx0XHRpZih3aWRnZXRJZCl7XG5cdFx0XHRcdFx0XHRcdHZhciB3aWRnZXQgPSBoYXNoW3dpZGdldElkXTtcblx0XHRcdFx0XHRcdFx0aWYod2lkZ2V0KXtcdC8vIG1heSBiZSBudWxsIG9uIHBhZ2Ugdy9tdWx0aXBsZSBkb2pvJ3MgbG9hZGVkXG5cdFx0XHRcdFx0XHRcdFx0b3V0QXJ5LnB1c2god2lkZ2V0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fWVsc2UgaWYobm9kZSAhPT0gc2tpcE5vZGUpe1xuXHRcdFx0XHRcdFx0XHRnZXRDaGlsZHJlbkhlbHBlcihub2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z2V0Q2hpbGRyZW5IZWxwZXIocm9vdCk7XG5cdFx0XHRyZXR1cm4gb3V0QXJ5O1xuXHRcdH0sXG5cblx0XHRfZGVzdHJveUFsbDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDb2RlIHRvIGRlc3Ryb3kgYWxsIHdpZGdldHMgYW5kIGRvIG90aGVyIGNsZWFudXAgb24gcGFnZSB1bmxvYWRcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgZm9jdXMgbWFuYWdlciBsaW5nZXJpbmcgcmVmZXJlbmNlcyB0byB3aWRnZXRzIGFuZCBub2Rlc1xuXHRcdFx0ZGlqaXQuX2N1ckZvY3VzID0gbnVsbDtcblx0XHRcdGRpaml0Ll9wcmV2Rm9jdXMgPSBudWxsO1xuXHRcdFx0ZGlqaXQuX2FjdGl2ZVN0YWNrID0gW107XG5cblx0XHRcdC8vIERlc3Ryb3kgYWxsIHRoZSB3aWRnZXRzLCB0b3AgZG93blxuXHRcdFx0YXJyYXkuZm9yRWFjaChyZWdpc3RyeS5maW5kV2lkZ2V0cyh3aW4uYm9keSgpKSwgZnVuY3Rpb24od2lkZ2V0KXtcblx0XHRcdFx0Ly8gQXZvaWQgZG91YmxlIGRlc3Ryb3kgb2Ygd2lkZ2V0cyBsaWtlIE1lbnUgdGhhdCBhcmUgYXR0YWNoZWQgdG8gPGJvZHk+XG5cdFx0XHRcdC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGxvZ2ljYWxseSBjaGlsZHJlbiBvZiBvdGhlciB3aWRnZXRzLlxuXHRcdFx0XHRpZighd2lkZ2V0Ll9kZXN0cm95ZWQpe1xuXHRcdFx0XHRcdGlmKHdpZGdldC5kZXN0cm95UmVjdXJzaXZlKXtcblx0XHRcdFx0XHRcdHdpZGdldC5kZXN0cm95UmVjdXJzaXZlKCk7XG5cdFx0XHRcdFx0fWVsc2UgaWYod2lkZ2V0LmRlc3Ryb3kpe1xuXHRcdFx0XHRcdFx0d2lkZ2V0LmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRnZXRFbmNsb3NpbmdXaWRnZXQ6IGZ1bmN0aW9uKC8qRE9NTm9kZSovIG5vZGUpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHdpZGdldCB3aG9zZSBET00gdHJlZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIERPTU5vZGUsIG9yIG51bGwgaWZcblx0XHRcdC8vXHRcdHRoZSBub2RlIGlzIG5vdCBjb250YWluZWQgd2l0aGluIHRoZSBET00gdHJlZSBvZiBhbnkgd2lkZ2V0XG5cdFx0XHR3aGlsZShub2RlKXtcblx0XHRcdFx0dmFyIGlkID0gbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkZ2V0SWRcIik7XG5cdFx0XHRcdGlmKGlkKXtcblx0XHRcdFx0XHRyZXR1cm4gaGFzaFtpZF07XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvLyBJbiBjYXNlIHNvbWVvbmUgbmVlZHMgdG8gYWNjZXNzIGhhc2guXG5cdFx0Ly8gQWN0dWFsbHksIHRoaXMgaXMgYWNjZXNzZWQgZnJvbSBXaWRnZXRTZXQgYmFjay1jb21wYXRpYmlsaXR5IGNvZGVcblx0XHRfaGFzaDogaGFzaFxuXHR9O1xuXG5cdGRpaml0LnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG5cblx0cmV0dXJuIHJlZ2lzdHJ5O1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZXJDb25maWcsIGRlZmF1bHRDb25maWcsIGdsb2JhbCwgd2luZG93KSB7IHRoaXMubG9hZGVyVmVyc2lvbiA9IFwiMS4xNi41XCI7IChmdW5jdGlvbihcblx0dXNlckNvbmZpZyxcblx0ZGVmYXVsdENvbmZpZ1xuKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBpcyB0aGUgXCJzb3VyY2UgbG9hZGVyXCIgYW5kIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgRG9qbyBkdXJpbmcgZGV2ZWxvcG1lbnQuIFlvdSBtYXkgYWxzbyBsb2FkIERvam8gd2l0aFxuXHQvL1x0XHRhbnkgQU1ELWNvbXBsaWFudCBsb2FkZXIgdmlhIHRoZSBwYWNrYWdlIG1haW4gbW9kdWxlIGRvam8vbWFpbi5cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdFRoaXMgaXMgdGhlIFwic291cmNlIGxvYWRlclwiIGZvciBEb2pvLiBJdCBwcm92aWRlcyBhbiBBTUQtY29tcGxpYW50IGxvYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkXG5cdC8vXHRcdHRvIG9wZXJhdGUgaW4gZWl0aGVyIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cyBtb2Rlcy4gQWZ0ZXIgdGhlIGxvYWRlciBpcyBkZWZpbmVkLCBkb2pvIGlzIGxvYWRlZFxuXHQvL1x0XHRJQVcgdGhlIHBhY2thZ2UgbWFpbiBtb2R1bGUgZG9qby9tYWluLiBJbiB0aGUgZXZlbnQgeW91IHdpc2ggdG8gdXNlIGEgZm9yZWlnbiBsb2FkZXIsIHlvdSBtYXkgbG9hZCBkb2pvIGFzIGEgcGFja2FnZVxuXHQvL1x0XHR2aWEgdGhlIHBhY2thZ2UgbWFpbiBtb2R1bGUgZG9qby9tYWluIGFuZCB0aGlzIGxvYWRlciBpcyBub3QgcmVxdWlyZWQ7IHNlZSBkb2pvL3BhY2thZ2UuanNvbiBmb3IgZGV0YWlscy5cblx0Ly9cblx0Ly9cdFx0SW4gb3JkZXIgdG8ga2VlcCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHYxLnggbGluZSwgdGhpcyBsb2FkZXIgaW5jbHVkZXMgYWRkaXRpb25hbCBtYWNoaW5lcnkgdGhhdCBlbmFibGVzXG5cdC8vXHRcdHRoZSBkb2pvLnByb3ZpZGUsIGRvam8ucmVxdWlyZSBldCBhbCBBUEkuIFRoaXMgbWFjaGluZXJ5IGlzIGxvYWRlZCBieSBkZWZhdWx0LCBidXQgbWF5IGJlIGR5bmFtaWNhbGx5IHJlbW92ZWRcblx0Ly9cdFx0dmlhIHRoZSBoYXMuanMgQVBJIGFuZCBzdGF0aWNhbGx5IHJlbW92ZWQgdmlhIHRoZSBidWlsZCBzeXN0ZW0uXG5cdC8vXG5cdC8vXHRcdFRoaXMgbG9hZGVyIGluY2x1ZGVzIHNuaWZmaW5nIG1hY2hpbmVyeSB0byBkZXRlcm1pbmUgdGhlIGVudmlyb25tZW50OyB0aGUgZm9sbG93aW5nIGVudmlyb25tZW50cyBhcmUgc3VwcG9ydGVkOlxuXHQvL1xuXHQvL1x0XHQtIGJyb3dzZXJcblx0Ly9cdFx0LSBub2RlLmpzXG5cdC8vXHRcdC0gcmhpbm9cblx0Ly9cblx0Ly9cdFx0VGhpcyBpcyB0aGUgc28tY2FsbGVkIFwic291cmNlIGxvYWRlclwiLiBBcyBzdWNoLCBpdCBpbmNsdWRlcyBtYW55IG9wdGlvbmFsIGZlYXR1cmVzIHRoYXQgbWF5IGJlIGRpc2NhcmRlZCBieVxuXHQvL1x0XHRidWlsZGluZyBhIGN1c3RvbWl6ZWQgdmVyc2lvbiB3aXRoIHRoZSBidWlsZCBzeXN0ZW0uXG5cblx0Ly8gRGVzaWduIGFuZCBJbXBsZW1lbnRhdGlvbiBOb3Rlc1xuXHQvL1xuXHQvLyBUaGlzIGlzIGEgZG9qby1zcGVjaWZpYyBhZGFwdGlvbiBvZiBiZExvYWQsIGRvbmF0ZWQgdG8gdGhlIGRvam8gZm91bmRhdGlvbiBieSBBbHRvdmlzbyBMTEMuXG5cdC8vXG5cdC8vIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyBhbiBBTUQtY29tcGxpYW50IChodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb24pXG5cdC8vIGxvYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIG9wZXJhdGUgaW4gZWl0aGVyIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cyBtb2Rlcy5cblx0Ly9cblx0Ly8gU2luY2UgdGhpcyBtYWNoaW5lcnkgaW1wbGVtZW50cyBhIGxvYWRlciwgaXQgZG9lcyBub3QgaGF2ZSB0aGUgbHV4dXJ5IG9mIHVzaW5nIGEgbG9hZCBzeXN0ZW0gYW5kL29yXG5cdC8vIGxldmVyYWdpbmcgYSB1dGlsaXR5IGxpYnJhcnkuIFRoaXMgcmVzdWx0cyBpbiBhbiB1bnBsZWFzYW50bHkgbG9uZyBmaWxlOyBoZXJlIGlzIGEgcm9hZCBtYXAgb2YgdGhlIGNvbnRlbnRzOlxuXHQvL1xuXHQvL1x0IDEuIFNtYWxsIGxpYnJhcnkgZm9yIHVzZSBpbXBsZW1lbnRpbmcgdGhlIGxvYWRlci5cblx0Ly9cdCAyLiBEZWZpbmUgdGhlIGhhcy5qcyBBUEk7IHRoaXMgaXMgdXNlZCB0aHJvdWdob3V0IHRoZSBsb2FkZXIgdG8gYnJhY2tldCBmZWF0dXJlcy5cblx0Ly9cdCAzLiBEZWZpbmUgdGhlIG5vZGUuanMgYW5kIHJoaW5vIHNuaWZmcyBhbmQgc25pZmYuXG5cdC8vXHQgNC4gRGVmaW5lIHRoZSBsb2FkZXIncyBkYXRhLlxuXHQvL1x0IDUuIERlZmluZSB0aGUgY29uZmlndXJhdGlvbiBtYWNoaW5lcnkuXG5cdC8vXHQgNi4gRGVmaW5lIHRoZSBzY3JpcHQgZWxlbWVudCBzbmlmZmluZyBtYWNoaW5lcnkgYW5kIHNuaWZmIGZvciBjb25maWd1cmF0aW9uIGRhdGEuXG5cdC8vXHQgNy4gQ29uZmlndXJlIHRoZSBsb2FkZXIgSUFXIHRoZSBwcm92aWRlZCB1c2VyLCBkZWZhdWx0LCBhbmQgc25pZmZpbmcgZGF0YS5cblx0Ly9cdCA4LiBEZWZpbmUgdGhlIGdsb2JhbCByZXF1aXJlIGZ1bmN0aW9uLlxuXHQvL1x0IDkuIERlZmluZSB0aGUgbW9kdWxlIHJlc29sdXRpb24gbWFjaGluZXJ5LlxuXHQvL1x0MTAuIERlZmluZSB0aGUgbW9kdWxlIGFuZCBwbHVnaW4gbW9kdWxlIGRlZmluaXRpb24gbWFjaGluZXJ5XG5cdC8vXHQxMS4gRGVmaW5lIHRoZSBzY3JpcHQgaW5qZWN0aW9uIG1hY2hpbmVyeS5cblx0Ly9cdDEyLiBEZWZpbmUgdGhlIHdpbmRvdyBsb2FkIGRldGVjdGlvbi5cblx0Ly9cdDEzLiBEZWZpbmUgdGhlIGxvZ2dpbmcgQVBJLlxuXHQvL1x0MTQuIERlZmluZSB0aGUgdHJhY2luZyBBUEkuXG5cdC8vXHQxNi4gRGVmaW5lIHRoZSBBTUQgZGVmaW5lIGZ1bmN0aW9uLlxuXHQvL1x0MTcuIERlZmluZSB0aGUgZG9qbyB2MS54IHByb3ZpZGUvcmVxdWlyZSBtYWNoaW5lcnktLXNvIGNhbGxlZCBcImxlZ2FjeVwiIG1vZGVzLlxuXHQvL1x0MTguIFB1Ymxpc2ggZ2xvYmFsIHZhcmlhYmxlcy5cblx0Ly9cblx0Ly8gTGFuZ3VhZ2UgYW5kIEFjcm9ueW1zIGFuZCBJZGlvbXNcblx0Ly9cblx0Ly8gbW9kdWxlSWQ6IGEgQ0pTIG1vZHVsZSBpZGVudGlmaWVyLCAodXNlZCBmb3IgcHVibGljIEFQSXMpXG5cdC8vIG1pZDogbW9kdWxlSWQgKHVzZWQgaW50ZXJuYWxseSlcblx0Ly8gcGFja2FnZUlkOiBhIHBhY2thZ2UgaWRlbnRpZmllciAodXNlZCBmb3IgcHVibGljIEFQSXMpXG5cdC8vIHBpZDogcGFja2FnZUlkICh1c2VkIGludGVybmFsbHkpOyB0aGUgaW1wbGllZCBzeXN0ZW0gb3IgZGVmYXVsdCBwYWNrYWdlIGhhcyBwaWQ9PT1cIlwiXG5cdC8vIHBhY2s6IHBhY2thZ2UgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHJlZmVyZW5jZSBhIHBhY2thZ2Ugb2JqZWN0IChzaW5jZSBqYXZhc2NyaXB0IGhhcyByZXNlcnZlZCB3b3JkcyBpbmNsdWRpbmcgXCJwYWNrYWdlXCIpXG5cdC8vIHByaWQ6IHBsdWdpbiByZXNvdXJjZSBpZGVudGlmaWVyXG5cdC8vIFRoZSBpbnRlZ2VyIGNvbnN0YW50IDEgaXMgdXNlZCBpbiBwbGFjZSBvZiB0cnVlIGFuZCAwIGluIHBsYWNlIG9mIGZhbHNlLlxuXHQvL1xuXHQvLyBUaGUgXCJmb3JlaWduLWxvYWRlclwiIGhhcyBjb25kaXRpb24gaXMgZGVmaW5lZCBpZiBhbm90aGVyIGxvYWRlciBpcyBiZWluZyB1c2VkIChlLmcuIHdlYnBhY2spIGFuZCB0aGlzIGNvZGUgaXMgb25seVxuXHQvLyBuZWVkZWQgZm9yIHJlc29sdmluZyBtb2R1bGUgaWRlbnRpZmllcnMgYmFzZWQgb24gdGhlIGNvbmZpZy4gIEluIHRoaXMgY2FzZSwgb25seSB0aGUgZnVuY3Rpb25zIHJlcXVpcmUudG9VcmwgYW5kIFxuXHQvLyByZXF1aXJlLnRvQWJzTWlkIGFyZSBzdXBwb3J0ZWQuICBUaGUgcmVxdWlyZSBhbmQgZGVmaW5lIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZC5cblxuXHQvLyBkZWZpbmUgZ2xvYmFsXG5cdHZhciBnbG9iYWxPYmplY3QgPSAoZnVuY3Rpb24oKXtcblx0XHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gZ2xvYmFsIHNwZWMgZGVmaW5lcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBjYWxsZWQgJ2dsb2JhbCdcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxuXHRcdFx0Ly8gYGdsb2JhbGAgaXMgYWxzbyBkZWZpbmVkIGluIE5vZGVKU1xuXHRcdFx0cmV0dXJuIGdsb2JhbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdC8vIHdpbmRvdyBpcyBkZWZpbmVkIGluIGJyb3dzZXJzXG5cdFx0XHRyZXR1cm4gd2luZG93O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdC8vIHNlbGYgaXMgZGVmaW5lZCBpbiBXZWJXb3JrZXJzXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pKCk7XG5cblx0Ly8gZGVmaW5lIGEgbWluaW1hbCBsaWJyYXJ5IHRvIGhlbHAgYnVpbGQgdGhlIGxvYWRlclxuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7XG5cdFx0fSxcblxuXHRcdGlzRW1wdHkgPSBmdW5jdGlvbihpdCl7XG5cdFx0XHRmb3IodmFyIHAgaW4gaXQpe1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAxO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZyA9IHt9LnRvU3RyaW5nLFxuXG5cdFx0aXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGl0KXtcblx0XHRcdHJldHVybiB0b1N0cmluZy5jYWxsKGl0KSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG5cdFx0fSxcblxuXHRcdGlzU3RyaW5nID0gZnVuY3Rpb24oaXQpe1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpID09IFwiW29iamVjdCBTdHJpbmddXCI7XG5cdFx0fSxcblxuXHRcdGlzQXJyYXkgPSBmdW5jdGlvbihpdCl7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkgPT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXHRcdH0sXG5cblx0XHRmb3JFYWNoID0gZnVuY3Rpb24odmVjdG9yLCBjYWxsYmFjayl7XG5cdFx0XHRpZih2ZWN0b3Ipe1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmVjdG9yLmxlbmd0aDspe1xuXHRcdFx0XHRcdGNhbGxiYWNrKHZlY3RvcltpKytdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRtaXggPSBmdW5jdGlvbihkZXN0LCBzcmMpe1xuXHRcdFx0Zm9yKHZhciBwIGluIHNyYyl7XG5cdFx0XHRcdGRlc3RbcF0gPSBzcmNbcF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVzdDtcblx0XHR9LFxuXG5cdFx0bWFrZUVycm9yID0gZnVuY3Rpb24oZXJyb3IsIGluZm8pe1xuXHRcdFx0cmV0dXJuIG1peChuZXcgRXJyb3IoZXJyb3IpLCB7c3JjOlwiZG9qb0xvYWRlclwiLCBpbmZvOmluZm99KTtcblx0XHR9LFxuXG5cdFx0dWlkU2VlZCA9IDEsXG5cblx0XHR1aWQgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUmV0dXJucyBhIHVuaXF1ZSBpZGVudGlmaWVyICh3aXRoaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBkb2N1bWVudCkgb2YgdGhlIGZvcm0gL19kKy8uXG5cdFx0XHRyZXR1cm4gXCJfXCIgKyB1aWRTZWVkKys7XG5cdFx0fSxcblxuXHRcdC8vIEZJWE1FOiBob3cgdG8gZG9jIHdpbmRvdy5yZXF1aXJlKCkgYXBpXG5cblx0XHQvLyB0aGlzIHdpbGwgYmUgdGhlIGdsb2JhbCByZXF1aXJlIGZ1bmN0aW9uOyBkZWZpbmUgaXQgaW1tZWRpYXRlbHkgc28gd2UgY2FuIHN0YXJ0IGhhbmdpbmcgdGhpbmdzIG9mZiBvZiBpdFxuXHRcdHJlcSA9IGZ1bmN0aW9uKFxuXHRcdFx0Y29uZmlnLFx0XHQgIC8vKG9iamVjdCwgb3B0aW9uYWwpIGhhc2ggb2YgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0XHRkZXBlbmRlbmNpZXMsIC8vKGFycmF5IG9mIGNvbW1vbmpzLm1vZHVsZUlkLCBvcHRpb25hbCkgbGlzdCBvZiBtb2R1bGVzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXBwbHlpbmcgY2FsbGJhY2tcblx0XHRcdGNhbGxiYWNrXHQgIC8vKGZ1bmN0aW9uLCBvcHRpb25hbCkgbGFtYmRhIGV4cHJlc3Npb24gdG8gYXBwbHkgdG8gbW9kdWxlIHZhbHVlcyBpbXBsaWVkIGJ5IGRlcGVuZGVuY2llc1xuXHRcdCl7XG5cdFx0XHRyZXR1cm4gY29udGV4dFJlcXVpcmUoY29uZmlnLCBkZXBlbmRlbmNpZXMsIGNhbGxiYWNrLCAwLCByZXEpO1xuXHRcdH0sXG5cblx0XHQvLyB0aGUgbG9hZGVyIHVzZXMgdGhlIGhhcy5qcyBBUEkgdG8gY29udHJvbCBmZWF0dXJlIGluY2x1c2lvbi9leGNsdXNpb247IGRlZmluZSB0aGVuIHVzZSB0aHJvdWdob3V0XG5cdFx0Z2xvYmFsID0gZ2xvYmFsT2JqZWN0LFxuXG5cdFx0ZG9jID0gZ2xvYmFsLmRvY3VtZW50LFxuXG5cdFx0ZWxlbWVudCA9IGRvYyAmJiBkb2MuY3JlYXRlRWxlbWVudChcIkRpVlwiKSxcblxuXHRcdGhhcyA9IHJlcS5oYXMgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRcdHJldHVybiBpc0Z1bmN0aW9uKGhhc0NhY2hlW25hbWVdKSA/IChoYXNDYWNoZVtuYW1lXSA9IGhhc0NhY2hlW25hbWVdKGdsb2JhbCwgZG9jLCBlbGVtZW50KSkgOiBoYXNDYWNoZVtuYW1lXTtcblx0XHR9LFxuXG5cdFx0aGFzQ2FjaGUgPSBoYXMuY2FjaGUgPSBkZWZhdWx0Q29uZmlnLmhhc0NhY2hlO1xuXG5cdGlmIChpc0Z1bmN0aW9uKHVzZXJDb25maWcpKSB7XG5cdFx0dXNlckNvbmZpZyA9IHVzZXJDb25maWcoZ2xvYmFsT2JqZWN0KTtcblx0fVxuXG5cdGhhcy5hZGQgPSBmdW5jdGlvbihuYW1lLCB0ZXN0LCBub3csIGZvcmNlKXtcblx0XHQoaGFzQ2FjaGVbbmFtZV09PT11bmRlZmluZWQgfHwgZm9yY2UpICYmIChoYXNDYWNoZVtuYW1lXSA9IHRlc3QpO1xuXHRcdHJldHVybiBub3cgJiYgaGFzKG5hbWUpO1xuXHR9O1xuXG5cdCAwICYmIGhhcy5hZGQoXCJob3N0LW5vZGVcIiwgdXNlckNvbmZpZy5oYXMgJiYgXCJob3N0LW5vZGVcIiBpbiB1c2VyQ29uZmlnLmhhcyA/XG5cdFx0dXNlckNvbmZpZy5oYXNbXCJob3N0LW5vZGVcIl0gOlxuXHRcdCh0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIHByb2Nlc3MudmVyc2lvbnMudjgpKTtcblx0aWYoIDAgKXtcblx0XHQvLyBmaXh1cCB0aGUgZGVmYXVsdCBjb25maWcgZm9yIG5vZGUuanMgZW52aXJvbm1lbnRcblx0XHRyZXF1aXJlKFwiLi9fYmFzZS9jb25maWdOb2RlLmpzXCIpLmNvbmZpZyhkZWZhdWx0Q29uZmlnKTtcblx0XHQvLyByZW1lbWJlciBub2RlJ3MgcmVxdWlyZSAod2l0aCByZXNwZWN0IHRvIGJhc2VVcmw9PWRvam8ncyByb290KVxuXHRcdGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2gubm9kZVJlcXVpcmUgPSByZXF1aXJlO1xuXHR9XG5cblx0IDAgJiYgaGFzLmFkZChcImhvc3Qtcmhpbm9cIiwgdXNlckNvbmZpZy5oYXMgJiYgXCJob3N0LXJoaW5vXCIgaW4gdXNlckNvbmZpZy5oYXMgP1xuXHRcdHVzZXJDb25maWcuaGFzW1wiaG9zdC1yaGlub1wiXSA6XG5cdFx0KHR5cGVvZiBsb2FkID09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIFBhY2thZ2VzID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgUGFja2FnZXMgPT0gXCJvYmplY3RcIikpKTtcblx0aWYoIDAgKXtcblx0XHQvLyBvd2luZyB0byByaGlubydzIGxhbWUgZmVhdHVyZSB0aGF0IGhpZGVzIHRoZSBzb3VyY2Ugb2YgdGhlIHNjcmlwdCwgZ2l2ZSB0aGUgdXNlciBhIHdheSB0byBzcGVjaWZ5IHRoZSBiYXNlVXJsLi4uXG5cdFx0Zm9yKHZhciBiYXNlVXJsID0gdXNlckNvbmZpZy5iYXNlVXJsIHx8IFwiLlwiLCBhcmcsIHJoaW5vQXJncyA9IHRoaXMuYXJndW1lbnRzLCBpID0gMDsgaSA8IHJoaW5vQXJncy5sZW5ndGg7KXtcblx0XHRcdGFyZyA9IChyaGlub0FyZ3NbaSsrXSArIFwiXCIpLnNwbGl0KFwiPVwiKTtcblx0XHRcdGlmKGFyZ1swXSA9PSBcImJhc2VVcmxcIil7XG5cdFx0XHRcdGJhc2VVcmwgPSBhcmdbMV07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2FkKGJhc2VVcmwgKyBcIi9fYmFzZS9jb25maWdSaGluby5qc1wiKTtcblx0XHRyaGlub0Rvam9Db25maWcoZGVmYXVsdENvbmZpZywgYmFzZVVybCwgcmhpbm9BcmdzKTtcblx0fVxuXG5cdCAwICYmIGhhcy5hZGQoXCJob3N0LXdlYndvcmtlclwiLCAoKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcpICYmIChzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSk7XG5cdGlmKCAwICl7XG5cdFx0bWl4KGRlZmF1bHRDb25maWcuaGFzQ2FjaGUsIHtcblx0XHRcdFwiaG9zdC1icm93c2VyXCI6IDAsXG5cdFx0XHRcImRvbVwiOiAwLFxuXHRcdFx0XCJkb2pvLWRvbS1yZWFkeS1hcGlcIjogMCxcblx0XHRcdFwiZG9qby1zbmlmZlwiOiAwLFxuXHRcdFx0XCJkb2pvLWluamVjdC1hcGlcIjogMSxcblx0XHRcdFwiaG9zdC13ZWJ3b3JrZXJcIjogMSxcblx0XHRcdFwiZG9qby1ndWFyYW50ZWUtY29uc29sZVwiOiAwIC8vIGNvbnNvbGUgaXMgaW1tdXRhYmxlIGluIEZGMzArLCBzZWUgaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTgxMDBcblx0XHR9KTtcblxuXHRcdGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2ggPSB7XG5cdFx0XHRpbmplY3RVcmw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spe1xuXHRcdFx0XHQvLyBUT0RPOlxuXHRcdFx0XHQvL1x0XHRUaGlzIGlzIG5vdCBhc3luYywgbm9yIGNhbiBpdCBiZSBpbiBXZWJ3b3JrZXJzLiAgSXQgY291bGQgYmUgbWFkZSBiZXR0ZXIgYnkgcGFzc2luZ1xuXHRcdFx0XHQvL1x0XHR0aGUgZW50aXJlIHJlcXVpcmUgYXJyYXkgaW50byBpbXBvcnRTY3JpcHRzIGF0LiAgVGhpcyB3YXkgdGhlIHNjcmlwdHMgYXJlIGxvYWRlZCBpblxuXHRcdFx0XHQvL1x0XHRhc3luYyBtb2RlOyBldmVuIGlmIHRoZSBjYWxsYmFja3MgYXJlIHJhbiBpbiBzeW5jLiAgSXQgaXMgbm90IGEgbWFqb3IgaXNzdWUgYXMgd2Vid29ya2Vyc1xuXHRcdFx0XHQvL1x0XHR0ZW5kIHRvIGJlIGxvbmcgcnVubmluZyB3aGVyZSBpbml0aWFsIHN0YXJ0dXAgaXMgbm90IGEgbWFqb3IgZmFjdG9yLlxuXG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRpbXBvcnRTY3JpcHRzKHVybCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdGNvbnNvbGUuaW5mbyhcImZhaWxlZCB0byBsb2FkIHJlc291cmNlIChcIiArIHVybCArIFwiKVwiKTtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIHVzZXJDb25maWcgaGFzIHRlc3RzIG92ZXJyaWRlIGRlZmF1bHRDb25maWcgaGFzIHRlc3RzOyBkbyB0aGlzIGFmdGVyIHRoZSBlbnZpcm9ubWVudCBkZXRlY3Rpb24gYmVjYXVzZVxuXHQvLyB0aGUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIHVzdWFsbHkgc2V0cyBzb21lIGhhcyBmZWF0dXJlIHZhbHVlcyBpbiB0aGUgaGFzQ2FjaGUuXG5cdGZvcih2YXIgcCBpbiB1c2VyQ29uZmlnLmhhcyl7XG5cdFx0aGFzLmFkZChwLCB1c2VyQ29uZmlnLmhhc1twXSwgMCwgMSk7XG5cdH1cblxuXHQvL1xuXHQvLyBkZWZpbmUgdGhlIGxvYWRlciBkYXRhXG5cdC8vXG5cblx0Ly8gdGhlIGxvYWRlciB3aWxsIHVzZSB0aGVzZSBsaWtlIHN5bWJvbHMgaWYgdGhlIGxvYWRlciBoYXMgdGhlIHRyYWNlQXBpOyBvdGhlcndpc2Vcblx0Ly8gZGVmaW5lIG1hZ2ljIG51bWJlcnMgc28gdGhhdCBtb2R1bGVzIGNhbiBiZSBwcm92aWRlZCBhcyBwYXJ0IG9mIGRlZmF1bHRDb25maWdcblx0dmFyIHJlcXVlc3RlZCA9IDEsXG5cdFx0YXJyaXZlZCA9IDIsXG5cdFx0bm9ubW9kdWxlID0gMyxcblx0XHRleGVjdXRpbmcgPSA0LFxuXHRcdGV4ZWN1dGVkID0gNTtcblxuXHRpZiggMCApe1xuXHRcdC8vIHRoZXNlIG1ha2UgZGVidWdnaW5nIG5pY2U7IGJ1dCB1c2luZyBzdHJpbmdzIGZvciBzeW1ib2xzIGlzIGEgZ3Jvc3Mgcm9va2llIGVycm9yOyBkb24ndCBkbyBpdCBmb3IgcHJvZHVjdGlvbiBjb2RlXG5cdFx0cmVxdWVzdGVkID0gXCJyZXF1ZXN0ZWRcIjtcblx0XHRhcnJpdmVkID0gXCJhcnJpdmVkXCI7XG5cdFx0bm9ubW9kdWxlID0gXCJub3QtYS1tb2R1bGVcIjtcblx0XHRleGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuXHRcdGV4ZWN1dGVkID0gXCJleGVjdXRlZFwiO1xuXHR9XG5cblx0dmFyIGxlZ2FjeU1vZGUgPSAwLFxuXHRcdHN5bmMgPSBcInN5bmNcIixcblx0XHR4ZCA9IFwieGRcIixcblx0XHRzeW5jRXhlY1N0YWNrID0gW10sXG5cdFx0ZG9qb1JlcXVpcmVQbHVnaW4gPSAwLFxuXHRcdGNoZWNrRG9qb1JlcXVpcmVQbHVnaW4gPSBub29wLFxuXHRcdHRyYW5zZm9ybVRvQW1kID0gbm9vcCxcblx0XHRnZXRYaHI7XG5cdGlmKCAwICl7XG5cdFx0cmVxLmlzWGRVcmwgPSBub29wO1xuXG5cdFx0cmVxLmluaXRTeW5jTG9hZGVyID0gZnVuY3Rpb24oZG9qb1JlcXVpcmVQbHVnaW5fLCBjaGVja0Rvam9SZXF1aXJlUGx1Z2luXywgdHJhbnNmb3JtVG9BbWRfKXtcblx0XHRcdC8vIHRoZSBmaXJzdCBkb2pvL19iYXNlL2xvYWRlciBsb2FkZWQgZ2V0cyB0byBkZWZpbmUgdGhlc2UgdmFyaWFibGVzOyB0aGV5IGFyZSBkZXNpZ25lZCB0byB3b3JrXG5cdFx0XHQvLyBpbiB0aGUgcHJlc2VuY2Ugb2YgemVybyB0byBtYW55IG1hcHBlZCBkb2pvL19iYXNlL2xvYWRlcnNcblx0XHRcdGlmKCFkb2pvUmVxdWlyZVBsdWdpbil7XG5cdFx0XHRcdGRvam9SZXF1aXJlUGx1Z2luID0gZG9qb1JlcXVpcmVQbHVnaW5fO1xuXHRcdFx0XHRjaGVja0Rvam9SZXF1aXJlUGx1Z2luID0gY2hlY2tEb2pvUmVxdWlyZVBsdWdpbl87XG5cdFx0XHRcdHRyYW5zZm9ybVRvQW1kID0gdHJhbnNmb3JtVG9BbWRfO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzeW5jOnN5bmMsXG5cdFx0XHRcdHJlcXVlc3RlZDpyZXF1ZXN0ZWQsXG5cdFx0XHRcdGFycml2ZWQ6YXJyaXZlZCxcblx0XHRcdFx0bm9ubW9kdWxlOm5vbm1vZHVsZSxcblx0XHRcdFx0ZXhlY3V0aW5nOmV4ZWN1dGluZyxcblx0XHRcdFx0ZXhlY3V0ZWQ6ZXhlY3V0ZWQsXG5cdFx0XHRcdHN5bmNFeGVjU3RhY2s6c3luY0V4ZWNTdGFjayxcblx0XHRcdFx0bW9kdWxlczptb2R1bGVzLFxuXHRcdFx0XHRleGVjUTpleGVjUSxcblx0XHRcdFx0Z2V0TW9kdWxlOmdldE1vZHVsZSxcblx0XHRcdFx0aW5qZWN0TW9kdWxlOmluamVjdE1vZHVsZSxcblx0XHRcdFx0c2V0QXJyaXZlZDpzZXRBcnJpdmVkLFxuXHRcdFx0XHRzaWduYWw6c2lnbmFsLFxuXHRcdFx0XHRmaW5pc2hFeGVjOmZpbmlzaEV4ZWMsXG5cdFx0XHRcdGV4ZWNNb2R1bGU6ZXhlY01vZHVsZSxcblx0XHRcdFx0ZG9qb1JlcXVpcmVQbHVnaW46ZG9qb1JlcXVpcmVQbHVnaW4sXG5cdFx0XHRcdGdldExlZ2FjeU1vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gbGVnYWN5TW9kZTt9LFxuXHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGU6Z3VhcmRDaGVja0NvbXBsZXRlXG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHRpZiggMCAgfHwgIDAgKXtcblx0XHRcdC8vIGluIGxlZ2FjeSBzeW5jIG1vZGUsIHRoZSBsb2FkZXIgbmVlZHMgYSBtaW5pbWFsIFhIUiBsaWJyYXJ5XG5cblx0XHRcdHZhciBsb2NhdGlvblByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wsXG5cdFx0XHRcdGxvY2F0aW9uSG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG5cdFx0XHRyZXEuaXNYZFVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHRcdGlmKC9eXFwuLy50ZXN0KHVybCkpe1xuXHRcdFx0XHRcdC8vIGJlZ2lucyB3aXRoIGEgZG90IGlzIGFsd2F5cyByZWxhdGl2ZSB0byBwYWdlIFVSTDsgdGhlcmVmb3JlIG5vdCB4ZG9tYWluXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKC9eXFwvXFwvLy50ZXN0KHVybCkpe1xuXHRcdFx0XHRcdC8vIGZvciB2MS42LSBiYWNrY29tcGF0LCB1cmwgc3RhcnRpbmcgd2l0aCAvLyBpbmRpY2F0ZXMgeGRvbWFpblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGdldCBwcm90b2NvbCBhbmQgaG9zdFxuXHRcdFx0XHQvLyBcXC8rIHRha2VzIGNhcmUgb2YgdGhlIHR5cGljYWwgZmlsZSBwcm90b2NvbCB0aGF0IGxvb2tzIGxpa2UgZmlsZTovLy9kcml2ZS9wYXRoL3RvL2ZpbGVcblx0XHRcdFx0Ly8gbG9jYXRpb25Ib3N0IGlzIGZhbHN5IGlmIGZpbGUgcHJvdG9jb2wgPT4gaWYgbG9jYXRpb25Qcm90b2NvbCBtYXRjaGVzIGFuZCBpcyBcImZpbGU6XCIsIHx8IHdpbGwgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdHZhciBtYXRjaCA9IHVybC5tYXRjaCgvXihbXlxcL1xcOl0rXFw6KVxcLysoW15cXC9dKykvKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoICYmIChtYXRjaFsxXSAhPSBsb2NhdGlvblByb3RvY29sIHx8IChsb2NhdGlvbkhvc3QgJiYgbWF0Y2hbMl0gIT0gbG9jYXRpb25Ib3N0KSk7XG5cdFx0XHR9O1xuXG5cblx0XHRcdC8vIG5vdGU6IHRvIGdldCB0aGUgZmlsZTovLyBwcm90b2NvbCB0byB3b3JrIGluIEZGLCB5b3UgbXVzdCBzZXQgc2VjdXJpdHkuZmlsZXVyaS5zdHJpY3Rfb3JpZ2luX3BvbGljeSB0byBmYWxzZSBpbiBhYm91dDpjb25maWdcblx0XHRcdCAxIHx8IGhhcy5hZGQoXCJkb2pvLXhoci1mYWN0b3J5XCIsIDEpO1xuXHRcdFx0IDAgJiYgaGFzLmFkZChcImRvam8tZm9yY2UtYWN0aXZleC14aHJcIiwgIDEgICYmICFkb2MuYWRkRXZlbnRMaXN0ZW5lciAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT0gXCJmaWxlOlwiKTtcblx0XHRcdGhhcy5hZGQoXCJuYXRpdmUteGhyXCIsIHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKTtcblx0XHRcdGlmKGhhcyhcIm5hdGl2ZS14aHJcIikgJiYgISAwICl7XG5cdFx0XHRcdGdldFhociA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIGlmIGluIHRoZSBicm93c2VyIGFuIG9sZCBJRTsgZmluZCBhbiB4aHJcblx0XHRcdFx0Zm9yKHZhciBYTUxIVFRQX1BST0dJRFMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddLCBwcm9naWQsIGkgPSAwOyBpIDwgMzspe1xuXHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdHByb2dpZCA9IFhNTEhUVFBfUFJPR0lEU1tpKytdO1xuXHRcdFx0XHRcdFx0aWYobmV3IEFjdGl2ZVhPYmplY3QocHJvZ2lkKSl7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgcHJvZ2lkIHdvcmtzOyB0aGVyZWZvcmUsIHVzZSBpdCBmcm9tIG5vdyBvblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHQvLyBzcXVlbGNoOyB3ZSdyZSBqdXN0IHRyeWluZyB0byBmaW5kIGEgZ29vZCBBY3RpdmVYIHByb2dpZFxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhleSBhbGwgZmFpbCwgdGhlbiBwcm9naWQgZW5kcyB1cCBhcyB0aGUgbGFzdCBhdHRlbXB0IGFuZCB0aGF0IHdpbGwgc2lnbmFsIHRoZSBlcnJvclxuXHRcdFx0XHRcdFx0Ly8gdGhlIGZpcnN0IHRpbWUgdGhlIGNsaWVudCBhY3R1YWxseSB0cmllcyB0byBleGVjIGFuIHhoclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRnZXRYaHIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChwcm9naWQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmVxLmdldFhociA9IGdldFhocjtcblxuXHRcdFx0aGFzLmFkZChcImRvam8tZ2V0dGV4dC1hcGlcIiwgMSk7XG5cdFx0XHRyZXEuZ2V0VGV4dCA9IGZ1bmN0aW9uKHVybCwgYXN5bmMsIG9uTG9hZCl7XG5cdFx0XHRcdHZhciB4aHIgPSBnZXRYaHIoKTtcblx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGZpeHVwVXJsKHVybCksIGZhbHNlKTtcblx0XHRcdFx0eGhyLnNlbmQobnVsbCk7XG5cdFx0XHRcdGlmKHhoci5zdGF0dXMgPT0gMjAwIHx8ICghbG9jYXRpb24uaG9zdCAmJiAheGhyLnN0YXR1cykpe1xuXHRcdFx0XHRcdGlmKG9uTG9hZCl7XG5cdFx0XHRcdFx0XHRvbkxvYWQoeGhyLnJlc3BvbnNlVGV4dCwgYXN5bmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGhyb3cgbWFrZUVycm9yKFwieGhyRmFpbGVkXCIsIHhoci5zdGF0dXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0fTtcblx0XHR9XG5cdH1lbHNle1xuXHRcdHJlcS5hc3luYyA9IDE7XG5cdH1cblxuXHQvL1xuXHQvLyBsb2FkZXIgZXZhbFxuXHQvL1xuXHR2YXIgZXZhbF8gPSAgIDEgID9cblx0XHQvLyBub29wIGV2YWwgaWYgdGhlcmUgYXJlIGNzcCByZXN0cmljdGlvbnNcblx0XHRmdW5jdGlvbigpe30gOlxuXHRcdC8vIHVzZSB0aGUgZnVuY3Rpb24gY29uc3RydWN0b3Igc28gb3VyIGV2YWwgaXMgc2NvcGVkIGNsb3NlIHRvIChidXQgbm90IGluKSBpbiB0aGUgZ2xvYmFsIHNwYWNlIHdpdGggbWluaW1hbCBwb2xsdXRpb25cblx0XHRuZXcgRnVuY3Rpb24oJ3JldHVybiBldmFsKGFyZ3VtZW50c1swXSk7Jyk7XG5cblx0cmVxLmV2YWwgPVxuXHRcdGZ1bmN0aW9uKHRleHQsIGhpbnQpe1xuXHRcdFx0cmV0dXJuIGV2YWxfKHRleHQgKyBcIlxcclxcbi8vIyBzb3VyY2VVUkw9XCIgKyBoaW50KTtcblx0XHR9O1xuXG5cdC8vXG5cdC8vIGxvYWRlciBtaWNybyBldmVudHMgQVBJXG5cdC8vXG5cdHZhciBsaXN0ZW5lclF1ZXVlcyA9IHt9LFxuXHRcdGVycm9yID0gXCJlcnJvclwiLFxuXHRcdHNpZ25hbCA9IHJlcS5zaWduYWwgPSBmdW5jdGlvbih0eXBlLCBhcmdzKXtcblx0XHRcdHZhciBxdWV1ZSA9IGxpc3RlbmVyUXVldWVzW3R5cGVdO1xuXHRcdFx0Ly8gbm90aWNlIHdlIHJ1biBhIGNvcHkgb2YgdGhlIHF1ZXVlOyB0aGlzIGFsbG93cyBsaXN0ZW5lcnMgdG8gYWRkL3JlbW92ZVxuXHRcdFx0Ly8gb3RoZXIgbGlzdGVuZXJzIHdpdGhvdXQgYWZmZWN0aW5nIHRoaXMgcGFydGljdWxhciBzaWduYWxcblx0XHRcdGZvckVhY2gocXVldWUgJiYgcXVldWUuc2xpY2UoMCksIGZ1bmN0aW9uKGxpc3RlbmVyKXtcblx0XHRcdFx0bGlzdGVuZXIuYXBwbHkobnVsbCwgaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc10pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvbiA9IHJlcS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIG5vdGljZSBhIHF1ZXVlIGlzIG5vdCBjcmVhdGVkIHVudGlsIGEgY2xpZW50IGFjdHVhbGx5IGNvbm5lY3RzXG5cdFx0XHR2YXIgcXVldWUgPSBsaXN0ZW5lclF1ZXVlc1t0eXBlXSB8fCAobGlzdGVuZXJRdWV1ZXNbdHlwZV0gPSBbXSk7XG5cdFx0XHRxdWV1ZS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlbW92ZTpmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGk8cXVldWUubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdFx0aWYocXVldWVbaV09PT1saXN0ZW5lcil7XG5cdFx0XHRcdFx0XHRcdHF1ZXVlLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXG5cdC8vIGNvbmZpZ3VyYXRpb24gbWFjaGluZXJ5OyB3aXRoIGFuIG9wdGltaXplZC9idWlsdCBkZWZhdWx0Q29uZmlnLCBhbGwgY29uZmlndXJhdGlvbiBtYWNoaW5lcnkgY2FuIGJlIGRpc2NhcmRlZFxuXHQvLyBsZXhpY2FsIHZhcmlhYmxlcyBob2xkIGtleSBsb2FkZXIgZGF0YSBzdHJ1Y3R1cmVzIHRvIGhlbHAgd2l0aCBtaW5pZmljYXRpb247IHRoZXNlIG1heSBiZSBjb21wbGV0ZWx5LFxuXHQvLyBvbmUtdGltZSBpbml0aWFsaXplZCBieSBkZWZhdWx0Q29uZmlnIGZvciBvcHRpbWl6ZWQvYnVpbHQgdmVyc2lvbnNcblx0dmFyXG5cdFx0YWxpYXNlc1xuXHRcdFx0Ly8gYSB2ZWN0b3Igb2YgcGFpcnMgb2YgW3JlZ2V4cyBvciBzdHJpbmcsIHJlcGxhY2VtZW50XSA9PiAoYWxpYXMsIGFjdHVhbClcblx0XHRcdD0gW10sXG5cblx0XHRwYXRoc1xuXHRcdFx0Ly8gQ29tbW9uSlMgcGF0aHNcblx0XHRcdD0ge30sXG5cblx0XHRwYXRoc01hcFByb2dcblx0XHRcdC8vIGxpc3Qgb2YgKGZyb20tcGF0aCwgdG8tcGF0aCwgcmVnZXgsIGxlbmd0aCkgZGVyaXZlZCBmcm9tIHBhdGhzO1xuXHRcdFx0Ly8gYSBcInByb2dyYW1cIiB0byBhcHBseSBwYXRoczsgc2VlIGNvbXB1dGVNYXBQcm9nXG5cdFx0XHQ9IFtdLFxuXG5cdFx0cGFja3Ncblx0XHRcdC8vIGEgbWFwIGZyb20gcGFja2FnZUlkIHRvIHBhY2thZ2UgY29uZmlndXJhdGlvbiBvYmplY3Q7IHNlZSBmaXh1cFBhY2thZ2VJbmZvXG5cdFx0XHQ9IHt9LFxuXG5cdFx0bWFwID0gcmVxLm1hcFxuXHRcdFx0Ly8gQU1EIG1hcCBjb25maWcgdmFyaWFibGU7IGRvam8vX2Jhc2Uva2VybmVsIG5lZWRzIHJlcS5tYXAgdG8gZmlndXJlIG91dCB0aGUgc2NvcGUgbWFwXG5cdFx0XHQ9IHt9LFxuXG5cdFx0bWFwUHJvZ3Ncblx0XHRcdC8vIHZlY3RvciBvZiBxdWFkcyBhcyBkZXNjcmliZWQgYnkgY29tcHV0ZU1hcFByb2c7IG1hcC1rZXkgaXMgQU1EIG1hcCBrZXksIG1hcC12YWx1ZSBpcyBBTUQgbWFwIHZhbHVlXG5cdFx0XHQ9IFtdLFxuXG5cdFx0bW9kdWxlc1xuXHRcdFx0Ly8gQSBoYXNoOihtaWQpIC0tPiAobW9kdWxlLW9iamVjdCkgdGhlIG1vZHVsZSBuYW1lc3BhY2Vcblx0XHRcdC8vXG5cdFx0XHQvLyBwaWQ6IHRoZSBwYWNrYWdlIGlkZW50aWZpZXIgdG8gd2hpY2ggdGhlIG1vZHVsZSBiZWxvbmdzIChlLmcuLCBcImRvam9cIik7IFwiXCIgaW5kaWNhdGVzIHRoZSBzeXN0ZW0gb3IgZGVmYXVsdCBwYWNrYWdlXG5cdFx0XHQvLyBtaWQ6IHRoZSBmdWxseS1yZXNvbHZlZCAoaS5lLiwgbWFwcGluZ3MgaGF2ZSBiZWVuIGFwcGxpZWQpIG1vZHVsZSBpZGVudGlmaWVyIHdpdGhvdXQgdGhlIHBhY2thZ2UgaWRlbnRpZmllciAoZS5nLiwgXCJkb2pvL2lvL3NjcmlwdFwiKVxuXHRcdFx0Ly8gdXJsOiB0aGUgVVJMIGZyb20gd2hpY2ggdGhlIG1vZHVsZSB3YXMgcmV0cmlldmVkXG5cdFx0XHQvLyBwYWNrOiB0aGUgcGFja2FnZSBvYmplY3Qgb2YgdGhlIHBhY2thZ2UgdG8gd2hpY2ggdGhlIG1vZHVsZSBiZWxvbmdzXG5cdFx0XHQvLyBleGVjdXRlZDogMCA9PiBub3QgZXhlY3V0ZWQ7IGV4ZWN1dGluZyA9PiBpbiB0aGUgcHJvY2VzcyBvZiB0cmF2ZXJzaW5nIGRlcHMgYW5kIHJ1bm5pbmcgZmFjdG9yeTsgZXhlY3V0ZWQgPT4gZmFjdG9yeSBoYXMgYmVlbiBleGVjdXRlZFxuXHRcdFx0Ly8gZGVwczogdGhlIGRlcGVuZGVuY3kgdmVjdG9yIGZvciB0aGlzIG1vZHVsZSAodmVjdG9yIG9mIG1vZHVsZXMgb2JqZWN0cylcblx0XHRcdC8vIGRlZjogdGhlIGZhY3RvcnkgZm9yIHRoaXMgbW9kdWxlXG5cdFx0XHQvLyByZXN1bHQ6IHRoZSByZXN1bHQgb2YgdGhlIHJ1bm5pbmcgdGhlIGZhY3RvcnkgZm9yIHRoaXMgbW9kdWxlXG5cdFx0XHQvLyBpbmplY3RlZDogKDAgfCByZXF1ZXN0ZWQgfCBhcnJpdmVkKSB0aGUgc3RhdHVzIG9mIHRoZSBtb2R1bGU7IG5vbm1vZHVsZSBtZWFucyB0aGUgcmVzb3VyY2UgZGlkIG5vdCBjYWxsIGRlZmluZVxuXHRcdFx0Ly8gbG9hZDogcGx1Z2luIGxvYWQgZnVuY3Rpb247IGFwcGxpY2FibGUgb25seSBmb3IgcGx1Z2luc1xuXHRcdFx0Ly9cblx0XHRcdC8vIE1vZHVsZXMgZ28gdGhyb3VnaCBzZXZlcmFsIHBoYXNlcyBpbiBjcmVhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAxLiBSZXF1ZXN0ZWQ6IHNvbWUgb3RoZXIgbW9kdWxlJ3MgZGVmaW5pdGlvbiBvciBhIHJlcXVpcmUgYXBwbGljYXRpb24gY29udGFpbmVkIHRoZSByZXF1ZXN0ZWQgbW9kdWxlIGluXG5cdFx0XHQvL1x0ICBpdHMgZGVwZW5kZW5jeSB2ZWN0b3Igb3IgZXhlY3V0aW5nIGNvZGUgZXhwbGljaXRseSBkZW1hbmRzIGEgbW9kdWxlIHZpYSByZXEucmVxdWlyZS5cblx0XHRcdC8vXG5cdFx0XHQvLyAyLiBJbmplY3RlZDogYSBzY3JpcHQgZWxlbWVudCBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgaW5zZXJ0LXBvaW50IGVsZW1lbnQgZGVtYW5kaW5nIHRoZSByZXNvdXJjZSBpbXBsaWVkIGJ5IHRoZSBVUkxcblx0XHRcdC8vXG5cdFx0XHQvLyAzLiBMb2FkZWQ6IHRoZSByZXNvdXJjZSBpbmplY3RlZCBpbiBbMl0gaGFzIGJlZW4gZXZhbHVhdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIDQuIERlZmluZWQ6IHRoZSByZXNvdXJjZSBjb250YWluZWQgYSBkZWZpbmUgc3RhdGVtZW50IHRoYXQgYWR2aXNlZCB0aGUgbG9hZGVyIGFib3V0IHRoZSBtb2R1bGUuIE5vdGljZSB0aGF0IHNvbWVcblx0XHRcdC8vXHQgIHJlc291cmNlcyBtYXkganVzdCBjb250YWluIGEgYnVuZGxlIG9mIGNvZGUgYW5kIG5ldmVyIGZvcm1hbGx5IGRlZmluZSBhIG1vZHVsZSB2aWEgZGVmaW5lXG5cdFx0XHQvL1xuXHRcdFx0Ly8gNS4gRXZhbHVhdGVkOiB0aGUgbW9kdWxlIHdhcyBkZWZpbmVkIHZpYSBkZWZpbmUgYW5kIHRoZSBsb2FkZXIgaGFzIGV2YWx1YXRlZCB0aGUgZmFjdG9yeSBhbmQgY29tcHV0ZWQgYSByZXN1bHQuXG5cdFx0XHQ9IHt9LFxuXG5cdFx0Y2FjaGVCdXN0XG5cdFx0XHQvLyBxdWVyeSBzdHJpbmcgdG8gYXBwZW5kIHRvIG1vZHVsZSBVUkxzIHRvIGJ1c3QgYnJvd3NlciBjYWNoZVxuXHRcdFx0PSBcIlwiLFxuXG5cdFx0Y2FjaGVcblx0XHRcdC8vIGhhc2g6KG1pZCB8IHVybCktLT4oZnVuY3Rpb24gfCBzdHJpbmcpXG5cdFx0XHQvL1xuXHRcdFx0Ly8gQSBjYWNoZSBvZiByZXNvdXJjZXMuIFRoZSByZXNvdXJjZXMgYXJyaXZlIHZpYSBhIGNvbmZpZy5jYWNoZSBvYmplY3QsIHdoaWNoIGlzIGEgaGFzaCBmcm9tIGVpdGhlciBtaWQgLS0+IGZ1bmN0aW9uIG9yXG5cdFx0XHQvLyB1cmwgLS0+IHN0cmluZy4gVGhlIHVybCBrZXkgaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHRoZSBtaWQga2V5IGJ5IGFsd2F5cyBjb250YWluaW5nIHRoZSBwcmVmaXggXCJ1cmw6XCIuIHVybCBrZXlzIGFzIHByb3ZpZGVkXG5cdFx0XHQvLyBieSBjb25maWcuY2FjaGUgYWx3YXlzIGhhdmUgYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50cyBvZiB0aGUgcmVzb3VyY2UgYXQgdGhlIGdpdmVuIHVybC4gbWlkIGtleXMgYXMgcHJvdmlkZWRcblx0XHRcdC8vIGJ5IGNvbmZpZ2wuY2FjaGUgYWx3YXlzIGhhdmUgYSBmdW5jdGlvbiB2YWx1ZSB0aGF0IGNhdXNlcyB0aGUgc2FtZSBjb2RlIHRvIGV4ZWN1dGUgYXMgaWYgdGhlIG1vZHVsZSB3YXMgc2NyaXB0IGluamVjdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIEJvdGgga2luZHMgb2Yga2V5LXZhbHVlIHBhaXJzIGFyZSBlbnRlcmVkIGludG8gY2FjaGUgdmlhIHRoZSBmdW5jdGlvbiBjb25zdW1lUGVuZGluZ0NhY2hlLCB3aGljaCBtYXkgcmVsb2NhdGUga2V5cyBhcyBnaXZlblxuXHRcdFx0Ly8gYnkgYW55IG1hcHBpbmdzICppZmYqIHRoZSBjb25maWcuY2FjaGUgd2FzIHJlY2VpdmVkIGFzIHBhcnQgb2YgYSBtb2R1bGUgcmVzb3VyY2UgcmVxdWVzdC5cblx0XHRcdC8vXG5cdFx0XHQvLyBGdXJ0aGVyLCBmb3IgbWlkIGtleXMsIHRoZSBpbXBsaWVkIHVybCBpcyBjb21wdXRlZCBhbmQgdGhlIHZhbHVlIGlzIGVudGVyZWQgaW50byB0aGF0IGtleSBhcyB3ZWxsLiBUaGlzIGFsbG93cyBtYXBwZWQgbW9kdWxlc1xuXHRcdFx0Ly8gdG8gcmV0cmlldmUgY2FjaGVkIGl0ZW1zIHRoYXQgbWF5IGhhdmUgYXJyaXZlZCBjb25zZXF1ZW50IHRvIGFub3RoZXIgbmFtZXNwYWNlLlxuXHRcdFx0Ly9cblx0XHRcdCA9IHt9LFxuXG5cdFx0dXJsS2V5UHJlZml4XG5cdFx0XHQvLyB0aGUgcHJlZml4IHRvIHByZXBlbmQgdG8gYSBVUkwga2V5IGluIHRoZSBjYWNoZS5cblx0XHRcdD0gXCJ1cmw6XCIsXG5cblx0XHRwZW5kaW5nQ2FjaGVJbnNlcnRcblx0XHRcdC8vIGhhc2g6KG1pZCktLT4oZnVuY3Rpb24pXG5cdFx0XHQvL1xuXHRcdFx0Ly8gR2l2ZXMgYSBzZXQgb2YgY2FjaGUgbW9kdWxlcyBwZW5kaW5nIGVudHJ5IGludG8gY2FjaGUuIFdoZW4gY2FjaGVkIG1vZHVsZXMgYXJlIHB1Ymxpc2hlZCB0byB0aGUgbG9hZGVyLCB0aGV5IGFyZVxuXHRcdFx0Ly8gZW50ZXJlZCBpbnRvIHBlbmRpbmdDYWNoZUluc2VydDsgbW9kdWxlcyBhcmUgdGhlbiBwcmVzc2VkIGludG8gY2FjaGUgdXBvbiAoMSkgQU1EIGRlZmluZSBvciAoMikgdXBvbiByZWNlaXZpbmcgYW5vdGhlclxuXHRcdFx0Ly8gaW5kZXBlbmRlbnQgc2V0IG9mIGNhY2hlZCBtb2R1bGVzLiAoMSkgaXMgdGhlIHVzdWFsIGNhc2UsIGFuZCB0aGlzIGNhc2UgYWxsb3dzIG5vcm1hbGl6aW5nIG1pZHMgZ2l2ZW4gaW4gdGhlIHBlbmRpbmdcblx0XHRcdC8vIGNhY2hlIGZvciB0aGUgbG9jYWwgY29uZmlndXJhdGlvbiwgcG9zc2libHkgcmVsb2NhdGluZyBtb2R1bGVzLlxuXHRcdFx0ID0ge30sXG5cblx0XHRkb2pvU25pZmZDb25maWdcblx0XHRcdC8vIG1hcCBvZiBjb25maWd1cmF0aW9uIHZhcmlhYmxlc1xuXHRcdFx0Ly8gZ2l2ZSB0aGUgZGF0YS1kb2pvLWNvbmZpZyBhcyBzbmlmZmVkIGZyb20gdGhlIGRvY3VtZW50IChpZiBhbnkpXG5cdFx0XHQ9IHt9LFxuXG5cdFx0aW5zZXJ0UG9pbnRTaWJsaW5nXG5cdFx0XHQvLyB0aGUgbm9kZXMgdXNlZCB0byBsb2NhdGUgd2hlcmUgc2NyaXB0cyBhcmUgaW5qZWN0ZWQgaW50byB0aGUgZG9jdW1lbnRcblx0XHRcdD0gMDtcblxuXHRpZiggMSApe1xuXHRcdGlmICghIDEgKSB7XG5cdFx0XHR2YXIgY29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCA9IGZ1bmN0aW9uKHJlZmVyZW5jZU1vZHVsZSwgY2xlYXIpe1xuXHRcdFx0XHRcdGNsZWFyID0gY2xlYXIgIT09IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBwLCBpdGVtLCBtYXRjaCwgbm93LCBtO1xuXHRcdFx0XHRcdGZvcihwIGluIHBlbmRpbmdDYWNoZUluc2VydCl7XG5cdFx0XHRcdFx0XHRpdGVtID0gcGVuZGluZ0NhY2hlSW5zZXJ0W3BdO1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBwLm1hdGNoKC9edXJsXFw6KC4rKS8pO1xuXHRcdFx0XHRcdFx0aWYobWF0Y2gpe1xuXHRcdFx0XHRcdFx0XHRjYWNoZVt1cmxLZXlQcmVmaXggKyB0b1VybChtYXRjaFsxXSwgcmVmZXJlbmNlTW9kdWxlKV0gPSAgaXRlbTtcblx0XHRcdFx0XHRcdH1lbHNlIGlmKHA9PVwiKm5vd1wiKXtcblx0XHRcdFx0XHRcdFx0bm93ID0gaXRlbTtcblx0XHRcdFx0XHRcdH1lbHNlIGlmKHAhPVwiKm5vcmVmXCIpe1xuXHRcdFx0XHRcdFx0XHRtID0gZ2V0TW9kdWxlSW5mbyhwLCByZWZlcmVuY2VNb2R1bGUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRjYWNoZVttLm1pZF0gPSBjYWNoZVt1cmxLZXlQcmVmaXggKyBtLnVybF0gPSBpdGVtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihub3cpe1xuXHRcdFx0XHRcdFx0bm93KGNyZWF0ZVJlcXVpcmUocmVmZXJlbmNlTW9kdWxlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNsZWFyKXtcblx0XHRcdFx0XHRcdHBlbmRpbmdDYWNoZUluc2VydCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIGVzY2FwZVN0cmluZyA9IGZ1bmN0aW9uKHMpe1xuXHRcdFx0XHRyZXR1cm4gcy5yZXBsYWNlKC8oW1xcLiQ/Knx7fVxcKFxcKVxcW1xcXVxcXFxcXC9cXCteXSkvZywgZnVuY3Rpb24oYyl7IHJldHVybiBcIlxcXFxcIiArIGM7IH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0Y29tcHV0ZU1hcFByb2cgPSBmdW5jdGlvbihtYXAsIGRlc3Qpe1xuXHRcdFx0XHQvLyBUaGlzIHJvdXRpbmUgdGFrZXMgYSBtYXAgYXMgcmVwcmVzZW50ZWQgYnkgYSBKYXZhU2NyaXB0IG9iamVjdCBhbmQgaW5pdGlhbGl6ZXMgZGVzdCwgYSB2ZWN0b3Igb2Zcblx0XHRcdFx0Ly8gcXVhZHMgb2YgKG1hcC1rZXksIG1hcC12YWx1ZSwgcmVmZXgtZm9yLW1hcC1rZXksIGxlbmd0aC1vZi1tYXAta2V5KSwgc29ydGVkIGRlY3JlYXNpbmcgYnkgbGVuZ3RoLVxuXHRcdFx0XHQvLyBvZi1tYXAta2V5LiBUaGUgcmVnZXggbG9va3MgZm9yIHRoZSBtYXAta2V5IGZvbGxvd2VkIGJ5IGVpdGhlciBcIi9cIiBvciBlbmQtb2Ytc3RyaW5nIGF0IHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0Ly8gb2YgYSB0aGUgc2VhcmNoIHNvdXJjZS4gTm90aWNlIHRoZSBtYXAtdmFsdWUgaXMgaXJyZWxldmFudCB0byB0aGUgYWxnb3JpdGhtXG5cdFx0XHRcdGRlc3Quc3BsaWNlKDAsIGRlc3QubGVuZ3RoKTtcblx0XHRcdFx0Zm9yKHZhciBwIGluIG1hcCl7XG5cdFx0XHRcdFx0ZGVzdC5wdXNoKFtcblx0XHRcdFx0XHRcdHAsXG5cdFx0XHRcdFx0XHRtYXBbcF0sXG5cdFx0XHRcdFx0XHRuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlU3RyaW5nKHApICsgXCIoXFwvfCQpXCIpLFxuXHRcdFx0XHRcdFx0cC5sZW5ndGhdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZXN0LnNvcnQoZnVuY3Rpb24obGhzLCByaHMpeyByZXR1cm4gcmhzWzNdIC0gbGhzWzNdOyB9KTtcblx0XHRcdFx0cmV0dXJuIGRlc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHRjb21wdXRlQWxpYXNlcyA9IGZ1bmN0aW9uKGNvbmZpZywgZGVzdCl7XG5cdFx0XHRcdGZvckVhY2goY29uZmlnLCBmdW5jdGlvbihwYWlyKXtcblx0XHRcdFx0XHQvLyB0YWtlIGEgZml4ZWQtdXAgY29weS4uLlxuXHRcdFx0XHRcdGRlc3QucHVzaChbaXNTdHJpbmcocGFpclswXSkgPyBuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlU3RyaW5nKHBhaXJbMF0pICsgXCIkXCIpIDogcGFpclswXSwgcGFpclsxXV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblxuXHRcdFx0Zml4dXBQYWNrYWdlSW5mbyA9IGZ1bmN0aW9uKHBhY2thZ2VJbmZvKXtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBwcmVjaXNlIChuYW1lLCBsb2NhdGlvbiwgbWFpbiwgbWFwcGluZ3MpIGZvciBhIHBhY2thZ2Vcblx0XHRcdFx0dmFyIG5hbWUgPSBwYWNrYWdlSW5mby5uYW1lO1xuXHRcdFx0XHRpZighbmFtZSl7XG5cdFx0XHRcdFx0Ly8gcGFja2FnZUluZm8gbXVzdCBiZSBhIHN0cmluZyB0aGF0IGdpdmVzIHRoZSBuYW1lXG5cdFx0XHRcdFx0bmFtZSA9IHBhY2thZ2VJbmZvO1xuXHRcdFx0XHRcdHBhY2thZ2VJbmZvID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja2FnZUluZm8gPSBtaXgoe21haW46XCJtYWluXCJ9LCBwYWNrYWdlSW5mbyk7XG5cdFx0XHRcdHBhY2thZ2VJbmZvLmxvY2F0aW9uID0gcGFja2FnZUluZm8ubG9jYXRpb24gPyBwYWNrYWdlSW5mby5sb2NhdGlvbiA6IG5hbWU7XG5cblx0XHRcdFx0Ly8gcGFja2FnZU1hcCBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIEFNRCBtYXBcblx0XHRcdFx0aWYocGFja2FnZUluZm8ucGFja2FnZU1hcCl7XG5cdFx0XHRcdFx0bWFwW25hbWVdID0gcGFja2FnZUluZm8ucGFja2FnZU1hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCFwYWNrYWdlSW5mby5tYWluLmluZGV4T2YoXCIuL1wiKSl7XG5cdFx0XHRcdFx0cGFja2FnZUluZm8ubWFpbiA9IHBhY2thZ2VJbmZvLm1haW4uc3Vic3RyaW5nKDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm93IHRoYXQgd2UndmUgZ290IGEgZnVsbHktcmVzb2x2ZWQgcGFja2FnZSBvYmplY3QsIHB1c2ggaXQgaW50byB0aGUgY29uZmlndXJhdGlvblxuXHRcdFx0XHRwYWNrc1tuYW1lXSA9IHBhY2thZ2VJbmZvO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVsYXllZE1vZHVsZUNvbmZpZ1xuXHRcdFx0XHQvLyBtb2R1bGUgY29uZmlnIGNhbm5vdCBiZSBjb25zdW1lZCB1bnRpbCB0aGUgbG9hZGVyIGlzIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQ7IHRoZXJlZm9yZSwgYWxsXG5cdFx0XHRcdC8vIG1vZHVsZSBjb25maWcgZGV0ZWN0ZWQgZHVyaW5nIGJvb3RpbmcgaXMgbWVtb3JpemVkIGFuZCBhcHBsaWVkIGF0IHRoZSBlbmQgb2YgbG9hZGVyIGluaXRpYWxpemF0aW9uXG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgaXMgYSBiaXQgb2YgYSBrbHVkZ2U7IGFsbCBjb25maWcgc2hvdWxkIGJlIG1vdmVkIHRvIGVuZCBvZiBsb2FkZXIgaW5pdGlhbGl6YXRpb24sIGJ1dFxuXHRcdFx0XHQvLyB3ZSdsbCBkZWxheSB0aGlzIGNob3JlIGFuZCBkbyBpdCB3aXRoIGEgZmluYWwgbG9hZGVyIDEueCBjbGVhbnVwIGFmdGVyIHRoZSAyLnggbG9hZGVyIHByb3RvdHlwaW5nIGlzIGNvbXBsZXRlXG5cdFx0XHRcdD0gW10sXG5cblxuXHRcdFx0Y29uZmlnID0gZnVuY3Rpb24oY29uZmlnLCBib290aW5nLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0XHRmb3IodmFyIHAgaW4gY29uZmlnKXtcblx0XHRcdFx0XHRpZihwPT1cIndhaXRTZWNvbmRzXCIpe1xuXHRcdFx0XHRcdFx0cmVxLndhaXRtcyA9IChjb25maWdbcF0gfHwgMCkgKiAxMDAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwPT1cImNhY2hlQnVzdFwiKXtcblx0XHRcdFx0XHRcdGNhY2hlQnVzdCA9IGNvbmZpZ1twXSA/IChpc1N0cmluZyhjb25maWdbcF0pID8gY29uZmlnW3BdIDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocD09XCJiYXNlVXJsXCIgfHwgcD09XCJjb21ib1wiKXtcblx0XHRcdFx0XHRcdHJlcVtwXSA9IGNvbmZpZ1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIDAgICYmIHA9PVwiYXN5bmNcIil7XG5cdFx0XHRcdFx0XHQvLyBmYWxzeSBvciBcInN5bmNcIiA9PiBsZWdhY3kgc3luYyBsb2FkZXJcblx0XHRcdFx0XHRcdC8vIFwieGRcIiA9PiBzeW5jIGJ1dCBsb2FkaW5nIHhkb21haW4gdHJlZSBhbmQgdGhlcmVmb3JlIGxvYWRpbmcgYXN5bmNocm9ub3VzbHkgKG5vdCBjb25maWd1cmFibGUsIHNldCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBsb2FkZXIpXG5cdFx0XHRcdFx0XHQvLyBcImxlZ2FjeUFzeW5jXCIgPT4gcGVybWFuZW50bHkgaW4gXCJ4ZFwiIGJ5IGNob2ljZVxuXHRcdFx0XHRcdFx0Ly8gXCJkZWJ1Z0F0QWxsQ29zdHNcIiA9PiB0cnlpbmcgdG8gbG9hZCBldmVyeXRoaW5nIHZpYSBzY3JpcHQgaW5qZWN0aW9uIChub3QgaW1wbGVtZW50ZWQpXG5cdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIG11c3QgYmUgdHJ1dGh5ID0+IEFNRFxuXHRcdFx0XHRcdFx0Ly8gbGVnYWN5TW9kZTogc3luYyB8IGxlZ2FjeUFzeW5jIHwgeGQgfCBmYWxzZVxuXHRcdFx0XHRcdFx0dmFyIG1vZGUgPSBjb25maWdbcF07XG5cdFx0XHRcdFx0XHRyZXEubGVnYWN5TW9kZSA9IGxlZ2FjeU1vZGUgPSAoaXNTdHJpbmcobW9kZSkgJiYgL3N5bmN8bGVnYWN5QXN5bmMvLnRlc3QobW9kZSkgPyBtb2RlIDogKCFtb2RlID8gc3luYyA6IGZhbHNlKSk7XG5cdFx0XHRcdFx0XHRyZXEuYXN5bmMgPSAhbGVnYWN5TW9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoY29uZmlnW3BdIT09aGFzQ2FjaGUpe1xuXHRcdFx0XHRcdFx0Ly8gYWNjdW11bGF0ZSByYXcgY29uZmlnIGluZm8gZm9yIGNsaWVudCBhcHBzIHdoaWNoIGNhbiB1c2UgdGhpcyB0byBwYXNzIHRoZWlyIG93biBjb25maWdcblx0XHRcdFx0XHRcdHJlcS5yYXdDb25maWdbcF0gPSBjb25maWdbcF07XG5cdFx0XHRcdFx0XHRwIT1cImhhc1wiICYmIGhhcy5hZGQoXCJjb25maWctXCIrcCwgY29uZmlnW3BdLCAwLCBib290aW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgYmFzZVVybCBleGlzdHNcblx0XHRcdFx0aWYoIXJlcS5iYXNlVXJsKXtcblx0XHRcdFx0XHRyZXEuYmFzZVVybCA9IFwiLi9cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgYmFzZVVybCBlbmRzIHdpdGggYSBzbGFzaFxuXHRcdFx0XHRpZighL1xcLyQvLnRlc3QocmVxLmJhc2VVcmwpKXtcblx0XHRcdFx0XHRyZXEuYmFzZVVybCArPSBcIi9cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBkbyB0aGUgc3BlY2lhbCB3b3JrIGZvciBoYXMsIHBhY2thZ2VzLCBwYWNrYWdlUGF0aHMsIHBhdGhzLCBhbGlhc2VzLCBhbmQgY2FjaGVcblxuXHRcdFx0XHRmb3IocCBpbiBjb25maWcuaGFzKXtcblx0XHRcdFx0XHRoYXMuYWRkKHAsIGNvbmZpZy5oYXNbcF0sIDAsIGJvb3RpbmcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yIGVhY2ggcGFja2FnZSBmb3VuZCBpbiBhbnkgcGFja2FnZXMgY29uZmlnIGl0ZW0sIGF1Z21lbnQgdGhlIHBhY2tzIG1hcCBvd25lZCBieSB0aGUgbG9hZGVyXG5cdFx0XHRcdGZvckVhY2goY29uZmlnLnBhY2thZ2VzLCBmaXh1cFBhY2thZ2VJbmZvKTtcblxuXHRcdFx0XHQvLyBmb3IgZWFjaCBwYWNrYWdlUGF0aCBmb3VuZCBpbiBhbnkgcGFja2FnZVBhdGhzIGNvbmZpZyBpdGVtLCBhdWdtZW50IHRoZSBwYWNrYWdlQ29uZmlnXG5cdFx0XHRcdC8vIHBhY2thZ2VQYXRocyBpcyBkZXByZWNhdGVkOyByZW1vdmUgaW4gMi4wXG5cdFx0XHRcdGZvcih2YXIgYmFzZVVybCBpbiBjb25maWcucGFja2FnZVBhdGhzKXtcblx0XHRcdFx0XHRmb3JFYWNoKGNvbmZpZy5wYWNrYWdlUGF0aHNbYmFzZVVybF0sIGZ1bmN0aW9uKHBhY2thZ2VJbmZvKXtcblx0XHRcdFx0XHRcdHZhciBsb2NhdGlvbiA9IGJhc2VVcmwgKyBcIi9cIiArIHBhY2thZ2VJbmZvO1xuXHRcdFx0XHRcdFx0aWYoaXNTdHJpbmcocGFja2FnZUluZm8pKXtcblx0XHRcdFx0XHRcdFx0cGFja2FnZUluZm8gPSB7bmFtZTpwYWNrYWdlSW5mb307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYWNrYWdlSW5mby5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuXHRcdFx0XHRcdFx0Zml4dXBQYWNrYWdlSW5mbyhwYWNrYWdlSW5mbyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3RpY2UgdGhhdCBjb21wdXRlTWFwUHJvZyB0cmVhdHMgdGhlIGRlc3QgYXMgYSByZWZlcmVuY2U7IHRoZXJlZm9yZSwgaWYvd2hlbiB0aGF0IHZhcmlhYmxlXG5cdFx0XHRcdC8vIGlzIHB1Ymxpc2hlZCAoc2VlIGRvam8tcHVibGlzaC1wcml2YXRlcyksIHRoZSBwdWJsaXNoZWQgdmFyaWFibGUgd2lsbCBhbHdheXMgaG9sZCBhIHZhbGlkIHZhbHVlLlxuXG5cdFx0XHRcdC8vIHRoaXMgbXVzdCBjb21lIGFmdGVyIGFsbCBwYWNrYWdlIHByb2Nlc3Npbmcgc2luY2UgcGFja2FnZSBwcm9jZXNzaW5nIG1heSBtdXRhdGUgbWFwXG5cdFx0XHRcdGNvbXB1dGVNYXBQcm9nKG1peChtYXAsIGNvbmZpZy5tYXApLCBtYXBQcm9ncyk7XG5cdFx0XHRcdGZvckVhY2gobWFwUHJvZ3MsIGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHRcdGl0ZW1bMV0gPSBjb21wdXRlTWFwUHJvZyhpdGVtWzFdLCBbXSk7XG5cdFx0XHRcdFx0aWYoaXRlbVswXT09XCIqXCIpe1xuXHRcdFx0XHRcdFx0bWFwUHJvZ3Muc3RhciA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBwdXNoIGluIGFueSBwYXRocyBhbmQgcmVjb21wdXRlIHRoZSBpbnRlcm5hbCBwYXRobWFwXG5cdFx0XHRcdGNvbXB1dGVNYXBQcm9nKG1peChwYXRocywgY29uZmlnLnBhdGhzKSwgcGF0aHNNYXBQcm9nKTtcblxuXHRcdFx0XHQvLyBhbGlhc2VzXG5cdFx0XHRcdGNvbXB1dGVBbGlhc2VzKGNvbmZpZy5hbGlhc2VzLCBhbGlhc2VzKTtcblxuXHRcdFx0XHRpZiAoISAxICkge1xuXHRcdFx0XHRcdGlmKGJvb3Rpbmcpe1xuXHRcdFx0XHRcdFx0ZGVsYXllZE1vZHVsZUNvbmZpZy5wdXNoKHtjb25maWc6Y29uZmlnLmNvbmZpZ30pO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Zm9yKHAgaW4gY29uZmlnLmNvbmZpZyl7XG5cdFx0XHRcdFx0XHRcdHZhciBtb2R1bGUgPSBnZXRNb2R1bGUocCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmNvbmZpZyA9IG1peChtb2R1bGUuY29uZmlnIHx8IHt9LCBjb25maWcuY29uZmlnW3BdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBwdXNoIGluIGFueSBuZXcgY2FjaGUgdmFsdWVzXG5cdFx0XHRcdFx0aWYoY29uZmlnLmNhY2hlKXtcblx0XHRcdFx0XHRcdGNvbnN1bWVQZW5kaW5nQ2FjaGVJbnNlcnQoKTtcblx0XHRcdFx0XHRcdHBlbmRpbmdDYWNoZUluc2VydCA9IGNvbmZpZy5jYWNoZTtcblx0XHRcdFx0XHRcdC8vaW5qZWN0IG5vdyBhbGwgZGVwZW5jaWVzIHNvIGNhY2hlIGlzIGF2YWlsYWJsZSBmb3IgbWFwcGVkIG1vZHVsZVxuXHRcdFx0XHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCgwLCAhIWNvbmZpZy5jYWNoZVtcIipub3JlZlwiXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNpZ25hbChcImNvbmZpZ1wiLCBbY29uZmlnLCByZXEucmF3Q29uZmlnXSk7XG5cdFx0XHR9O1xuXG5cdFx0Ly9cblx0XHQvLyBleGVjdXRlIHRoZSB2YXJpb3VzIHNuaWZmczsgdXNlckNvbmZpZyBjYW4gb3ZlcnJpZGUgYW5kIHZhbHVlXG5cdFx0Ly9cblxuXHRcdGlmKCAwICB8fCAgMCApe1xuXHRcdFx0Ly8gdGhlIHNuaWZmIHJlZ2V4IGxvb2tzIGZvciBhIHNyYyBhdHRyaWJ1dGUgZW5kaW5nIGluIGRvam8uanMsIG9wdGlvbmFsbHkgcHJlY2VkZWQgd2l0aCBhIHBhdGguXG5cdFx0XHQvLyBtYXRjaFszXSByZXR1cm5zIHRoZSBwYXRoIHRvIGRvam8uanMgKGlmIGFueSkgd2l0aG91dCB0aGUgdHJhaWxpbmcgc2xhc2guIFRoaXMgaXMgdXNlZCBmb3IgdGhlXG5cdFx0XHQvLyBkb2pvIGxvY2F0aW9uIG9uIENETiBkZXBsb3ltZW50cyBhbmQgYmFzZVVybCB3aGVuIGVpdGhlci9ib3RoIG9mIHRoZXNlIGFyZSBub3QgcHJvdmlkZWRcblx0XHRcdC8vIGV4cGxpY2l0bHkgaW4gdGhlIGNvbmZpZyBkYXRhOyB0aGlzIGlzIHRoZSAxLjYtIGJlaGF2aW9yLlxuXG5cdFx0XHR2YXIgc2NyaXB0cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHNjcmlwdCwgZG9qb0Rpciwgc3JjLCBtYXRjaDtcblx0XHRcdHdoaWxlKGkgPCBzY3JpcHRzLmxlbmd0aCl7XG5cdFx0XHRcdHNjcmlwdCA9IHNjcmlwdHNbaSsrXTtcblx0XHRcdFx0aWYoKHNyYyA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpICYmIChtYXRjaCA9IHNyYy5tYXRjaCgvKCgoLiopXFwvKXxeKWRvam9cXC5qcyhcXFd8JCkvaSkpKXtcblx0XHRcdFx0XHQvLyBzbmlmZiBkb2pvRGlyIGFuZCBiYXNlVXJsXG5cdFx0XHRcdFx0ZG9qb0RpciA9IG1hdGNoWzNdIHx8IFwiXCI7XG5cdFx0XHRcdFx0ZGVmYXVsdENvbmZpZy5iYXNlVXJsID0gZGVmYXVsdENvbmZpZy5iYXNlVXJsIHx8IGRvam9EaXI7XG5cblx0XHRcdFx0XHQvLyByZW1lbWJlciBhbiBpbnNlcnRQb2ludFNpYmxpbmdcblx0XHRcdFx0XHRpbnNlcnRQb2ludFNpYmxpbmcgPSBzY3JpcHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzbmlmZiBjb25maWd1cmF0aW9uIG9uIGF0dHJpYnV0ZSBpbiBzY3JpcHQgZWxlbWVudFxuXHRcdFx0XHRpZigoc3JjID0gKHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRvam8tY29uZmlnXCIpIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkakNvbmZpZ1wiKSkpKXtcblx0XHRcdFx0XHRkb2pvU25pZmZDb25maWcgPSByZXEuZXZhbChcIih7IFwiICsgc3JjICsgXCIgfSlcIiwgXCJkYXRhLWRvam8tY29uZmlnXCIpO1xuXG5cdFx0XHRcdFx0Ly8gcmVtZW1iZXIgYW4gaW5zZXJ0UG9pbnRTaWJsaW5nXG5cdFx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nID0gc2NyaXB0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc25pZmYgcmVxdWlyZWpzIGF0dHJpYnV0ZVxuXHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdGlmKChzcmMgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYWluXCIpKSl7XG5cdFx0XHRcdFx0XHRkb2pvU25pZmZDb25maWcuZGVwcyA9IGRvam9TbmlmZkNvbmZpZy5kZXBzIHx8IFtzcmNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKCAwICl7XG5cdFx0XHQvLyBwYXNzIGRvd24gZG9oLnRlc3RDb25maWcgZnJvbSBwYXJlbnQgYXMgaWYgaXQgd2VyZSBhIGRhdGEtZG9qby1jb25maWdcblx0XHRcdHRyeXtcblx0XHRcdFx0aWYod2luZG93LnBhcmVudCAhPSB3aW5kb3cgJiYgd2luZG93LnBhcmVudC5yZXF1aXJlKXtcblx0XHRcdFx0XHR2YXIgZG9oID0gd2luZG93LnBhcmVudC5yZXF1aXJlKFwiZG9oXCIpO1xuXHRcdFx0XHRcdGRvaCAmJiBtaXgoZG9qb1NuaWZmQ29uZmlnLCBkb2gudGVzdENvbmZpZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXt9XG5cdFx0fVxuXG5cdFx0Ly8gY29uZmlndXJlIHRoZSBsb2FkZXI7IGxldCB0aGUgdXNlciBvdmVycmlkZSBkZWZhdWx0c1xuXHRcdHJlcS5yYXdDb25maWcgPSB7fTtcblx0XHRjb25maWcoZGVmYXVsdENvbmZpZywgMSk7XG5cblx0XHQvLyBkbyB0aGlzIGJlZm9yZSBzZXR0aW5nIHVzZXJDb25maWcvc25pZmZDb25maWcgdG8gYWxsb3cgdXNlckNvbmZpZy9zbmlmZiBvdmVycmlkZXNcblx0XHRpZiggMCApe1xuXHRcdFx0cGFja3MuZG9qby5sb2NhdGlvbiA9IGRvam9EaXI7XG5cdFx0XHRpZihkb2pvRGlyKXtcblx0XHRcdFx0ZG9qb0RpciArPSBcIi9cIjtcblx0XHRcdH1cblx0XHRcdHBhY2tzLmRpaml0LmxvY2F0aW9uID0gZG9qb0RpciArIFwiLi4vZGlqaXQvXCI7XG5cdFx0XHRwYWNrcy5kb2pveC5sb2NhdGlvbiA9IGRvam9EaXIgKyBcIi4uL2Rvam94L1wiO1xuXHRcdH1cblxuXHRcdGNvbmZpZyh1c2VyQ29uZmlnLCAxKTtcblx0XHRjb25maWcoZG9qb1NuaWZmQ29uZmlnLCAxKTtcblxuXHR9ZWxzZXtcblx0XHQvLyBubyBjb25maWcgQVBJLCBhc3N1bWUgZGVmYXVsdENvbmZpZyBoYXMgZXZlcnl0aGluZyB0aGUgbG9hZGVyIG5lZWRzLi4uZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG5cdFx0cGF0aHMgPSBkZWZhdWx0Q29uZmlnLnBhdGhzO1xuXHRcdHBhdGhzTWFwUHJvZyA9IGRlZmF1bHRDb25maWcucGF0aHNNYXBQcm9nO1xuXHRcdHBhY2tzID0gZGVmYXVsdENvbmZpZy5wYWNrcztcblx0XHRhbGlhc2VzID0gZGVmYXVsdENvbmZpZy5hbGlhc2VzO1xuXHRcdG1hcFByb2dzID0gZGVmYXVsdENvbmZpZy5tYXBQcm9ncztcblx0XHRtb2R1bGVzID0gZGVmYXVsdENvbmZpZy5tb2R1bGVzO1xuXHRcdGNhY2hlID0gZGVmYXVsdENvbmZpZy5jYWNoZTtcblx0XHRjYWNoZUJ1c3QgPSBkZWZhdWx0Q29uZmlnLmNhY2hlQnVzdDtcblxuXHRcdC8vIHJlbWVtYmVyIHRoZSBkZWZhdWx0IGNvbmZpZyBmb3Igb3RoZXIgcHJvY2Vzc2VzIChlLmcuLCBkb2pvL2NvbmZpZylcblx0XHRyZXEucmF3Q29uZmlnID0gZGVmYXVsdENvbmZpZztcblx0fVxuXG5cblx0aWYgKCEgMSApIHtcblx0XHRpZiggMCApe1xuXHRcdFx0cmVxLmNvbWJvID0gcmVxLmNvbWJvIHx8IHthZGQ6bm9vcH07XG5cdFx0XHR2YXIgY29tYm9QZW5kaW5nID0gMCxcblx0XHRcdFx0Y29tYm9zUGVuZGluZyA9IFtdLFxuXHRcdFx0XHRjb21ib1BlbmRpbmdUaW1lciA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXG5cdFx0Ly8gYnVpbGQgdGhlIGxvYWRlciBtYWNoaW5lcnkgaWF3IGNvbmZpZ3VyYXRpb24sIGluY2x1ZGluZyBoYXMgZmVhdHVyZSB0ZXN0c1xuXHRcdHZhciBpbmplY3REZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHQvLyBjaGVja0NvbXBsZXRlIT0wIGhvbGRzIHRoZSBpZGxlIHNpZ25hbDsgd2UncmUgbm90IGlkbGUgaWYgd2UncmUgaW5qZWN0aW5nIGRlcGVuZGVuY2llc1xuXHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRmb3JFYWNoKG1vZHVsZS5kZXBzLCBpbmplY3RNb2R1bGUpO1xuXHRcdFx0XHRcdGlmKCAwICAmJiBjb21ib1BlbmRpbmcgJiYgIWNvbWJvUGVuZGluZ1RpbWVyKXtcblx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZ1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y29tYm9QZW5kaW5nID0gMDtcblx0XHRcdFx0XHRcdFx0Y29tYm9QZW5kaW5nVGltZXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRyZXEuY29tYm8uZG9uZShmdW5jdGlvbihtaWRzLCB1cmwpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgb25Mb2FkQ2FsbGJhY2s9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkZWZRIGlzIGEgdmVjdG9yIG9mIG1vZHVsZSBkZWZpbml0aW9ucyAxLXRvLTEsIG9udG8gbWlkc1xuXHRcdFx0XHRcdFx0XHRcdFx0cnVuRGVmUSgwLCBtaWRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGNvbWJvc1BlbmRpbmcucHVzaChtaWRzKTtcblx0XHRcdFx0XHRcdFx0XHRpbmplY3RpbmdNb2R1bGUgPSBtaWRzO1xuXHRcdFx0XHRcdFx0XHRcdHJlcS5pbmplY3RVcmwodXJsLCBvbkxvYWRDYWxsYmFjaywgbWlkcyk7XG5cdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdFx0XHRcdFx0fSwgcmVxKTtcblx0XHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjb250ZXh0UmVxdWlyZSA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIHJlZmVyZW5jZU1vZHVsZSwgY29udGV4dFJlcXVpcmUpe1xuXHRcdFx0XHR2YXIgbW9kdWxlLCBzeW50aGV0aWNNaWQ7XG5cdFx0XHRcdGlmKGlzU3RyaW5nKGExKSl7XG5cdFx0XHRcdFx0Ly8gc2lnbmF0dXJlIGlzIChtb2R1bGVJZClcblx0XHRcdFx0XHRtb2R1bGUgPSBnZXRNb2R1bGUoYTEsIHJlZmVyZW5jZU1vZHVsZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYobW9kdWxlICYmIG1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgbWFrZUVycm9yKFwidW5kZWZpbmVkTW9kdWxlXCIsIGExKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighaXNBcnJheShhMSkpe1xuXHRcdFx0XHRcdC8vIGExIGlzIGEgY29uZmlndXJhdGlvblxuXHRcdFx0XHRcdGNvbmZpZyhhMSwgMCwgcmVmZXJlbmNlTW9kdWxlKTtcblxuXHRcdFx0XHRcdC8vIGp1Z2dsZSBhcmdzOyAoYTIsIGEzKSBtYXkgYmUgKGRlcGVuZGVuY2llcywgY2FsbGJhY2spXG5cdFx0XHRcdFx0YTEgPSBhMjtcblx0XHRcdFx0XHRhMiA9IGEzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGlzQXJyYXkoYTEpKXtcblx0XHRcdFx0XHQvLyBzaWduYXR1cmUgaXMgKHJlcXVlc3RMaXN0IFssY2FsbGJhY2tdKVxuXHRcdFx0XHRcdGlmKCFhMS5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0YTIgJiYgYTIoKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHN5bnRoZXRpY01pZCA9IFwicmVxdWlyZSpcIiArIHVpZCgpO1xuXG5cdFx0XHRcdFx0XHQvLyByZXNvbHZlIHRoZSByZXF1ZXN0IGxpc3Qgd2l0aCByZXNwZWN0IHRvIHRoZSByZWZlcmVuY2UgbW9kdWxlXG5cdFx0XHRcdFx0XHRmb3IodmFyIG1pZCwgZGVwcyA9IFtdLCBpID0gMDsgaSA8IGExLmxlbmd0aDspe1xuXHRcdFx0XHRcdFx0XHRtaWQgPSBhMVtpKytdO1xuXHRcdFx0XHRcdFx0XHRkZXBzLnB1c2goZ2V0TW9kdWxlKG1pZCwgcmVmZXJlbmNlTW9kdWxlKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGNvbnN0cnVjdCBhIHN5bnRoZXRpYyBtb2R1bGUgdG8gY29udHJvbCBleGVjdXRpb24gb2YgdGhlIHJlcXVlc3RMaXN0LCBhbmQsIG9wdGlvbmFsbHksIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRtb2R1bGUgPSBtaXgobWFrZU1vZHVsZUluZm8oXCJcIiwgc3ludGhldGljTWlkLCAwLCBcIlwiKSwge1xuXHRcdFx0XHRcdFx0XHRpbmplY3RlZDogYXJyaXZlZCxcblx0XHRcdFx0XHRcdFx0ZGVwczogZGVwcyxcblx0XHRcdFx0XHRcdFx0ZGVmOiBhMiB8fCBub29wLFxuXHRcdFx0XHRcdFx0XHRyZXF1aXJlOiByZWZlcmVuY2VNb2R1bGUgPyByZWZlcmVuY2VNb2R1bGUucmVxdWlyZSA6IHJlcSxcblx0XHRcdFx0XHRcdFx0Z2M6IDEgLy9nYXJiYWdlIGNvbGxlY3Rcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0bW9kdWxlc1ttb2R1bGUubWlkXSA9IG1vZHVsZTtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2tDb21wbGV0ZSE9MCBob2xkcyB0aGUgaWRsZSBzaWduYWw7IHdlJ3JlIG5vdCBpZGxlIGlmIHdlJ3JlIGluamVjdGluZyBkZXBlbmRlbmNpZXNcblx0XHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhtb2R1bGUpO1xuXG5cdFx0XHRcdFx0XHQvLyB0cnkgdG8gaW1tZWRpYXRlbHkgZXhlY3V0ZVxuXHRcdFx0XHRcdFx0Ly8gaWYgYWxyZWFkeSB0cmF2ZXJzaW5nIGEgZmFjdG9yeSB0cmVlLCB0aGVuIHN0cmljdCBjYXVzZXMgY2lyY3VsYXIgZGVwZW5kZW5jeSB0byBhYm9ydCB0aGUgZXhlY3V0aW9uOyBtYXliZVxuXHRcdFx0XHRcdFx0Ly8gaXQncyBwb3NzaWJsZSB0byBleGVjdXRlIHRoaXMgcmVxdWlyZSBsYXRlciBhZnRlciB0aGUgY3VycmVudCB0cmF2ZXJzYWwgY29tcGxldGVzIGFuZCBhdm9pZCB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0XHRcdFx0XHRcdC8vIC4uLmJ1dCAqYWx3YXlzKiBpbnNpc3Qgb24gaW1tZWRpYXRlIGluIHN5bmNoIG1vZGVcblx0XHRcdFx0XHRcdHZhciBzdHJpY3QgPSBjaGVja0NvbXBsZXRlR3VhcmQgJiYgbGVnYWN5TW9kZSE9c3luYztcblx0XHRcdFx0XHRcdGd1YXJkQ2hlY2tDb21wbGV0ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRleGVjTW9kdWxlKG1vZHVsZSwgc3RyaWN0KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYoIW1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRcdC8vIHNvbWUgZGVwcyB3ZXJlbid0IG9uIGJvYXJkIG9yIGNpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgYW5kIHN0cmljdDsgdGhlcmVmb3JlLCBwdXNoIGludG8gdGhlIGV4ZWNRXG5cdFx0XHRcdFx0XHRcdGV4ZWNRLnB1c2gobW9kdWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbnRleHRSZXF1aXJlO1xuXHRcdFx0fSxcblxuXHRcdFx0Y3JlYXRlUmVxdWlyZSA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdGlmKCFtb2R1bGUpe1xuXHRcdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG1vZHVsZS5yZXF1aXJlO1xuXHRcdFx0XHRpZighcmVzdWx0KXtcblx0XHRcdFx0XHRyZXN1bHQgPSBmdW5jdGlvbihhMSwgYTIsIGEzKXtcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZXh0UmVxdWlyZShhMSwgYTIsIGEzLCBtb2R1bGUsIHJlc3VsdCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRtb2R1bGUucmVxdWlyZSA9IG1peChyZXN1bHQsIHJlcSk7XG5cdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZSA9IG1vZHVsZTtcblx0XHRcdFx0XHRyZXN1bHQudG9VcmwgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRcdFx0XHRcdHJldHVybiB0b1VybChuYW1lLCBtb2R1bGUpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmVzdWx0LnRvQWJzTWlkID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0XHRcdHJldHVybiB0b0Fic01pZChtaWQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdFx0cmVzdWx0LnVuZGVmID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0XHRcdFx0cmVxLnVuZGVmKG1pZCwgbW9kdWxlKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0XHRyZXN1bHQuc3luY0xvYWRObHMgPSBmdW5jdGlvbihtaWQpe1xuXHRcdFx0XHRcdFx0XHR2YXIgbmxzTW9kdWxlSW5mbyA9IGdldE1vZHVsZUluZm8obWlkLCBtb2R1bGUpLFxuXHRcdFx0XHRcdFx0XHRcdG5sc01vZHVsZSA9IG1vZHVsZXNbbmxzTW9kdWxlSW5mby5taWRdO1xuXHRcdFx0XHRcdFx0XHRpZighbmxzTW9kdWxlIHx8ICFubHNNb2R1bGUuZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdFx0XHRcdGNhY2hlZCA9IGNhY2hlW25sc01vZHVsZUluZm8ubWlkXSB8fCBjYWNoZVt1cmxLZXlQcmVmaXggKyBubHNNb2R1bGVJbmZvLnVybF07XG5cdFx0XHRcdFx0XHRcdFx0aWYoY2FjaGVkKXtcblx0XHRcdFx0XHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KGNhY2hlZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRubHNNb2R1bGUgPSBtb2R1bGVzW25sc01vZHVsZUluZm8ubWlkXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5sc01vZHVsZSAmJiBubHNNb2R1bGUuZXhlY3V0ZWQgJiYgbmxzTW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHQgIGV4ZWNRID1cblx0XHRcdFx0Ly8gVGhlIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkLlxuXHRcdFx0XHRbXSxcblxuXHRcdFx0ZGVmUSA9XG5cdFx0XHRcdC8vIFRoZSBxdWV1ZSBvZiBkZWZpbmUgYXJndW1lbnRzIHNlbnQgdG8gbG9hZGVyLlxuXHRcdFx0XHRbXSxcblxuXHRcdFx0d2FpdGluZyA9XG5cdFx0XHRcdC8vIFRoZSBzZXQgb2YgbW9kdWxlcyB1cG9uIHdoaWNoIHRoZSBsb2FkZXIgaXMgd2FpdGluZyBmb3IgZGVmaW5pdGlvbiB0byBhcnJpdmVcblx0XHRcdFx0e30sXG5cblx0XHRcdHNldFJlcXVlc3RlZCA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdG1vZHVsZS5pbmplY3RlZCA9IHJlcXVlc3RlZDtcblx0XHRcdFx0d2FpdGluZ1ttb2R1bGUubWlkXSA9IDE7XG5cdFx0XHRcdGlmKG1vZHVsZS51cmwpe1xuXHRcdFx0XHRcdHdhaXRpbmdbbW9kdWxlLnVybF0gPSBtb2R1bGUucGFjayB8fCAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VGltZXIoKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldEFycml2ZWQgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRtb2R1bGUuaW5qZWN0ZWQgPSBhcnJpdmVkO1xuXHRcdFx0XHRkZWxldGUgd2FpdGluZ1ttb2R1bGUubWlkXTtcblx0XHRcdFx0aWYobW9kdWxlLnVybCl7XG5cdFx0XHRcdFx0ZGVsZXRlIHdhaXRpbmdbbW9kdWxlLnVybF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoaXNFbXB0eSh3YWl0aW5nKSl7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lcigpO1xuXHRcdFx0XHRcdCAwICAmJiBsZWdhY3lNb2RlPT14ZCAmJiAobGVnYWN5TW9kZSA9IHN5bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRleGVjQ29tcGxldGUgPSByZXEuaWRsZSA9XG5cdFx0XHRcdC8vIHNheXMgdGhlIGxvYWRlciBoYXMgY29tcGxldGVkIChvciBub3QpIGl0cyB3b3JrXG5cdFx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuICFkZWZRLmxlbmd0aCAmJiBpc0VtcHR5KHdhaXRpbmcpICYmICFleGVjUS5sZW5ndGggJiYgIWNoZWNrQ29tcGxldGVHdWFyZDtcblx0XHRcdFx0fTtcblx0fVxuXG5cdHZhciBydW5NYXBQcm9nID0gZnVuY3Rpb24odGFyZ2V0TWlkLCBtYXApe1xuXHRcdFx0Ly8gc2VhcmNoIGZvciB0YXJnZXRNaWQgaW4gbWFwOyByZXR1cm4gdGhlIG1hcCBpdGVtIGlmIGZvdW5kOyBmYWxzeSBvdGhlcndpc2Vcblx0XHRcdGlmKG1hcCl7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYobWFwW2ldWzJdLnRlc3QodGFyZ2V0TWlkKSl7XG5cdFx0XHRcdFx0cmV0dXJuIG1hcFtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdGNvbXBhY3RQYXRoID0gZnVuY3Rpb24ocGF0aCl7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdHNlZ21lbnQsIGxhc3RTZWdtZW50O1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpLnNwbGl0KCcvJyk7XG5cdFx0XHR3aGlsZShwYXRoLmxlbmd0aCl7XG5cdFx0XHRcdHNlZ21lbnQgPSBwYXRoLnNoaWZ0KCk7XG5cdFx0XHRcdGlmKHNlZ21lbnQ9PVwiLi5cIiAmJiByZXN1bHQubGVuZ3RoICYmIGxhc3RTZWdtZW50IT1cIi4uXCIpe1xuXHRcdFx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHRcdFx0XHRsYXN0U2VnbWVudCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG5cdFx0XHRcdH1lbHNlIGlmKHNlZ21lbnQhPVwiLlwiKXtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChsYXN0U2VnbWVudD0gc2VnbWVudCk7XG5cdFx0XHRcdH0gLy8gZWxzZSBpZ25vcmUgXCIuXCJcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQuam9pbihcIi9cIik7XG5cdFx0fSxcblxuXHRcdG1ha2VNb2R1bGVJbmZvID0gZnVuY3Rpb24ocGlkLCBtaWQsIHBhY2ssIHVybCl7XG5cdFx0XHRpZiggMCApe1xuXHRcdFx0XHR2YXIgeGQ9IHJlcS5pc1hkVXJsKHVybCk7XG5cdFx0XHRcdHJldHVybiB7cGlkOnBpZCwgbWlkOm1pZCwgcGFjazpwYWNrLCB1cmw6dXJsLCBleGVjdXRlZDowLCBkZWY6MCwgaXNYZDp4ZCwgaXNBbWQ6ISEoeGQgfHwgKHBhY2tzW3BpZF0gJiYgcGFja3NbcGlkXS5pc0FtZCkpfTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4ge3BpZDpwaWQsIG1pZDptaWQsIHBhY2s6cGFjaywgdXJsOnVybCwgZXhlY3V0ZWQ6MCwgZGVmOjB9O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRNb2R1bGVJbmZvXyA9IGZ1bmN0aW9uKG1pZCwgcmVmZXJlbmNlTW9kdWxlLCBwYWNrcywgbW9kdWxlcywgYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgYWx3YXlzQ3JlYXRlLCBmcm9tUGVuZGluZ0NhY2hlKXtcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluc3RlYWQgb2YgdXNpbmcgbGV4aWNhbCB2YXJpYWJsZXMgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIG15IGJlIHVzZWQgaW5kZXBlbmRlbnQgb2YgdGhlIGxvYWRlciAoZS5nLiwgdGhlIGJ1aWxkZXIpXG5cdFx0XHQvLyBhbHdheXNDcmVhdGUgaXMgdXNlZnVsIGluIHRoaXMgY2FzZSBzbyB0aGF0IGdldE1vZHVsZUluZm8gbmV2ZXIgcmV0dXJucyByZWZlcmVuY2VzIHRvIHJlYWwgbW9kdWxlcyBvd25lZCBieSB0aGUgbG9hZGVyXG5cdFx0XHR2YXIgcGlkLCBwYWNrLCBtaWRJblBhY2thZ2UsIG1hcEl0ZW0sIHVybCwgcmVzdWx0LCBpc1JlbGF0aXZlLCByZXF1ZXN0ZWRNaWQ7XG5cdFx0XHRyZXF1ZXN0ZWRNaWQgPSBtaWQ7XG5cdFx0XHRpc1JlbGF0aXZlID0gL15cXC4vLnRlc3QobWlkKTtcblx0XHRcdGlmKC8oXlxcLyl8KFxcOil8KFxcLmpzJCkvLnRlc3QobWlkKSB8fCAoaXNSZWxhdGl2ZSAmJiAhcmVmZXJlbmNlTW9kdWxlKSl7XG5cdFx0XHRcdC8vIGFic29sdXRlIHBhdGggb3IgcHJvdG9jb2wgb2YgLmpzIGZpbGV0eXBlLCBvciByZWxhdGl2ZSBwYXRoIGJ1dCBubyByZWZlcmVuY2UgbW9kdWxlIGFuZCB0aGVyZWZvcmUgcmVsYXRpdmUgdG8gcGFnZVxuXHRcdFx0XHQvLyB3aGF0ZXZlciBpdCBpcywgaXQncyBub3QgYSBtb2R1bGUgYnV0IGp1c3QgYSBVUkwgb2Ygc29tZSBzb3J0XG5cdFx0XHRcdC8vIG5vdGU6IHBpZD09PTAgaW5kaWNhdGVzIHRoZSByb3V0aW5lIGlzIHJldHVybmluZyBhbiB1bm1vZGlmaWVkIG1pZFxuXG5cdFx0XHRcdHJldHVybiBtYWtlTW9kdWxlSW5mbygwLCBtaWQsIDAsIG1pZCk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gcmVsYXRpdmUgbW9kdWxlIGlkcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZU1vZHVsZTsgZ2V0IHJpZCBvZiBhbnkgZG90c1xuXHRcdFx0XHRtaWQgPSBjb21wYWN0UGF0aChpc1JlbGF0aXZlID8gKHJlZmVyZW5jZU1vZHVsZS5taWQgKyBcIi8uLi9cIiArIG1pZCkgOiBtaWQpO1xuXHRcdFx0XHRpZigvXlxcLi8udGVzdChtaWQpKXtcblx0XHRcdFx0XHR0aHJvdyBtYWtlRXJyb3IoXCJpcnJhdGlvbmFsUGF0aFwiLCBtaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIG1pZCBpcyBhbiBhYnNvbHV0ZSBtaWRcblxuXHRcdFx0XHQvLyBtYXAgdGhlIG1pZFxuXHRcdFx0XHRpZighZnJvbVBlbmRpbmdDYWNoZSAmJiAhaXNSZWxhdGl2ZSAmJiBtYXBQcm9ncy5zdGFyKXtcblx0XHRcdFx0XHRtYXBJdGVtID0gcnVuTWFwUHJvZyhtaWQsIG1hcFByb2dzLnN0YXJbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFtYXBJdGVtICYmIHJlZmVyZW5jZU1vZHVsZSl7XG5cdFx0XHRcdFx0bWFwSXRlbSA9IHJ1bk1hcFByb2cocmVmZXJlbmNlTW9kdWxlLm1pZCwgbWFwUHJvZ3MpO1xuXHRcdFx0XHRcdG1hcEl0ZW0gPSBtYXBJdGVtICYmIHJ1bk1hcFByb2cobWlkLCBtYXBJdGVtWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKG1hcEl0ZW0pe1xuXHRcdFx0XHRcdG1pZCA9IG1hcEl0ZW1bMV0gKyBtaWQuc3Vic3RyaW5nKG1hcEl0ZW1bM10pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRjaCA9IG1pZC5tYXRjaCgvXihbXlxcL10rKShcXC8oLispKT8kLyk7XG5cdFx0XHRcdHBpZCA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcIlwiO1xuXHRcdFx0XHRpZigocGFjayA9IHBhY2tzW3BpZF0pKXtcblx0XHRcdFx0XHRtaWQgPSBwaWQgKyBcIi9cIiArIChtaWRJblBhY2thZ2UgPSAobWF0Y2hbM10gfHwgcGFjay5tYWluKSk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHBpZCA9IFwiXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZWFyY2ggYWxpYXNlc1xuXHRcdFx0XHR2YXIgY2FuZGlkYXRlTGVuZ3RoID0gMCxcblx0XHRcdFx0XHRjYW5kaWRhdGUgPSAwO1xuXHRcdFx0XHRmb3JFYWNoKGFsaWFzZXMsIGZ1bmN0aW9uKHBhaXIpe1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IG1pZC5tYXRjaChwYWlyWzBdKTtcblx0XHRcdFx0XHRpZihtYXRjaCAmJiBtYXRjaC5sZW5ndGg+Y2FuZGlkYXRlTGVuZ3RoKXtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZSA9IGlzRnVuY3Rpb24ocGFpclsxXSkgPyBtaWQucmVwbGFjZShwYWlyWzBdLCBwYWlyWzFdKSA6IHBhaXJbMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYoY2FuZGlkYXRlKXtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0TW9kdWxlSW5mb18oY2FuZGlkYXRlLCAwLCBwYWNrcywgbW9kdWxlcywgYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgYWx3YXlzQ3JlYXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCA9IG1vZHVsZXNbbWlkXTtcblx0XHRcdFx0aWYocmVzdWx0KXtcblx0XHRcdFx0XHRyZXR1cm4gYWx3YXlzQ3JlYXRlID8gbWFrZU1vZHVsZUluZm8ocmVzdWx0LnBpZCwgcmVzdWx0Lm1pZCwgcmVzdWx0LnBhY2ssIHJlc3VsdC51cmwpIDogbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBnZXQgaGVyZSBpZmYgdGhlIHNvdWdodC1hZnRlciBtb2R1bGUgZG9lcyBub3QgeWV0IGV4aXN0OyB0aGVyZWZvcmUsIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgVVJMIGdpdmVuIHRoZVxuXHRcdFx0Ly8gZnVsbHkgcmVzb2x2ZWQgKGkuZS4sIGFsbCByZWxhdGl2ZSBpbmRpY2F0b3JzIGFuZCBwYWNrYWdlIG1hcHBpbmcgcmVzb2x2ZWQpIG1vZHVsZSBpZFxuXG5cdFx0XHQvLyBub3RlOiBwaWQhPT0wIGluZGljYXRlcyB0aGUgcm91dGluZSBpcyByZXR1cm5pbmcgYSB1cmwgdGhhdCBoYXMgLmpzIGFwcGVuZGVkIHVubW9kaWZpZWQgbWlkXG5cdFx0XHRtYXBJdGVtID0gcnVuTWFwUHJvZyhtaWQsIHBhdGhzTWFwUHJvZyk7XG5cdFx0XHRpZihtYXBJdGVtKXtcblx0XHRcdFx0dXJsID0gbWFwSXRlbVsxXSArIG1pZC5zdWJzdHJpbmcobWFwSXRlbVszXSk7XG5cdFx0XHR9ZWxzZSBpZihwaWQpe1xuXHRcdFx0XHR1cmwgPSAocGFjay5sb2NhdGlvbi5zbGljZSgtMSkgPT09ICcvJyA/IHBhY2subG9jYXRpb24uc2xpY2UoMCwgLTEpIDogcGFjay5sb2NhdGlvbikgKyBcIi9cIiArIG1pZEluUGFja2FnZTtcblx0XHRcdH1lbHNlIGlmKCAwICl7XG5cdFx0XHRcdHVybCA9IFwiLi4vXCIgKyBtaWQ7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0dXJsID0gbWlkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgcmVzdWx0IGlzIG5vdCBhYnNvbHV0ZSwgYWRkIGJhc2VVcmxcblx0XHRcdGlmKCEoLyheXFwvKXwoXFw6KS8udGVzdCh1cmwpKSl7XG5cdFx0XHRcdHVybCA9IGJhc2VVcmwgKyB1cmw7XG5cdFx0XHR9XG5cdFx0XHR1cmwgKz0gXCIuanNcIjtcblx0XHRcdHJldHVybiBtYWtlTW9kdWxlSW5mbyhwaWQsIG1pZCwgcGFjaywgY29tcGFjdFBhdGgodXJsKSk7XG5cdFx0fSxcblxuXHRcdGdldE1vZHVsZUluZm8gPSBmdW5jdGlvbihtaWQsIHJlZmVyZW5jZU1vZHVsZSwgZnJvbVBlbmRpbmdDYWNoZSl7XG5cdFx0XHRyZXR1cm4gZ2V0TW9kdWxlSW5mb18obWlkLCByZWZlcmVuY2VNb2R1bGUsIHBhY2tzLCBtb2R1bGVzLCByZXEuYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgdW5kZWZpbmVkLCBmcm9tUGVuZGluZ0NhY2hlKTtcblx0XHR9O1xuXG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIHJlc29sdmVQbHVnaW5SZXNvdXJjZUlkID0gZnVuY3Rpb24ocGx1Z2luLCBwcmlkLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0XHRyZXR1cm4gcGx1Z2luLm5vcm1hbGl6ZSA/IHBsdWdpbi5ub3JtYWxpemUocHJpZCwgZnVuY3Rpb24obWlkKXtyZXR1cm4gdG9BYnNNaWQobWlkLCByZWZlcmVuY2VNb2R1bGUpO30pIDogdG9BYnNNaWQocHJpZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdH0sXG5cblx0XHRcdGR5bmFtaWNQbHVnaW5VaWRHZW5lcmF0b3IgPSAwLFxuXG5cdFx0XHRnZXRNb2R1bGUgPSBmdW5jdGlvbihtaWQsIHJlZmVyZW5jZU1vZHVsZSwgaW1tZWRpYXRlKXtcblx0XHRcdFx0Ly8gY29tcHV0ZSBhbmQgb3B0aW9uYWxseSBjb25zdHJ1Y3QgKGlmIG5lY2Vzc2FyeSkgdGhlIG1vZHVsZSBpbXBsaWVkIGJ5IHRoZSBtaWQgd2l0aCByZXNwZWN0IHRvIHJlZmVyZW5jZU1vZHVsZVxuXHRcdFx0XHR2YXIgbWF0Y2gsIHBsdWdpbiwgcHJpZCwgcmVzdWx0O1xuXHRcdFx0XHRtYXRjaCA9IG1pZC5tYXRjaCgvXiguKz8pXFwhKC4qKSQvKTtcblx0XHRcdFx0aWYobWF0Y2gpe1xuXHRcdFx0XHRcdC8vIG5hbWUgd2FzIDxwbHVnaW4tbW9kdWxlPiE8cGx1Z2luLXJlc291cmNlLWlkPlxuXHRcdFx0XHRcdHBsdWdpbiA9IGdldE1vZHVsZShtYXRjaFsxXSwgcmVmZXJlbmNlTW9kdWxlLCBpbW1lZGlhdGUpO1xuXG5cdFx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUgPT0gc3luYyAmJiAhcGx1Z2luLmV4ZWN1dGVkKXtcblx0XHRcdFx0XHRcdGluamVjdE1vZHVsZShwbHVnaW4pO1xuXHRcdFx0XHRcdFx0aWYocGx1Z2luLmluamVjdGVkPT09YXJyaXZlZCAmJiAhcGx1Z2luLmV4ZWN1dGVkKXtcblx0XHRcdFx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0ZXhlY01vZHVsZShwbHVnaW4pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHBsdWdpbi5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihwbHVnaW4pO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIHdlIGFyZSBpbiB4ZG9tYWluIG1vZGUgZm9yIHNvbWUgcmVhc29uXG5cdFx0XHRcdFx0XHRcdGV4ZWNRLnVuc2hpZnQocGx1Z2luKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblxuXG5cdFx0XHRcdFx0aWYocGx1Z2luLmV4ZWN1dGVkID09PSBleGVjdXRlZCAmJiAhcGx1Z2luLmxvYWQpe1xuXHRcdFx0XHRcdFx0Ly8gZXhlY3V0ZWQgdGhlIG1vZHVsZSBub3Qga25vd2luZyBpdCB3YXMgYSBwbHVnaW5cblx0XHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihwbHVnaW4pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBwbHVnaW4gaGFzIG5vdCBiZWVuIGxvYWRlZCwgdGhlbiBjYW4ndCByZXNvbHZlIHRoZSBwcmlkIGFuZCAgbXVzdCBhc3N1bWUgdGhpcyBwbHVnaW4gaXMgZHluYW1pYyB1bnRpbCB3ZSBmaW5kIG91dCBvdGhlcndpc2Vcblx0XHRcdFx0XHRpZihwbHVnaW4ubG9hZCl7XG5cdFx0XHRcdFx0XHRwcmlkID0gcmVzb2x2ZVBsdWdpblJlc291cmNlSWQocGx1Z2luLCBtYXRjaFsyXSwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0XHRcdG1pZCA9IChwbHVnaW4ubWlkICsgXCIhXCIgKyAocGx1Z2luLmR5bmFtaWMgPyArK2R5bmFtaWNQbHVnaW5VaWRHZW5lcmF0b3IgKyBcIiFcIiA6IFwiXCIpICsgcHJpZCk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRwcmlkID0gbWF0Y2hbMl07XG5cdFx0XHRcdFx0XHRtaWQgPSBwbHVnaW4ubWlkICsgXCIhXCIgKyAoKytkeW5hbWljUGx1Z2luVWlkR2VuZXJhdG9yKSArIFwiIXdhaXRpbmdGb3JQbHVnaW5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0ge3BsdWdpbjpwbHVnaW4sIG1pZDptaWQsIHJlcTpjcmVhdGVSZXF1aXJlKHJlZmVyZW5jZU1vZHVsZSksIHByaWQ6cHJpZH07XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHJlc3VsdCA9IGdldE1vZHVsZUluZm8obWlkLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtb2R1bGVzW3Jlc3VsdC5taWRdIHx8ICghaW1tZWRpYXRlICYmIChtb2R1bGVzW3Jlc3VsdC5taWRdID0gcmVzdWx0KSk7XG5cdFx0XHR9O1xuXHR9XG5cblx0dmFyIHRvQWJzTWlkID0gcmVxLnRvQWJzTWlkID0gZnVuY3Rpb24obWlkLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0cmV0dXJuIGdldE1vZHVsZUluZm8obWlkLCByZWZlcmVuY2VNb2R1bGUpLm1pZDtcblx0XHR9LFxuXG5cdFx0dG9VcmwgPSByZXEudG9VcmwgPSBmdW5jdGlvbihuYW1lLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0dmFyIG1vZHVsZUluZm8gPSBnZXRNb2R1bGVJbmZvKG5hbWUrXCIveFwiLCByZWZlcmVuY2VNb2R1bGUpLFxuXHRcdFx0XHR1cmw9IG1vZHVsZUluZm8udXJsO1xuXHRcdFx0cmV0dXJuIGZpeHVwVXJsKG1vZHVsZUluZm8ucGlkPT09MCA/XG5cdFx0XHRcdC8vIGlmIHBpZD09PTAsIHRoZW4gbmFtZSBoYWQgYSBwcm90b2NvbCBvciBhYnNvbHV0ZSBwYXRoOyBlaXRoZXIgd2F5LCB0b1VybCBpcyB0aGUgaWRlbnRpZnkgZnVuY3Rpb24gaW4gc3VjaCBjYXNlc1xuXHRcdFx0XHRuYW1lIDpcblx0XHRcdFx0Ly8gXCIveC5qc1wiIHNpbmNlIGdldE1vZHVsZUluZm8gYXV0b21hdGljYWxseSBhcHBlbmRzIFwiLmpzXCIgYW5kIHdlIGFwcGVuZGVkIFwiL3hcIiB0byBtYWtlIG5hbWUgbG9vayBsaWtlIGEgbW9kdWxlIGlkXG5cdFx0XHRcdHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aC01KVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIG5vbk1vZHVsZVByb3BzID0ge1xuXHRcdFx0XHRpbmplY3RlZDogYXJyaXZlZCxcblx0XHRcdFx0ZXhlY3V0ZWQ6IGV4ZWN1dGVkLFxuXHRcdFx0XHRkZWY6IG5vbm1vZHVsZSxcblx0XHRcdFx0cmVzdWx0OiBub25tb2R1bGVcblx0XHRcdH0sXG5cblx0XHRcdG1ha2VDanMgPSBmdW5jdGlvbihtaWQpe1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlc1ttaWRdID0gbWl4KHttaWQ6bWlkfSwgbm9uTW9kdWxlUHJvcHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2pzUmVxdWlyZU1vZHVsZSA9IG1ha2VDanMoXCJyZXF1aXJlXCIpLFxuXHRcdFx0Y2pzRXhwb3J0c01vZHVsZSA9IG1ha2VDanMoXCJleHBvcnRzXCIpLFxuXHRcdFx0Y2pzTW9kdWxlTW9kdWxlID0gbWFrZUNqcyhcIm1vZHVsZVwiKSxcblxuXHRcdFx0cnVuRmFjdG9yeSA9IGZ1bmN0aW9uKG1vZHVsZSwgYXJncyl7XG5cdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1ydW4tZmFjdG9yeVwiLCBbbW9kdWxlLm1pZF0pO1xuXHRcdFx0XHR2YXIgZmFjdG9yeSA9IG1vZHVsZS5kZWYsXG5cdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHQgMCAgJiYgc3luY0V4ZWNTdGFjay51bnNoaWZ0KG1vZHVsZSk7XG5cdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0cmVzdWx0PSBpc0Z1bmN0aW9uKGZhY3RvcnkpID8gZmFjdG9yeS5hcHBseShudWxsLCBhcmdzKSA6IGZhY3Rvcnk7XG5cdFx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtb2R1bGUucmVzdWx0ID0gbWFrZUVycm9yKFwiZmFjdG9yeVRocmV3XCIsIFttb2R1bGUsIGVdKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRyZXN1bHQ9IGlzRnVuY3Rpb24oZmFjdG9yeSkgPyBmYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3MpIDogZmFjdG9yeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtb2R1bGUucmVzdWx0ID0gcmVzdWx0PT09dW5kZWZpbmVkICYmIG1vZHVsZS5janMgPyBtb2R1bGUuY2pzLmV4cG9ydHMgOiByZXN1bHQ7XG5cdFx0XHRcdCAwICAmJiBzeW5jRXhlY1N0YWNrLnNoaWZ0KG1vZHVsZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydEV4ZWMgPSB7fSxcblxuXHRcdFx0ZGVmT3JkZXIgPSAwLFxuXG5cdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4gPSBmdW5jdGlvbihwbHVnaW5Nb2R1bGUpe1xuXHRcdFx0XHR2YXIgcGx1Z2luID0gcGx1Z2luTW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0cGx1Z2luTW9kdWxlLmR5bmFtaWMgPSBwbHVnaW4uZHluYW1pYztcblx0XHRcdFx0cGx1Z2luTW9kdWxlLm5vcm1hbGl6ZSA9IHBsdWdpbi5ub3JtYWxpemU7XG5cdFx0XHRcdHBsdWdpbk1vZHVsZS5sb2FkID0gcGx1Z2luLmxvYWQ7XG5cdFx0XHRcdHJldHVybiBwbHVnaW5Nb2R1bGU7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNvbHZlUGx1Z2luTG9hZFEgPSBmdW5jdGlvbihwbHVnaW4pe1xuXHRcdFx0XHQvLyBwbHVnaW5zIGlzIGEgbmV3bHkgZXhlY3V0ZWQgbW9kdWxlIHRoYXQgaGFzIGEgbG9hZFEgd2FpdGluZyB0byBydW5cblxuXHRcdFx0XHQvLyBzdGVwIDE6IHRyYXZlcnNlIHRoZSBsb2FkUSBhbmQgZml4dXAgdGhlIG1pZCBhbmQgcHJpZDsgcmVtZW1iZXIgdGhlIG1hcCBmcm9tIG9yaWdpbmFsIG1pZCB0byBuZXcgbWlkXG5cdFx0XHRcdC8vIHJlY2FsbCB0aGUgb3JpZ2luYWwgbWlkIHdhcyBjcmVhdGVkIGJlZm9yZSB0aGUgcGx1Z2luIHdhcyBvbiBib2FyZCBhbmQgdGhlcmVmb3JlIGl0IHdhcyBpbXBvc3NpYmxlIHRvXG5cdFx0XHRcdC8vIGNvbXB1dGUgdGhlIGZpbmFsIG1pZDsgYWNjb3JkaW5nbHksIHByaWQgbWF5IG9yIG1heSBub3QgY2hhbmdlLCBidXQgdGhlIG1pZCB3aWxsIGRlZmluaXRlbHkgY2hhbmdlXG5cdFx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdFx0Zm9yRWFjaChwbHVnaW4ubG9hZFEsIGZ1bmN0aW9uKHBzZXVkb1BsdWdpblJlc291cmNlKXtcblx0XHRcdFx0XHQvLyBtYW51ZmFjdHVyZSBhbmQgaW5zZXJ0IHRoZSByZWFsIG1vZHVsZSBpbiBtb2R1bGVzXG5cdFx0XHRcdFx0dmFyIHByaWQgPSByZXNvbHZlUGx1Z2luUmVzb3VyY2VJZChwbHVnaW4sIHBzZXVkb1BsdWdpblJlc291cmNlLnByaWQsIHBzZXVkb1BsdWdpblJlc291cmNlLnJlcS5tb2R1bGUpLFxuXHRcdFx0XHRcdFx0bWlkID0gcGx1Z2luLmR5bmFtaWMgPyBwc2V1ZG9QbHVnaW5SZXNvdXJjZS5taWQucmVwbGFjZSgvd2FpdGluZ0ZvclBsdWdpbiQvLCBwcmlkKSA6IChwbHVnaW4ubWlkICsgXCIhXCIgKyBwcmlkKSxcblx0XHRcdFx0XHRcdHBsdWdpblJlc291cmNlID0gbWl4KG1peCh7fSwgcHNldWRvUGx1Z2luUmVzb3VyY2UpLCB7bWlkOm1pZCwgcHJpZDpwcmlkLCBpbmplY3RlZDowfSk7XG5cdFx0XHRcdFx0aWYoIW1vZHVsZXNbbWlkXSB8fCAhbW9kdWxlc1ttaWRdLmluamVjdGVkIC8qZm9yIHJlcXVpcmUudW5kZWYqLyl7XG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgYSBuZXcgKHRoZSByZWFsKSBwbHVnaW4gcmVzb3VyY2UgYW5kIGluamVjdCBpdCBub3JtYWxseSBub3cgdGhhdCB0aGUgcGx1Z2luIGlzIG9uIGJvYXJkXG5cdFx0XHRcdFx0XHRpbmplY3RQbHVnaW4obW9kdWxlc1ttaWRdID0gcGx1Z2luUmVzb3VyY2UpO1xuXHRcdFx0XHRcdH0gLy8gZWxzZSB0aGlzIHdhcyBhIGR1cGxpY2F0ZSByZXF1ZXN0IGZvciB0aGUgc2FtZSAocGx1Z2luLCByaWQpIGZvciBhIG5vbmR5bmFtaWMgcGx1Z2luXG5cblx0XHRcdFx0XHQvLyBwbHVnaW5SZXNvdXJjZSBpcyByZWFsbHkganVzdCBhIHBsYWNlaG9sZGVyIHdpdGggdGhlIHdyb25nIG1pZCAoYmVjYXVzZSB3ZSBjb3VsZG4ndCBjYWxjdWxhdGUgaXQgdW50aWwgdGhlIHBsdWdpbiB3YXMgb24gYm9hcmQpXG5cdFx0XHRcdFx0Ly8gbWFyayBpcyBhcyBhcnJpdmVkIGFuZCBkZWxldGUgaXQgZnJvbSBtb2R1bGVzOyB0aGUgcmVhbCBtb2R1bGUgd2FzIHJlcXVlc3RlZCBhYm92ZVxuXHRcdFx0XHRcdG1hcFtwc2V1ZG9QbHVnaW5SZXNvdXJjZS5taWRdID0gbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHRcdHNldEFycml2ZWQocHNldWRvUGx1Z2luUmVzb3VyY2UpO1xuXHRcdFx0XHRcdGRlbGV0ZSBtb2R1bGVzW3BzZXVkb1BsdWdpblJlc291cmNlLm1pZF07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwbHVnaW4ubG9hZFEgPSAwO1xuXG5cdFx0XHRcdC8vIHN0ZXAyOiByZXBsYWNlIGFsbCByZWZlcmVuY2VzIHRvIGFueSBwbGFjZWhvbGRlciBtb2R1bGVzIHdpdGggcmVhbCBtb2R1bGVzXG5cdFx0XHRcdHZhciBzdWJzdGl0dXRlTW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdFx0Zm9yKHZhciByZXBsYWNlbWVudCwgZGVwcyA9IG1vZHVsZS5kZXBzIHx8IFtdLCBpID0gMDsgaTxkZXBzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRcdHJlcGxhY2VtZW50ID0gbWFwW2RlcHNbaV0ubWlkXTtcblx0XHRcdFx0XHRcdGlmKHJlcGxhY2VtZW50KXtcblx0XHRcdFx0XHRcdFx0ZGVwc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yKHZhciBwIGluIG1vZHVsZXMpe1xuXHRcdFx0XHRcdHN1YnN0aXR1dGVNb2R1bGVzKG1vZHVsZXNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvckVhY2goZXhlY1EsIHN1YnN0aXR1dGVNb2R1bGVzKTtcblx0XHRcdH0sXG5cblx0XHRcdGZpbmlzaEV4ZWMgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItZmluaXNoLWV4ZWNcIiwgW21vZHVsZS5taWRdKTtcblx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gZXhlY3V0ZWQ7XG5cdFx0XHRcdG1vZHVsZS5kZWZPcmRlciA9IGRlZk9yZGVyKys7XG5cdFx0XHRcdCAwICAmJiBmb3JFYWNoKG1vZHVsZS5wcm92aWRlcywgZnVuY3Rpb24oY2IpeyBjYigpOyB9KTtcblx0XHRcdFx0aWYobW9kdWxlLmxvYWRRKXtcblx0XHRcdFx0XHQvLyB0aGUgbW9kdWxlIHdhcyBhIHBsdWdpblxuXHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihtb2R1bGUpO1xuXHRcdFx0XHRcdHJlc29sdmVQbHVnaW5Mb2FkUShtb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgdGhpcyBtb2R1bGUgZnJvbSB0aGUgZXhlY1Fcblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgZXhlY1EubGVuZ3RoOyl7XG5cdFx0XHRcdFx0aWYoZXhlY1FbaV0gPT09IG1vZHVsZSl7XG5cdFx0XHRcdFx0XHRleGVjUS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRlbGV0ZSByZWZlcmVuY2VzIHRvIHN5bnRoZXRpYyBtb2R1bGVzXG5cdFx0XHRcdGlmICgvXnJlcXVpcmVcXCovLnRlc3QobW9kdWxlLm1pZCkpIHtcblx0XHRcdFx0XHRkZWxldGUgbW9kdWxlc1ttb2R1bGUubWlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Y2lyY2xlVHJhY2UgPSBbXSxcblxuXHRcdFx0ZXhlY01vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgc3RyaWN0KXtcblx0XHRcdFx0Ly8gcnVuIHRoZSBkZXBlbmRlbmN5IHZlY3RvciwgdGhlbiBydW4gdGhlIGZhY3RvcnkgZm9yIG1vZHVsZVxuXHRcdFx0XHRpZihtb2R1bGUuZXhlY3V0ZWQgPT09IGV4ZWN1dGluZyl7XG5cdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWNpcmN1bGFyLWRlcGVuZGVuY3lcIiwgW2NpcmNsZVRyYWNlLmNvbmNhdChtb2R1bGUubWlkKS5qb2luKFwiLT5cIildKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtb2R1bGUuZGVmIHx8IHN0cmljdCkgPyBhYm9ydEV4ZWMgOiAgKG1vZHVsZS5janMgJiYgbW9kdWxlLmNqcy5leHBvcnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhdCB0aGlzIHBvaW50IHRoZSBtb2R1bGUgaXMgZWl0aGVyIG5vdCBleGVjdXRlZCBvciBmdWxseSBleGVjdXRlZFxuXG5cblx0XHRcdFx0aWYoIW1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0aWYoIW1vZHVsZS5kZWYpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFib3J0RXhlYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIG1pZCA9IG1vZHVsZS5taWQsXG5cdFx0XHRcdFx0XHRkZXBzID0gbW9kdWxlLmRlcHMgfHwgW10sXG5cdFx0XHRcdFx0XHRhcmcsIGFyZ1Jlc3VsdCxcblx0XHRcdFx0XHRcdGFyZ3MgPSBbXSxcblx0XHRcdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdGNpcmNsZVRyYWNlLnB1c2gobWlkKTtcblx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1leGVjLW1vZHVsZVwiLCBbXCJleGVjXCIsIGNpcmNsZVRyYWNlLmxlbmd0aCwgbWlkXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZm9yIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgYXNzdW1lIHRoZSBmaXJzdCBtb2R1bGUgZW5jb3VudGVyZWQgd2FzIGV4ZWN1dGVkIE9LXG5cdFx0XHRcdFx0Ly8gbW9kdWxlcyB0aGF0IGNpcmN1bGFybHkgZGVwZW5kIG9uIGEgbW9kdWxlIHRoYXQgaGFzIG5vdCBydW4gaXRzIGZhY3Rvcnkgd2lsbCBnZXRcblx0XHRcdFx0XHQvLyB0aGUgcHJlLW1hZGUgY2pzLmV4cG9ydHM9PT1tb2R1bGUucmVzdWx0LiBUaGV5IGNhbiB0YWtlIGEgcmVmZXJlbmNlIHRvIHRoaXMgb2JqZWN0IGFuZC9vclxuXHRcdFx0XHRcdC8vIGFkZCBwcm9wZXJ0aWVzIHRvIGl0LiBXaGVuIHRoZSBtb2R1bGUgZmluYWxseSBydW5zIGl0cyBmYWN0b3J5LCB0aGUgZmFjdG9yeSBjYW5cblx0XHRcdFx0XHQvLyByZWFkL3dyaXRlL3JlcGxhY2UgdGhpcyBvYmplY3QuIE5vdGljZSB0aGF0IHNvIGxvbmcgYXMgdGhlIG9iamVjdCBpc24ndCByZXBsYWNlZCwgYW55XG5cdFx0XHRcdFx0Ly8gcmVmZXJlbmNlIHRha2VuIGVhcmxpZXIgd2hpbGUgd2Fsa2luZyB0aGUgZGVwcyBsaXN0IGlzIHN0aWxsIHZhbGlkLlxuXHRcdFx0XHRcdG1vZHVsZS5leGVjdXRlZCA9IGV4ZWN1dGluZztcblx0XHRcdFx0XHR3aGlsZSgoYXJnID0gZGVwc1tpKytdKSl7XG5cdFx0XHRcdFx0XHRhcmdSZXN1bHQgPSAoKGFyZyA9PT0gY2pzUmVxdWlyZU1vZHVsZSkgPyBjcmVhdGVSZXF1aXJlKG1vZHVsZSkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKGFyZyA9PT0gY2pzRXhwb3J0c01vZHVsZSkgPyBtb2R1bGUuY2pzLmV4cG9ydHMgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCgoYXJnID09PSBjanNNb2R1bGVNb2R1bGUpID8gbW9kdWxlLmNqcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleGVjTW9kdWxlKGFyZywgc3RyaWN0KSkpKTtcblx0XHRcdFx0XHRcdGlmKGFyZ1Jlc3VsdCA9PT0gYWJvcnRFeGVjKXtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gMDtcblx0XHRcdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWV4ZWMtbW9kdWxlXCIsIFtcImFib3J0XCIsIG1pZF0pO1xuXHRcdFx0XHRcdFx0XHQgMCAgJiYgY2lyY2xlVHJhY2UucG9wKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhYm9ydEV4ZWM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goYXJnUmVzdWx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVuRmFjdG9yeShtb2R1bGUsIGFyZ3MpO1xuXHRcdFx0XHRcdGZpbmlzaEV4ZWMobW9kdWxlKTtcblx0XHRcdFx0XHQgMCAgJiYgY2lyY2xlVHJhY2UucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYXQgdGhpcyBwb2ludCB0aGUgbW9kdWxlIGlzIGd1YXJhbnRlZWQgZnVsbHkgZXhlY3V0ZWRcblxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLnJlc3VsdDtcblx0XHRcdH0sXG5cblxuXHRcdFx0Y2hlY2tDb21wbGV0ZUd1YXJkID0gMCxcblxuXHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlID0gZnVuY3Rpb24ocHJvYyl7XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRjaGVja0NvbXBsZXRlR3VhcmQrKztcblx0XHRcdFx0XHRwcm9jKCk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHQvLyBodHRwczovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNjYxN1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1maW5hbGx5e1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGVHdWFyZC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV4ZWNDb21wbGV0ZSgpKXtcblx0XHRcdFx0XHRzaWduYWwoXCJpZGxlXCIsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIGtlZXAgZ29pbmcgdGhyb3VnaCB0aGUgZXhlY1EgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgZmFjdG9yeSBpcyBleGVjdXRlZFxuXHRcdFx0XHQvLyBwbHVnaW5zLCByZWN1cnNpb24sIGNhY2hlZCBtb2R1bGVzIGFsbCBtYWtlIGZvciBtYW55IGV4ZWN1dGlvbiBwYXRoIHBvc3NpYmlsaXRpZXNcblx0XHRcdFx0aWYoY2hlY2tDb21wbGV0ZUd1YXJkKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y2hlY2tEb2pvUmVxdWlyZVBsdWdpbigpO1xuXHRcdFx0XHRcdGZvcih2YXIgY3VycmVudERlZk9yZGVyLCBtb2R1bGUsIGkgPSAwOyBpIDwgZXhlY1EubGVuZ3RoOyl7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVmT3JkZXIgPSBkZWZPcmRlcjtcblx0XHRcdFx0XHRcdG1vZHVsZSA9IGV4ZWNRW2ldO1xuXHRcdFx0XHRcdFx0ZXhlY01vZHVsZShtb2R1bGUpO1xuXHRcdFx0XHRcdFx0aWYoY3VycmVudERlZk9yZGVyIT1kZWZPcmRlcil7XG5cdFx0XHRcdFx0XHRcdC8vIGRlZk9yZGVyIHdhcyBidW1wZWQgb25lIG9yIG1vcmUgdGltZXMgaW5kaWNhdGluZyBzb21ldGhpbmcgd2FzIGV4ZWN1dGVkIChub3RlLCB0aGlzIGluZGljYXRlc1xuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZXhlY1Egd2FzIG1vZGlmaWVkLCBtYXliZSBhIGxvdCAoZm9yIGV4YW1wbGUgYSBsYXRlciBtb2R1bGUgY2F1c2VzIGFuIGVhcmxpZXIgbW9kdWxlIHRvIGV4ZWN1dGUpXG5cdFx0XHRcdFx0XHRcdGNoZWNrRG9qb1JlcXVpcmVQbHVnaW4oKTtcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gbm90aGluZyBoYXBwZW5lZDsgY2hlY2sgdGhlIG5leHQgbW9kdWxlIGluIHRoZSBleGVjIHF1ZXVlXG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0fVxuXG5cdHZhciBmaXh1cFVybD0gdHlwZW9mIHVzZXJDb25maWcuZml4dXBVcmwgPT0gXCJmdW5jdGlvblwiID8gdXNlckNvbmZpZy5maXh1cFVybCA6IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHR1cmwgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIHVybCBpcyBhIEphdmFzY3JpcHQgc3RyaW5nIChzb21lIHBhdGhzIG1heSBiZSBhIEphdmEgc3RyaW5nKVxuXHRcdFx0cmV0dXJuIHVybCArIChjYWNoZUJ1c3QgPyAoKC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgY2FjaGVCdXN0KSA6IFwiXCIpO1xuXHRcdH07XG5cblxuXG5cdGlmKCAwICl7XG5cdFx0cmVxLnVuZGVmID0gZnVuY3Rpb24obW9kdWxlSWQsIHJlZmVyZW5jZU1vZHVsZSl7XG5cdFx0XHQvLyBJbiBvcmRlciB0byByZWxvYWQgYSBtb2R1bGUsIGl0IG11c3QgYmUgdW5kZWZpbmVkICh0aGlzIHJvdXRpbmUpIGFuZCB0aGVuIHJlLXJlcXVlc3RlZC5cblx0XHRcdC8vIFRoaXMgaXMgdXNlZnVsIGZvciB0ZXN0aW5nIGZyYW1ld29ya3MgKGF0IGxlYXN0KS5cblx0XHRcdHZhciBtb2R1bGUgPSBnZXRNb2R1bGUobW9kdWxlSWQsIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRzZXRBcnJpdmVkKG1vZHVsZSk7XG5cdFx0XHRtaXgobW9kdWxlLCB7ZGVmOjAsIGV4ZWN1dGVkOjAsIGluamVjdGVkOjAsIG5vZGU6MCwgbG9hZDowfSk7XG5cdFx0fTtcblx0fVxuXG5cdGlmKCBmYWxzZSApe1xuXHRcdGlmKCAwID09PXVuZGVmaW5lZCl7XG5cdFx0XHQgMCAmJiBoYXMuYWRkKFwiZG9qby1sb2FkZXItZXZhbC1oaW50LXVybFwiLCAxKTtcblx0XHR9XG5cblx0XHR2YXIgaW5qZWN0UGx1Z2luID0gZnVuY3Rpb24oXG5cdFx0XHRcdG1vZHVsZVxuXHRcdFx0KXtcblx0XHRcdFx0Ly8gaW5qZWN0cyB0aGUgcGx1Z2luIG1vZHVsZSBnaXZlbiBieSBtb2R1bGU7IG1heSBoYXZlIHRvIGluamVjdCB0aGUgcGx1Z2luIGl0c2VsZlxuXHRcdFx0XHR2YXIgcGx1Z2luID0gbW9kdWxlLnBsdWdpbjtcblxuXHRcdFx0XHRpZihwbHVnaW4uZXhlY3V0ZWQgPT09IGV4ZWN1dGVkICYmICFwbHVnaW4ubG9hZCl7XG5cdFx0XHRcdFx0Ly8gZXhlY3V0ZWQgdGhlIG1vZHVsZSBub3Qga25vd2luZyBpdCB3YXMgYSBwbHVnaW5cblx0XHRcdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4ocGx1Z2luKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbkxvYWQgPSBmdW5jdGlvbihkZWYpe1xuXHRcdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGRlZjtcblx0XHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRcdGZpbmlzaEV4ZWMobW9kdWxlKTtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmKHBsdWdpbi5sb2FkKXtcblx0XHRcdFx0XHRwbHVnaW4ubG9hZChtb2R1bGUucHJpZCwgbW9kdWxlLnJlcSwgb25Mb2FkKTtcblx0XHRcdFx0fWVsc2UgaWYocGx1Z2luLmxvYWRRKXtcblx0XHRcdFx0XHRwbHVnaW4ubG9hZFEucHVzaChtb2R1bGUpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyB0aGUgdW5zaGlmdCBpbnN0ZWFkIG9mIHB1c2ggaXMgaW1wb3J0YW50OiB3ZSBkb24ndCB3YW50IHBsdWdpbnMgdG8gZXhlY3V0ZSBhc1xuXHRcdFx0XHRcdC8vIGRlcGVuZGVuY2llcyBvZiBzb21lIG90aGVyIG1vZHVsZSBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlIGNpcmNsZXMgd2hlbiB0aGUgcGx1Z2luXG5cdFx0XHRcdFx0Ly8gbG9hZFEgaXMgcnVuOyBhbHNvLCBnZW5lcmFsbHksIHdlIHdhbnQgcGx1Z2lucyB0byBydW4gZWFybHkgc2luY2UgdGhleSBtYXkgbG9hZFxuXHRcdFx0XHRcdC8vIHNldmVyYWwgb3RoZXIgbW9kdWxlcyBhbmQgdGhlcmVmb3JlIGNhbiBwb3RlbnRpYWxseSB1bmJsb2NrIG1hbnkgbW9kdWxlc1xuXHRcdFx0XHRcdHBsdWdpbi5sb2FkUSA9IFttb2R1bGVdO1xuXHRcdFx0XHRcdGV4ZWNRLnVuc2hpZnQocGx1Z2luKTtcblx0XHRcdFx0XHRpbmplY3RNb2R1bGUocGx1Z2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gZm9yIElFLCBpbmplY3RpbmcgYSBtb2R1bGUgbWF5IHJlc3VsdCBpbiBhIHJlY3Vyc2l2ZSBleGVjdXRpb24gaWYgdGhlIG1vZHVsZSBpcyBpbiB0aGUgY2FjaGVcblxuXHRcdFx0Y2FjaGVkID0gMCxcblxuXHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMCxcblxuXHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMCxcblxuXHRcdFx0ZXZhbE1vZHVsZVRleHQgPSBmdW5jdGlvbih0ZXh0LCBtb2R1bGUpe1xuXHRcdFx0XHQvLyBzZWUgZGVmKCkgZm9yIHRoZSBpbmplY3RpbmdDYWNoZWRNb2R1bGUgYnJhY2tldDsgaXQgc2ltcGx5IGNhdXNlcyBhIHNob3J0LCBzYWZlIGNpcmN1aXRcblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oW1wiJ10pdXNlIHN0cmljdFxcMS9nLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMTtcblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRpZih0ZXh0PT09Y2FjaGVkKXtcblx0XHRcdFx0XHRcdFx0Y2FjaGVkLmNhbGwobnVsbCk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0cmVxLmV2YWwodGV4dCwgIDAgID8gbW9kdWxlLnVybCA6IG1vZHVsZS5taWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwiZXZhbE1vZHVsZVRocmV3XCIsIG1vZHVsZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aWYodGV4dD09PWNhY2hlZCl7XG5cdFx0XHRcdFx0XHRjYWNoZWQuY2FsbChudWxsKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHJlcS5ldmFsKHRleHQsICAwICA/IG1vZHVsZS51cmwgOiBtb2R1bGUubWlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMDtcblx0XHRcdH0sXG5cblx0XHRcdGluamVjdE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdC8vIEluamVjdCB0aGUgbW9kdWxlLiBJbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCwgdGhpcyBtZWFucyBhcHBlbmRpbmcgYSBzY3JpcHQgZWxlbWVudCBpbnRvXG5cdFx0XHRcdC8vIHRoZSBkb2N1bWVudDsgaW4gb3RoZXIgZW52aXJvbm1lbnRzLCBpdCBtZWFucyBsb2FkaW5nIGEgZmlsZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gSWYgaW4gc3luY2hyb25vdXMgbW9kZSwgdGhlbiBnZXQgdGhlIG1vZHVsZSBzeW5jaHJvbm91c2x5IGlmIGl0J3Mgbm90IHhkb21haW5Mb2FkaW5nLlxuXG5cdFx0XHRcdHZhciBtaWQgPSBtb2R1bGUubWlkLFxuXHRcdFx0XHRcdHVybCA9IG1vZHVsZS51cmw7XG5cdFx0XHRcdGlmKG1vZHVsZS5leGVjdXRlZCB8fCBtb2R1bGUuaW5qZWN0ZWQgfHwgd2FpdGluZ1ttaWRdIHx8IChtb2R1bGUudXJsICYmICgobW9kdWxlLnBhY2sgJiYgd2FpdGluZ1ttb2R1bGUudXJsXT09PW1vZHVsZS5wYWNrKSB8fCB3YWl0aW5nW21vZHVsZS51cmxdPT0xKSkpe1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRSZXF1ZXN0ZWQobW9kdWxlKTtcblxuXHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdHZhciB2aWFDb21ibyA9IDA7XG5cdFx0XHRcdFx0aWYobW9kdWxlLnBsdWdpbiAmJiBtb2R1bGUucGx1Z2luLmlzQ29tYm8pe1xuXHRcdFx0XHRcdFx0Ly8gYSBjb21ibyBwbHVnaW47IHRoZXJlZm9yZSwgbXVzdCBiZSBoYW5kbGVkIGJ5IGNvbWJvIHNlcnZpY2Vcblx0XHRcdFx0XHRcdC8vIHRoZSBwcmlkIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG8gYSBVUkwgKGlmIHJlcXVpcmVkIGJ5IHRoZSBwbHVnaW4pIGR1cmluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhlIG5vcm1hbGl6ZSBwcm9jZXNzOyBpbiBhbnkgZXZlbnQsIHRoZXJlIGlzIG5vIHdheSBmb3IgdGhlIGxvYWRlciB0byBrbm93IGhvdyB0b1xuXHRcdFx0XHRcdFx0Ly8gdG8gdGhlIGNvbnZlcnNpb247IHRoZXJlZm9yZSB0aGUgdGhpcmQgYXJndW1lbnQgaXMgemVyb1xuXHRcdFx0XHRcdFx0cmVxLmNvbWJvLmFkZChtb2R1bGUucGx1Z2luLm1pZCwgbW9kdWxlLnByaWQsIDAsIHJlcSk7XG5cdFx0XHRcdFx0XHR2aWFDb21ibyA9IDE7XG5cdFx0XHRcdFx0fWVsc2UgaWYoIW1vZHVsZS5wbHVnaW4pe1xuXHRcdFx0XHRcdFx0dmlhQ29tYm8gPSByZXEuY29tYm8uYWRkKDAsIG1vZHVsZS5taWQsIG1vZHVsZS51cmwsIHJlcSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHZpYUNvbWJvKXtcblx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZz0gMTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihtb2R1bGUucGx1Z2luKXtcblx0XHRcdFx0XHRpbmplY3RQbHVnaW4obW9kdWxlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gLy8gZWxzZSBhIG5vcm1hbCBtb2R1bGUgKG5vdCBhIHBsdWdpbilcblxuXG5cdFx0XHRcdHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cnVuRGVmUShtb2R1bGUpO1xuXHRcdFx0XHRcdGlmKG1vZHVsZS5pbmplY3RlZCAhPT0gYXJyaXZlZCl7XG5cdFx0XHRcdFx0XHQvLyB0aGUgc2NyaXB0IHRoYXQgY29udGFpbmVkIHRoZSBtb2R1bGUgYXJyaXZlZCBhbmQgaGFzIGJlZW4gZXhlY3V0ZWQgeWV0XG5cdFx0XHRcdFx0XHQvLyBub3RoaW5nIHdhcyBhZGRlZCB0byB0aGUgZGVmUSAoc28gaXQgd2Fzbid0IGFuIEFNRCBtb2R1bGUpIGFuZCB0aGUgbW9kdWxlXG5cdFx0XHRcdFx0XHQvLyB3YXNuJ3QgbWFya2VkIGFzIGFycml2ZWQgYnkgZG9qby5wcm92aWRlIChzbyBpdCB3YXNuJ3QgYSB2MS42LSBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0Ly8gdGhlcmVmb3JlLCBpdCBtdXN0IG5vdCBoYXZlIGJlZW4gYSBtb2R1bGU7IGFkanVzdCBzdGF0ZSBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJub0RlZmluZVwiLCBtb2R1bGUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2V0QXJyaXZlZChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0bWl4KG1vZHVsZSwgbm9uTW9kdWxlUHJvcHMpO1xuXHRcdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWRlZmluZS1ub25tb2R1bGVcIiwgW21vZHVsZS51cmxdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggMCAgJiYgbGVnYWN5TW9kZSl7XG5cdFx0XHRcdFx0XHQvLyBtdXN0IGNhbGwgY2hlY2tDb21wbGV0ZSBldmVuIGluIGZvciBzeW5jIGxvYWRlciBiZWNhdXNlIHdlIG1heSBiZSBpbiB4ZG9tYWluTG9hZGluZyBtb2RlO1xuXHRcdFx0XHRcdFx0Ly8gYnV0LCBpZiB4ZCBsb2FkaW5nLCB0aGVuIGRvbid0IGNhbGwgY2hlY2tDb21wbGV0ZSB1bnRpbCBvdXQgb2YgdGhlIGN1cnJlbnQgc3luYyB0cmF2ZXJzYWxcblx0XHRcdFx0XHRcdC8vIGluIG9yZGVyIHRvIHByZXNlcnZlIG9yZGVyIG9mIGV4ZWN1dGlvbiBvZiB0aGUgZG9qby5yZXF1aXJlZCBtb2R1bGVzXG5cdFx0XHRcdFx0XHQhc3luY0V4ZWNTdGFjay5sZW5ndGggJiYgY2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0Y2FjaGVkID0gY2FjaGVbbWlkXSB8fCBjYWNoZVt1cmxLZXlQcmVmaXggKyBtb2R1bGUudXJsXTtcblx0XHRcdFx0aWYoY2FjaGVkKXtcblx0XHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItaW5qZWN0XCIsIFtcImNhY2hlXCIsIG1vZHVsZS5taWQsIHVybF0pO1xuXHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KGNhY2hlZCwgbW9kdWxlKTtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjaygpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggMCAgJiYgbGVnYWN5TW9kZSl7XG5cdFx0XHRcdFx0aWYobW9kdWxlLmlzWGQpe1xuXHRcdFx0XHRcdFx0Ly8gc3dpdGNoIHRvIGFzeW5jIG1vZGUgdGVtcG9yYXJpbHk7IGlmIGN1cnJlbnQgbGVnYWN5TW9kZSE9c3luYywgdGhlbiBpcyBtdXN0IGJlIG9uZSBvZiB7bGVnYWN5QXN5bmMsIHhkLCBmYWxzZX1cblx0XHRcdFx0XHRcdGxlZ2FjeU1vZGU9PXN5bmMgJiYgKGxlZ2FjeU1vZGUgPSB4ZCk7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIHRocm91Z2ggYW5kIGxvYWQgdmlhIHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0XHR9ZWxzZSBpZihtb2R1bGUuaXNBbWQgJiYgbGVnYWN5TW9kZSE9c3luYyl7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIHRocm91Z2ggYW5kIGxvYWQgdmlhIHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIG1vZGUgbWF5IGJlIHN5bmMsIHhkL2xlZ2FjeUFzeW5jLCBvciBhc3luYzsgbW9kdWxlIG1heSBiZSBBTUQgb3IgbGVnYWN5OyBidXQgbW9kdWxlIGlzIGFsd2F5cyBsb2NhdGVkIG9uIHRoZSBzYW1lIGRvbWFpblxuXHRcdFx0XHRcdFx0dmFyIHhockNhbGxiYWNrID0gZnVuY3Rpb24odGV4dCl7XG5cdFx0XHRcdFx0XHRcdGlmKGxlZ2FjeU1vZGU9PXN5bmMpe1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSB0b3Agb2Ygc3luY0V4ZWNTdGFjayBnaXZlcyB0aGUgY3VycmVudCBzeW5jaHJvbm91c2x5IGV4ZWN1dGluZyBtb2R1bGU7IHRoZSBsb2FkZXIgbmVlZHNcblx0XHRcdFx0XHRcdFx0XHQvLyB0byBrbm93IHRoaXMgaWYgaXQgaGFzIHRvIHN3aXRjaCB0byBhc3luYyBsb2FkaW5nIGluIHRoZSBtaWRkbGUgb2YgZXZhbHVhdGluZyBhIGxlZ2FjeSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGhhcHBlbnMgd2hlbiBhIG1vZHVsZXMgZG9qby5yZXF1aXJlJ3MgYSBtb2R1bGUgdGhhdCBtdXN0IGJlIGxvYWRlZCBhc3luYyBiZWNhdXNlIGl0J3MgeGRvbWFpblxuXHRcdFx0XHRcdFx0XHRcdC8vICh1c2luZyB1bnNoaWZ0L3NoaWZ0IGJlY2F1c2UgdGhlcmUgaXMgbm8gYmFjaygpIG1ldGhvZHMgZm9yIEphdmFzY3JpcHQgYXJyYXlzKVxuXHRcdFx0XHRcdFx0XHRcdHN5bmNFeGVjU3RhY2sudW5zaGlmdChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KHRleHQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0XHRcdFx0c3luY0V4ZWNTdGFjay5zaGlmdCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gbWF5YmUgdGhlIG1vZHVsZSB3YXMgYW4gQU1EIG1vZHVsZVxuXHRcdFx0XHRcdFx0XHRcdHJ1bkRlZlEobW9kdWxlKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGxlZ2FjeSBtb2R1bGVzIG5ldmVyIGdldCB0byBkZWZpbmVNb2R1bGUoKSA9PiBjanMgYW5kIGluamVjdGVkIG5ldmVyIHNldDsgYWxzbyBldmFsdWF0aW9uIGltcGxpZXMgZXhlY3V0aW5nXG5cdFx0XHRcdFx0XHRcdFx0aWYoIW1vZHVsZS5janMpe1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0QXJyaXZlZChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmluaXNoRXhlYyhtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmKG1vZHVsZS5maW5pc2gpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2hpbGUgc3luY2hyb25vdXNseSBldmFsdWF0aW5nIHRoaXMgbW9kdWxlLCBkb2pvLnJlcXVpcmUgd2FzIGFwcGxpZWQgcmVmZXJlbmNpbmcgYSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoYXQgaGFkIHRvIGJlIGxvYWRlZCBhc3luYzsgdGhlcmVmb3JlLCB0aGUgbG9hZGVyIHN0b3BwZWQgYW5zd2VyaW5nIGFsbCBkb2pvLnJlcXVpcmVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlcXVlc3RzIHNvIHRoZXkgY291bGQgYmUgYW5zd2VyZWQgY29tcGxldGVseSBpbiB0aGUgY29ycmVjdCBzZXF1ZW5jZTsgbW9kdWxlLmZpbmlzaCBnaXZlc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGxpc3Qgb2YgZG9qby5yZXF1aXJlcyB0aGF0IG11c3QgYmUgcmUtYXBwbGllZCBvbmNlIGFsbCB0YXJnZXQgbW9kdWxlcyBhcmUgYXZhaWxhYmxlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gbWFrZSBhIHN5bnRoZXRpYyBtb2R1bGUgdG8gZXhlY3V0ZSB0aGUgZG9qby5yZXF1aXJlJ3MgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY29tcHV0ZSBhIGd1YXJhbnRlZWQtdW5pcXVlIG1pZCBmb3IgdGhlIHN5bnRoZXRpYyBmaW5pc2ggbW9kdWxlOyByZW1lbWJlciB0aGUgZmluaXNoIHZlY3RvcjsgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZmVyZW5jZSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFRPRE86IGNhbiB3ZSBqdXN0IGxlYXZlIHRoZSBtb2R1bGUuZmluaXNoLi4ud2hhdCdzIGl0IGh1cnRpbmc/XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZmluaXNoTWlkID0gbWlkICsgXCIqZmluaXNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpbmlzaCA9IG1vZHVsZS5maW5pc2g7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgbW9kdWxlLmZpbmlzaDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmKGZpbmlzaE1pZCwgW1wiZG9qb1wiLCAoXCJkb2pvL3JlcXVpcmUhXCIgKyBmaW5pc2guam9pbihcIixcIikpLnJlcGxhY2UoL1xcLi9nLCBcIi9cIildLCBmdW5jdGlvbihkb2pvKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yRWFjaChmaW5pc2gsIGZ1bmN0aW9uKG1pZCl7IGRvam8ucmVxdWlyZShtaWQpOyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdW5zaGlmdCwgbm90IHB1c2gsIHdoaWNoIGNhdXNlcyB0aGUgY3VycmVudCB0cmF2ZXJzYWwgdG8gYmUgcmVhdHRlbXB0ZWQgZnJvbSB0aGUgdG9wXG5cdFx0XHRcdFx0XHRcdFx0XHRleGVjUS51bnNoaWZ0KGdldE1vZHVsZShmaW5pc2hNaWQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRyYW5zZm9ybVRvQW1kKG1vZHVsZSwgdGV4dCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGV4dCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRldmFsTW9kdWxlVGV4dCh0ZXh0LCBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRyYW5zZm9ybVRvQW1kIHJldHVybmVkIGZhbHN5LCB0aGVuIHRoZSBtb2R1bGUgd2FzIGFscmVhZHkgQU1EIGFuZCBpdCBjYW4gYmUgc2NyaXB0LWluamVjdGVkXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkbyBzbyB0byBpbXByb3ZlIGRlYnVnYWJpbGl0eShldmVuIHRob3VnaCBpdCBtZWFucyBhbm90aGVyIGRvd25sb2FkLi4ud2hpY2ggcHJvYmFibHkgd29uJ3QgaGFwcGVuIHdpdGggYSBnb29kIGJyb3dzZXIgY2FjaGUpXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmplY3RpbmdNb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXEuaW5qZWN0VXJsKGZpeHVwVXJsKHVybCksIG9uTG9hZENhbGxiYWNrLCBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1pbmplY3RcIiwgW1wieGhyXCIsIG1vZHVsZS5taWQsIHVybCwgbGVnYWN5TW9kZSE9c3luY10pO1xuXHRcdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRcdHJlcS5nZXRUZXh0KHVybCwgbGVnYWN5TW9kZSE9c3luYywgeGhyQ2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJ4aHJJbmplY3RGYWlsZWRcIiwgW21vZHVsZSwgZV0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHJlcS5nZXRUZXh0KHVybCwgbGVnYWN5TW9kZSE9c3luYywgeGhyQ2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBlbHNlIGFzeW5jIG1vZGUgb3IgZmVsbCB0aHJvdWdoIGluIHhkb21haW4gbG9hZGluZyBtb2RlOyBlaXRoZXIgd2F5LCBsb2FkIGJ5IHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWluamVjdFwiLCBbXCJzY3JpcHRcIiwgbW9kdWxlLm1pZCwgdXJsXSk7XG5cdFx0XHRcdGluamVjdGluZ01vZHVsZSA9IG1vZHVsZTtcblx0XHRcdFx0cmVxLmluamVjdFVybChmaXh1cFVybCh1cmwpLCBvbkxvYWRDYWxsYmFjaywgbW9kdWxlKTtcblx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdH0sXG5cblx0XHRcdGRlZmluZU1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgZGVwcywgZGVmKXtcblx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWRlZmluZS1tb2R1bGVcIiwgW21vZHVsZS5taWQsIGRlcHNdKTtcblxuXHRcdFx0XHRpZiggMCAgJiYgbW9kdWxlLnBsdWdpbiAmJiBtb2R1bGUucGx1Z2luLmlzQ29tYm8pe1xuXHRcdFx0XHRcdC8vIHRoZSBtb2R1bGUgaXMgYSBwbHVnaW4gcmVzb3VyY2UgbG9hZGVkIGJ5IHRoZSBjb21ibyBzZXJ2aWNlXG5cdFx0XHRcdFx0Ly8gbm90ZTogY2hlY2sgZm9yIG1vZHVsZS5wbHVnaW4gc2hvdWxkIGJlIGVub3VnaCBzaW5jZSBub3JtYWwgcGx1Z2luIHJlc291cmNlcyBzaG91bGRcblx0XHRcdFx0XHQvLyBub3QgZm9sbG93IHRoaXMgcGF0aDsgbW9kdWxlLnBsdWdpbi5pc0NvbWJvIGlzIGZ1dHVyZS1wcm9vZmluZyBiZWx0IGFuZCBzdXNwZW5kZXJzXG5cdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGlzRnVuY3Rpb24oZGVmKSA/IGRlZigpIDogZGVmO1xuXHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdFx0cmV0dXJuIG1vZHVsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtaWQgPSBtb2R1bGUubWlkO1xuXHRcdFx0XHRpZihtb2R1bGUuaW5qZWN0ZWQgPT09IGFycml2ZWQpe1xuXHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwibXVsdGlwbGVEZWZpbmVcIiwgbW9kdWxlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIG1vZHVsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtaXgobW9kdWxlLCB7XG5cdFx0XHRcdFx0ZGVwczogZGVwcyxcblx0XHRcdFx0XHRkZWY6IGRlZixcblx0XHRcdFx0XHRjanM6IHtcblx0XHRcdFx0XHRcdGlkOiBtb2R1bGUubWlkLFxuXHRcdFx0XHRcdFx0dXJpOiBtb2R1bGUudXJsLFxuXHRcdFx0XHRcdFx0ZXhwb3J0czogKG1vZHVsZS5yZXN1bHQgPSB7fSksXG5cdFx0XHRcdFx0XHRzZXRFeHBvcnRzOiBmdW5jdGlvbihleHBvcnRzKXtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmNqcy5leHBvcnRzID0gZXhwb3J0cztcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjb25maWc6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1vZHVsZS5jb25maWc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyByZXNvbHZlIGRlcHMgd2l0aCByZXNwZWN0IHRvIHRoaXMgbW9kdWxlXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGRlcHNbaV07IGkrKyl7XG5cdFx0XHRcdFx0ZGVwc1tpXSA9IGdldE1vZHVsZShkZXBzW2ldLCBtb2R1bGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUgJiYgIXdhaXRpbmdbbWlkXSl7XG5cdFx0XHRcdFx0Ly8gdGhlIG1vZHVsZSBzaG93ZWQgdXAgd2l0aG91dCBiZWluZyBhc2tlZCBmb3I7IGl0IHdhcyBwcm9iYWJseSBpbiBhIDxzY3JpcHQ+IGVsZW1lbnRcblx0XHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMobW9kdWxlKTtcblx0XHRcdFx0XHRleGVjUS5wdXNoKG1vZHVsZSk7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblxuXHRcdFx0XHRpZighaXNGdW5jdGlvbihkZWYpICYmICFkZXBzLmxlbmd0aCl7XG5cdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGRlZjtcblx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlO1xuXHRcdFx0fSxcblxuXHRcdFx0cnVuRGVmUSA9IGZ1bmN0aW9uKHJlZmVyZW5jZU1vZHVsZSwgbWlkcyl7XG5cdFx0XHRcdC8vIGRlZlEgaXMgYW4gYXJyYXkgb2YgW2lkLCBkZXBlbmRlbmNpZXMsIGZhY3RvcnldXG5cdFx0XHRcdC8vIG1pZHMgKGlmIGFueSkgaXMgYSB2ZWN0b3Igb2YgbWlkcyBnaXZlbiBieSBhIGNvbWJvIHNlcnZpY2Vcblx0XHRcdFx0dmFyIGRlZmluZWRNb2R1bGVzID0gW10sXG5cdFx0XHRcdFx0bW9kdWxlLCBhcmdzO1xuXHRcdFx0XHR3aGlsZShkZWZRLmxlbmd0aCl7XG5cdFx0XHRcdFx0YXJncyA9IGRlZlEuc2hpZnQoKTtcblx0XHRcdFx0XHRtaWRzICYmIChhcmdzWzBdPSBtaWRzLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdC8vIGV4cGxpY2l0IGRlZmluZSBpbmRpY2F0ZXMgcG9zc2libGUgbXVsdGlwbGUgbW9kdWxlcyBpbiBhIHNpbmdsZSBmaWxlOyBkZWxheSBpbmplY3RpbmcgZGVwZW5kZW5jaWVzIHVudGlsIGRlZlEgZnVsbHlcblx0XHRcdFx0XHQvLyBwcm9jZXNzZWQgc2luY2UgbW9kdWxlcyBlYXJsaWVyIGluIHRoZSBxdWV1ZSBkZXBlbmQgb24gYWxyZWFkeS1hcnJpdmVkIG1vZHVsZXMgdGhhdCBhcmUgbGF0ZXIgaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdFx0Ly8gVE9ETzogd2hhdCBpZiBubyBhcmdzWzBdIGFuZCBubyByZWZlcmVuY2VNb2R1bGVcblx0XHRcdFx0XHRtb2R1bGUgPSAoYXJnc1swXSAmJiBnZXRNb2R1bGUoYXJnc1swXSkpIHx8IHJlZmVyZW5jZU1vZHVsZTtcblx0XHRcdFx0XHRkZWZpbmVkTW9kdWxlcy5wdXNoKFttb2R1bGUsIGFyZ3NbMV0sIGFyZ3NbMl1dKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdW1lUGVuZGluZ0NhY2hlSW5zZXJ0KHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRcdGZvckVhY2goZGVmaW5lZE1vZHVsZXMsIGZ1bmN0aW9uKGFyZ3Mpe1xuXHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhkZWZpbmVNb2R1bGUuYXBwbHkobnVsbCwgYXJncykpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdH1cblxuXHR2YXIgdGltZXJJZCA9IDAsXG5cdFx0Y2xlYXJUaW1lciA9IG5vb3AsXG5cdFx0c3RhcnRUaW1lciA9IG5vb3A7XG5cdGlmKCAwICl7XG5cdFx0Ly8gVGltZXIgbWFjaGluZXJ5IHRoYXQgbW9uaXRvcnMgaG93IGxvbmcgdGhlIGxvYWRlciBpcyB3YWl0aW5nIGFuZCBzaWduYWxzIGFuIGVycm9yIHdoZW4gdGhlIHRpbWVyIHJ1bnMgb3V0LlxuXHRcdGNsZWFyVGltZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0dGltZXJJZCAmJiBjbGVhclRpbWVvdXQodGltZXJJZCk7XG5cdFx0XHR0aW1lcklkID0gMDtcblx0XHR9O1xuXG5cdFx0c3RhcnRUaW1lciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRjbGVhclRpbWVyKCk7XG5cdFx0XHRpZihyZXEud2FpdG1zKXtcblx0XHRcdFx0dGltZXJJZCA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lcigpO1xuXHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwidGltZW91dFwiLCB3YWl0aW5nKSk7XG5cdFx0XHRcdH0sIHJlcS53YWl0bXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRpZiAoIDAgKSB7XG5cdFx0Ly8gVGVzdCBmb3IgSUUncyBkaWZmZXJlbnQgd2F5IG9mIHNpZ25hbGluZyB3aGVuIHNjcmlwdHMgZmluaXNoIGxvYWRpbmcuICBOb3RlIHRoYXQgYWNjb3JkaW5nIHRvXG5cdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNTA5NiNjb21tZW50OjE0LCBJRTkgYWxzbyBuZWVkcyB0byBmb2xsb3cgdGhlXG5cdFx0Ly8gSUUgc3BlY2lmaWMgY29kZSBwYXRoIGV2ZW4gdGhvdWdoIGl0IGhhcyBhbiBhZGRFdmVudExpc3RlbmVyKCkgbWV0aG9kLlxuXHRcdC8vIFVua25vd24gaWYgc3BlY2lhbCBwYXRoIG5lZWRlZCBvbiBJRTEwKywgd2hpY2ggYWxzbyBoYXMgYSBkb2N1bWVudC5hdHRhY2hFdmVudCgpIG1ldGhvZC5cblx0XHQvLyBTaG91bGQgZXZhbHVhdGUgdG8gZmFsc2UgZm9yIE9wZXJhIGFuZCBXaW5kb3dzIDggYXBwcywgZXZlbiB0aG91Z2ggdGhleSBkb2N1bWVudC5hdHRhY2hFdmVudCgpXG5cdFx0Ly8gIGlzIGRlZmluZWQgaW4gYm90aCB0aG9zZSBlbnZpcm9ubWVudHMuXG5cdFx0IDAgJiYgaGFzLmFkZChcImllLWV2ZW50LWJlaGF2aW9yXCIsIGRvYy5hdHRhY2hFdmVudCAmJiB0eXBlb2YgV2luZG93cyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0KHR5cGVvZiBvcGVyYSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvcGVyYS50b1N0cmluZygpICE9IFwiW29iamVjdCBPcGVyYV1cIikpO1xuXHR9XG5cblx0aWYoIDAgICYmICggZmFsc2UgIHx8ICAxICkpe1xuXHRcdHZhciBkb21PbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50TmFtZSwgaWVFdmVudE5hbWUsIGhhbmRsZXIpe1xuXHRcdFx0XHQvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBET00gbm9kZSB1c2luZyB0aGUgQVBJIGFwcHJvcHJpYXRlIGZvciB0aGUgY3VycmVudCBicm93c2VyO1xuXHRcdFx0XHQvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGlzY29ubmVjdCB0aGUgbGlzdGVuZXIuXG5cdFx0XHRcdGlmKCEgMCApe1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRub2RlLmF0dGFjaEV2ZW50KGllRXZlbnROYW1lLCBoYW5kbGVyKTtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdG5vZGUuZGV0YWNoRXZlbnQoaWVFdmVudE5hbWUsIGhhbmRsZXIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR3aW5kb3dPbkxvYWRMaXN0ZW5lciA9IGRvbU9uKHdpbmRvdywgXCJsb2FkXCIsIFwib25sb2FkXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlcS5wYWdlTG9hZGVkID0gMTtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTYyNDhcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdGRvYy5yZWFkeVN0YXRlIT1cImNvbXBsZXRlXCIgJiYgKGRvYy5yZWFkeVN0YXRlID0gXCJjb21wbGV0ZVwiKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdpbmRvd09uTG9hZExpc3RlbmVyKCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmKCBmYWxzZSApe1xuXHRcdFx0Ly8gaWYgdGhlIGxvYWRlciBpcyBvbiB0aGUgcGFnZSwgdGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgc2NyaXB0IGVsZW1lbnRcblx0XHRcdC8vIGdldHRpbmcgaXRzIHBhcmVudCBhbmQgdGhlbiBkb2luZyBpbnNlcnRCZWZvcmUgc29sdmVzIHRoZSBcIk9wZXJhdGlvbiBBYm9ydGVkXCJcblx0XHRcdC8vIGVycm9yIGluIElFIGZyb20gYXBwZW5kaW5nIHRvIGEgbm9kZSB0aGF0IGlzbid0IHByb3Blcmx5IGNsb3NlZDsgc2VlXG5cdFx0XHQvLyBkb2pvL3Rlc3RzL19iYXNlL2xvYWRlci9yZXF1aXJlanMvc2ltcGxlLWJhZGJhc2UuaHRtbCBmb3IgYW4gZXhhbXBsZVxuXHRcdFx0Ly8gZG9uJ3QgdXNlIHNjcmlwdHMgd2l0aCB0eXBlIGRvam8vLi4uIHNpbmNlIHRoZXNlIG1heSBiZSByZW1vdmVkOyBzZWUgIzE1ODA5XG5cdFx0XHQvLyBwcmVmZXIgdG8gdXNlIHRoZSBpbnNlcnRQb2ludCBjb21wdXRlZCBkdXJpbmcgdGhlIGNvbmZpZyBzbmlmZiBpbiBjYXNlIGEgc2NyaXB0IGlzIHJlbW92ZWQ7IHNlZSAjMTY5NThcblx0XHRcdHZhciBzY3JpcHRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0c2NyaXB0O1xuXHRcdFx0d2hpbGUoIWluc2VydFBvaW50U2libGluZyl7XG5cdFx0XHRcdGlmKCEvXmRvam8vLnRlc3QoKHNjcmlwdCA9IHNjcmlwdHNbaSsrXSkgJiYgc2NyaXB0LnR5cGUpKXtcblx0XHRcdFx0XHRpbnNlcnRQb2ludFNpYmxpbmc9IHNjcmlwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXEuaW5qZWN0VXJsID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgb3duZXIpe1xuXHRcdFx0XHQvLyBpbnNlcnQgYSBzY3JpcHQgZWxlbWVudCB0byB0aGUgaW5zZXJ0LXBvaW50IGVsZW1lbnQgd2l0aCBzcmM9dXJsO1xuXHRcdFx0XHQvLyBhcHBseSBjYWxsYmFjayB1cG9uIGRldGVjdGluZyB0aGUgc2NyaXB0IGhhcyBsb2FkZWQuXG5cblx0XHRcdFx0dmFyIG5vZGUgPSBvd25lci5ub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksXG5cdFx0XHRcdFx0b25Mb2FkID0gZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0XHRcdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJsb2FkXCIgfHwgL2NvbXBsZXRlfGxvYWRlZC8udGVzdChub2RlLnJlYWR5U3RhdGUpKXtcblx0XHRcdFx0XHRcdFx0bG9hZERpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0XHRlcnJvckRpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bG9hZERpc2Nvbm5lY3RvciA9IGRvbU9uKG5vZGUsIFwibG9hZFwiLCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBvbkxvYWQpLFxuXHRcdFx0XHRcdGVycm9yRGlzY29ubmVjdG9yID0gZG9tT24obm9kZSwgXCJlcnJvclwiLCBcIm9uZXJyb3JcIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRsb2FkRGlzY29ubmVjdG9yKCk7XG5cdFx0XHRcdFx0XHRlcnJvckRpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJzY3JpcHRFcnJvcjogXCIgKyB1cmwsIFt1cmwsIGVdKSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0XHRcdFx0bm9kZS5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuXHRcdFx0XHRub2RlLnNyYyA9IHVybDtcblx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGluc2VydFBvaW50U2libGluZyk7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRpZiggMCApe1xuXHRcdHJlcS5sb2cgPSBmdW5jdGlvbigpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhhcmd1bWVudHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZSl7fVxuXHRcdH07XG5cdH1lbHNle1xuXHRcdHJlcS5sb2cgPSBub29wO1xuXHR9XG5cblx0aWYoIDAgKXtcblx0XHR2YXIgdHJhY2UgPSByZXEudHJhY2UgPSBmdW5jdGlvbihcblx0XHRcdGdyb3VwLFx0Ly8gdGhlIHRyYWNlIGdyb3VwIHRvIHdoaWNoIHRoaXMgYXBwbGljYXRpb24gYmVsb25nc1xuXHRcdFx0YXJnc1x0Ly8gdGhlIGNvbnRlbnRzIG9mIHRoZSB0cmFjZVxuXHRcdCl7XG5cdFx0XHQvLy9cblx0XHRcdC8vIFRyYWNpbmcgaW50ZXJmYWNlIGJ5IGdyb3VwLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFNlbmRzIHRoZSBjb250ZW50cyBvZiBhcmdzIHRvIHRoZSBjb25zb2xlIGlmZiAocmVxLnRyYWNlLm9uICYmIHJlcS50cmFjZVtncm91cF0pXG5cblx0XHRcdGlmKHRyYWNlLm9uICYmIHRyYWNlLmdyb3VwW2dyb3VwXSl7XG5cdFx0XHRcdHNpZ25hbChcInRyYWNlXCIsIFtncm91cCwgYXJnc10pO1xuXHRcdFx0XHRmb3IodmFyIGFyZywgZHVtcCA9IFtdLCB0ZXh0PSBcInRyYWNlOlwiICsgZ3JvdXAgKyAoYXJncy5sZW5ndGggPyAoXCI6XCIgKyBhcmdzWzBdKSA6IFwiXCIpLCBpPSAxOyBpPGFyZ3MubGVuZ3RoOyl7XG5cdFx0XHRcdFx0YXJnID0gYXJnc1tpKytdO1xuXHRcdFx0XHRcdGlmKGlzU3RyaW5nKGFyZykpe1xuXHRcdFx0XHRcdFx0dGV4dCArPSBcIiwgXCIgKyBhcmc7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRkdW1wLnB1c2goYXJnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVxLmxvZyh0ZXh0KTtcblx0XHRcdFx0ZHVtcC5sZW5ndGggJiYgZHVtcC5wdXNoKFwiLlwiKTtcblx0XHRcdFx0cmVxLmxvZy5hcHBseShyZXEsIGR1bXApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0bWl4KHRyYWNlLCB7XG5cdFx0XHRvbjoxLFxuXHRcdFx0Z3JvdXA6e30sXG5cdFx0XHRzZXQ6ZnVuY3Rpb24oZ3JvdXAsIHZhbHVlKXtcblx0XHRcdFx0aWYoaXNTdHJpbmcoZ3JvdXApKXtcblx0XHRcdFx0XHR0cmFjZS5ncm91cFtncm91cF09IHZhbHVlO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRtaXgodHJhY2UuZ3JvdXAsIGdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRyYWNlLnNldChtaXgobWl4KG1peCh7fSwgZGVmYXVsdENvbmZpZy50cmFjZSksIHVzZXJDb25maWcudHJhY2UpLCBkb2pvU25pZmZDb25maWcudHJhY2UpKTtcblx0XHRvbihcImNvbmZpZ1wiLCBmdW5jdGlvbihjb25maWcpe1xuXHRcdFx0Y29uZmlnLnRyYWNlICYmIHRyYWNlLnNldChjb25maWcudHJhY2UpO1xuXHRcdH0pO1xuXHR9ZWxzZXtcblx0XHRyZXEudHJhY2UgPSBub29wO1xuXHR9XG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIGRlZiA9IGZ1bmN0aW9uKFxuXHRcdFx0bWlkLFx0XHQgIC8vKGNvbW1vbmpzLm1vZHVsZUlkLCBvcHRpb25hbClcblx0XHRcdGRlcGVuZGVuY2llcywgLy8oYXJyYXkgb2YgY29tbW9uanMubW9kdWxlSWQsIG9wdGlvbmFsKSBsaXN0IG9mIG1vZHVsZXMgdG8gYmUgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGZhY3Rvcnlcblx0XHRcdGZhY3RvcnlcdFx0ICAvLyhhbnkpXG5cdFx0KXtcblx0XHRcdC8vL1xuXHRcdFx0Ly8gQWR2aXNlcyB0aGUgbG9hZGVyIG9mIGEgbW9kdWxlIGZhY3RvcnkuIC8vSW1wbGVtZW50cyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb24uXG5cdFx0XHQvLy9cblx0XHRcdC8vbm90ZVxuXHRcdFx0Ly8gQ29tbW9uSlMgZmFjdG9yeSBzY2FuIGNvdXJ0ZXN5IG9mIGh0dHA6Ly9yZXF1aXJlanMub3JnXG5cblx0XHRcdHZhciBhcml0eSA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRcdGRlZmF1bHREZXBzID0gW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJtb2R1bGVcIl0sXG5cdFx0XHRcdC8vIHRoZSBwcmVkb21pbmF0ZSBzaWduYXR1cmUuLi5cblx0XHRcdFx0YXJncyA9IFswLCBtaWQsIGRlcGVuZGVuY2llc107XG5cdFx0XHRpZihhcml0eT09MSl7XG5cdFx0XHRcdGFyZ3MgPSBbMCwgKGlzRnVuY3Rpb24obWlkKSA/IGRlZmF1bHREZXBzIDogW10pLCBtaWRdO1xuXHRcdFx0fWVsc2UgaWYoYXJpdHk9PTIgJiYgaXNTdHJpbmcobWlkKSl7XG5cdFx0XHRcdGFyZ3MgPSBbbWlkLCAoaXNGdW5jdGlvbihkZXBlbmRlbmNpZXMpID8gZGVmYXVsdERlcHMgOiBbXSksIGRlcGVuZGVuY2llc107XG5cdFx0XHR9ZWxzZSBpZihhcml0eT09Myl7XG5cdFx0XHRcdGFyZ3MgPSBbbWlkLCBkZXBlbmRlbmNpZXMsIGZhY3RvcnldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggMCAgJiYgYXJnc1sxXT09PWRlZmF1bHREZXBzKXtcblx0XHRcdFx0YXJnc1syXS50b1N0cmluZygpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyhcXC9cXCooW1xcc1xcU10qPylcXCpcXC98XFwvXFwvKC4qKSQpL21nLCBcIlwiKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9yZXF1aXJlXFwoW1wiJ10oW1xcd1xcIVxcLV9cXC5cXC9dKylbXCInXVxcKS9nLCBmdW5jdGlvbihtYXRjaCwgZGVwKXtcblx0XHRcdFx0XHRhcmdzWzFdLnB1c2goZGVwKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlcS50cmFjZShcImxvYWRlci1kZWZpbmVcIiwgYXJncy5zbGljZSgwLCAyKSk7XG5cdFx0XHR2YXIgdGFyZ2V0TW9kdWxlID0gYXJnc1swXSAmJiBnZXRNb2R1bGUoYXJnc1swXSksXG5cdFx0XHRcdG1vZHVsZTtcblx0XHRcdGlmKHRhcmdldE1vZHVsZSAmJiAhd2FpdGluZ1t0YXJnZXRNb2R1bGUubWlkXSl7XG5cdFx0XHRcdC8vIGdpdmVuIGEgbWlkIHRoYXQgaGFzbid0IGJlZW4gcmVxdWVzdGVkOyB0aGVyZWZvcmUsIGRlZmluZWQgdGhyb3VnaCBtZWFucyBvdGhlciB0aGFuIGluamVjdGluZ1xuXHRcdFx0XHQvLyBjb25zZXF1ZW50IHRvIGEgcmVxdWlyZSgpIG9yIGRlZmluZSgpIGFwcGxpY2F0aW9uOyBleGFtcGxlcyBpbmNsdWRlIGRlZmluaW5nIG1vZHVsZXMgb24tdGhlLWZseVxuXHRcdFx0XHQvLyBkdWUgdG8gc29tZSBjb2RlIHBhdGggb3IgaW5jbHVkaW5nIGEgbW9kdWxlIGluIGEgc2NyaXB0IGVsZW1lbnQuIEluIGFueSBjYXNlLFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBjYWxsYmFjayB3YWl0aW5nIHRvIGZpbmlzaCBwcm9jZXNzaW5nIGFuZCBub3RoaW5nIHRvIHRyaWdnZXIgdGhlIGRlZlEgYW5kIHRoZVxuXHRcdFx0XHQvLyBkZXBlbmRlbmNpZXMgYXJlIG5ldmVyIHJlcXVlc3RlZDsgdGhlcmVmb3JlLCBkbyBpdCBoZXJlLlxuXHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMoZGVmaW5lTW9kdWxlKHRhcmdldE1vZHVsZSwgYXJnc1sxXSwgYXJnc1syXSkpO1xuXHRcdFx0fWVsc2UgaWYoISAwICB8fCAhIDEgIHx8IGluamVjdGluZ0NhY2hlZE1vZHVsZSl7XG5cdFx0XHRcdC8vIG5vdCBJRSBwYXRoOiBhbm9ueW1vdXMgbW9kdWxlIGFuZCB0aGVyZWZvcmUgbXVzdCBoYXZlIGJlZW4gaW5qZWN0ZWQ7IHRoZXJlZm9yZSwgb25Mb2FkIHdpbGwgZmlyZSBpbW1lZGlhdGVseVxuXHRcdFx0XHQvLyBhZnRlciBzY3JpcHQgZmluaXNoZXMgYmVpbmcgZXZhbHVhdGVkIGFuZCB0aGUgZGVmUSBjYW4gYmUgcnVuIGZyb20gdGhhdCBjYWxsYmFjayB0byBkZXRlY3QgdGhlIG1vZHVsZSBpZFxuXHRcdFx0XHRkZWZRLnB1c2goYXJncyk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gSUUgcGF0aDogcG9zc2libHkgYW5vbnltb3VzIG1vZHVsZSBhbmQgdGhlcmVmb3JlIGluamVjdGVkOyB0aGVyZWZvcmUsIGNhbm5vdCBkZXBlbmQgb24gMS10by0xLFxuXHRcdFx0XHQvLyBpbi1vcmRlciBleGVjIG9mIG9uTG9hZCB3aXRoIHNjcmlwdCBldmFsIChzaW5jZSBpdCdzIElFKSBhbmQgbXVzdCBtYW51YWxseSBkZXRlY3QgaGVyZVxuXHRcdFx0XHR0YXJnZXRNb2R1bGUgPSB0YXJnZXRNb2R1bGUgfHwgaW5qZWN0aW5nTW9kdWxlO1xuXHRcdFx0XHRpZighdGFyZ2V0TW9kdWxlKXtcblx0XHRcdFx0XHRmb3IobWlkIGluIHdhaXRpbmcpe1xuXHRcdFx0XHRcdFx0bW9kdWxlID0gbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHRcdFx0aWYobW9kdWxlICYmIG1vZHVsZS5ub2RlICYmIG1vZHVsZS5ub2RlLnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpe1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiggMCAgJiYgIXRhcmdldE1vZHVsZSl7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpPGNvbWJvc1BlbmRpbmcubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGUgPSBjb21ib3NQZW5kaW5nW2ldO1xuXHRcdFx0XHRcdFx0XHRpZih0YXJnZXRNb2R1bGUubm9kZSAmJiB0YXJnZXRNb2R1bGUubm9kZS5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKXtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGU9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCAwICAmJiBpc0FycmF5KHRhcmdldE1vZHVsZSkpe1xuXHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhkZWZpbmVNb2R1bGUoZ2V0TW9kdWxlKHRhcmdldE1vZHVsZS5zaGlmdCgpKSwgYXJnc1sxXSwgYXJnc1syXSkpO1xuXHRcdFx0XHRcdGlmKCF0YXJnZXRNb2R1bGUubGVuZ3RoKXtcblx0XHRcdFx0XHRcdGNvbWJvc1BlbmRpbmcuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2UgaWYodGFyZ2V0TW9kdWxlKXtcblx0XHRcdFx0XHRjb25zdW1lUGVuZGluZ0NhY2hlSW5zZXJ0KHRhcmdldE1vZHVsZSk7XG5cdFx0XHRcdFx0aW5qZWN0RGVwZW5kZW5jaWVzKGRlZmluZU1vZHVsZSh0YXJnZXRNb2R1bGUsIGFyZ3NbMV0sIGFyZ3NbMl0pKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJpZURlZmluZUZhaWxlZFwiLCBhcmdzWzBdKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZGVmLmFtZCA9IHtcblx0XHRcdHZlbmRvcjpcImRvam90b29sa2l0Lm9yZ1wiXG5cdFx0fTtcblxuXHRcdGlmKCAwICl7XG5cdFx0XHRyZXEuZGVmID0gZGVmO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YXIgZGVmID0gbm9vcDtcblx0fVxuXHQvLyBhbGxvdyBjb25maWcgdG8gb3ZlcnJpZGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBuYW1lZCBmdW5jdGlvbnM7IHRoaXMgaXMgdXNlZnVsIGZvclxuXHQvLyBub24tYnJvd3NlciBlbnZpcm9ubWVudHMsIGUuZy4sIG92ZXJyaWRpbmcgaW5qZWN0VXJsLCBnZXRUZXh0LCBsb2csIGV0Yy4gaW4gbm9kZS5qcywgUmhpbm8sIGV0Yy5cblx0Ly8gYWxzbyB1c2VmdWwgZm9yIHRlc3RpbmcgYW5kIG1vbmtleSBwYXRjaGluZyBsb2FkZXJcblx0bWl4KG1peChyZXEsIGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2gpLCB1c2VyQ29uZmlnLmxvYWRlclBhdGNoKTtcblxuXHQvLyBub3cgdGhhdCByZXEgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHdvbid0IGNoYW5nZSwgd2UgY2FuIGhvb2sgaXQgdXAgdG8gdGhlIGVycm9yIHNpZ25hbFxuXHRvbihlcnJvciwgZnVuY3Rpb24oYXJnKXtcblx0XHR0cnl7XG5cdFx0XHRjb25zb2xlLmVycm9yKGFyZyk7XG5cdFx0XHRpZihhcmcgaW5zdGFuY2VvZiBFcnJvcil7XG5cdFx0XHRcdGZvcih2YXIgcCBpbiBhcmcpe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHAgKyBcIjpcIiwgYXJnW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIi5cIik7XG5cdFx0XHR9XG5cdFx0fWNhdGNoKGUpe31cblx0fSk7XG5cblx0Ly8gYWx3YXlzIHB1Ymxpc2ggdGhlc2Vcblx0bWl4KHJlcSwge1xuXHRcdHVpZDp1aWQsXG5cdFx0Y2FjaGU6Y2FjaGUsXG5cdFx0cGFja3M6cGFja3Ncblx0fSk7XG5cblxuXHRpZiggMCApe1xuXHRcdG1peChyZXEsIHtcblx0XHRcdC8vIHRoZXNlIG1heSBiZSBpbnRlcmVzdGluZyB0byBsb29rIGF0IHdoZW4gZGVidWdnaW5nXG5cdFx0XHRwYXRoczpwYXRocyxcblx0XHRcdGFsaWFzZXM6YWxpYXNlcyxcblx0XHRcdG1vZHVsZXM6bW9kdWxlcyxcblx0XHRcdGxlZ2FjeU1vZGU6bGVnYWN5TW9kZSxcblx0XHRcdGV4ZWNROmV4ZWNRLFxuXHRcdFx0ZGVmUTpkZWZRLFxuXHRcdFx0d2FpdGluZzp3YWl0aW5nLFxuXG5cdFx0XHQvLyB0aGVzZSBhcmUgdXNlZCBmb3IgdGVzdGluZ1xuXHRcdFx0Ly8gVE9ETzogbW92ZSB0ZXN0aW5nIGluZnJhc3RydWN0dXJlIHRvIGEgZGlmZmVyZW50IGhhcyBmZWF0dXJlXG5cdFx0XHRwYWNrczpwYWNrcyxcblx0XHRcdG1hcFByb2dzOm1hcFByb2dzLFxuXHRcdFx0cGF0aHNNYXBQcm9nOnBhdGhzTWFwUHJvZyxcblx0XHRcdGxpc3RlbmVyUXVldWVzOmxpc3RlbmVyUXVldWVzLFxuXG5cdFx0XHQvLyB0aGVzZSBhcmUgdXNlZCBieSB0aGUgYnVpbGRlciAoYXQgbGVhc3QpXG5cdFx0XHRjb21wdXRlTWFwUHJvZzpjb21wdXRlTWFwUHJvZyxcblx0XHRcdGNvbXB1dGVBbGlhc2VzOmNvbXB1dGVBbGlhc2VzLFxuXHRcdFx0cnVuTWFwUHJvZzpydW5NYXBQcm9nLFxuXHRcdFx0Y29tcGFjdFBhdGg6Y29tcGFjdFBhdGgsXG5cdFx0XHRnZXRNb2R1bGVJbmZvOmdldE1vZHVsZUluZm9fXG5cdFx0fSk7XG5cdH1cblxuXHQvLyB0aGUgbG9hZGVyIGNhbiBiZSBkZWZpbmVkIGV4YWN0bHkgb25jZTsgbG9vayBmb3IgZ2xvYmFsIGRlZmluZSB3aGljaCBpcyB0aGUgc3ltYm9sIEFNRCBsb2FkZXJzIGFyZVxuXHQvLyAqcmVxdWlyZWQqIHRvIGRlZmluZSAoYXMgb3Bwb3NlZCB0byByZXF1aXJlLCB3aGljaCBpcyBvcHRpb25hbClcblx0aWYoZ2xvYmFsLmRlZmluZSl7XG5cdFx0aWYoIDAgKXtcblx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwiZGVmaW5lQWxyZWFkeURlZmluZWRcIiwgMCkpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1lbHNle1xuXHRcdGdsb2JhbC5kZWZpbmUgPSBkZWY7XG5cdFx0Z2xvYmFsLnJlcXVpcmUgPSByZXE7XG5cdFx0aWYoIDAgKXtcblx0XHRcdHJlcXVpcmUgPSByZXE7XG5cdFx0fVxuXHR9XG5cblx0aWYoIDAgICYmIHJlcS5jb21ibyAmJiByZXEuY29tYm8ucGx1Z2lucyl7XG5cdFx0dmFyIHBsdWdpbnMgPSByZXEuY29tYm8ucGx1Z2lucyxcblx0XHRcdHBsdWdpbk5hbWU7XG5cdFx0Zm9yKHBsdWdpbk5hbWUgaW4gcGx1Z2lucyl7XG5cdFx0XHRtaXgobWl4KGdldE1vZHVsZShwbHVnaW5OYW1lKSwgcGx1Z2luc1twbHVnaW5OYW1lXSksIHtpc0NvbWJvOjEsIGV4ZWN1dGVkOlwiZXhlY3V0ZWRcIiwgbG9hZDoxfSk7XG5cdFx0fVxuXHR9XG5cblx0aWYoIDEgICYmICEgMSApe1xuXHRcdGZvckVhY2goZGVsYXllZE1vZHVsZUNvbmZpZywgZnVuY3Rpb24oYyl7IGNvbmZpZyhjKTsgfSk7XG5cdFx0dmFyIGJvb3REZXBzID0gZG9qb1NuaWZmQ29uZmlnLmRlcHMgfHxcdHVzZXJDb25maWcuZGVwcyB8fCBkZWZhdWx0Q29uZmlnLmRlcHMsXG5cdFx0XHRib290Q2FsbGJhY2sgPSBkb2pvU25pZmZDb25maWcuY2FsbGJhY2sgfHwgdXNlckNvbmZpZy5jYWxsYmFjayB8fCBkZWZhdWx0Q29uZmlnLmNhbGxiYWNrO1xuXHRcdHJlcS5ib290ID0gKGJvb3REZXBzIHx8IGJvb3RDYWxsYmFjaykgPyBbYm9vdERlcHMgfHwgW10sIGJvb3RDYWxsYmFja10gOiAwO1xuXHR9XG5cdGlmKCEgMSApe1xuXHRcdCFyZXEuYXN5bmMgJiYgcmVxKFtcImRvam9cIl0pO1xuXHRcdHJlcS5ib290ICYmIHJlcS5hcHBseShudWxsLCByZXEuYm9vdCk7XG5cdH1cbn0pXG4uY2FsbCh0aGlzLCB1c2VyQ29uZmlnLCBkZWZhdWx0Q29uZmlnKTt9OyIsImRlZmluZShbXG5cdFwiLi9oYXNcIixcblx0XCIuL19iYXNlL2xhbmdcIixcblx0XCIuL2Vycm9ycy9DYW5jZWxFcnJvclwiLFxuXHRcIi4vcHJvbWlzZS9Qcm9taXNlXCIsXG5cdFwiLi9oYXMhY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uPy4vcHJvbWlzZS9pbnN0cnVtZW50YXRpb25cIlxuXSwgZnVuY3Rpb24oaGFzLCBsYW5nLCBDYW5jZWxFcnJvciwgUHJvbWlzZSwgaW5zdHJ1bWVudGF0aW9uKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL0RlZmVycmVkXG5cblx0dmFyIFBST0dSRVNTID0gMCxcblx0XHRcdFJFU09MVkVEID0gMSxcblx0XHRcdFJFSkVDVEVEID0gMjtcblx0dmFyIEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFID0gXCJUaGlzIGRlZmVycmVkIGhhcyBhbHJlYWR5IGJlZW4gZnVsZmlsbGVkLlwiO1xuXG5cdHZhciBmcmVlemVPYmplY3QgPSBPYmplY3QuZnJlZXplIHx8IGZ1bmN0aW9uKCl7fTtcblxuXHR2YXIgc2lnbmFsV2FpdGluZyA9IGZ1bmN0aW9uKHdhaXRpbmcsIHR5cGUsIHJlc3VsdCwgcmVqZWN0aW9uLCBkZWZlcnJlZCl7XG5cdFx0aWYoaGFzKFwiY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpKXtcblx0XHRcdGlmKHR5cGUgPT09IFJFSkVDVEVEICYmIERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCAmJiB3YWl0aW5nLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZChyZXN1bHQsIGZhbHNlLCByZWplY3Rpb24sIGRlZmVycmVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd2FpdGluZy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRzaWduYWxMaXN0ZW5lcih3YWl0aW5nW2ldLCB0eXBlLCByZXN1bHQsIHJlamVjdGlvbik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBzaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyLCB0eXBlLCByZXN1bHQsIHJlamVjdGlvbil7XG5cdFx0dmFyIGZ1bmMgPSBsaXN0ZW5lclt0eXBlXTtcblx0XHR2YXIgZGVmZXJyZWQgPSBsaXN0ZW5lci5kZWZlcnJlZDtcblx0XHRpZihmdW5jKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0dmFyIG5ld1Jlc3VsdCA9IGZ1bmMocmVzdWx0KTtcblx0XHRcdFx0aWYodHlwZSA9PT0gUFJPR1JFU1Mpe1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBuZXdSZXN1bHQgIT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0c2lnbmFsRGVmZXJyZWQoZGVmZXJyZWQsIHR5cGUsIG5ld1Jlc3VsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRpZihuZXdSZXN1bHQgJiYgdHlwZW9mIG5ld1Jlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsID0gbmV3UmVzdWx0LmNhbmNlbDtcblx0XHRcdFx0XHRcdG5ld1Jlc3VsdC50aGVuKFxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbWFrZSByZXNvbHZlcnMgaWYgdGhleSdyZSBhY3R1YWxseSBnb2luZyB0byBiZSB1c2VkXG5cdFx0XHRcdFx0XHRcdFx0bWFrZURlZmVycmVkU2lnbmFsZXIoZGVmZXJyZWQsIFJFU09MVkVEKSxcblx0XHRcdFx0XHRcdFx0XHRtYWtlRGVmZXJyZWRTaWduYWxlcihkZWZlcnJlZCwgUkVKRUNURUQpLFxuXHRcdFx0XHRcdFx0XHRcdG1ha2VEZWZlcnJlZFNpZ25hbGVyKGRlZmVycmVkLCBQUk9HUkVTUykpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzaWduYWxEZWZlcnJlZChkZWZlcnJlZCwgUkVTT0xWRUQsIG5ld1Jlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlcnJvcil7XG5cdFx0XHRcdHNpZ25hbERlZmVycmVkKGRlZmVycmVkLCBSRUpFQ1RFRCwgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0c2lnbmFsRGVmZXJyZWQoZGVmZXJyZWQsIHR5cGUsIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0aWYoaGFzKFwiY29uZmlnLWRlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpKXtcblx0XHRcdGlmKHR5cGUgPT09IFJFSkVDVEVEICYmIERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZChyZXN1bHQsICEhZnVuYywgcmVqZWN0aW9uLCBkZWZlcnJlZC5wcm9taXNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIG1ha2VEZWZlcnJlZFNpZ25hbGVyID0gZnVuY3Rpb24oZGVmZXJyZWQsIHR5cGUpe1xuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRzaWduYWxEZWZlcnJlZChkZWZlcnJlZCwgdHlwZSwgdmFsdWUpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIHNpZ25hbERlZmVycmVkID0gZnVuY3Rpb24oZGVmZXJyZWQsIHR5cGUsIHJlc3VsdCl7XG5cdFx0aWYoIWRlZmVycmVkLmlzQ2FuY2VsZWQoKSl7XG5cdFx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRcdGNhc2UgUFJPR1JFU1M6XG5cdFx0XHRcdFx0ZGVmZXJyZWQucHJvZ3Jlc3MocmVzdWx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBSRVNPTFZFRDpcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgUkVKRUNURUQ6XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KHJlc3VsdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBEZWZlcnJlZCA9IGZ1bmN0aW9uKGNhbmNlbGVyKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZGVmZXJyZWQuIFRoaXMgQVBJIGlzIHByZWZlcnJlZCBvdmVyXG5cdFx0Ly9cdFx0YGRvam8vX2Jhc2UvRGVmZXJyZWRgLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZGVmZXJyZWQsIGFzIGFuIGFic3RyYWN0aW9uIG92ZXIgKHByaW1hcmlseSlcblx0XHQvL1x0XHRhc3luY2hyb25vdXMgb3BlcmF0aW9ucy4gVGhlIGRlZmVycmVkIGlzIHRoZSBwcml2YXRlIGludGVyZmFjZVxuXHRcdC8vXHRcdHRoYXQgc2hvdWxkIG5vdCBiZSByZXR1cm5lZCB0byBjYWxsaW5nIGNvZGUuIFRoYXQncyB3aGF0IHRoZVxuXHRcdC8vXHRcdGBwcm9taXNlYCBpcyBmb3IuIFNlZSBgZG9qby9wcm9taXNlL1Byb21pc2VgLlxuXHRcdC8vIGNhbmNlbGVyOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRXaWxsIGJlIGludm9rZWQgaWYgdGhlIGRlZmVycmVkIGlzIGNhbmNlbGVkLiBUaGUgY2FuY2VsZXJcblx0XHQvL1x0XHRyZWNlaXZlcyB0aGUgcmVhc29uIHRoZSBkZWZlcnJlZCB3YXMgY2FuY2VsZWQgYXMgaXRzIGFyZ3VtZW50LlxuXHRcdC8vXHRcdFRoZSBkZWZlcnJlZCBpcyByZWplY3RlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUsIG9yIGEgbmV3XG5cdFx0Ly9cdFx0YGRvam8vZXJyb3JzL0NhbmNlbEVycm9yYCBpbnN0YW5jZS5cblxuXHRcdC8vIHByb21pc2U6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0VGhlIHB1YmxpYyBwcm9taXNlIG9iamVjdCB0aGF0IGNsaWVudHMgY2FuIGFkZCBjYWxsYmFja3MgdG8uIFxuXHRcdHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKTtcblxuXHRcdHZhciBkZWZlcnJlZCA9IHRoaXM7XG5cdFx0dmFyIGZ1bGZpbGxlZCwgcmVzdWx0LCByZWplY3Rpb247XG5cdFx0dmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cdFx0dmFyIHdhaXRpbmcgPSBbXTtcblxuXHRcdGlmKGhhcyhcImNvbmZpZy1kZWZlcnJlZEluc3RydW1lbnRhdGlvblwiKSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSl7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkZWZlcnJlZCwgRGVmZXJyZWQpO1xuXHRcdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UocHJvbWlzZSwgRGVmZXJyZWQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNSZXNvbHZlZCA9IHByb21pc2UuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gZnVsZmlsbGVkID09PSBSRVNPTFZFRDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc1JlamVjdGVkID0gcHJvbWlzZS5pc1JlamVjdGVkID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gcmVqZWN0ZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHJldHVybiBmdWxmaWxsZWQgPT09IFJFSkVDVEVEO1xuXHRcdH07XG5cblx0XHR0aGlzLmlzRnVsZmlsbGVkID0gcHJvbWlzZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gISFmdWxmaWxsZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNDYW5jZWxlZCA9IHByb21pc2UuaXNDYW5jZWxlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIGRlZmVycmVkIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHRyZXR1cm4gY2FuY2VsZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMucHJvZ3Jlc3MgPSBmdW5jdGlvbih1cGRhdGUsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RW1pdCBhIHByb2dyZXNzIHVwZGF0ZSBvbiB0aGUgZGVmZXJyZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEVtaXQgYSBwcm9ncmVzcyB1cGRhdGUgb24gdGhlIGRlZmVycmVkLiBQcm9ncmVzcyB1cGRhdGVzXG5cdFx0XHQvL1x0XHRjYW4gYmUgdXNlZCB0byBjb21tdW5pY2F0ZSB1cGRhdGVzIGFib3V0IHRoZSBhc3luY2hyb25vdXNcblx0XHRcdC8vXHRcdG9wZXJhdGlvbiBiZWZvcmUgaXQgaGFzIGZpbmlzaGVkLlxuXHRcdFx0Ly8gdXBkYXRlOiBhbnlcblx0XHRcdC8vXHRcdFRoZSBwcm9ncmVzcyB1cGRhdGUuIFBhc3NlZCB0byBwcm9nYmFja3MuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IG5vIHByb2dyZXNzIGNhbiBiZSBlbWl0dGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIG9yaWdpbmFsIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZC5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdHNpZ25hbFdhaXRpbmcod2FpdGluZywgUFJPR1JFU1MsIHVwZGF0ZSwgbnVsbCwgZGVmZXJyZWQpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1lbHNlIGlmKHN0cmljdCA9PT0gdHJ1ZSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihGVUxGSUxMRURfRVJST1JfTUVTU0FHRSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdHJpY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlc29sdmUgdGhlIGRlZmVycmVkLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRSZXNvbHZlIHRoZSBkZWZlcnJlZCwgcHV0dGluZyBpdCBpbiBhIHN1Y2Nlc3Mgc3RhdGUuXG5cdFx0XHQvLyB2YWx1ZTogYW55XG5cdFx0XHQvL1x0XHRUaGUgcmVzdWx0IG9mIHRoZSBkZWZlcnJlZC4gUGFzc2VkIHRvIGNhbGxiYWNrcy5cblx0XHRcdC8vIHN0cmljdDogQm9vbGVhbj9cblx0XHRcdC8vXHRcdElmIHN0cmljdCwgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZGVmZXJyZWQgaGFzIGFscmVhZHlcblx0XHRcdC8vXHRcdGJlZW4gZnVsZmlsbGVkIGFuZCBjb25zZXF1ZW50bHkgY2Fubm90IGJlIHJlc29sdmVkLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIG9yaWdpbmFsIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZC5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdC8vIFNldCBmdWxmaWxsZWQsIHN0b3JlIHZhbHVlLiBBZnRlciBzaWduYWxpbmcgd2FpdGluZyBsaXN0ZW5lcnMgdW5zZXRcblx0XHRcdFx0Ly8gd2FpdGluZy5cblx0XHRcdFx0c2lnbmFsV2FpdGluZyh3YWl0aW5nLCBmdWxmaWxsZWQgPSBSRVNPTFZFRCwgcmVzdWx0ID0gdmFsdWUsIG51bGwsIGRlZmVycmVkKTtcblx0XHRcdFx0d2FpdGluZyA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fWVsc2UgaWYoc3RyaWN0ID09PSB0cnVlKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHJlamVjdCA9IHRoaXMucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVqZWN0IHRoZSBkZWZlcnJlZC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0UmVqZWN0IHRoZSBkZWZlcnJlZCwgcHV0dGluZyBpdCBpbiBhbiBlcnJvciBzdGF0ZS5cblx0XHRcdC8vIGVycm9yOiBhbnlcblx0XHRcdC8vXHRcdFRoZSBlcnJvciByZXN1bHQgb2YgdGhlIGRlZmVycmVkLiBQYXNzZWQgdG8gZXJyYmFja3MuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IGNhbm5vdCBiZSByZWplY3RlZC5cblx0XHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRoZSBvcmlnaW5hbCBwcm9taXNlIGZvciB0aGUgZGVmZXJyZWQuXG5cblx0XHRcdGlmKCFmdWxmaWxsZWQpe1xuXHRcdFx0XHRpZihoYXMoXCJjb25maWctZGVmZXJyZWRJbnN0cnVtZW50YXRpb25cIikgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe1xuXHRcdFx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHJlamVjdGlvbiA9IHt9LCByZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNpZ25hbFdhaXRpbmcod2FpdGluZywgZnVsZmlsbGVkID0gUkVKRUNURUQsIHJlc3VsdCA9IGVycm9yLCByZWplY3Rpb24sIGRlZmVycmVkKTtcblx0XHRcdFx0d2FpdGluZyA9IG51bGw7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fWVsc2UgaWYoc3RyaWN0ID09PSB0cnVlKXtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEZVTEZJTExFRF9FUlJPUl9NRVNTQUdFKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy50aGVuID0gcHJvbWlzZS50aGVuID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVycmJhY2ssIHByb2diYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgbmV3IGNhbGxiYWNrcyB0byB0aGUgZGVmZXJyZWQuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFkZCBuZXcgY2FsbGJhY2tzIHRvIHRoZSBkZWZlcnJlZC4gQ2FsbGJhY2tzIGNhbiBiZSBhZGRlZFxuXHRcdFx0Ly9cdFx0YmVmb3JlIG9yIGFmdGVyIHRoZSBkZWZlcnJlZCBpcyBmdWxmaWxsZWQuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuXG5cdFx0XHQvL1x0XHRSZWNlaXZlcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0XHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuXHRcdFx0Ly9cdFx0UmVjZWl2ZXMgdGhlIHJlamVjdGlvbiBlcnJvci5cblx0XHRcdC8vIHByb2diYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBlbWl0cyBhIHByb2dyZXNzXG5cdFx0XHQvL1x0XHR1cGRhdGUuIFJlY2VpdmVzIHRoZSBwcm9ncmVzcyB1cGRhdGUuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayhzKS5cblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNoYWluaW5nIG1hbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG5cblx0XHRcdHZhciBsaXN0ZW5lciA9IFtwcm9nYmFjaywgY2FsbGJhY2ssIGVycmJhY2tdO1xuXHRcdFx0Ly8gRW5zdXJlIHdlIGNhbmNlbCB0aGUgcHJvbWlzZSB3ZSdyZSB3YWl0aW5nIGZvciwgb3IgaWYgY2FsbGJhY2svZXJyYmFja1xuXHRcdFx0Ly8gaGF2ZSByZXR1cm5lZCBhIHByb21pc2UsIGNhbmNlbCB0aGF0IG9uZS5cblx0XHRcdGxpc3RlbmVyLmNhbmNlbCA9IHByb21pc2UuY2FuY2VsO1xuXHRcdFx0bGlzdGVuZXIuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoZnVuY3Rpb24ocmVhc29uKXtcblx0XHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBjYW5jZWwgaXMgcmVhbGx5IGF2YWlsYWJsZSwgcmV0dXJuZWQgcHJvbWlzZXMgYXJlIG5vdFxuXHRcdFx0XHQvLyByZXF1aXJlZCB0byBleHBvc2UgYGNhbmNlbGBcblx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmNhbmNlbCAmJiBsaXN0ZW5lci5jYW5jZWwocmVhc29uKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYoZnVsZmlsbGVkICYmICF3YWl0aW5nKXtcblx0XHRcdFx0c2lnbmFsTGlzdGVuZXIobGlzdGVuZXIsIGZ1bGZpbGxlZCwgcmVzdWx0LCByZWplY3Rpb24pO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHdhaXRpbmcucHVzaChsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIuZGVmZXJyZWQucHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jYW5jZWwgPSBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKHJlYXNvbiwgc3RyaWN0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRJbmZvcm0gdGhlIGRlZmVycmVkIGl0IG1heSBjYW5jZWwgaXRzIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEluZm9ybSB0aGUgZGVmZXJyZWQgaXQgbWF5IGNhbmNlbCBpdHMgYXN5bmNocm9ub3VzIG9wZXJhdGlvbi5cblx0XHRcdC8vXHRcdFRoZSBkZWZlcnJlZCdzIChvcHRpb25hbCkgY2FuY2VsZXIgaXMgaW52b2tlZCBhbmQgdGhlXG5cdFx0XHQvL1x0XHRkZWZlcnJlZCB3aWxsIGJlIGxlZnQgaW4gYSByZWplY3RlZCBzdGF0ZS4gQ2FuIGFmZmVjdCBvdGhlclxuXHRcdFx0Ly9cdFx0cHJvbWlzZXMgdGhhdCBvcmlnaW5hdGUgd2l0aCB0aGUgc2FtZSBkZWZlcnJlZC5cblx0XHRcdC8vIHJlYXNvbjogYW55XG5cdFx0XHQvL1x0XHRBIG1lc3NhZ2UgdGhhdCBtYXkgYmUgc2VudCB0byB0aGUgZGVmZXJyZWQncyBjYW5jZWxlcixcblx0XHRcdC8vXHRcdGV4cGxhaW5pbmcgd2h5IGl0J3MgYmVpbmcgY2FuY2VsZWQuXG5cdFx0XHQvLyBzdHJpY3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRJZiBzdHJpY3QsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmVycmVkIGhhcyBhbHJlYWR5XG5cdFx0XHQvL1x0XHRiZWVuIGZ1bGZpbGxlZCBhbmQgY29uc2VxdWVudGx5IGNhbm5vdCBiZSBjYW5jZWxlZC5cblx0XHRcdC8vIHJldHVybnM6IGFueVxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgcmVqZWN0aW9uIHJlYXNvbiBpZiB0aGUgZGVmZXJyZWQgd2FzIGNhbmNlbGVkXG5cdFx0XHQvL1x0XHRub3JtYWxseS5cblxuXHRcdFx0aWYoIWZ1bGZpbGxlZCl7XG5cdFx0XHRcdC8vIENhbmNlbCBjYW4gYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgdGhlIGRlZmVycmVkIGlzIGZ1bGZpbGxlZFxuXHRcdFx0XHRpZihjYW5jZWxlcil7XG5cdFx0XHRcdFx0dmFyIHJldHVybmVkUmVhc29uID0gY2FuY2VsZXIocmVhc29uKTtcblx0XHRcdFx0XHRyZWFzb24gPSB0eXBlb2YgcmV0dXJuZWRSZWFzb24gPT09IFwidW5kZWZpbmVkXCIgPyByZWFzb24gOiByZXR1cm5lZFJlYXNvbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYW5jZWxlZCA9IHRydWU7XG5cdFx0XHRcdGlmKCFmdWxmaWxsZWQpe1xuXHRcdFx0XHRcdC8vIEFsbG93IGNhbmNlbGVyIHRvIHByb3ZpZGUgaXRzIG93biByZWFzb24sIGJ1dCBmYWxsIGJhY2sgdG8gYSBDYW5jZWxFcnJvclxuXHRcdFx0XHRcdGlmKHR5cGVvZiByZWFzb24gPT09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0cmVhc29uID0gbmV3IENhbmNlbEVycm9yKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlamVjdChyZWFzb24pO1xuXHRcdFx0XHRcdHJldHVybiByZWFzb247XG5cdFx0XHRcdH1lbHNlIGlmKGZ1bGZpbGxlZCA9PT0gUkVKRUNURUQgJiYgcmVzdWx0ID09PSByZWFzb24pe1xuXHRcdFx0XHRcdHJldHVybiByZWFzb247XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKHN0cmljdCA9PT0gdHJ1ZSl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihGVUxGSUxMRURfRVJST1JfTUVTU0FHRSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZyZWV6ZU9iamVjdChwcm9taXNlKTtcblx0fTtcblxuXHREZWZlcnJlZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuXHRcdC8vIHJldHVybnM6IFN0cmluZ1xuXHRcdC8vXHRcdFJldHVybnMgYFtvYmplY3QgRGVmZXJyZWRdYC5cblxuXHRcdHJldHVybiBcIltvYmplY3QgRGVmZXJyZWRdXCI7XG5cdH07XG5cblx0aWYoaW5zdHJ1bWVudGF0aW9uKXtcblx0XHRpbnN0cnVtZW50YXRpb24oRGVmZXJyZWQpO1xuXHR9XG5cblx0cmV0dXJuIERlZmVycmVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9hc3BlY3RcIiwgXCIuL29uXCJdLCBmdW5jdGlvbihhc3BlY3QsIG9uKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL0V2ZW50ZWRcblxuIFx0XCJ1c2Ugc3RyaWN0XCI7XG4gXHR2YXIgYWZ0ZXIgPSBhc3BlY3QuYWZ0ZXI7XG5cdGZ1bmN0aW9uIEV2ZW50ZWQoKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIG9yIGJhc2UgY2xhc3MsXG5cdFx0Ly9cdFx0dG8gYWRkIG9uKCkgYW5kIGVtaXQoKSBtZXRob2RzIHRvIGEgY2xhc3Ncblx0XHQvL1x0XHRmb3IgbGlzdGVuaW5nIGZvciBldmVudHMgYW5kIGVtaXR0aW5nIGV2ZW50czpcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdHxcdGRlZmluZShbXCJkb2pvL0V2ZW50ZWRcIiwgXCJkb2pvL19iYXNlL2RlY2xhcmVcIiwgXCJkb2pvL1N0YXRlZnVsXCJcblx0XHQvL1x0XHR8XHRdLCBmdW5jdGlvbihFdmVudGVkLCBkZWNsYXJlLCBTdGF0ZWZ1bCl7XG5cdFx0Ly9cdFx0fFx0XHR2YXIgRXZlbnRlZFN0YXRlZnVsID0gZGVjbGFyZShbRXZlbnRlZCwgU3RhdGVmdWxdLCB7Li4ufSk7XG5cdFx0Ly9cdFx0fFx0XHR2YXIgaW5zdGFuY2UgPSBuZXcgRXZlbnRlZFN0YXRlZnVsKCk7XG5cdFx0Ly9cdFx0fFx0XHRpbnN0YW5jZS5vbihcIm9wZW5cIiwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vXHRcdHxcdFx0Li4uIGRvIHNvbWV0aGluZyB3aXRoIGV2ZW50XG5cdFx0Ly9cdFx0fFx0IH0pO1xuXHRcdC8vXHRcdHxcblx0XHQvL1x0XHR8XHRpbnN0YW5jZS5lbWl0KFwib3BlblwiLCB7bmFtZTpcInNvbWUgZXZlbnRcIiwgLi4ufSk7XG5cdH1cblx0RXZlbnRlZC5wcm90b3R5cGUgPSB7XG5cdFx0b246IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcblx0XHRcdHJldHVybiBvbi5wYXJzZSh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZnVuY3Rpb24odGFyZ2V0LCB0eXBlKXtcblx0XHRcdFx0cmV0dXJuIGFmdGVyKHRhcmdldCwgJ29uJyArIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0ZW1pdDogZnVuY3Rpb24odHlwZSwgZXZlbnQpe1xuXHRcdFx0dmFyIGFyZ3MgPSBbdGhpc107XG5cdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBvbi5lbWl0LmFwcGx5KG9uLCBhcmdzKTtcblx0XHR9XG5cdH07XG5cdHJldHVybiBFdmVudGVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9kZWNsYXJlXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9fYmFzZS9hcnJheVwiLCBcIi4vd2hlblwiXSwgZnVuY3Rpb24oZGVjbGFyZSwgbGFuZywgYXJyYXksIHdoZW4pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vU3RhdGVmdWxcblxucmV0dXJuIGRlY2xhcmUoXCJkb2pvLlN0YXRlZnVsXCIsIG51bGwsIHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0QmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IHByb3ZpZGUgbmFtZWQgcHJvcGVydGllcyB3aXRoIG9wdGlvbmFsIGdldHRlci9zZXR0ZXJcblx0Ly9cdFx0Y29udHJvbCBhbmQgdGhlIGFiaWxpdHkgdG8gd2F0Y2ggZm9yIHByb3BlcnR5IGNoYW5nZXNcblx0Ly9cblx0Ly9cdFx0VGhlIGNsYXNzIGFsc28gcHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gYXV0by1tYWdpY2FsbHkgbWFuYWdlIGdldHRlcnNcblx0Ly9cdFx0YW5kIHNldHRlcnMgZm9yIG9iamVjdCBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMuXG5cdC8vXHRcdFxuXHQvL1x0XHRHZXR0ZXJzIGFuZCBTZXR0ZXJzIHNob3VsZCBmb2xsb3cgdGhlIGZvcm1hdCBvZiBfeHh4R2V0dGVyIG9yIF94eHhTZXR0ZXIgd2hlcmUgXG5cdC8vXHRcdHRoZSB4eHggaXMgYSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gaGFuZGxlLiAgU28gYW4gYXR0cmlidXRlIG9mIFwiZm9vXCIgXG5cdC8vXHRcdHdvdWxkIGhhdmUgYSBjdXN0b20gZ2V0dGVyIG9mIF9mb29HZXR0ZXIgYW5kIGEgY3VzdG9tIHNldHRlciBvZiBfZm9vU2V0dGVyLlxuXHQvL1xuXHQvLyBleGFtcGxlOlxuXHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL1N0YXRlZnVsXCIsIGZ1bmN0aW9uKFN0YXRlZnVsKSB7XG5cdC8vXHR8XHRcdHZhciBvYmogPSBuZXcgU3RhdGVmdWwoKTtcblx0Ly9cdHxcdFx0b2JqLndhdGNoKFwiZm9vXCIsIGZ1bmN0aW9uKCl7XG5cdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJmb28gY2hhbmdlZCB0byBcIiArIHRoaXMuZ2V0KFwiZm9vXCIpKTtcblx0Ly9cdHxcdFx0fSk7XG5cdC8vXHR8XHRcdG9iai5zZXQoXCJmb29cIixcImJhclwiKTtcblx0Ly9cdHxcdH0pO1xuXG5cdC8vIF9hdHRyUGFpck5hbWVzOiBIYXNoXG5cdC8vXHRcdFVzZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgYSBoYXNoIHRvIGNhY2hlIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdGhlaXIgZ2V0dGVyIFxuXHQvL1x0XHRhbmQgc2V0dGVyIG5hbWVzLlxuXHRfYXR0clBhaXJOYW1lczoge30sXG5cblx0X2dldEF0dHJOYW1lczogZnVuY3Rpb24obmFtZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRIZWxwZXIgZnVuY3Rpb24gZm9yIGdldCgpIGFuZCBzZXQoKS5cblx0XHQvL1x0XHRDYWNoZXMgYXR0cmlidXRlIG5hbWUgdmFsdWVzIHNvIHdlIGRvbid0IGRvIHRoZSBzdHJpbmcgb3BzIGV2ZXJ5IHRpbWUuXG5cdFx0Ly8gdGFnczpcblx0XHQvL1x0XHRwcml2YXRlXG5cblx0XHR2YXIgYXBuID0gdGhpcy5fYXR0clBhaXJOYW1lcztcblx0XHRpZihhcG5bbmFtZV0peyByZXR1cm4gYXBuW25hbWVdOyB9XG5cdFx0cmV0dXJuIChhcG5bbmFtZV0gPSB7XG5cdFx0XHRzOiBcIl9cIiArIG5hbWUgKyBcIlNldHRlclwiLFxuXHRcdFx0ZzogXCJfXCIgKyBuYW1lICsgXCJHZXR0ZXJcIlxuXHRcdH0pO1xuXHR9LFxuXG5cdHBvc3RzY3JpcHQ6IGZ1bmN0aW9uKC8qT2JqZWN0PyovIHBhcmFtcyl7XG5cdFx0Ly8gQXV0b21hdGljIHNldHRpbmcgb2YgcGFyYW1zIGR1cmluZyBjb25zdHJ1Y3Rpb25cblx0XHRpZiAocGFyYW1zKXsgdGhpcy5zZXQocGFyYW1zKTsgfVxuXHR9LFxuXG5cdF9nZXQ6IGZ1bmN0aW9uKG5hbWUsIG5hbWVzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFByaXZhdGUgZnVuY3Rpb24gdGhhdCBkb2VzIGEgZ2V0IGJhc2VkIG9mZiBhIGhhc2ggb2YgbmFtZXNcblx0XHQvLyBuYW1lczpcblx0XHQvL1x0XHRIYXNoIG9mIG5hbWVzIG9mIGN1c3RvbSBhdHRyaWJ1dGVzXG5cdFx0cmV0dXJuIHR5cGVvZiB0aGlzW25hbWVzLmddID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzW25hbWVzLmddKCkgOiB0aGlzW25hbWVdO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKC8qU3RyaW5nKi9uYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEdldCBhIHByb3BlcnR5IG9uIGEgU3RhdGVmdWwgaW5zdGFuY2UuXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRUaGUgcHJvcGVydHkgdG8gZ2V0LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHZhbHVlIG9uIHRoaXMgU3RhdGVmdWwgaW5zdGFuY2UuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0R2V0IGEgbmFtZWQgcHJvcGVydHkgb24gYSBTdGF0ZWZ1bCBvYmplY3QuIFRoZSBwcm9wZXJ0eSBtYXlcblx0XHQvL1x0XHRwb3RlbnRpYWxseSBiZSByZXRyaWV2ZWQgdmlhIGEgZ2V0dGVyIG1ldGhvZCBpbiBzdWJjbGFzc2VzLiBJbiB0aGUgYmFzZSBjbGFzc1xuXHRcdC8vXHRcdHRoaXMganVzdCByZXRyaWV2ZXMgdGhlIG9iamVjdCdzIHByb3BlcnR5LlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9TdGF0ZWZ1bFwiLCBmdW5jdGlvbihTdGF0ZWZ1bCkge1xuXHRcdC8vXHR8XHRcdHZhciBzdGF0ZWZ1bCA9IG5ldyBTdGF0ZWZ1bCh7Zm9vOiAzfSk7XG5cdFx0Ly9cdHxcdFx0c3RhdGVmdWwuZ2V0KFwiZm9vXCIpIC8vIHJldHVybnMgM1xuXHRcdC8vXHR8XHRcdHN0YXRlZnVsLmZvbyAvLyByZXR1cm5zIDNcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRoaXMuX2dldEF0dHJOYW1lcyhuYW1lKSk7IC8vQW55XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oLypTdHJpbmcqL25hbWUsIC8qT2JqZWN0Ki92YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZXQgYSBwcm9wZXJ0eSBvbiBhIFN0YXRlZnVsIGluc3RhbmNlXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRUaGUgcHJvcGVydHkgdG8gc2V0LlxuXHRcdC8vIHZhbHVlOlxuXHRcdC8vXHRcdFRoZSB2YWx1ZSB0byBzZXQgaW4gdGhlIHByb3BlcnR5LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIHJldHVybnMgdGhpcyBkb2pvLlN0YXRlZnVsIGluc3RhbmNlLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFNldHMgbmFtZWQgcHJvcGVydGllcyBvbiBhIHN0YXRlZnVsIG9iamVjdCBhbmQgbm90aWZpZXMgYW55IHdhdGNoZXJzIG9mXG5cdFx0Ly9cdFx0dGhlIHByb3BlcnR5LiBBIHByb2dyYW1tYXRpYyBzZXR0ZXIgbWF5IGJlIGRlZmluZWQgaW4gc3ViY2xhc3Nlcy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vU3RhdGVmdWxcIiwgZnVuY3Rpb24oU3RhdGVmdWwpIHtcblx0XHQvL1x0fFx0XHR2YXIgc3RhdGVmdWwgPSBuZXcgU3RhdGVmdWwoKTtcblx0XHQvL1x0fFx0XHRzdGF0ZWZ1bC53YXRjaChmdW5jdGlvbihuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpe1xuXHRcdC8vXHR8XHRcdFx0Ly8gdGhpcyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgc2V0IGJlbG93XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHRcdHN0YXRlZnVsLnNldChmb28sIDUpO1xuXHRcdC8vXHRzZXQoKSBtYXkgYWxzbyBiZSBjYWxsZWQgd2l0aCBhIGhhc2ggb2YgbmFtZS92YWx1ZSBwYWlycywgZXg6XG5cdFx0Ly9cdHxcdFx0c3RhdGVmdWwuc2V0KHtcblx0XHQvL1x0fFx0XHRcdGZvbzogXCJIb3dkeVwiLFxuXHRcdC8vXHR8XHRcdFx0YmFyOiAzXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHRUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBzZXQoZm9vLCBcIkhvd2R5XCIpIGFuZCBzZXQoYmFyLCAzKVxuXG5cdFx0Ly8gSWYgYW4gb2JqZWN0IGlzIHVzZWQsIGl0ZXJhdGUgdGhyb3VnaCBvYmplY3Rcblx0XHRpZih0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIil7XG5cdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdGlmKG5hbWUuaGFzT3duUHJvcGVydHkoeCkgJiYgeCAhPVwiX3dhdGNoQ2FsbGJhY2tzXCIpe1xuXHRcdFx0XHRcdHRoaXMuc2V0KHgsIG5hbWVbeF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YXIgbmFtZXMgPSB0aGlzLl9nZXRBdHRyTmFtZXMobmFtZSksXG5cdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2dldChuYW1lLCBuYW1lcyksXG5cdFx0XHRzZXR0ZXIgPSB0aGlzW25hbWVzLnNdLFxuXHRcdFx0cmVzdWx0O1xuXHRcdGlmKHR5cGVvZiBzZXR0ZXIgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHQvLyB1c2UgdGhlIGV4cGxpY2l0IHNldHRlclxuXHRcdFx0cmVzdWx0ID0gc2V0dGVyLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gbm8gc2V0dGVyIHNvIHNldCBhdHRyaWJ1dGUgZGlyZWN0bHlcblx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0aWYodGhpcy5fd2F0Y2hDYWxsYmFja3Mpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Ly8gSWYgc2V0dGVyIHJldHVybmVkIGEgcHJvbWlzZSwgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUsIG90aGVyd2lzZSBjYWxsIHdhdGNoZXMgaW1tZWRpYXRlbHlcblx0XHRcdHdoZW4ocmVzdWx0LCBmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLl93YXRjaENhbGxiYWNrcyhuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzOyAvLyBkb2pvL1N0YXRlZnVsXG5cdH0sXG5cdF9jaGFuZ2VBdHRyVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEludGVybmFsIGhlbHBlciBmb3IgZGlyZWN0bHkgY2hhbmdpbmcgYW4gYXR0cmlidXRlIHZhbHVlLlxuXHRcdC8vXG5cdFx0Ly8gbmFtZTogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIHByb3BlcnR5IHRvIHNldC5cblx0XHQvLyB2YWx1ZTogTWl4ZWRcblx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2V0IGluIHRoZSBwcm9wZXJ0eS5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdERpcmVjdGx5IGNoYW5nZSB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIG9iamVjdCwgYnlwYXNzaW5nIGFueSBcblx0XHQvL1x0XHRhY2Nlc3NvciBzZXR0ZXIuICBBbHNvIGhhbmRsZXMgdGhlIGNhbGxpbmcgb2Ygd2F0Y2ggYW5kIGVtaXR0aW5nIGV2ZW50cy4gXG5cdFx0Ly9cdFx0SXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBieSBkZXNjZW5kYW50IGNsYXNzIHdoZW4gdGhlcmUgYXJlIHR3byB2YWx1ZXMgXG5cdFx0Ly9cdFx0b2YgYXR0cmlidXRlcyB0aGF0IGFyZSBsaW5rZWQsIGJ1dCBjYWxsaW5nIC5zZXQoKSBpcyBub3QgYXBwcm9wcmlhdGUuXG5cblx0XHR2YXIgb2xkVmFsdWUgPSB0aGlzLmdldChuYW1lKTtcblx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0aWYodGhpcy5fd2F0Y2hDYWxsYmFja3Mpe1xuXHRcdFx0dGhpcy5fd2F0Y2hDYWxsYmFja3MobmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7IC8vIGRvam8vU3RhdGVmdWxcblx0fSxcblx0d2F0Y2g6IGZ1bmN0aW9uKC8qU3RyaW5nPyovbmFtZSwgLypGdW5jdGlvbiovY2FsbGJhY2spe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0V2F0Y2hlcyBhIHByb3BlcnR5IGZvciBjaGFuZ2VzXG5cdFx0Ly8gbmFtZTpcblx0XHQvL1x0XHRJbmRpY2F0ZXMgdGhlIHByb3BlcnR5IHRvIHdhdGNoLiBUaGlzIGlzIG9wdGlvbmFsICh0aGUgY2FsbGJhY2sgbWF5IGJlIHRoZVxuXHRcdC8vXHRcdG9ubHkgcGFyYW1ldGVyKSwgYW5kIGlmIG9taXR0ZWQsIGFsbCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIHdhdGNoZWRcblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdEFuIG9iamVjdCBoYW5kbGUgZm9yIHRoZSB3YXRjaC4gVGhlIHVud2F0Y2ggbWV0aG9kIG9mIHRoaXMgb2JqZWN0XG5cdFx0Ly9cdFx0Y2FuIGJlIHVzZWQgdG8gZGlzY29udGludWUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eTpcblx0XHQvL1x0XHR8XHR2YXIgd2F0Y2hIYW5kbGUgPSBvYmoud2F0Y2goXCJmb29cIiwgY2FsbGJhY2spO1xuXHRcdC8vXHRcdHxcdHdhdGNoSGFuZGxlLnVud2F0Y2goKTsgLy8gY2FsbGJhY2sgd29uJ3QgYmUgY2FsbGVkIG5vd1xuXHRcdC8vIGNhbGxiYWNrOlxuXHRcdC8vXHRcdFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXJcblx0XHQvL1x0XHR0aGUgcHJvcGVydHkgaGFzIGJlZW4gY2hhbmdlZC4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHx0aGlzfFxuXHRcdC8vXHRcdHNldCB0byB0aGUgaW5zdGFuY2UsIHRoZSBmaXJzdCBhcmd1bWVudCBhcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHksIHRoZVxuXHRcdC8vXHRcdHNlY29uZCBhcmd1bWVudCBhcyB0aGUgb2xkIHZhbHVlIGFuZCB0aGUgdGhpcmQgYXJndW1lbnQgYXMgdGhlIG5ldyB2YWx1ZS5cblxuXHRcdHZhciBjYWxsYmFja3MgPSB0aGlzLl93YXRjaENhbGxiYWNrcztcblx0XHRpZighY2FsbGJhY2tzKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNhbGxiYWNrcyA9IHRoaXMuX3dhdGNoQ2FsbGJhY2tzID0gZnVuY3Rpb24obmFtZSwgb2xkVmFsdWUsIHZhbHVlLCBpZ25vcmVDYXRjaGFsbCl7XG5cdFx0XHRcdHZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9wZXJ0eUNhbGxiYWNrcyl7XG5cdFx0XHRcdFx0aWYocHJvcGVydHlDYWxsYmFja3Mpe1xuXHRcdFx0XHRcdFx0cHJvcGVydHlDYWxsYmFja3MgPSBwcm9wZXJ0eUNhbGxiYWNrcy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHByb3BlcnR5Q2FsbGJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5Q2FsbGJhY2tzW2ldLmNhbGwoc2VsZiwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdG5vdGlmeShjYWxsYmFja3NbJ18nICsgbmFtZV0pO1xuXHRcdFx0XHRpZighaWdub3JlQ2F0Y2hhbGwpe1xuXHRcdFx0XHRcdG5vdGlmeShjYWxsYmFja3NbXCIqXCJdKTsgLy8gdGhlIGNhdGNoLWFsbFxuXHRcdFx0XHR9XG5cdFx0XHR9OyAvLyB3ZSB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGFuIG9iamVjdCBzbyBpdCB3aWxsIGJlIGlnbm9yZWQgYnkgSlNPTiBjb252ZXJzaW9uXG5cdFx0fVxuXHRcdGlmKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdGNhbGxiYWNrID0gbmFtZTtcblx0XHRcdG5hbWUgPSBcIipcIjtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIHByZXBlbmQgd2l0aCBkYXNoIHRvIHByZXZlbnQgbmFtZSBjb25mbGljdHMgd2l0aCBmdW5jdGlvbiAobGlrZSBcIm5hbWVcIiBwcm9wZXJ0eSlcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdH1cblx0XHR2YXIgcHJvcGVydHlDYWxsYmFja3MgPSBjYWxsYmFja3NbbmFtZV07XG5cdFx0aWYodHlwZW9mIHByb3BlcnR5Q2FsbGJhY2tzICE9PSBcIm9iamVjdFwiKXtcblx0XHRcdHByb3BlcnR5Q2FsbGJhY2tzID0gY2FsbGJhY2tzW25hbWVdID0gW107XG5cdFx0fVxuXHRcdHByb3BlcnR5Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG5cdFx0Ly8gVE9ETzogUmVtb3ZlIHVud2F0Y2ggaW4gMi4wXG5cdFx0dmFyIGhhbmRsZSA9IHt9O1xuXHRcdGhhbmRsZS51bndhdGNoID0gaGFuZGxlLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKHByb3BlcnR5Q2FsbGJhY2tzLCBjYWxsYmFjayk7XG5cdFx0XHRpZihpbmRleCA+IC0xKXtcblx0XHRcdFx0cHJvcGVydHlDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBoYW5kbGU7IC8vT2JqZWN0XG5cdH1cblxufSk7XG5cbn0pO1xuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi4vaGFzXCIsIFwiLi9sYW5nXCJdLCBmdW5jdGlvbihkb2pvLCBoYXMsIGxhbmcpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UvYXJyYXlcblxuXHQvLyBvdXIgb2xkIHNpbXBsZSBmdW5jdGlvbiBidWlsZGVyIHN0dWZmXG5cdHZhciBjYWNoZSA9IHt9LCB1O1xuXG5cdGZ1bmN0aW9uIGJ1aWxkRm4oZm4pe1xuXHRcdHJldHVybiBjYWNoZVtmbl0gPSBuZXcgRnVuY3Rpb24oXCJpdGVtXCIsIFwiaW5kZXhcIiwgXCJhcnJheVwiLCBmbik7IC8vIEZ1bmN0aW9uXG5cdH1cblx0Ly8gbWFnaWMgc25pcHBldDogaWYodHlwZW9mIGZuID09IFwic3RyaW5nXCIpIGZuID0gY2FjaGVbZm5dIHx8IGJ1aWxkRm4oZm4pO1xuXG5cdC8vIGV2ZXJ5ICYgc29tZVxuXG5cdGZ1bmN0aW9uIGV2ZXJ5T3JTb21lKHNvbWUpe1xuXHRcdHZhciBldmVyeSA9ICFzb21lO1xuXHRcdHJldHVybiBmdW5jdGlvbihhLCBmbiwgbyl7XG5cdFx0XHR2YXIgaSA9IDAsIGwgPSBhICYmIGEubGVuZ3RoIHx8IDAsIHJlc3VsdDtcblx0XHRcdGlmKGwgJiYgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgYSA9IGEuc3BsaXQoXCJcIik7XG5cdFx0XHRpZih0eXBlb2YgZm4gPT0gXCJzdHJpbmdcIikgZm4gPSBjYWNoZVtmbl0gfHwgYnVpbGRGbihmbik7XG5cdFx0XHRpZihvKXtcblx0XHRcdFx0Zm9yKDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0cmVzdWx0ID0gIWZuLmNhbGwobywgYVtpXSwgaSwgYSk7XG5cdFx0XHRcdFx0aWYoc29tZSBeIHJlc3VsdCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHRyZXN1bHQgPSAhZm4oYVtpXSwgaSwgYSk7XG5cdFx0XHRcdFx0aWYoc29tZSBeIHJlc3VsdCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBldmVyeTsgLy8gQm9vbGVhblxuXHRcdH07XG5cdH1cblxuXHQvLyBpbmRleE9mLCBsYXN0SW5kZXhPZlxuXG5cdGZ1bmN0aW9uIGluZGV4KHVwKXtcblx0XHR2YXIgZGVsdGEgPSAxLCBsT3ZlciA9IDAsIHVPdmVyID0gMDtcblx0XHRpZighdXApe1xuXHRcdFx0ZGVsdGEgPSBsT3ZlciA9IHVPdmVyID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbihhLCB4LCBmcm9tLCBsYXN0KXtcblx0XHRcdGlmKGxhc3QgJiYgZGVsdGEgPiAwKXtcblx0XHRcdFx0Ly8gVE9ETzogd2h5IGRvIHdlIHVzZSBhIG5vbi1zdGFuZGFyZCBzaWduYXR1cmU/IHdoeSBkbyB3ZSBuZWVkIFwibGFzdFwiP1xuXHRcdFx0XHRyZXR1cm4gYXJyYXkubGFzdEluZGV4T2YoYSwgeCwgZnJvbSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbCA9IGEgJiYgYS5sZW5ndGggfHwgMCwgZW5kID0gdXAgPyBsICsgdU92ZXIgOiBsT3ZlciwgaTtcblx0XHRcdGlmKGZyb20gPT09IHUpe1xuXHRcdFx0XHRpID0gdXAgPyBsT3ZlciA6IGwgKyB1T3Zlcjtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZihmcm9tIDwgMCl7XG5cdFx0XHRcdFx0aSA9IGwgKyBmcm9tO1xuXHRcdFx0XHRcdGlmKGkgPCAwKXtcblx0XHRcdFx0XHRcdGkgPSBsT3Zlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGkgPSBmcm9tID49IGwgPyBsICsgdU92ZXIgOiBmcm9tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZihsICYmIHR5cGVvZiBhID09IFwic3RyaW5nXCIpIGEgPSBhLnNwbGl0KFwiXCIpO1xuXHRcdFx0Zm9yKDsgaSAhPSBlbmQ7IGkgKz0gZGVsdGEpe1xuXHRcdFx0XHRpZihhW2ldID09IHgpe1xuXHRcdFx0XHRcdHJldHVybiBpOyAvLyBOdW1iZXJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xOyAvLyBOdW1iZXJcblx0XHR9O1xuXHR9XG5cblx0dmFyIGFycmF5ID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIEphdmFzY3JpcHQgdjEuNiBhcnJheSBleHRlbnNpb25zLlxuXG5cdFx0ZXZlcnk6IGV2ZXJ5T3JTb21lKGZhbHNlKSxcblx0XHQvKj09PT09XG5cdFx0IGV2ZXJ5OiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KXtcblx0XHRcdCAvLyBzdW1tYXJ5OlxuXHRcdFx0IC8vXHRcdERldGVybWluZXMgd2hldGhlciBvciBub3QgZXZlcnkgaXRlbSBpbiBhcnIgc2F0aXNmaWVzIHRoZVxuXHRcdFx0IC8vXHRcdGNvbmRpdGlvbiBpbXBsZW1lbnRlZCBieSBjYWxsYmFjay5cblx0XHRcdCAvLyBhcnI6IEFycmF5fFN0cmluZ1xuXHRcdFx0IC8vXHRcdHRoZSBhcnJheSB0byBpdGVyYXRlIG9uLiBJZiBhIHN0cmluZywgb3BlcmF0ZXMgb24gaW5kaXZpZHVhbCBjaGFyYWN0ZXJzLlxuXHRcdFx0IC8vIGNhbGxiYWNrOiBGdW5jdGlvbnxTdHJpbmdcblx0XHRcdCAvL1x0XHRhIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGl0ZW0sIGluZGV4LFxuXHRcdFx0IC8vXHRcdGFuZCBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBjb25kaXRpb24gaXMgbWV0LlxuXHRcdFx0IC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdCAvL1x0XHRtYXkgYmUgdXNlZCB0byBzY29wZSB0aGUgY2FsbCB0byBjYWxsYmFja1xuXHRcdFx0IC8vIHJldHVybnM6IEJvb2xlYW5cblx0XHRcdCAvLyBkZXNjcmlwdGlvbjpcblx0XHRcdCAvL1x0XHRUaGlzIGZ1bmN0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZSBKYXZhU2NyaXB0IDEuNiBBcnJheS5ldmVyeSgpIG1ldGhvZCwgd2l0aCBvbmUgZGlmZmVyZW5jZTogd2hlblxuXHRcdFx0IC8vXHRcdHJ1biBvdmVyIHNwYXJzZSBhcnJheXMsIHRoaXMgaW1wbGVtZW50YXRpb24gcGFzc2VzIHRoZSBcImhvbGVzXCIgaW4gdGhlIHNwYXJzZSBhcnJheSB0b1xuXHRcdFx0IC8vXHRcdHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgdmFsdWUgb2YgdW5kZWZpbmVkLiBKYXZhU2NyaXB0IDEuNidzIGV2ZXJ5IHNraXBzIHRoZSBob2xlcyBpbiB0aGUgc3BhcnNlIGFycmF5LlxuXHRcdFx0IC8vXHRcdEZvciBtb3JlIGRldGFpbHMsIHNlZTpcblx0XHRcdCAvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2V2ZXJ5XG5cdFx0XHQgLy8gZXhhbXBsZTpcblx0XHRcdCAvL1x0fFx0Ly8gcmV0dXJucyBmYWxzZVxuXHRcdFx0IC8vXHR8XHRhcnJheS5ldmVyeShbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbT4xOyB9KTtcblx0XHRcdCAvLyBleGFtcGxlOlxuXHRcdFx0IC8vXHR8XHQvLyByZXR1cm5zIHRydWVcblx0XHRcdCAvL1x0fFx0YXJyYXkuZXZlcnkoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0+MDsgfSk7XG5cdFx0IH0sXG5cdFx0ID09PT09Ki9cblxuXHRcdHNvbWU6IGV2ZXJ5T3JTb21lKHRydWUpLFxuXHRcdC8qPT09PT1cblx0XHRzb21lOiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHREZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFueSBpdGVtIGluIGFyciBzYXRpc2ZpZXMgdGhlXG5cdFx0XHQvL1x0XHRjb25kaXRpb24gaW1wbGVtZW50ZWQgYnkgY2FsbGJhY2suXG5cdFx0XHQvLyBhcnI6IEFycmF5fFN0cmluZ1xuXHRcdFx0Ly9cdFx0dGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4gSWYgYSBzdHJpbmcsIG9wZXJhdGVzIG9uIGluZGl2aWR1YWwgY2hhcmFjdGVycy5cblx0XHRcdC8vIGNhbGxiYWNrOiBGdW5jdGlvbnxTdHJpbmdcblx0XHRcdC8vXHRcdGEgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogaXRlbSwgaW5kZXgsXG5cdFx0XHQvL1x0XHRhbmQgYXJyYXkgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgY29uZGl0aW9uIGlzIG1ldC5cblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdG1heSBiZSB1c2VkIHRvIHNjb3BlIHRoZSBjYWxsIHRvIGNhbGxiYWNrXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gY29ycmVzcG9uZHMgdG8gdGhlIEphdmFTY3JpcHQgMS42IEFycmF5LnNvbWUoKSBtZXRob2QsIHdpdGggb25lIGRpZmZlcmVuY2U6IHdoZW5cblx0XHRcdC8vXHRcdHJ1biBvdmVyIHNwYXJzZSBhcnJheXMsIHRoaXMgaW1wbGVtZW50YXRpb24gcGFzc2VzIHRoZSBcImhvbGVzXCIgaW4gdGhlIHNwYXJzZSBhcnJheSB0b1xuXHRcdFx0Ly9cdFx0dGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSB2YWx1ZSBvZiB1bmRlZmluZWQuIEphdmFTY3JpcHQgMS42J3Mgc29tZSBza2lwcyB0aGUgaG9sZXMgaW4gdGhlIHNwYXJzZSBhcnJheS5cblx0XHRcdC8vXHRcdEZvciBtb3JlIGRldGFpbHMsIHNlZTpcblx0XHRcdC8vXHRcdGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvc29tZVxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIGlzIHRydWVcblx0XHRcdC8vXHR8IGFycmF5LnNvbWUoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0+MTsgfSk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHwgLy8gaXMgZmFsc2Vcblx0XHRcdC8vXHR8IGFycmF5LnNvbWUoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW08MTsgfSk7XG5cdFx0fSxcblx0XHQ9PT09PSovXG5cblx0XHRpbmRleE9mOiBpbmRleCh0cnVlKSxcblx0XHQvKj09PT09XG5cdFx0aW5kZXhPZjogZnVuY3Rpb24oYXJyLCB2YWx1ZSwgZnJvbUluZGV4LCBmaW5kTGFzdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0bG9jYXRlcyB0aGUgZmlyc3QgaW5kZXggb2YgdGhlIHByb3ZpZGVkIHZhbHVlIGluIHRoZVxuXHRcdFx0Ly9cdFx0cGFzc2VkIGFycmF5LiBJZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLCAtMSBpcyByZXR1cm5lZC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgY29ycmVzcG9uZHMgdG8gdGhlIEphdmFTY3JpcHQgMS42IEFycmF5LmluZGV4T2YgbWV0aG9kLCB3aXRoIHR3byBkaWZmZXJlbmNlczpcblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQxLiB3aGVuIHJ1biBvdmVyIHNwYXJzZSBhcnJheXMsIHRoZSBEb2pvIGZ1bmN0aW9uIGludm9rZXMgdGhlIGNhbGxiYWNrIGZvciBldmVyeSBpbmRleFxuXHRcdFx0Ly9cdFx0ICAgd2hlcmVhcyBKYXZhU2NyaXB0IDEuNidzIGluZGV4T2Ygc2tpcHMgdGhlIGhvbGVzIGluIHRoZSBzcGFyc2UgYXJyYXkuXG5cdFx0XHQvL1x0XHQyLiB1c2VzIGVxdWFsaXR5ICg9PSkgcmF0aGVyIHRoYW4gc3RyaWN0IGVxdWFsaXR5ICg9PT0pXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0Rm9yIGRldGFpbHMgb24gdGhpcyBtZXRob2QsIHNlZTpcblx0XHRcdC8vXHRcdGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvaW5kZXhPZlxuXHRcdFx0Ly8gYXJyOiBBcnJheVxuXHRcdFx0Ly8gdmFsdWU6IE9iamVjdFxuXHRcdFx0Ly8gZnJvbUluZGV4OiBJbnRlZ2VyP1xuXHRcdFx0Ly8gZmluZExhc3Q6IEJvb2xlYW4/XG5cdFx0XHQvL1x0XHRNYWtlcyBpbmRleE9mKCkgd29yayBsaWtlIGxhc3RJbmRleE9mKCkuICBVc2VkIGludGVybmFsbHk7IG5vdCBtZWFudCBmb3IgZXh0ZXJuYWwgdXNhZ2UuXG5cdFx0XHQvLyByZXR1cm5zOiBOdW1iZXJcblx0XHR9LFxuXHRcdD09PT09Ki9cblxuXHRcdGxhc3RJbmRleE9mOiBpbmRleChmYWxzZSksXG5cdFx0Lyo9PT09PVxuXHRcdGxhc3RJbmRleE9mOiBmdW5jdGlvbihhcnIsIHZhbHVlLCBmcm9tSW5kZXgpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdGxvY2F0ZXMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIHByb3ZpZGVkIHZhbHVlIGluIHRoZSBwYXNzZWRcblx0XHRcdC8vXHRcdGFycmF5LiBJZiB0aGUgdmFsdWUgaXMgbm90IGZvdW5kLCAtMSBpcyByZXR1cm5lZC5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdCBcdC8vXHRcdFRoaXMgbWV0aG9kIGNvcnJlc3BvbmRzIHRvIHRoZSBKYXZhU2NyaXB0IDEuNiBBcnJheS5sYXN0SW5kZXhPZiBtZXRob2QsIHdpdGggdHdvIGRpZmZlcmVuY2VzOlxuXHRcdCBcdC8vXG5cdFx0IFx0Ly9cdFx0MS4gd2hlbiBydW4gb3ZlciBzcGFyc2UgYXJyYXlzLCB0aGUgRG9qbyBmdW5jdGlvbiBpbnZva2VzIHRoZSBjYWxsYmFjayBmb3IgZXZlcnkgaW5kZXhcblx0XHQgXHQvL1x0XHQgICB3aGVyZWFzIEphdmFTY3JpcHQgMS42J3MgbGFzSW5kZXhPZiBza2lwcyB0aGUgaG9sZXMgaW4gdGhlIHNwYXJzZSBhcnJheS5cblx0XHQgXHQvL1x0XHQyLiB1c2VzIGVxdWFsaXR5ICg9PSkgcmF0aGVyIHRoYW4gc3RyaWN0IGVxdWFsaXR5ICg9PT0pXG5cdFx0IFx0Ly9cblx0XHQgXHQvL1x0XHRGb3IgZGV0YWlscyBvbiB0aGlzIG1ldGhvZCwgc2VlOlxuXHRcdCBcdC8vXHRcdGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2Zcblx0XHRcdC8vIGFycjogQXJyYXksXG5cdFx0XHQvLyB2YWx1ZTogT2JqZWN0LFxuXHRcdFx0Ly8gZnJvbUluZGV4OiBJbnRlZ2VyP1xuXHRcdFx0Ly8gcmV0dXJuczogTnVtYmVyXG5cdFx0fSxcblx0XHQ9PT09PSovXG5cblx0XHRmb3JFYWNoOiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRmb3IgZXZlcnkgaXRlbSBpbiBhcnIsIGNhbGxiYWNrIGlzIGludm9rZWQuIFJldHVybiB2YWx1ZXMgYXJlIGlnbm9yZWQuXG5cdFx0XHQvL1x0XHRJZiB5b3Ugd2FudCB0byBicmVhayBvdXQgb2YgdGhlIGxvb3AsIGNvbnNpZGVyIHVzaW5nIGFycmF5LmV2ZXJ5KCkgb3IgYXJyYXkuc29tZSgpLlxuXHRcdFx0Ly9cdFx0Zm9yRWFjaCBkb2VzIG5vdCBhbGxvdyBicmVha2luZyBvdXQgb2YgdGhlIGxvb3Agb3ZlciB0aGUgaXRlbXMgaW4gYXJyLlxuXHRcdFx0Ly8gYXJyOlxuXHRcdFx0Ly9cdFx0dGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4gSWYgYSBzdHJpbmcsIG9wZXJhdGVzIG9uIGluZGl2aWR1YWwgY2hhcmFjdGVycy5cblx0XHRcdC8vIGNhbGxiYWNrOlxuXHRcdFx0Ly9cdFx0YSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBpdGVtLCBpbmRleCwgYW5kIGFycmF5XG5cdFx0XHQvLyB0aGlzT2JqZWN0OlxuXHRcdFx0Ly9cdFx0bWF5IGJlIHVzZWQgdG8gc2NvcGUgdGhlIGNhbGwgdG8gY2FsbGJhY2tcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBjb3JyZXNwb25kcyB0byB0aGUgSmF2YVNjcmlwdCAxLjYgQXJyYXkuZm9yRWFjaCgpIG1ldGhvZCwgd2l0aCBvbmUgZGlmZmVyZW5jZTogd2hlblxuXHRcdFx0Ly9cdFx0cnVuIG92ZXIgc3BhcnNlIGFycmF5cywgdGhpcyBpbXBsZW1lbnRhdGlvbiBwYXNzZXMgdGhlIFwiaG9sZXNcIiBpbiB0aGUgc3BhcnNlIGFycmF5IHRvXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIHZhbHVlIG9mIHVuZGVmaW5lZC4gSmF2YVNjcmlwdCAxLjYncyBmb3JFYWNoIHNraXBzIHRoZSBob2xlcyBpbiB0aGUgc3BhcnNlIGFycmF5LlxuXHRcdFx0Ly9cdFx0Rm9yIG1vcmUgZGV0YWlscywgc2VlOlxuXHRcdFx0Ly9cdFx0aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9mb3JFYWNoXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHwgLy8gbG9nIG91dCBhbGwgbWVtYmVycyBvZiB0aGUgYXJyYXk6XG5cdFx0XHQvL1x0fCBhcnJheS5mb3JFYWNoKFxuXHRcdFx0Ly9cdHxcdFx0WyBcInRoaW5nZXJcIiwgXCJibGFoXCIsIFwiaG93ZHlcIiwgMTAgXSxcblx0XHRcdC8vXHR8XHRcdGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhpdGVtKTtcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8ICk7XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHwgLy8gbG9nIG91dCB0aGUgbWVtYmVycyBhbmQgdGhlaXIgaW5kZXhlc1xuXHRcdFx0Ly9cdHwgYXJyYXkuZm9yRWFjaChcblx0XHRcdC8vXHR8XHRcdFsgXCJ0aGluZ2VyXCIsIFwiYmxhaFwiLCBcImhvd2R5XCIsIDEwIF0sXG5cdFx0XHQvL1x0fFx0XHRmdW5jdGlvbihpdGVtLCBpZHgsIGFycil7XG5cdFx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKGl0ZW0sIFwiYXQgaW5kZXg6XCIsIGlkeCk7XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fCApO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIHVzZSBhIHNjb3BlZCBvYmplY3QgbWVtYmVyIGFzIHRoZSBjYWxsYmFja1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8IHZhciBvYmogPSB7XG5cdFx0XHQvL1x0fFx0XHRwcmVmaXg6IFwibG9nZ2VkIHZpYSBvYmouY2FsbGJhY2s6XCIsXG5cdFx0XHQvL1x0fFx0XHRjYWxsYmFjazogZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKHRoaXMucHJlZml4LCBpdGVtKTtcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8IH07XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHwgLy8gc3BlY2lmeWluZyB0aGUgc2NvcGUgZnVuY3Rpb24gZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGluIHRoYXQgc2NvcGVcblx0XHRcdC8vXHR8IGFycmF5LmZvckVhY2goXG5cdFx0XHQvL1x0fFx0XHRbIFwidGhpbmdlclwiLCBcImJsYWhcIiwgXCJob3dkeVwiLCAxMCBdLFxuXHRcdFx0Ly9cdHxcdFx0b2JqLmNhbGxiYWNrLFxuXHRcdFx0Ly9cdHxcdFx0b2JqXG5cdFx0XHQvL1x0fCApO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8IC8vIGFsdGVybmF0ZWx5LCB3ZSBjYW4gYWNjb21wbGlzaCB0aGUgc2FtZSB0aGluZyB3aXRoIGxhbmcuaGl0Y2goKVxuXHRcdFx0Ly9cdHwgYXJyYXkuZm9yRWFjaChcblx0XHRcdC8vXHR8XHRcdFsgXCJ0aGluZ2VyXCIsIFwiYmxhaFwiLCBcImhvd2R5XCIsIDEwIF0sXG5cdFx0XHQvL1x0fFx0XHRsYW5nLmhpdGNoKG9iaiwgXCJjYWxsYmFja1wiKVxuXHRcdFx0Ly9cdHwgKTtcblx0XHRcdC8vIGFycjogQXJyYXl8U3RyaW5nXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb258U3RyaW5nXG5cdFx0XHQvLyB0aGlzT2JqZWN0OiBPYmplY3Q/XG5cblx0XHRcdHZhciBpID0gMCwgbCA9IGFyciAmJiBhcnIubGVuZ3RoIHx8IDA7XG5cdFx0XHRpZihsICYmIHR5cGVvZiBhcnIgPT0gXCJzdHJpbmdcIikgYXJyID0gYXJyLnNwbGl0KFwiXCIpO1xuXHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrID09IFwic3RyaW5nXCIpIGNhbGxiYWNrID0gY2FjaGVbY2FsbGJhY2tdIHx8IGJ1aWxkRm4oY2FsbGJhY2spO1xuXHRcdFx0aWYodGhpc09iamVjdCl7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpc09iamVjdCwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Zm9yKDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0Y2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG1hcDogZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgdGhpc09iamVjdCwgQ3RyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRhcHBsaWVzIGNhbGxiYWNrIHRvIGVhY2ggZWxlbWVudCBvZiBhcnIgYW5kIHJldHVybnNcblx0XHRcdC8vXHRcdGFuIEFycmF5IHdpdGggdGhlIHJlc3VsdHNcblx0XHRcdC8vIGFycjogQXJyYXl8U3RyaW5nXG5cdFx0XHQvL1x0XHR0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvbi4gSWYgYSBzdHJpbmcsIG9wZXJhdGVzIG9uXG5cdFx0XHQvL1x0XHRpbmRpdmlkdWFsIGNoYXJhY3RlcnMuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb258U3RyaW5nXG5cdFx0XHQvL1x0XHRhIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHMsIChpdGVtLCBpbmRleCxcblx0XHRcdC8vXHRcdGFycmF5KSxcdCBhbmQgcmV0dXJucyBhIHZhbHVlXG5cdFx0XHQvLyB0aGlzT2JqZWN0OiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRtYXkgYmUgdXNlZCB0byBzY29wZSB0aGUgY2FsbCB0byBjYWxsYmFja1xuXHRcdFx0Ly8gcmV0dXJuczogQXJyYXlcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBjb3JyZXNwb25kcyB0byB0aGUgSmF2YVNjcmlwdCAxLjYgQXJyYXkubWFwKCkgbWV0aG9kLCB3aXRoIG9uZSBkaWZmZXJlbmNlOiB3aGVuXG5cdFx0XHQvL1x0XHRydW4gb3ZlciBzcGFyc2UgYXJyYXlzLCB0aGlzIGltcGxlbWVudGF0aW9uIHBhc3NlcyB0aGUgXCJob2xlc1wiIGluIHRoZSBzcGFyc2UgYXJyYXkgdG9cblx0XHRcdC8vXHRcdHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgdmFsdWUgb2YgdW5kZWZpbmVkLiBKYXZhU2NyaXB0IDEuNidzIG1hcCBza2lwcyB0aGUgaG9sZXMgaW4gdGhlIHNwYXJzZSBhcnJheS5cblx0XHRcdC8vXHRcdEZvciBtb3JlIGRldGFpbHMsIHNlZTpcblx0XHRcdC8vXHRcdGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbWFwXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHwgLy8gcmV0dXJucyBbMiwgMywgNCwgNV1cblx0XHRcdC8vXHR8IGFycmF5Lm1hcChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbSsxIH0pO1xuXG5cdFx0XHQvLyBUT0RPOiB3aHkgZG8gd2UgaGF2ZSBhIG5vbi1zdGFuZGFyZCBzaWduYXR1cmUgaGVyZT8gZG8gd2UgbmVlZCBcIkN0clwiP1xuXHRcdFx0dmFyIGkgPSAwLCBsID0gYXJyICYmIGFyci5sZW5ndGggfHwgMCwgb3V0ID0gbmV3IChDdHIgfHwgQXJyYXkpKGwpO1xuXHRcdFx0aWYobCAmJiB0eXBlb2YgYXJyID09IFwic3RyaW5nXCIpIGFyciA9IGFyci5zcGxpdChcIlwiKTtcblx0XHRcdGlmKHR5cGVvZiBjYWxsYmFjayA9PSBcInN0cmluZ1wiKSBjYWxsYmFjayA9IGNhY2hlW2NhbGxiYWNrXSB8fCBidWlsZEZuKGNhbGxiYWNrKTtcblx0XHRcdGlmKHRoaXNPYmplY3Qpe1xuXHRcdFx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHRvdXRbaV0gPSBjYWxsYmFjay5jYWxsKHRoaXNPYmplY3QsIGFycltpXSwgaSwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdG91dFtpXSA9IGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dDsgLy8gQXJyYXlcblx0XHR9LFxuXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IEFycmF5IHdpdGggdGhvc2UgaXRlbXMgZnJvbSBhcnIgdGhhdCBtYXRjaCB0aGVcblx0XHRcdC8vXHRcdGNvbmRpdGlvbiBpbXBsZW1lbnRlZCBieSBjYWxsYmFjay5cblx0XHRcdC8vIGFycjogQXJyYXlcblx0XHRcdC8vXHRcdHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb258U3RyaW5nXG5cdFx0XHQvL1x0XHRhIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cyAoaXRlbSxcblx0XHRcdC8vXHRcdGluZGV4LCBhcnJheSkuIFRoZSByZXR1cm4gb2YgdGhpcyBmdW5jdGlvbiBpcyBleHBlY3RlZCB0b1xuXHRcdFx0Ly9cdFx0YmUgYSBib29sZWFuIHdoaWNoIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkLWluIGl0ZW1cblx0XHRcdC8vXHRcdHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVybmVkIGFycmF5LlxuXHRcdFx0Ly8gdGhpc09iamVjdDogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0bWF5IGJlIHVzZWQgdG8gc2NvcGUgdGhlIGNhbGwgdG8gY2FsbGJhY2tcblx0XHRcdC8vIHJldHVybnM6IEFycmF5XG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gY29ycmVzcG9uZHMgdG8gdGhlIEphdmFTY3JpcHQgMS42IEFycmF5LmZpbHRlcigpIG1ldGhvZCwgd2l0aCBvbmUgZGlmZmVyZW5jZTogd2hlblxuXHRcdFx0Ly9cdFx0cnVuIG92ZXIgc3BhcnNlIGFycmF5cywgdGhpcyBpbXBsZW1lbnRhdGlvbiBwYXNzZXMgdGhlIFwiaG9sZXNcIiBpbiB0aGUgc3BhcnNlIGFycmF5IHRvXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIHZhbHVlIG9mIHVuZGVmaW5lZC4gSmF2YVNjcmlwdCAxLjYncyBmaWx0ZXIgc2tpcHMgdGhlIGhvbGVzIGluIHRoZSBzcGFyc2UgYXJyYXkuXG5cdFx0XHQvL1x0XHRGb3IgbW9yZSBkZXRhaWxzLCBzZWU6XG5cdFx0XHQvL1x0XHRodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2ZpbHRlclxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIHJldHVybnMgWzIsIDMsIDRdXG5cdFx0XHQvL1x0fCBhcnJheS5maWx0ZXIoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0+MTsgfSk7XG5cblx0XHRcdC8vIFRPRE86IGRvIHdlIG5lZWQgXCJDdHJcIiBoZXJlIGxpa2UgaW4gbWFwKCk/XG5cdFx0XHR2YXIgaSA9IDAsIGwgPSBhcnIgJiYgYXJyLmxlbmd0aCB8fCAwLCBvdXQgPSBbXSwgdmFsdWU7XG5cdFx0XHRpZihsICYmIHR5cGVvZiBhcnIgPT0gXCJzdHJpbmdcIikgYXJyID0gYXJyLnNwbGl0KFwiXCIpO1xuXHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrID09IFwic3RyaW5nXCIpIGNhbGxiYWNrID0gY2FjaGVbY2FsbGJhY2tdIHx8IGJ1aWxkRm4oY2FsbGJhY2spO1xuXHRcdFx0aWYodGhpc09iamVjdCl7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdHZhbHVlID0gYXJyW2ldO1xuXHRcdFx0XHRcdGlmKGNhbGxiYWNrLmNhbGwodGhpc09iamVjdCwgdmFsdWUsIGksIGFycikpe1xuXHRcdFx0XHRcdFx0b3V0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZvcig7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdHZhbHVlID0gYXJyW2ldO1xuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKHZhbHVlLCBpLCBhcnIpKXtcblx0XHRcdFx0XHRcdG91dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXQ7IC8vIEFycmF5XG5cdFx0fSxcblxuXHRcdGNsZWFyQ2FjaGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRjYWNoZSA9IHt9O1xuXHRcdH1cblx0fTtcblxuXG5cdGhhcyhcImV4dGVuZC1kb2pvXCIpICYmIGxhbmcubWl4aW4oZG9qbywgYXJyYXkpO1xuXG5cdHJldHVybiBhcnJheTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4uL2dsb2JhbFwiLCBcIi4uL2hhc1wiLCBcInJlcXVpcmVcIl0sIGZ1bmN0aW9uKGdsb2JhbCwgaGFzLCByZXF1aXJlKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL19iYXNlL2NvbmZpZ1xuXG4vKj09PT09XG5yZXR1cm4ge1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gZHVyaW5nIGJvb3RzdHJhcC5cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdEJ5IGRlZmluaW5nIHVzZXIgY29uZmlndXJhdGlvbiBhcyBhIG1vZHVsZSB2YWx1ZSwgYW4gZW50aXJlIGNvbmZpZ3VyYXRpb24gY2FuIGJlIHNwZWNpZmllZCBpbiBhIGJ1aWxkLFxuXHQvL1x0XHR0aGVyZWJ5IGVsaW1pbmF0aW5nIHRoZSBuZWVkIGZvciBzbmlmZmluZyBhbmQgb3IgZXhwbGljaXRseSBzZXR0aW5nIGluIHRoZSBnbG9iYWwgdmFyaWFibGUgZG9qb0NvbmZpZy5cblx0Ly9cdFx0QWxzbywgd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgZG9qbyBleGlzdCBpbiBhIHNpbmdsZSBhcHBsaWNhdGlvbiwgZWFjaCB3aWxsIG5lY2Vzc2FyaWx5IGJlIGxvY2F0ZWRcblx0Ly9cdFx0YXQgYW4gdW5pcXVlIGFic29sdXRlIG1vZHVsZSBpZGVudGlmaWVyIGFzIGdpdmVuIGJ5IHRoZSBwYWNrYWdlIGNvbmZpZ3VyYXRpb24uIEltcGxlbWVudGluZyBjb25maWd1cmF0aW9uXG5cdC8vXHRcdGFzIGEgbW9kdWxlIGFsbG93cyBmb3Igc3BlY2lmeWluZyB1bmlxdWUsIHBlci1pbnN0YW5jZSBjb25maWd1cmF0aW9ucy5cblx0Ly8gZXhhbXBsZTpcblx0Ly9cdFx0Q3JlYXRlIGEgc2Vjb25kIGluc3RhbmNlIG9mIGRvam8gd2l0aCBhIGRpZmZlcmVudCwgaW5zdGFuY2UtdW5pcXVlIGNvbmZpZ3VyYXRpb24gKGFzc3VtZSB0aGUgbG9hZGVyIGFuZFxuXHQvL1x0XHRkb2pvLmpzIGFyZSBhbHJlYWR5IGxvYWRlZCkuXG5cdC8vXHRcdHxcdC8vIHNwZWNpZnkgYSBjb25maWd1cmF0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBkb2pvIGF0IHRoZSBhYnNvbHV0ZSBtb2R1bGUgaWRlbnRpZmllciBcIm15RG9qb1wiXG5cdC8vXHRcdHxcdHJlcXVpcmUoe1xuXHQvL1x0XHR8XHRcdHBhY2thZ2VzOlt7XG5cdC8vXHRcdHxcdFx0XHRuYW1lOlwibXlEb2pvXCIsXG5cdC8vXHRcdHxcdFx0XHRsb2NhdGlvbjpcIi5cIiwgLy9hc3N1bWUgYmFzZVVybCBwb2ludHMgdG8gZG9qby5qc1xuXHQvL1x0XHR8XHRcdH1dXG5cdC8vXHRcdHxcdH0pO1xuXHQvL1x0XHR8XG5cdC8vXHRcdHxcdC8vIHNwZWNpZnkgYSBjb25maWd1cmF0aW9uIGZvciB0aGUgbXlEb2pvIGluc3RhbmNlXG5cdC8vXHRcdHxcdGRlZmluZShcIm15RG9qby9jb25maWdcIiwge1xuXHQvL1x0XHR8XHRcdC8vIG5vcm1hbCBjb25maWd1cmF0aW9uIHZhcmlhYmxlcyBnbyBoZXJlLCBlLmcuLFxuXHQvL1x0XHR8XHRcdGxvY2FsZTpcImZyLWNhXCJcblx0Ly9cdFx0fFx0fSk7XG5cdC8vXHRcdHxcblx0Ly9cdFx0fFx0Ly8gbG9hZCBhbmQgdXNlIHRoZSBuZXcgaW5zdGFuY2Ugb2YgZG9qb1xuXHQvL1x0XHR8XHRyZXF1aXJlKFtcIm15RG9qb1wiXSwgZnVuY3Rpb24oZG9qbyl7XG5cdC8vXHRcdHxcdFx0Ly8gZG9qbyBpcyB0aGUgbmV3IGluc3RhbmNlIG9mIGRvam9cblx0Ly9cdFx0fFx0XHQvLyB1c2UgYXMgcmVxdWlyZWRcblx0Ly9cdFx0fFx0fSk7XG5cblx0Ly8gaXNEZWJ1ZzogQm9vbGVhblxuXHQvL1x0XHREZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBzZXQgdG8gYHRydWVgLCBlbnN1cmVzIHRoYXQgRG9qbyBwcm92aWRlc1xuXHQvL1x0XHRleHRlbmRlZCBkZWJ1Z2dpbmcgZmVlZGJhY2sgdG8gdGhlIGNvbnNvbGUuXG5cdGlzRGVidWc6IGZhbHNlLFxuXG5cdC8vIGxvY2FsZTogU3RyaW5nXG5cdC8vXHRcdFRoZSBsb2NhbGUgdG8gYXNzdW1lIGZvciBsb2FkaW5nIGxvY2FsaXplZCByZXNvdXJjZXMgaW4gdGhpcyBwYWdlLFxuXHQvL1x0XHRzcGVjaWZpZWQgYWNjb3JkaW5nIHRvIFtSRkMgMzA2Nl0oaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzA2Ni50eHQpLlxuXHQvL1x0XHRNdXN0IGJlIHNwZWNpZmllZCBlbnRpcmVseSBpbiBsb3dlcmNhc2UsIGUuZy4gYGVuLXVzYCBhbmQgYHpoLWNuYC5cblx0Ly9cdFx0U2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBgZG9qby5pMThuYCBhbmQgYGRvam8ucmVxdWlyZUxvY2FsaXphdGlvbmBcblx0Ly9cdFx0Zm9yIGRldGFpbHMgb24gbG9hZGluZyBsb2NhbGl6ZWQgcmVzb3VyY2VzLiBJZiBubyBsb2NhbGUgaXMgc3BlY2lmaWVkLFxuXHQvL1x0XHREb2pvIGFzc3VtZXMgdGhlIGxvY2FsZSBvZiB0aGUgdXNlciBhZ2VudCwgYWNjb3JkaW5nIHRvIGBuYXZpZ2F0b3IudXNlckxhbmd1YWdlYFxuXHQvL1x0XHRvciBgbmF2aWdhdG9yLmxhbmd1YWdlYCBwcm9wZXJ0aWVzLlxuXHRsb2NhbGU6IHVuZGVmaW5lZCxcblxuXHQvLyBleHRyYUxvY2FsZTogQXJyYXlcblx0Ly9cdFx0Tm8gZGVmYXVsdCB2YWx1ZS4gU3BlY2lmaWVzIGFkZGl0aW9uYWwgbG9jYWxlcyB3aG9zZVxuXHQvL1x0XHRyZXNvdXJjZXMgc2hvdWxkIGFsc28gYmUgbG9hZGVkIGFsb25nc2lkZSB0aGUgZGVmYXVsdCBsb2NhbGUgd2hlblxuXHQvL1x0XHRjYWxscyB0byBgZG9qby5yZXF1aXJlTG9jYWxpemF0aW9uKClgIGFyZSBwcm9jZXNzZWQuXG5cdGV4dHJhTG9jYWxlOiB1bmRlZmluZWQsXG5cblx0Ly8gYmFzZVVybDogU3RyaW5nXG5cdC8vXHRcdFRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggYGRvam8uanNgIGlzIGxvY2F0ZWQuIFVuZGVyIG5vcm1hbFxuXHQvL1x0XHRjb25kaXRpb25zLCBEb2pvIGF1dG8tZGV0ZWN0cyB0aGUgY29ycmVjdCBsb2NhdGlvbiBmcm9tIHdoaWNoIGl0XG5cdC8vXHRcdHdhcyBsb2FkZWQuIFlvdSBtYXkgbmVlZCB0byBtYW51YWxseSBjb25maWd1cmUgYGJhc2VVcmxgIGluIGNhc2VzXG5cdC8vXHRcdHdoZXJlIHlvdSBoYXZlIHJlbmFtZWQgYGRvam8uanNgIG9yIGluIHdoaWNoIGA8YmFzZT5gIHRhZ3MgY29uZnVzZVxuXHQvL1x0XHRzb21lIGJyb3dzZXJzIChlLmcuIElFIDYpLiBUaGUgdmFyaWFibGUgYGRvam8uYmFzZVVybGAgaXMgYXNzaWduZWRcblx0Ly9cdFx0ZWl0aGVyIHRoZSB2YWx1ZSBvZiBgZGpDb25maWcuYmFzZVVybGAgaWYgb25lIGlzIHByb3ZpZGVkIG9yIHRoZVxuXHQvL1x0XHRhdXRvLWRldGVjdGVkIHJvb3QgaWYgbm90LiBPdGhlciBtb2R1bGVzIGFyZSBsb2NhdGVkIHJlbGF0aXZlIHRvXG5cdC8vXHRcdHRoaXMgcGF0aC4gVGhlIHBhdGggc2hvdWxkIGVuZCBpbiBhIHNsYXNoLlxuXHRiYXNlVXJsOiB1bmRlZmluZWQsXG5cblx0Ly8gbW9kdWxlUGF0aHM6IFtkZXByZWNhdGVkXSBPYmplY3Rcblx0Ly9cdFx0QSBtYXAgb2YgbW9kdWxlIG5hbWVzIHRvIHBhdGhzIHJlbGF0aXZlIHRvIGBkb2pvLmJhc2VVcmxgLiBUaGVcblx0Ly9cdFx0a2V5L3ZhbHVlIHBhaXJzIGNvcnJlc3BvbmQgZGlyZWN0bHkgdG8gdGhlIGFyZ3VtZW50cyB3aGljaFxuXHQvL1x0XHRgZG9qby5yZWdpc3Rlck1vZHVsZVBhdGhgIGFjY2VwdHMuIFNwZWNpZnlpbmdcblx0Ly9cdFx0YGRqQ29uZmlnLm1vZHVsZVBhdGhzID0geyBcImZvb1wiOiBcIi4uLy4uL2JhclwiIH1gIGlzIHRoZSBlcXVpdmFsZW50XG5cdC8vXHRcdG9mIGNhbGxpbmcgYGRvam8ucmVnaXN0ZXJNb2R1bGVQYXRoKFwiZm9vXCIsIFwiLi4vLi4vYmFyXCIpO2AuIE11bHRpcGxlXG5cdC8vXHRcdG1vZHVsZXMgbWF5IGJlIGNvbmZpZ3VyZWQgdmlhIGBkakNvbmZpZy5tb2R1bGVQYXRoc2AuXG5cdG1vZHVsZVBhdGhzOiB7fSxcblxuXHQvLyBhZGRPbkxvYWQ6IEZ1bmN0aW9ufEFycmF5XG5cdC8vXHRcdEFkZHMgYSBjYWxsYmFjayB2aWEgZG9qby9yZWFkeS4gVXNlZnVsIHdoZW4gRG9qbyBpcyBhZGRlZCBhZnRlclxuXHQvL1x0XHR0aGUgcGFnZSBsb2FkcyBhbmQgZGpDb25maWcuYWZ0ZXJPbkxvYWQgaXMgdHJ1ZS4gU3VwcG9ydHMgdGhlIHNhbWVcblx0Ly9cdFx0YXJndW1lbnRzIGFzIGRvam8vcmVhZHkuIFdoZW4gdXNpbmcgYSBmdW5jdGlvbiByZWZlcmVuY2UsIHVzZVxuXHQvL1x0XHRgZGpDb25maWcuYWRkT25Mb2FkID0gZnVuY3Rpb24oKXt9O2AuIEZvciBvYmplY3Qgd2l0aCBmdW5jdGlvbiBuYW1lIHVzZVxuXHQvL1x0XHRgZGpDb25maWcuYWRkT25Mb2FkID0gW215T2JqZWN0LCBcImZ1bmN0aW9uTmFtZVwiXTtgIGFuZCBmb3Igb2JqZWN0IHdpdGhcblx0Ly9cdFx0ZnVuY3Rpb24gcmVmZXJlbmNlIHVzZVxuXHQvL1x0XHRgZGpDb25maWcuYWRkT25Mb2FkID0gW215T2JqZWN0LCBmdW5jdGlvbigpe31dO2Bcblx0YWRkT25Mb2FkOiBudWxsLFxuXG5cdC8vIHBhcnNlT25Mb2FkOiBCb29sZWFuXG5cdC8vXHRcdFJ1biB0aGUgcGFyc2VyIGFmdGVyIHRoZSBwYWdlIGlzIGxvYWRlZFxuXHRwYXJzZU9uTG9hZDogZmFsc2UsXG5cblx0Ly8gcmVxdWlyZTogU3RyaW5nW11cblx0Ly9cdFx0QW4gYXJyYXkgb2YgbW9kdWxlIG5hbWVzIHRvIGJlIGxvYWRlZCBpbW1lZGlhdGVseSBhZnRlciBkb2pvLmpzIGhhcyBiZWVuIGluY2x1ZGVkXG5cdC8vXHRcdGluIGEgcGFnZS5cblx0cmVxdWlyZTogW10sXG5cblx0Ly8gZGVmYXVsdER1cmF0aW9uOiBOdW1iZXJcblx0Ly9cdFx0RGVmYXVsdCBkdXJhdGlvbiwgaW4gbWlsbGlzZWNvbmRzLCBmb3Igd2lwZSBhbmQgZmFkZSBhbmltYXRpb25zIHdpdGhpbiBkaWppdHMuXG5cdC8vXHRcdEFzc2lnbmVkIHRvIGRpaml0LmRlZmF1bHREdXJhdGlvbi5cblx0ZGVmYXVsdER1cmF0aW9uOiAyMDAsXG5cblx0Ly8gZG9qb0JsYW5rSHRtbFVybDogU3RyaW5nXG5cdC8vXHRcdFVzZWQgYnkgc29tZSBtb2R1bGVzIHRvIGNvbmZpZ3VyZSBhbiBlbXB0eSBpZnJhbWUuIFVzZWQgYnkgZG9qby9pby9pZnJhbWUgYW5kXG5cdC8vXHRcdGRvam8vYmFjaywgYW5kIGRpaml0L3BvcHVwIHN1cHBvcnQgaW4gSUUgd2hlcmUgYW4gaWZyYW1lIGlzIG5lZWRlZCB0byBtYWtlIHN1cmUgbmF0aXZlXG5cdC8vXHRcdGNvbnRyb2xzIGRvIG5vdCBibGVlZCB0aHJvdWdoIHRoZSBwb3B1cHMuIE5vcm1hbGx5IHRoaXMgY29uZmlndXJhdGlvbiB2YXJpYWJsZVxuXHQvL1x0XHRkb2VzIG5vdCBuZWVkIHRvIGJlIHNldCwgZXhjZXB0IHdoZW4gdXNpbmcgY3Jvc3MtZG9tYWluL0NETiBEb2pvIGJ1aWxkcy5cblx0Ly9cdFx0U2F2ZSBkb2pvL3Jlc291cmNlcy9ibGFuay5odG1sIHRvIHlvdXIgZG9tYWluIGFuZCBzZXQgYGRqQ29uZmlnLmRvam9CbGFua0h0bWxVcmxgXG5cdC8vXHRcdHRvIHRoZSBwYXRoIG9uIHlvdXIgZG9tYWluIHlvdXIgY29weSBvZiBibGFuay5odG1sLlxuXHRkb2pvQmxhbmtIdG1sVXJsOiB1bmRlZmluZWQsXG5cblx0Ly8gaW9QdWJsaXNoOiBCb29sZWFuP1xuXHQvL1x0XHRTZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSBwdWJsaXNoaW5nIG9mIHRvcGljcyBmb3IgdGhlIGRpZmZlcmVudCBwaGFzZXMgb2Zcblx0Ly9cdFx0SU8gb3BlcmF0aW9ucy4gUHVibGlzaGluZyBpcyBkb25lIHZpYSBkb2pvL3RvcGljLnB1Ymxpc2goKS4gU2VlIGRvam8vbWFpbi5fX0lvUHVibGlzaCBmb3IgYSBsaXN0XG5cdC8vXHRcdG9mIHRvcGljcyB0aGF0IGFyZSBwdWJsaXNoZWQuXG5cdGlvUHVibGlzaDogZmFsc2UsXG5cblx0Ly8gdHJhbnNwYXJlbnRDb2xvcjogQXJyYXlcblx0Ly9cdFx0QXJyYXkgY29udGFpbmluZyB0aGUgciwgZywgYiBjb21wb25lbnRzIHVzZWQgYXMgdHJhbnNwYXJlbnQgY29sb3IgaW4gZG9qby5Db2xvcjtcblx0Ly9cdFx0aWYgdW5kZWZpbmVkLCBbMjU1LDI1NSwyNTVdICh3aGl0ZSkgd2lsbCBiZSB1c2VkLlxuXHR0cmFuc3BhcmVudENvbG9yOiB1bmRlZmluZWQsXG5cdFxuXHQvLyBkZXBzOiBGdW5jdGlvbnxBcnJheVxuXHQvL1x0XHREZWZpbmVzIGRlcGVuZGVuY2llcyB0byBiZSB1c2VkIGJlZm9yZSB0aGUgbG9hZGVyIGhhcyBiZWVuIGxvYWRlZC5cblx0Ly9cdFx0V2hlbiBwcm92aWRlZCwgdGhleSBjYXVzZSB0aGUgbG9hZGVyIHRvIGV4ZWN1dGUgcmVxdWlyZShkZXBzLCBjYWxsYmFjaykgXG5cdC8vXHRcdG9uY2UgaXQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuIFNob3VsZCBiZSB1c2VkIHdpdGggY2FsbGJhY2suXG5cdGRlcHM6IHVuZGVmaW5lZCxcblx0XG5cdC8vIGNhbGxiYWNrOiBGdW5jdGlvbnxBcnJheVxuXHQvL1x0XHREZWZpbmVzIGEgY2FsbGJhY2sgdG8gYmUgdXNlZCB3aGVuIGRlcGVuZGVuY2llcyBhcmUgZGVmaW5lZCBiZWZvcmUgXG5cdC8vXHRcdHRoZSBsb2FkZXIgaGFzIGJlZW4gbG9hZGVkLiBXaGVuIHByb3ZpZGVkLCB0aGV5IGNhdXNlIHRoZSBsb2FkZXIgdG8gXG5cdC8vXHRcdGV4ZWN1dGUgcmVxdWlyZShkZXBzLCBjYWxsYmFjaykgb25jZSBpdCBoYXMgZmluaXNoZWQgbG9hZGluZy4gXG5cdC8vXHRcdFNob3VsZCBiZSB1c2VkIHdpdGggZGVwcy5cblx0Y2FsbGJhY2s6IHVuZGVmaW5lZCxcblx0XG5cdC8vIGRlZmVycmVkSW5zdHJ1bWVudGF0aW9uOiBCb29sZWFuXG5cdC8vXHRcdFdoZXRoZXIgZGVmZXJyZWQgaW5zdHJ1bWVudGF0aW9uIHNob3VsZCBiZSBsb2FkZWQgb3IgaW5jbHVkZWRcblx0Ly9cdFx0aW4gYnVpbGRzLlxuXHRkZWZlcnJlZEluc3RydW1lbnRhdGlvbjogdHJ1ZSxcblxuXHQvLyB1c2VEZWZlcnJlZEluc3RydW1lbnRhdGlvbjogQm9vbGVhbnxTdHJpbmdcblx0Ly9cdFx0V2hldGhlciB0aGUgZGVmZXJyZWQgaW5zdHJ1bWVudGF0aW9uIHNob3VsZCBiZSB1c2VkLlxuXHQvL1xuXHQvL1x0XHQqIGBcInJlcG9ydC1yZWplY3Rpb25zXCJgOiByZXBvcnQgZWFjaCByZWplY3Rpb24gYXMgaXQgb2NjdXJzLlxuXHQvL1x0XHQqIGB0cnVlYCBvciBgMWAgb3IgYFwicmVwb3J0LXVuaGFuZGxlZC1yZWplY3Rpb25zXCJgOiB3YWl0IDEgc2Vjb25kXG5cdC8vXHRcdFx0aW4gYW4gYXR0ZW1wdCB0byBkZXRlY3QgdW5oYW5kbGVkIHJlamVjdGlvbnMuXG5cdHVzZURlZmVycmVkSW5zdHJ1bWVudGF0aW9uOiBcInJlcG9ydC11bmhhbmRsZWQtcmVqZWN0aW9uc1wiXG59O1xuPT09PT0qL1xuXG5cdHZhciByZXN1bHQgPSB7fTtcblx0aWYoaGFzKFwiZG9qby1jb25maWctYXBpXCIpKXtcblx0XHQvLyBtdXN0IGJlIHRoZSBkb2pvIGxvYWRlcjsgdGFrZSBhIHNoYWxsb3cgY29weSBvZiByZXF1aXJlLnJhd0NvbmZpZ1xuXHRcdHZhciBzcmMgPSByZXF1aXJlLnJhd0NvbmZpZywgcDtcblx0XHRmb3IocCBpbiBzcmMpe1xuXHRcdFx0cmVzdWx0W3BdID0gc3JjW3BdO1xuXHRcdH1cblx0fWVsc2V7XG5cdFx0dmFyIGFkdmlzZUhhcyA9IGZ1bmN0aW9uKGZlYXR1cmVTZXQsIHByZWZpeCwgYm9vdGluZyl7XG5cdFx0XHRmb3IocCBpbiBmZWF0dXJlU2V0KXtcblx0XHRcdFx0cCE9XCJoYXNcIiAmJiBoYXMuYWRkKHByZWZpeCArIHAsIGZlYXR1cmVTZXRbcF0sIDAsIGJvb3RpbmcpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmVzdWx0ID0gaGFzKFwiZG9qby1sb2FkZXJcIikgP1xuXHRcdFx0Ly8gbXVzdCBiZSBhIGJ1aWx0IHZlcnNpb24gb2YgdGhlIGRvam8gbG9hZGVyOyBhbGwgY29uZmlnIHN0dWZmZWQgaW4gcmVxdWlyZS5yYXdDb25maWdcblx0XHRcdHJlcXVpcmUucmF3Q29uZmlnIDpcblx0XHRcdC8vIGEgZm9yZWlnbiBsb2FkZXJcblx0XHRcdGdsb2JhbC5kb2pvQ29uZmlnIHx8IGdsb2JhbC5kakNvbmZpZyB8fCB7fTtcblx0XHRhZHZpc2VIYXMocmVzdWx0LCBcImNvbmZpZ1wiLCAxKTtcblx0XHRhZHZpc2VIYXMocmVzdWx0LmhhcywgXCJcIiwgMSk7XG5cdH1cblxuXHRpZighcmVzdWx0LmxvY2FsZSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIpe1xuXHRcdC8vIERlZmF1bHQgbG9jYWxlIGZvciBicm93c2VycyAoZW5zdXJlIGl0J3MgcmVhZCBmcm9tIHVzZXItc2V0dGluZ3Mgbm90IGRvd25sb2FkIGxvY2FsZSkuXG5cdFx0dmFyIGxhbmd1YWdlID0gKG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcy5sZW5ndGgpID8gbmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6XG5cdFx0XHQobmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UpO1xuXHRcdGlmKGxhbmd1YWdlKXtcblx0XHRcdHJlc3VsdC5sb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59KTtcblxuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi4vb25cIiwgXCIuLi90b3BpY1wiLCBcIi4uL2FzcGVjdFwiLCBcIi4vZXZlbnRcIiwgXCIuLi9tb3VzZVwiLCBcIi4vc25pZmZcIiwgXCIuL2xhbmdcIiwgXCIuLi9rZXlzXCJdLCBmdW5jdGlvbihkb2pvLCBvbiwgaHViLCBhc3BlY3QsIGV2ZW50TW9kdWxlLCBtb3VzZSwgaGFzLCBsYW5nKXtcbi8vIG1vZHVsZTpcbi8vXHRcdGRvam8vX2Jhc2UvY29ubmVjdFxuXG5oYXMuYWRkKFwiZXZlbnRzLWtleXByZXNzLXR5cGVkXCIsIGZ1bmN0aW9uKCl7IC8vIGtleXByZXNzZXMgc2hvdWxkIG9ubHkgb2NjdXIgYSBwcmludGFibGUgY2hhcmFjdGVyIGlzIGhpdFxuXHR2YXIgdGVzdEtleUV2ZW50ID0ge2NoYXJDb2RlOiAwfTtcblx0dHJ5e1xuXHRcdHRlc3RLZXlFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiS2V5Ym9hcmRFdmVudFwiKTtcblx0XHQodGVzdEtleUV2ZW50LmluaXRLZXlib2FyZEV2ZW50IHx8IHRlc3RLZXlFdmVudC5pbml0S2V5RXZlbnQpLmNhbGwodGVzdEtleUV2ZW50LCBcImtleXByZXNzXCIsIHRydWUsIHRydWUsIG51bGwsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCA5LCAzKTtcblx0fWNhdGNoKGUpe31cblx0cmV0dXJuIHRlc3RLZXlFdmVudC5jaGFyQ29kZSA9PSAwICYmICFoYXMoXCJvcGVyYVwiKTtcbn0pO1xuXG5mdW5jdGlvbiBjb25uZWN0XyhvYmosIGV2ZW50LCBjb250ZXh0LCBtZXRob2QsIGRvbnRGaXgpe1xuXHRtZXRob2QgPSBsYW5nLmhpdGNoKGNvbnRleHQsIG1ldGhvZCk7XG5cdGlmKCFvYmogfHwgIShvYmouYWRkRXZlbnRMaXN0ZW5lciB8fCBvYmouYXR0YWNoRXZlbnQpKXtcblx0XHQvLyBpdCBpcyBhIG5vdCBhIERPTSBub2RlIGFuZCB3ZSBhcmUgdXNpbmcgdGhlIGRvam8uY29ubmVjdCBzdHlsZSBvZiB0cmVhdGluZyBhXG5cdFx0Ly8gbWV0aG9kIGxpa2UgYW4gZXZlbnQsIG11c3QgZ28gcmlnaHQgdG8gYXNwZWN0XG5cdFx0cmV0dXJuIGFzcGVjdC5hZnRlcihvYmogfHwgZG9qby5nbG9iYWwsIGV2ZW50LCBtZXRob2QsIHRydWUpO1xuXHR9XG5cdGlmKHR5cGVvZiBldmVudCA9PSBcInN0cmluZ1wiICYmIGV2ZW50LnN1YnN0cmluZygwLCAyKSA9PSBcIm9uXCIpe1xuXHRcdGV2ZW50ID0gZXZlbnQuc3Vic3RyaW5nKDIpO1xuXHR9XG5cdGlmKCFvYmope1xuXHRcdG9iaiA9IGRvam8uZ2xvYmFsO1xuXHR9XG5cdGlmKCFkb250Rml4KXtcblx0XHRzd2l0Y2goZXZlbnQpe1xuXHRcdFx0Ly8gZG9qby5jb25uZWN0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGVzZSBldmVudCB0eXBlc1xuXHRcdFx0Y2FzZSBcImtleXByZXNzXCI6XG5cdFx0XHRcdGV2ZW50ID0ga2V5cHJlc3M7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1vdXNlZW50ZXJcIjpcblx0XHRcdFx0ZXZlbnQgPSBtb3VzZS5lbnRlcjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibW91c2VsZWF2ZVwiOlxuXHRcdFx0XHRldmVudCA9IG1vdXNlLmxlYXZlO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0cmV0dXJuIG9uKG9iaiwgZXZlbnQsIG1ldGhvZCwgZG9udEZpeCk7XG59XG5cbnZhciBfcHVuY3RNYXAgPSB7XG5cdDEwNjo0Mixcblx0MTExOjQ3LFxuXHQxODY6NTksXG5cdDE4Nzo0Myxcblx0MTg4OjQ0LFxuXHQxODk6NDUsXG5cdDE5MDo0Nixcblx0MTkxOjQ3LFxuXHQxOTI6OTYsXG5cdDIxOTo5MSxcblx0MjIwOjkyLFxuXHQyMjE6OTMsXG5cdDIyMjozOSxcblx0MjI5OjExM1xufTtcbnZhciBldnRDb3B5S2V5ID0gaGFzKFwibWFjXCIpID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcblxuXG52YXIgX3N5bnRoZXNpemVFdmVudCA9IGZ1bmN0aW9uKGV2dCwgcHJvcHMpe1xuXHR2YXIgZmF1eCA9IGxhbmcubWl4aW4oe30sIGV2dCwgcHJvcHMpO1xuXHRzZXRLZXlDaGFyKGZhdXgpO1xuXHQvLyBGSVhNRTogd291bGQgcHJlZmVyIHRvIHVzZSBsYW5nLmhpdGNoOiBsYW5nLmhpdGNoKGV2dCwgZXZ0LnByZXZlbnREZWZhdWx0KTtcblx0Ly8gYnV0IGl0IHRocm93cyBhbiBlcnJvciB3aGVuIHByZXZlbnREZWZhdWx0IGlzIGludm9rZWQgb24gU2FmYXJpXG5cdC8vIGRvZXMgRXZlbnQucHJldmVudERlZmF1bHQgbm90IHN1cHBvcnQgXCJhcHBseVwiIG9uIFNhZmFyaT9cblx0ZmF1eC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCl7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyB9O1xuXHRmYXV4LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCl7IGV2dC5zdG9wUHJvcGFnYXRpb24oKTsgfTtcblx0cmV0dXJuIGZhdXg7XG59O1xuZnVuY3Rpb24gc2V0S2V5Q2hhcihldnQpe1xuXHRldnQua2V5Q2hhciA9IGV2dC5jaGFyQ29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZ0LmNoYXJDb2RlKSA6ICcnO1xuXHRldnQuY2hhck9yQ29kZSA9IGV2dC5rZXlDaGFyIHx8IGV2dC5rZXlDb2RlO1xufVxudmFyIGtleXByZXNzO1xuaWYoaGFzKFwiZXZlbnRzLWtleXByZXNzLXR5cGVkXCIpKXtcblx0Ly8gdGhpcyBlbXVsYXRlcyBGaXJlZm94J3Mga2V5cHJlc3MgYmVoYXZpb3Igd2hlcmUgZXZlcnkga2V5ZG93biBjYW4gY29ycmVzcG9uZCB0byBhIGtleXByZXNzXG5cdHZhciBfdHJ5U2V0S2V5Q29kZSA9IGZ1bmN0aW9uKGUsIGNvZGUpe1xuXHRcdHRyeXtcblx0XHRcdC8vIHNxdWVsY2ggZXJyb3JzIHdoZW4ga2V5Q29kZSBpcyByZWFkLW9ubHlcblx0XHRcdC8vIChlLmcuIGlmIGtleUNvZGUgaXMgY3RybCBvciBzaGlmdClcblx0XHRcdHJldHVybiAoZS5rZXlDb2RlID0gY29kZSk7XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHR9O1xuXHRrZXlwcmVzcyA9IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpe1xuXHRcdHZhciBrZXlkb3duU2lnbmFsID0gb24ob2JqZWN0LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdC8vIG11bmdlIGtleS9jaGFyQ29kZVxuXHRcdFx0dmFyIGs9ZXZ0LmtleUNvZGU7XG5cdFx0XHQvLyBUaGVzZSBhcmUgV2luZG93cyBWaXJ0dWFsIEtleSBDb2Rlc1xuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9saWJyYXJ5L2RlZmF1bHQuYXNwP3VybD0vbGlicmFyeS9lbi11cy93aW51aS9XaW5VSS9XaW5kb3dzVXNlckludGVyZmFjZS9Vc2VySW5wdXQvVmlydHVhbEtleUNvZGVzLmFzcFxuXHRcdFx0dmFyIHVucHJpbnRhYmxlID0gKGshPTEzKSAmJiBrIT0zMiAmJiAoayE9Mjd8fCFoYXMoXCJpZVwiKSkgJiYgKGs8NDh8fGs+OTApICYmIChrPDk2fHxrPjExMSkgJiYgKGs8MTg2fHxrPjE5MikgJiYgKGs8MjE5fHxrPjIyMikgJiYgayE9MjI5O1xuXHRcdFx0Ly8gc3ludGhlc2l6ZSBrZXlwcmVzcyBmb3IgbW9zdCB1bnByaW50YWJsZXMgYW5kIENUUkwta2V5c1xuXHRcdFx0aWYodW5wcmludGFibGV8fGV2dC5jdHJsS2V5KXtcblx0XHRcdFx0dmFyIGMgPSB1bnByaW50YWJsZSA/IDAgOiBrO1xuXHRcdFx0XHRpZihldnQuY3RybEtleSl7XG5cdFx0XHRcdFx0aWYoaz09MyB8fCBrPT0xMyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbChldnQuY3VycmVudFRhcmdldCwgZXZ0KTsgLy8gSUUgd2lsbCBwb3N0IENUUkwtQlJFQUssIENUUkwtRU5URVIgYXMga2V5cHJlc3MgbmF0aXZlbHlcblx0XHRcdFx0XHR9ZWxzZSBpZihjPjk1ICYmIGM8MTA2KXtcblx0XHRcdFx0XHRcdGMgLT0gNDg7IC8vIG1hcCBDVFJMLVtudW1wYWQgMC05XSB0byBBU0NJSVxuXHRcdFx0XHRcdH1lbHNlIGlmKCghZXZ0LnNoaWZ0S2V5KSYmKGM+PTY1JiZjPD05MCkpe1xuXHRcdFx0XHRcdFx0YyArPSAzMjsgLy8gbWFwIENUUkwtW0EtWl0gdG8gbG93ZXJjYXNlXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRjID0gX3B1bmN0TWFwW2NdIHx8IGM7IC8vIG1hcCBvdGhlciBwcm9ibGVtYXRpYyBDVFJMIGNvbWJpbmF0aW9ucyB0byBBU0NJSVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzaW11bGF0ZSBhIGtleXByZXNzIGV2ZW50XG5cdFx0XHRcdHZhciBmYXV4ID0gX3N5bnRoZXNpemVFdmVudChldnQsIHt0eXBlOiAna2V5cHJlc3MnLCBmYXV4OiB0cnVlLCBjaGFyQ29kZTogY30pO1xuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKGV2dC5jdXJyZW50VGFyZ2V0LCBmYXV4KTtcblx0XHRcdFx0aWYoaGFzKFwiaWVcIikpe1xuXHRcdFx0XHRcdF90cnlTZXRLZXlDb2RlKGV2dCwgZmF1eC5rZXlDb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHZhciBrZXlwcmVzc1NpZ25hbCA9IG9uKG9iamVjdCwgXCJrZXlwcmVzc1wiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0dmFyIGMgPSBldnQuY2hhckNvZGU7XG5cdFx0XHRjID0gYz49MzIgPyBjIDogMDtcblx0XHRcdGV2dCA9IF9zeW50aGVzaXplRXZlbnQoZXZ0LCB7Y2hhckNvZGU6IGMsIGZhdXg6IHRydWV9KTtcblx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2dCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKXtcblx0XHRcdFx0a2V5ZG93blNpZ25hbC5yZW1vdmUoKTtcblx0XHRcdFx0a2V5cHJlc3NTaWduYWwucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcbn1lbHNle1xuXHRpZihoYXMoXCJvcGVyYVwiKSl7XG5cdFx0a2V5cHJlc3MgPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKXtcblx0XHRcdHJldHVybiBvbihvYmplY3QsIFwia2V5cHJlc3NcIiwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0dmFyIGMgPSBldnQud2hpY2g7XG5cdFx0XHRcdGlmKGM9PTMpe1xuXHRcdFx0XHRcdGM9OTk7IC8vIE1vemlsbGEgbWFwcyBDVFJMLUJSRUFLIHRvIENUUkwtY1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNhbid0IHRyYXAgc29tZSBrZXlzIGF0IGFsbCwgbGlrZSBJTlNFUlQgYW5kIERFTEVURVxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBkaWZmZXJlbnRpYXRpbmcgaW5mbyBiZXR3ZWVuIERFTEVURSBhbmQgXCIuXCIsIG9yIElOU0VSVCBhbmQgXCItXCJcblx0XHRcdFx0YyA9IGM8MzIgJiYgIWV2dC5zaGlmdEtleSA/IDAgOiBjO1xuXHRcdFx0XHRpZihldnQuY3RybEtleSAmJiAhZXZ0LnNoaWZ0S2V5ICYmIGM+PTY1ICYmIGM8PTkwKXtcblx0XHRcdFx0XHQvLyBsb3dlcmNhc2UgQ1RSTC1bQS1aXSBrZXlzXG5cdFx0XHRcdFx0YyArPSAzMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBfc3ludGhlc2l6ZUV2ZW50KGV2dCwgeyBjaGFyQ29kZTogYyB9KSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9ZWxzZXtcblx0XHRrZXlwcmVzcyA9IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpe1xuXHRcdFx0cmV0dXJuIG9uKG9iamVjdCwgXCJrZXlwcmVzc1wiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRzZXRLZXlDaGFyKGV2dCk7XG5cdFx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2dCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG59XG5cbnZhciBjb25uZWN0ID0ge1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBkZWZpbmVzIHRoZSBkb2pvLmNvbm5lY3QgQVBJLlxuXHQvL1x0XHRUaGlzIG1vZHVsZXMgYWxzbyBwcm92aWRlcyBrZXlib2FyZCBldmVudCBoYW5kbGluZyBoZWxwZXJzLlxuXHQvL1x0XHRUaGlzIG1vZHVsZSBleHBvcnRzIGFuIGV4dGVuc2lvbiBldmVudCBmb3IgZW11bGF0aW5nIEZpcmVmb3gncyBrZXlwcmVzcyBoYW5kbGluZy5cblx0Ly9cdFx0SG93ZXZlciwgdGhpcyBleHRlbnNpb24gZXZlbnQgZXhpc3RzIHByaW1hcmlseSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kXG5cdC8vXHRcdGlzIG5vdCByZWNvbW1lbmRlZC4gV2ViS2l0IGFuZCBJRSB1c2VzIGFuIGFsdGVybmF0ZSBrZXlwcmVzcyBoYW5kbGluZyAob25seVxuXHQvL1x0XHRmaXJpbmcgZm9yIHByaW50YWJsZSBjaGFyYWN0ZXJzLCB0byBkaXN0aW5ndWlzaCBmcm9tIGtleWRvd24gZXZlbnRzKSwgYW5kIG1vc3Rcblx0Ly9cdFx0Y29uc2lkZXIgdGhlIFdlYktpdC9JRSBiZWhhdmlvciBtb3JlIGRlc2lyYWJsZS5cblxuXHRfa2V5cHJlc3M6a2V5cHJlc3MsXG5cblx0Y29ubmVjdDpmdW5jdGlvbihvYmosIGV2ZW50LCBjb250ZXh0LCBtZXRob2QsIGRvbnRGaXgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YGRvam8uY29ubmVjdGAgaXMgYSBkZXByZWNhdGVkIGV2ZW50IGhhbmRsaW5nIGFuZCBkZWxlZ2F0aW9uIG1ldGhvZCBpblxuXHRcdC8vXHRcdERvam8uIEl0IGFsbG93cyBvbmUgZnVuY3Rpb24gdG8gXCJsaXN0ZW4gaW5cIiBvbiB0aGUgZXhlY3V0aW9uIG9mXG5cdFx0Ly9cdFx0YW55IG90aGVyLCB0cmlnZ2VyaW5nIHRoZSBzZWNvbmQgd2hlbmV2ZXIgdGhlIGZpcnN0IGlzIGNhbGxlZC4gTWFueVxuXHRcdC8vXHRcdGxpc3RlbmVycyBtYXkgYmUgYXR0YWNoZWQgdG8gYSBmdW5jdGlvbiwgYW5kIHNvdXJjZSBmdW5jdGlvbnMgbWF5XG5cdFx0Ly9cdFx0YmUgZWl0aGVyIHJlZ3VsYXIgZnVuY3Rpb24gY2FsbHMgb3IgRE9NIGV2ZW50cy5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdENvbm5lY3RzIGxpc3RlbmVycyB0byBhY3Rpb25zLCBzbyB0aGF0IGFmdGVyIGV2ZW50IGZpcmVzLCBhXG5cdFx0Ly9cdFx0bGlzdGVuZXIgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWxcblx0XHQvL1x0XHRmdW5jdGlvbi5cblx0XHQvL1xuXHRcdC8vXHRcdFNpbmNlIGBkb2pvLmNvbm5lY3RgIGFsbG93cyB0aGUgc291cmNlIG9mIGV2ZW50cyB0byBiZSBlaXRoZXIgYVxuXHRcdC8vXHRcdFwicmVndWxhclwiIEphdmFTY3JpcHQgZnVuY3Rpb24gb3IgYSBET00gZXZlbnQsIGl0IHByb3ZpZGVzIGEgdW5pZm9ybVxuXHRcdC8vXHRcdGludGVyZmFjZSBmb3IgbGlzdGVuaW5nIHRvIGFsbCB0aGUgdHlwZXMgb2YgZXZlbnRzIHRoYXQgYW5cblx0XHQvL1x0XHRhcHBsaWNhdGlvbiBpcyBsaWtlbHkgdG8gZGVhbCB3aXRoIHRob3VnaCBhIHNpbmdsZSwgdW5pZmllZFxuXHRcdC8vXHRcdGludGVyZmFjZS4gRE9NIHByb2dyYW1tZXJzIG1heSB3YW50IHRvIHRoaW5rIG9mIGl0IGFzXG5cdFx0Ly9cdFx0XCJhZGRFdmVudExpc3RlbmVyIGZvciBldmVyeXRoaW5nIGFuZCBhbnl0aGluZ1wiLlxuXHRcdC8vXG5cdFx0Ly9cdFx0V2hlbiBzZXR0aW5nIHVwIGEgY29ubmVjdGlvbiwgdGhlIGBldmVudGAgcGFyYW1ldGVyIG11c3QgYmUgYVxuXHRcdC8vXHRcdHN0cmluZyB0aGF0IGlzIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QvZXZlbnQgdG8gYmUgbGlzdGVuZWQgZm9yLiBJZlxuXHRcdC8vXHRcdGBvYmpgIGlzIG51bGwsIGBrZXJuZWwuZ2xvYmFsYCBpcyBhc3N1bWVkLCBtZWFuaW5nIHRoYXQgY29ubmVjdGlvbnNcblx0XHQvL1x0XHR0byBnbG9iYWwgbWV0aG9kcyBhcmUgc3VwcG9ydGVkIGJ1dCBhbHNvIHRoYXQgeW91IG1heSBpbmFkdmVydGVudGx5XG5cdFx0Ly9cdFx0Y29ubmVjdCB0byBhIGdsb2JhbCBieSBwYXNzaW5nIGFuIGluY29ycmVjdCBvYmplY3QgbmFtZSBvciBpbnZhbGlkXG5cdFx0Ly9cdFx0cmVmZXJlbmNlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0YGRvam8uY29ubmVjdGAgZ2VuZXJhbGx5IGlzIGZvcmdpdmluZy4gSWYgeW91IHBhc3MgdGhlIG5hbWUgb2YgYVxuXHRcdC8vXHRcdGZ1bmN0aW9uIG9yIG1ldGhvZCB0aGF0IGRvZXMgbm90IHlldCBleGlzdCBvbiBgb2JqYCwgY29ubmVjdCB3aWxsXG5cdFx0Ly9cdFx0bm90IGZhaWwsIGJ1dCB3aWxsIGluc3RlYWQgc2V0IHVwIGEgc3R1YiBtZXRob2QuIFNpbWlsYXJseSwgbnVsbFxuXHRcdC8vXHRcdGFyZ3VtZW50cyBtYXkgc2ltcGx5IGJlIG9taXR0ZWQgc3VjaCB0aGF0IGZld2VyIHRoYW4gNCBhcmd1bWVudHNcblx0XHQvL1x0XHRtYXkgYmUgcmVxdWlyZWQgdG8gc2V0IHVwIGEgY29ubmVjdGlvbiBTZWUgdGhlIGV4YW1wbGVzIGZvciBkZXRhaWxzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhlIHJldHVybiB2YWx1ZSBpcyBhIGhhbmRsZSB0aGF0IGlzIG5lZWRlZCB0b1xuXHRcdC8vXHRcdHJlbW92ZSB0aGlzIGNvbm5lY3Rpb24gd2l0aCBgZG9qby5kaXNjb25uZWN0YC5cblx0XHQvL1xuXHRcdC8vIG9iajogT2JqZWN0P1xuXHRcdC8vXHRcdFRoZSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgZXZlbnQgZnVuY3Rpb24uXG5cdFx0Ly9cdFx0RGVmYXVsdHMgdG8gYGtlcm5lbC5nbG9iYWxgIGlmIG51bGwuXG5cdFx0Ly9cdFx0SWYgb2JqIGlzIGEgRE9NIG5vZGUsIHRoZSBjb25uZWN0aW9uIGlzIGRlbGVnYXRlZFxuXHRcdC8vXHRcdHRvIHRoZSBET00gZXZlbnQgbWFuYWdlciAodW5sZXNzIGRvbnRGaXggaXMgdHJ1ZSkuXG5cdFx0Ly9cblx0XHQvLyBldmVudDogU3RyaW5nXG5cdFx0Ly9cdFx0U3RyaW5nIG5hbWUgb2YgdGhlIGV2ZW50IGZ1bmN0aW9uIGluIG9iai5cblx0XHQvL1x0XHRJLmUuIGlkZW50aWZpZXMgYSBwcm9wZXJ0eSBgb2JqW2V2ZW50XWAuXG5cdFx0Ly9cblx0XHQvLyBjb250ZXh0OiBPYmplY3R8bnVsbFxuXHRcdC8vXHRcdFRoZSBvYmplY3QgdGhhdCBtZXRob2Qgd2lsbCByZWNlaXZlIGFzIFwidGhpc1wiLlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgY29udGV4dCBpcyBudWxsIGFuZCBtZXRob2QgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2Rcblx0XHQvL1x0XHRpbmhlcml0cyB0aGUgY29udGV4dCBvZiBldmVudC5cblx0XHQvL1xuXHRcdC8vXHRcdElmIG1ldGhvZCBpcyBhIHN0cmluZyB0aGVuIGNvbnRleHQgbXVzdCBiZSB0aGUgc291cmNlXG5cdFx0Ly9cdFx0b2JqZWN0IG9iamVjdCBmb3IgbWV0aG9kIChjb250ZXh0W21ldGhvZF0pLiBJZiBjb250ZXh0IGlzIG51bGwsXG5cdFx0Ly9cdFx0a2VybmVsLmdsb2JhbCBpcyB1c2VkLlxuXHRcdC8vXG5cdFx0Ly8gbWV0aG9kOiBTdHJpbmd8RnVuY3Rpb25cblx0XHQvL1x0XHRBIGZ1bmN0aW9uIHJlZmVyZW5jZSwgb3IgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIGNvbnRleHQuXG5cdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIGlkZW50aWZpZWQgYnkgbWV0aG9kIGZpcmVzIGFmdGVyIGV2ZW50IGRvZXMuXG5cdFx0Ly9cdFx0bWV0aG9kIHJlY2VpdmVzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgZXZlbnQuXG5cdFx0Ly9cdFx0U2VlIGNvbnRleHQgYXJndW1lbnQgY29tbWVudHMgZm9yIGluZm9ybWF0aW9uIG9uIG1ldGhvZCdzIHNjb3BlLlxuXHRcdC8vXG5cdFx0Ly8gZG9udEZpeDogQm9vbGVhbj9cblx0XHQvL1x0XHRJZiBvYmogaXMgYSBET00gbm9kZSwgc2V0IGRvbnRGaXggdG8gdHJ1ZSB0byBwcmV2ZW50IGRlbGVnYXRpb25cblx0XHQvL1x0XHRvZiB0aGlzIGNvbm5lY3Rpb24gdG8gdGhlIERPTSBldmVudCBtYW5hZ2VyLlxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXaGVuIG9iai5vbmNoYW5nZSgpLCBkbyB1aS51cGRhdGUoKTpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG9iaiwgXCJvbmNoYW5nZVwiLCB1aSwgXCJ1cGRhdGVcIik7XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYmosIFwib25jaGFuZ2VcIiwgdWksIHVpLnVwZGF0ZSk7IC8vIHNhbWVcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VXNpbmcgcmV0dXJuIHZhbHVlIGZvciBkaXNjb25uZWN0OlxuXHRcdC8vXHR8XHR2YXIgbGluayA9IGRvam8uY29ubmVjdChvYmosIFwib25jaGFuZ2VcIiwgdWksIFwidXBkYXRlXCIpO1xuXHRcdC8vXHR8XHQuLi5cblx0XHQvL1x0fFx0ZG9qby5kaXNjb25uZWN0KGxpbmspO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXaGVuIG9uZ2xvYmFsZXZlbnQgZXhlY3V0ZXMsIHdhdGNoZXIuaGFuZGxlciBpcyBpbnZva2VkOlxuXHRcdC8vXHR8XHRkb2pvLmNvbm5lY3QobnVsbCwgXCJvbmdsb2JhbGV2ZW50XCIsIHdhdGNoZXIsIFwiaGFuZGxlclwiKTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0V2hlbiBvYi5vbkN1c3RvbUV2ZW50IGV4ZWN1dGVzLCBjdXN0b21FdmVudEhhbmRsZXIgaXMgaW52b2tlZDpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG9iLCBcIm9uQ3VzdG9tRXZlbnRcIiwgbnVsbCwgXCJjdXN0b21FdmVudEhhbmRsZXJcIik7XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChvYiwgXCJvbkN1c3RvbUV2ZW50XCIsIFwiY3VzdG9tRXZlbnRIYW5kbGVyXCIpOyAvLyBzYW1lXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFdoZW4gb2Iub25DdXN0b21FdmVudCBleGVjdXRlcywgY3VzdG9tRXZlbnRIYW5kbGVyIGlzIGludm9rZWRcblx0XHQvL1x0XHR3aXRoIHRoZSBzYW1lIHNjb3BlICh0aGlzKTpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG9iLCBcIm9uQ3VzdG9tRXZlbnRcIiwgbnVsbCwgY3VzdG9tRXZlbnRIYW5kbGVyKTtcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG9iLCBcIm9uQ3VzdG9tRXZlbnRcIiwgY3VzdG9tRXZlbnRIYW5kbGVyKTsgLy8gc2FtZVxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXaGVuIGdsb2JhbEV2ZW50IGV4ZWN1dGVzLCBnbG9iYWxIYW5kbGVyIGlzIGludm9rZWRcblx0XHQvL1x0XHR3aXRoIHRoZSBzYW1lIHNjb3BlICh0aGlzKTpcblx0XHQvL1x0fFx0ZG9qby5jb25uZWN0KG51bGwsIFwiZ2xvYmFsRXZlbnRcIiwgbnVsbCwgZ2xvYmFsSGFuZGxlcik7XG5cdFx0Ly9cdHxcdGRvam8uY29ubmVjdChcImdsb2JhbEV2ZW50XCIsIGdsb2JhbEhhbmRsZXIpOyAvLyBzYW1lXG5cblx0XHQvLyBub3JtYWxpemUgYXJndW1lbnRzXG5cdFx0dmFyIGE9YXJndW1lbnRzLCBhcmdzPVtdLCBpPTA7XG5cdFx0Ly8gaWYgYVswXSBpcyBhIFN0cmluZywgb2JqIHdhcyBvbWl0dGVkXG5cdFx0YXJncy5wdXNoKHR5cGVvZiBhWzBdID09IFwic3RyaW5nXCIgPyBudWxsIDogYVtpKytdLCBhW2krK10pO1xuXHRcdC8vIGlmIHRoZSBhcmctYWZ0ZXItbmV4dCBpcyBhIFN0cmluZyBvciBGdW5jdGlvbiwgY29udGV4dCB3YXMgTk9UIG9taXR0ZWRcblx0XHR2YXIgYTEgPSBhW2krMV07XG5cdFx0YXJncy5wdXNoKHR5cGVvZiBhMSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBhMSA9PSBcImZ1bmN0aW9uXCIgPyBhW2krK10gOiBudWxsLCBhW2krK10pO1xuXHRcdC8vIGFic29yYiBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcblx0XHRmb3IodmFyIGw9YS5sZW5ndGg7IGk8bDsgaSsrKXtcdGFyZ3MucHVzaChhW2ldKTsgfVxuXHRcdHJldHVybiBjb25uZWN0Xy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSxcblxuXHRkaXNjb25uZWN0OmZ1bmN0aW9uKGhhbmRsZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZW1vdmUgYSBsaW5rIGNyZWF0ZWQgYnkgZG9qby5jb25uZWN0LlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFJlbW92ZXMgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBldmVudCBhbmQgdGhlIG1ldGhvZCByZWZlcmVuY2VkIGJ5IGhhbmRsZS5cblx0XHQvLyBoYW5kbGU6IEhhbmRsZVxuXHRcdC8vXHRcdHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGRvam8uY29ubmVjdCBjYWxsIHRoYXQgY3JlYXRlZCB0aGUgY29ubmVjdGlvbi5cblxuXHRcdGlmKGhhbmRsZSl7XG5cdFx0XHRoYW5kbGUucmVtb3ZlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN1YnNjcmliZTpmdW5jdGlvbih0b3BpYywgY29udGV4dCwgbWV0aG9kKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEF0dGFjaCBhIGxpc3RlbmVyIHRvIGEgbmFtZWQgdG9waWMuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBpcyBpbnZva2VkIHdoZW5ldmVyIHRoZVxuXHRcdC8vXHRcdG5hbWVkIHRvcGljIGlzIHB1Ymxpc2hlZCAoc2VlOiBkb2pvLnB1Ymxpc2gpLlxuXHRcdC8vXHRcdFJldHVybnMgYSBoYW5kbGUgd2hpY2ggaXMgbmVlZGVkIHRvIHVuc3Vic2NyaWJlIHRoaXMgbGlzdGVuZXIuXG5cdFx0Ly8gdG9waWM6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSB0b3BpYyB0byB3aGljaCB0byBzdWJzY3JpYmUuXG5cdFx0Ly8gY29udGV4dDogT2JqZWN0P1xuXHRcdC8vXHRcdFNjb3BlIGluIHdoaWNoIG1ldGhvZCB3aWxsIGJlIGludm9rZWQsIG9yIG51bGwgZm9yIGRlZmF1bHQgc2NvcGUuXG5cdFx0Ly8gbWV0aG9kOiBTdHJpbmd8RnVuY3Rpb25cblx0XHQvL1x0XHRUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIGNvbnRleHQsIG9yIGEgZnVuY3Rpb24gcmVmZXJlbmNlLiBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0XG5cdFx0Ly9cdFx0aXMgaW52b2tlZCB3aGVuIHRvcGljIGlzIHB1Ymxpc2hlZC5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRkb2pvLnN1YnNjcmliZShcImFsZXJ0c1wiLCBudWxsLCBmdW5jdGlvbihjYXB0aW9uLCBtZXNzYWdlKXsgYWxlcnQoY2FwdGlvbiArIFwiXFxuXCIgKyBtZXNzYWdlKTsgfSk7XG5cdFx0Ly9cdHxcdGRvam8ucHVibGlzaChcImFsZXJ0c1wiLCBbIFwicmVhZCB0aGlzXCIsIFwiaGVsbG8gd29ybGRcIiBdKTtcblx0XHRyZXR1cm4gaHViLnN1YnNjcmliZSh0b3BpYywgbGFuZy5oaXRjaChjb250ZXh0LCBtZXRob2QpKTtcblx0fSxcblxuXHRwdWJsaXNoOmZ1bmN0aW9uKHRvcGljLCBhcmdzKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEludm9rZSBhbGwgbGlzdGVuZXIgbWV0aG9kIHN1YnNjcmliZWQgdG8gdG9waWMuXG5cdFx0Ly8gdG9waWM6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSBuYW1lIG9mIHRoZSB0b3BpYyB0byBwdWJsaXNoLlxuXHRcdC8vIGFyZ3M6IEFycmF5P1xuXHRcdC8vXHRcdEFuIGFycmF5IG9mIGFyZ3VtZW50cy4gVGhlIGFyZ3VtZW50cyB3aWxsIGJlIGFwcGxpZWRcblx0XHQvL1x0XHR0byBlYWNoIHRvcGljIHN1YnNjcmliZXIgKGFzIGZpcnN0IGNsYXNzIHBhcmFtZXRlcnMsIHZpYSBhcHBseSkuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0ZG9qby5zdWJzY3JpYmUoXCJhbGVydHNcIiwgbnVsbCwgZnVuY3Rpb24oY2FwdGlvbiwgbWVzc2FnZSl7IGFsZXJ0KGNhcHRpb24gKyBcIlxcblwiICsgbWVzc2FnZSk7IH07XG5cdFx0Ly9cdHxcdGRvam8ucHVibGlzaChcImFsZXJ0c1wiLCBbIFwicmVhZCB0aGlzXCIsIFwiaGVsbG8gd29ybGRcIiBdKTtcblx0XHRyZXR1cm4gaHViLnB1Ymxpc2guYXBwbHkoaHViLCBbdG9waWNdLmNvbmNhdChhcmdzKSk7XG5cdH0sXG5cblx0Y29ubmVjdFB1Ymxpc2hlcjpmdW5jdGlvbih0b3BpYywgb2JqLCBldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRFbnN1cmUgdGhhdCBldmVyeSB0aW1lIG9iai5ldmVudCgpIGlzIGNhbGxlZCwgYSBtZXNzYWdlIGlzIHB1Ymxpc2hlZFxuXHRcdC8vXHRcdG9uIHRoZSB0b3BpYy4gUmV0dXJucyBhIGhhbmRsZSB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG5cdFx0Ly9cdFx0ZG9qby5kaXNjb25uZWN0KCkgdG8gZGlzYWJsZSBzdWJzZXF1ZW50IGF1dG9tYXRpYyBwdWJsaWNhdGlvbiBvblxuXHRcdC8vXHRcdHRoZSB0b3BpYy5cblx0XHQvLyB0b3BpYzogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIG5hbWUgb2YgdGhlIHRvcGljIHRvIHB1Ymxpc2guXG5cdFx0Ly8gb2JqOiBPYmplY3Q/XG5cdFx0Ly9cdFx0VGhlIHNvdXJjZSBvYmplY3QgZm9yIHRoZSBldmVudCBmdW5jdGlvbi4gRGVmYXVsdHMgdG8ga2VybmVsLmdsb2JhbFxuXHRcdC8vXHRcdGlmIG51bGwuXG5cdFx0Ly8gZXZlbnQ6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSBuYW1lIG9mIHRoZSBldmVudCBmdW5jdGlvbiBpbiBvYmouXG5cdFx0Ly9cdFx0SS5lLiBpZGVudGlmaWVzIGEgcHJvcGVydHkgb2JqW2V2ZW50XS5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRkb2pvLmNvbm5lY3RQdWJsaXNoZXIoXCIvYWpheC9zdGFydFwiLCBkb2pvLCBcInhockdldFwiKTtcblx0XHR2YXIgcGYgPSBmdW5jdGlvbigpeyBjb25uZWN0LnB1Ymxpc2godG9waWMsIGFyZ3VtZW50cyk7IH07XG5cdFx0cmV0dXJuIGV2ZW50ID8gY29ubmVjdC5jb25uZWN0KG9iaiwgZXZlbnQsIHBmKSA6IGNvbm5lY3QuY29ubmVjdChvYmosIHBmKTsgLy9IYW5kbGVcblx0fSxcblxuXHRpc0NvcHlLZXk6IGZ1bmN0aW9uKGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q2hlY2tzIGFuIGV2ZW50IGZvciB0aGUgY29weSBrZXkgKG1ldGEgb24gTWFjLCBhbmQgY3RybCBhbnl3aGVyZSBlbHNlKVxuXHRcdC8vIGU6IEV2ZW50XG5cdFx0Ly9cdFx0RXZlbnQgb2JqZWN0IHRvIGV4YW1pbmVcblx0XHRyZXR1cm4gZVtldnRDb3B5S2V5XTtcdC8vIEJvb2xlYW5cblx0fVxufTtcblxuY29ubmVjdC51bnN1YnNjcmliZSA9IGNvbm5lY3QuZGlzY29ubmVjdDtcbi8qPT09PT1cbiBjb25uZWN0LnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oaGFuZGxlKXtcblx0IC8vIHN1bW1hcnk6XG5cdCAvL1x0XHRSZW1vdmUgYSB0b3BpYyBsaXN0ZW5lci5cblx0IC8vIGhhbmRsZTogSGFuZGxlXG5cdCAvL1x0XHRUaGUgaGFuZGxlIHJldHVybmVkIGZyb20gYSBjYWxsIHRvIHN1YnNjcmliZS5cblx0IC8vIGV4YW1wbGU6XG5cdCAvL1x0fFx0dmFyIGFsZXJ0ZXIgPSBkb2pvLnN1YnNjcmliZShcImFsZXJ0c1wiLCBudWxsLCBmdW5jdGlvbihjYXB0aW9uLCBtZXNzYWdlKXsgYWxlcnQoY2FwdGlvbiArIFwiXFxuXCIgKyBtZXNzYWdlKTsgfTtcblx0IC8vXHR8XHQuLi5cblx0IC8vXHR8XHRkb2pvLnVuc3Vic2NyaWJlKGFsZXJ0ZXIpO1xuIH07XG4gPT09PT0qL1xuXG5oYXMoXCJleHRlbmQtZG9qb1wiKSAmJiBsYW5nLm1peGluKGRvam8sIGNvbm5lY3QpO1xucmV0dXJuIGNvbm5lY3Q7XG5cbn0pO1xuXG5cbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4uL2hhc1wiLCBcIi4vbGFuZ1wiXSwgZnVuY3Rpb24oZG9qbywgaGFzLCBsYW5nKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL19iYXNlL2RlY2xhcmVcblxuXHR2YXIgbWl4ID0gbGFuZy5taXhpbiwgb3AgPSBPYmplY3QucHJvdG90eXBlLCBvcHRzID0gb3AudG9TdHJpbmcsXG5cdFx0eHRvciwgY291bnRlciA9IDAsIGNuYW1lID0gXCJjb25zdHJ1Y3RvclwiO1xuXG5cdGlmKCFoYXMoXCJjc3AtcmVzdHJpY3Rpb25zXCIpKXtcblx0XHQvLyAnbmV3IEZ1bmN0aW9uKCknIGlzIHByZWZlcmFibGUgd2hlbiBhdmFpbGFibGUgc2luY2UgaXQgZG9lcyBub3QgY3JlYXRlIGEgY2xvc3VyZVxuXHRcdHh0b3IgPSBuZXcgRnVuY3Rpb247XG5cdH1lbHNle1xuXHRcdHh0b3IgPSBmdW5jdGlvbigpe307XG5cdH1cblxuXHRmdW5jdGlvbiBlcnIobXNnLCBjbHMpeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWNsYXJlXCIgKyAoY2xzID8gXCIgXCIgKyBjbHMgOiBcIlwiKSArIFwiOiBcIiArIG1zZyk7IH1cblxuXHQvLyBDMyBNZXRob2QgUmVzb2x1dGlvbiBPcmRlciAoc2VlIGh0dHA6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZC9yZWxlYXNlcy8yLjMvbXJvLylcblx0ZnVuY3Rpb24gYzNtcm8oYmFzZXMsIGNsYXNzTmFtZSl7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLCByb290cyA9IFt7Y2xzOiAwLCByZWZzOiBbXX1dLCBuYW1lTWFwID0ge30sIGNsc0NvdW50ID0gMSxcblx0XHRcdGwgPSBiYXNlcy5sZW5ndGgsIGkgPSAwLCBqLCBsaW4sIGJhc2UsIHRvcCwgcHJvdG8sIHJlYywgbmFtZSwgcmVmcztcblxuXHRcdC8vIGJ1aWxkIGEgbGlzdCBvZiBiYXNlcyBuYW1pbmcgdGhlbSBpZiBuZWVkZWRcblx0XHRmb3IoOyBpIDwgbDsgKytpKXtcblx0XHRcdGJhc2UgPSBiYXNlc1tpXTtcblx0XHRcdGlmKCFiYXNlKXtcblx0XHRcdFx0ZXJyKFwibWl4aW4gI1wiICsgaSArIFwiIGlzIHVua25vd24uIERpZCB5b3UgdXNlIGRvam8ucmVxdWlyZSB0byBwdWxsIGl0IGluP1wiLCBjbGFzc05hbWUpO1xuXHRcdFx0fWVsc2UgaWYob3B0cy5jYWxsKGJhc2UpICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIil7XG5cdFx0XHRcdGVycihcIm1peGluICNcIiArIGkgKyBcIiBpcyBub3QgYSBjYWxsYWJsZSBjb25zdHJ1Y3Rvci5cIiwgY2xhc3NOYW1lKTtcblx0XHRcdH1cblx0XHRcdGxpbiA9IGJhc2UuX21ldGEgPyBiYXNlLl9tZXRhLmJhc2VzIDogW2Jhc2VdO1xuXHRcdFx0dG9wID0gMDtcblx0XHRcdC8vIGFkZCBiYXNlcyB0byB0aGUgbmFtZSBtYXBcblx0XHRcdGZvcihqID0gbGluLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKXtcblx0XHRcdFx0cHJvdG8gPSBsaW5bal0ucHJvdG90eXBlO1xuXHRcdFx0XHRpZighcHJvdG8uaGFzT3duUHJvcGVydHkoXCJkZWNsYXJlZENsYXNzXCIpKXtcblx0XHRcdFx0XHRwcm90by5kZWNsYXJlZENsYXNzID0gXCJ1bmlxTmFtZV9cIiArIChjb3VudGVyKyspO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5hbWUgPSBwcm90by5kZWNsYXJlZENsYXNzO1xuXHRcdFx0XHRpZighbmFtZU1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7XG5cdFx0XHRcdFx0bmFtZU1hcFtuYW1lXSA9IHtjb3VudDogMCwgcmVmczogW10sIGNsczogbGluW2pdfTtcblx0XHRcdFx0XHQrK2Nsc0NvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlYyA9IG5hbWVNYXBbbmFtZV07XG5cdFx0XHRcdGlmKHRvcCAmJiB0b3AgIT09IHJlYyl7XG5cdFx0XHRcdFx0cmVjLnJlZnMucHVzaCh0b3ApO1xuXHRcdFx0XHRcdCsrdG9wLmNvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvcCA9IHJlYztcblx0XHRcdH1cblx0XHRcdCsrdG9wLmNvdW50O1xuXHRcdFx0cm9vdHNbMF0ucmVmcy5wdXNoKHRvcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGNsYXNzZXMgd2l0aG91dCBleHRlcm5hbCByZWZlcmVuY2VzIHJlY3Vyc2l2ZWx5XG5cdFx0d2hpbGUocm9vdHMubGVuZ3RoKXtcblx0XHRcdHRvcCA9IHJvb3RzLnBvcCgpO1xuXHRcdFx0cmVzdWx0LnB1c2godG9wLmNscyk7XG5cdFx0XHQtLWNsc0NvdW50O1xuXHRcdFx0Ly8gb3B0aW1pemF0aW9uOiBmb2xsb3cgYSBzaW5nbGUtbGlua2VkIGNoYWluXG5cdFx0XHR3aGlsZShyZWZzID0gdG9wLnJlZnMsIHJlZnMubGVuZ3RoID09IDEpe1xuXHRcdFx0XHR0b3AgPSByZWZzWzBdO1xuXHRcdFx0XHRpZighdG9wIHx8IC0tdG9wLmNvdW50KXtcblx0XHRcdFx0XHQvLyBicmFuY2ggb3IgZW5kIG9mIGNoYWluID0+IGRvIG5vdCBlbmQgdG8gcm9vdHNcblx0XHRcdFx0XHR0b3AgPSAwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHRvcC5jbHMpO1xuXHRcdFx0XHQtLWNsc0NvdW50O1xuXHRcdFx0fVxuXHRcdFx0aWYodG9wKXtcblx0XHRcdFx0Ly8gYnJhbmNoXG5cdFx0XHRcdGZvcihpID0gMCwgbCA9IHJlZnMubGVuZ3RoOyBpIDwgbDsgKytpKXtcblx0XHRcdFx0XHR0b3AgPSByZWZzW2ldO1xuXHRcdFx0XHRcdGlmKCEtLXRvcC5jb3VudCl7XG5cdFx0XHRcdFx0XHRyb290cy5wdXNoKHRvcCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGNsc0NvdW50KXtcblx0XHRcdGVycihcImNhbid0IGJ1aWxkIGNvbnNpc3RlbnQgbGluZWFyaXphdGlvblwiLCBjbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgc3VwZXJjbGFzcyBvZmZzZXRcblx0XHRiYXNlID0gYmFzZXNbMF07XG5cdFx0cmVzdWx0WzBdID0gYmFzZSA/XG5cdFx0XHRiYXNlLl9tZXRhICYmIGJhc2UgPT09IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gYmFzZS5fbWV0YS5iYXNlcy5sZW5ndGhdID9cblx0XHRcdFx0YmFzZS5fbWV0YS5iYXNlcy5sZW5ndGggOiAxIDogMDtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmhlcml0ZWQoYXJncywgYSwgZiwgZyl7XG5cdFx0dmFyIG5hbWUsIGNoYWlucywgYmFzZXMsIGNhbGxlciwgbWV0YSwgYmFzZSwgcHJvdG8sIG9wZiwgcG9zLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLl9pbmhlcml0ZWQgPSB0aGlzLl9pbmhlcml0ZWQgfHwge307XG5cblx0XHQvLyBjcmFjayBhcmd1bWVudHNcblx0XHRpZih0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRuYW1lID0gYXJncztcblx0XHRcdGFyZ3MgPSBhO1xuXHRcdFx0YSA9IGY7XG5cdFx0XHRmID0gZztcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgYXJncyA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdC8vIHN1cHBvcnQgc3RyaWN0IG1vZGVcblx0XHRcdGNhbGxlciA9IGFyZ3M7XG5cdFx0XHRhcmdzID0gYTtcblx0XHRcdGEgPSBmO1xuXHRcdH1lbHNle1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRjYWxsZXIgPSBhcmdzLmNhbGxlZTtcblx0XHRcdH1jYXRjaCAoZSl7XG5cdFx0XHRcdGlmKGUgaW5zdGFuY2VvZiBUeXBlRXJyb3Ipe1xuXHRcdFx0XHRcdC8vIGNhbGxlciB3YXMgZGVmaW5lZCBpbiBhIHN0cmljdC1tb2RlIGNvbnRleHRcblx0XHRcdFx0XHRlcnIoXCJzdHJpY3QgbW9kZSBpbmhlcml0ZWQoKSByZXF1aXJlcyB0aGUgY2FsbGVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCBiZWZvcmUgYXJndW1lbnRzXCIsIHRoaXMuZGVjbGFyZWRDbGFzcyk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRuYW1lID0gbmFtZSB8fCBjYWxsZXIubm9tO1xuXHRcdGlmKCFuYW1lKXtcblx0XHRcdGVycihcImNhbid0IGRlZHVjZSBhIG5hbWUgdG8gY2FsbCBpbmhlcml0ZWQoKVwiLCB0aGlzLmRlY2xhcmVkQ2xhc3MpO1xuXHRcdH1cblx0XHRmID0gZyA9IDA7XG5cblx0XHRtZXRhID0gdGhpcy5jb25zdHJ1Y3Rvci5fbWV0YTtcblx0XHRiYXNlcyA9IG1ldGEuYmFzZXM7XG5cblx0XHRwb3MgPSBjYWNoZS5wO1xuXHRcdGlmKG5hbWUgIT0gY25hbWUpe1xuXHRcdFx0Ly8gbWV0aG9kXG5cdFx0XHRpZihjYWNoZS5jICE9PSBjYWxsZXIpe1xuXHRcdFx0XHQvLyBjYWNoZSBidXN0XG5cdFx0XHRcdHBvcyA9IDA7XG5cdFx0XHRcdGJhc2UgPSBiYXNlc1swXTtcblx0XHRcdFx0bWV0YSA9IGJhc2UuX21ldGE7XG5cdFx0XHRcdGlmKG1ldGEuaGlkZGVuW25hbWVdICE9PSBjYWxsZXIpe1xuXHRcdFx0XHRcdC8vIGVycm9yIGRldGVjdGlvblxuXHRcdFx0XHRcdGNoYWlucyA9IG1ldGEuY2hhaW5zO1xuXHRcdFx0XHRcdGlmKGNoYWlucyAmJiB0eXBlb2YgY2hhaW5zW25hbWVdID09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRcdFx0ZXJyKFwiY2FsbGluZyBjaGFpbmVkIG1ldGhvZCB3aXRoIGluaGVyaXRlZDogXCIgKyBuYW1lLCB0aGlzLmRlY2xhcmVkQ2xhc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBmaW5kIGNhbGxlclxuXHRcdFx0XHRcdGRve1xuXHRcdFx0XHRcdFx0bWV0YSA9IGJhc2UuX21ldGE7XG5cdFx0XHRcdFx0XHRwcm90byA9IGJhc2UucHJvdG90eXBlO1xuXHRcdFx0XHRcdFx0aWYobWV0YSAmJiAocHJvdG9bbmFtZV0gPT09IGNhbGxlciAmJiBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBtZXRhLmhpZGRlbltuYW1lXSA9PT0gY2FsbGVyKSl7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH13aGlsZShiYXNlID0gYmFzZXNbKytwb3NdKTsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHRcdHBvcyA9IGJhc2UgPyBwb3MgOiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBuZXh0XG5cdFx0XHRiYXNlID0gYmFzZXNbKytwb3NdO1xuXHRcdFx0aWYoYmFzZSl7XG5cdFx0XHRcdHByb3RvID0gYmFzZS5wcm90b3R5cGU7XG5cdFx0XHRcdGlmKGJhc2UuX21ldGEgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpe1xuXHRcdFx0XHRcdGYgPSBwcm90b1tuYW1lXTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0b3BmID0gb3BbbmFtZV07XG5cdFx0XHRcdFx0ZG97XG5cdFx0XHRcdFx0XHRwcm90byA9IGJhc2UucHJvdG90eXBlO1xuXHRcdFx0XHRcdFx0ZiA9IHByb3RvW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYoZiAmJiAoYmFzZS5fbWV0YSA/IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpIDogZiAhPT0gb3BmKSl7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH13aGlsZShiYXNlID0gYmFzZXNbKytwb3NdKTsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmID0gYmFzZSAmJiBmIHx8IG9wW25hbWVdO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gY29uc3RydWN0b3Jcblx0XHRcdGlmKGNhY2hlLmMgIT09IGNhbGxlcil7XG5cdFx0XHRcdC8vIGNhY2hlIGJ1c3Rcblx0XHRcdFx0cG9zID0gMDtcblx0XHRcdFx0bWV0YSA9IGJhc2VzWzBdLl9tZXRhO1xuXHRcdFx0XHRpZihtZXRhICYmIG1ldGEuY3RvciAhPT0gY2FsbGVyKXtcblx0XHRcdFx0XHQvLyBlcnJvciBkZXRlY3Rpb25cblx0XHRcdFx0XHRjaGFpbnMgPSBtZXRhLmNoYWlucztcblx0XHRcdFx0XHRpZighY2hhaW5zIHx8IGNoYWlucy5jb25zdHJ1Y3RvciAhPT0gXCJtYW51YWxcIil7XG5cdFx0XHRcdFx0XHRlcnIoXCJjYWxsaW5nIGNoYWluZWQgY29uc3RydWN0b3Igd2l0aCBpbmhlcml0ZWRcIiwgdGhpcy5kZWNsYXJlZENsYXNzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZmluZCBjYWxsZXJcblx0XHRcdFx0XHR3aGlsZShiYXNlID0gYmFzZXNbKytwb3NdKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHRcdFx0bWV0YSA9IGJhc2UuX21ldGE7XG5cdFx0XHRcdFx0XHRpZihtZXRhICYmIG1ldGEuY3RvciA9PT0gY2FsbGVyKXtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvcyA9IGJhc2UgPyBwb3MgOiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBuZXh0XG5cdFx0XHR3aGlsZShiYXNlID0gYmFzZXNbKytwb3NdKXtcdC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHRcdFx0bWV0YSA9IGJhc2UuX21ldGE7XG5cdFx0XHRcdGYgPSBtZXRhID8gbWV0YS5jdG9yIDogYmFzZTtcblx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGYgPSBiYXNlICYmIGY7XG5cdFx0fVxuXG5cdFx0Ly8gY2FjaGUgdGhlIGZvdW5kIHN1cGVyIG1ldGhvZFxuXHRcdGNhY2hlLmMgPSBmO1xuXHRcdGNhY2hlLnAgPSBwb3M7XG5cblx0XHQvLyBub3cgd2UgaGF2ZSB0aGUgcmVzdWx0XG5cdFx0aWYoZil7XG5cdFx0XHRyZXR1cm4gYSA9PT0gdHJ1ZSA/IGYgOiBmLmFwcGx5KHRoaXMsIGEgfHwgYXJncyk7XG5cdFx0fVxuXHRcdC8vIGludGVudGlvbmFsbHkgbm8gcmV0dXJuIGlmIGEgc3VwZXIgbWV0aG9kIHdhcyBub3QgZm91bmRcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEluaGVyaXRlZChuYW1lLCBhcmdzLCBhKXtcblx0XHRpZih0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX2luaGVyaXRlZChuYW1lLCBhcmdzLCBhLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9faW5oZXJpdGVkKG5hbWUsIGFyZ3MsIHRydWUpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fX2luaGVyaXRlZChuYW1lLCBhcmdzLCB0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX19pbmhlcml0ZWQobmFtZSwgdHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmhlcml0ZWRfX2RlYnVnKGFyZ3MsIGExLCBhMiwgYTMpe1xuXHRcdHZhciBmID0gdGhpcy5nZXRJbmhlcml0ZWQoYXJncywgYTEsIGEyKTtcblx0XHRpZihmKXtcblx0XHRcdHJldHVybiBmLmFwcGx5KHRoaXMsIGEzIHx8IGEyIHx8IGExIHx8IGFyZ3MpO1xuXHRcdH1cblx0XHQvLyBpbnRlbnRpb25hbGx5IG5vIHJldHVybiBpZiBhIHN1cGVyIG1ldGhvZCB3YXMgbm90IGZvdW5kXG5cdH1cblxuXHR2YXIgaW5oZXJpdGVkSW1wbCA9IGRvam8uY29uZmlnLmlzRGVidWcgPyBpbmhlcml0ZWRfX2RlYnVnIDogaW5oZXJpdGVkO1xuXG5cdC8vIGVtdWxhdGlvbiBvZiBcImluc3RhbmNlb2ZcIlxuXHRmdW5jdGlvbiBpc0luc3RhbmNlT2YoY2xzKXtcblx0XHR2YXIgYmFzZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9tZXRhLmJhc2VzO1xuXHRcdGZvcih2YXIgaSA9IDAsIGwgPSBiYXNlcy5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0aWYoYmFzZXNbaV0gPT09IGNscyl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGNscztcblx0fVxuXG5cdGZ1bmN0aW9uIG1peE93bih0YXJnZXQsIHNvdXJjZSl7XG5cdFx0Ly8gYWRkIHByb3BzIGFkZGluZyBtZXRhZGF0YSBmb3IgaW5jb21pbmcgZnVuY3Rpb25zIHNraXBwaW5nIGEgY29uc3RydWN0b3Jcblx0XHRmb3IodmFyIG5hbWUgaW4gc291cmNlKXtcblx0XHRcdGlmKG5hbWUgIT0gY25hbWUgJiYgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpKXtcblx0XHRcdFx0dGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihoYXMoXCJidWctZm9yLWluLXNraXBzLXNoYWRvd2VkXCIpKXtcblx0XHRcdGZvcih2YXIgZXh0cmFOYW1lcz0gbGFuZy5fZXh0cmFOYW1lcywgaT0gZXh0cmFOYW1lcy5sZW5ndGg7IGk7KXtcblx0XHRcdFx0bmFtZSA9IGV4dHJhTmFtZXNbLS1pXTtcblx0XHRcdFx0aWYobmFtZSAhPSBjbmFtZSAmJiBzb3VyY2UuaGFzT3duUHJvcGVydHkobmFtZSkpe1xuXHRcdFx0XHRcdCAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gaW1wbGVtZW50YXRpb24gb2Ygc2FmZSBtaXhpbiBmdW5jdGlvblxuXHRmdW5jdGlvbiBzYWZlTWl4aW4odGFyZ2V0LCBzb3VyY2Upe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0TWl4IGluIHByb3BlcnRpZXMgc2tpcHBpbmcgYSBjb25zdHJ1Y3RvciBhbmQgZGVjb3JhdGluZyBmdW5jdGlvbnNcblx0XHQvL1x0XHRsaWtlIGl0IGlzIGRvbmUgYnkgZGVjbGFyZSgpLlxuXHRcdC8vIHRhcmdldDogT2JqZWN0XG5cdFx0Ly9cdFx0VGFyZ2V0IG9iamVjdCB0byBhY2NlcHQgbmV3IHByb3BlcnRpZXMuXG5cdFx0Ly8gc291cmNlOiBPYmplY3Rcblx0XHQvL1x0XHRTb3VyY2Ugb2JqZWN0IGZvciBuZXcgcHJvcGVydGllcy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gbWl4IGluIHByb3BlcnRpZXMgbGlrZSBsYW5nLm1peGluIGRvZXMsXG5cdFx0Ly9cdFx0YnV0IGl0IHNraXBzIGEgY29uc3RydWN0b3IgcHJvcGVydHkgYW5kIGRlY29yYXRlcyBmdW5jdGlvbnMgbGlrZVxuXHRcdC8vXHRcdGRlY2xhcmUoKSBkb2VzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0SXQgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoIGNsYXNzZXMgYW5kIG9iamVjdHMgcHJvZHVjZWQgd2l0aFxuXHRcdC8vXHRcdGRlY2xhcmUuIEZ1bmN0aW9ucyBtaXhlZCBpbiB3aXRoIGRvam8uc2FmZU1peGluIGNhbiB1c2Vcblx0XHQvL1x0XHR0aGlzLmluaGVyaXRlZCgpIGxpa2Ugbm9ybWFsIG1ldGhvZHMuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gaW1wbGVtZW50IGV4dGVuZCgpIG1ldGhvZCBvZiBhIGNvbnN0cnVjdG9yXG5cdFx0Ly9cdFx0cHJvZHVjZWQgd2l0aCBkZWNsYXJlKCkuXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgQSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJBLm0xXCIpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0bTI6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkEubTJcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkIubTFcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0Qi5leHRlbmQoe1xuXHRcdC8vXHR8XHRcdG0yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0dGhpcy5pbmhlcml0ZWQoYXJndW1lbnRzKTtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQi5tMlwiKTtcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgeCA9IG5ldyBCKCk7XG5cdFx0Ly9cdHxcdGRvam8uc2FmZU1peGluKHgsIHtcblx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIlgubTFcIik7XG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHRtMjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIlgubTJcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0eC5tMigpO1xuXHRcdC8vXHR8XHQvLyBwcmludHM6XG5cdFx0Ly9cdHxcdC8vIEEubTFcblx0XHQvL1x0fFx0Ly8gQi5tMVxuXHRcdC8vXHR8XHQvLyBYLm0xXG5cblx0XHR2YXIgbmFtZSwgdDtcblx0XHQvLyBhZGQgcHJvcHMgYWRkaW5nIG1ldGFkYXRhIGZvciBpbmNvbWluZyBmdW5jdGlvbnMgc2tpcHBpbmcgYSBjb25zdHJ1Y3RvclxuXHRcdGZvcihuYW1lIGluIHNvdXJjZSl7XG5cdFx0XHR0ID0gc291cmNlW25hbWVdO1xuXHRcdFx0aWYoKHQgIT09IG9wW25hbWVdIHx8ICEobmFtZSBpbiBvcCkpICYmIG5hbWUgIT0gY25hbWUpe1xuXHRcdFx0XHRpZihvcHRzLmNhbGwodCkgPT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXtcblx0XHRcdFx0XHQvLyBub24tdHJpdmlhbCBmdW5jdGlvbiBtZXRob2QgPT4gYXR0YWNoIGl0cyBuYW1lXG5cdFx0XHRcdFx0dC5ub20gPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGhhcyhcImJ1Zy1mb3ItaW4tc2tpcHMtc2hhZG93ZWRcIikgJiYgc291cmNlKXtcblx0XHRcdGZvcih2YXIgZXh0cmFOYW1lcz0gbGFuZy5fZXh0cmFOYW1lcywgaT0gZXh0cmFOYW1lcy5sZW5ndGg7IGk7KXtcblx0XHRcdFx0bmFtZSA9IGV4dHJhTmFtZXNbLS1pXTtcblx0XHRcdFx0dCA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdFx0aWYoKHQgIT09IG9wW25hbWVdIHx8ICEobmFtZSBpbiBvcCkpICYmIG5hbWUgIT0gY25hbWUpe1xuXHRcdFx0XHRcdGlmKG9wdHMuY2FsbCh0KSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpe1xuXHRcdFx0XHRcdFx0Ly8gbm9uLXRyaXZpYWwgZnVuY3Rpb24gbWV0aG9kID0+IGF0dGFjaCBpdHMgbmFtZVxuXHRcdFx0XHRcdFx0ICB0Lm5vbSA9IG5hbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChzb3VyY2Upe1xuXHRcdGRlY2xhcmUuc2FmZU1peGluKHRoaXMucHJvdG90eXBlLCBzb3VyY2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlU3ViY2xhc3MobWl4aW5zLCBwcm9wcyl7XG5cdFx0Ly8gY3JhY2sgcGFyYW1ldGVyc1xuXHRcdGlmKCEobWl4aW5zIGluc3RhbmNlb2YgQXJyYXkgfHwgdHlwZW9mIG1peGlucyA9PT0gJ2Z1bmN0aW9uJykpe1xuXHRcdFx0cHJvcHMgPSBtaXhpbnM7XG5cdFx0XHRtaXhpbnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cHJvcHMgPSBwcm9wcyB8fCB7fTtcblx0XHRtaXhpbnMgPSBtaXhpbnMgfHwgW107XG5cblx0XHRyZXR1cm4gZGVjbGFyZShbdGhpc10uY29uY2F0KG1peGlucyksIHByb3BzKTtcblx0fVxuXG5cdC8vIGNoYWluZWQgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBsZWdhY3kgZGVjbGFyZSgpXG5cdGZ1bmN0aW9uIGNoYWluZWRDb25zdHJ1Y3RvcihiYXNlcywgY3RvclNwZWNpYWwpe1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHMsIGFyZ3MgPSBhLCBhMCA9IGFbMF0sIGYsIGksIG0sXG5cdFx0XHRcdGwgPSBiYXNlcy5sZW5ndGgsIHByZUFyZ3M7XG5cblx0XHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIGEuY2FsbGVlKSl7XG5cdFx0XHRcdC8vIG5vdCBjYWxsZWQgdmlhIG5ldywgc28gZm9yY2UgaXRcblx0XHRcdFx0cmV0dXJuIGFwcGx5TmV3KGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMuX2luaGVyaXRlZCA9IHt9O1xuXHRcdFx0Ly8gcGVyZm9ybSB0aGUgc2hhbWFuJ3Mgcml0dWFscyBvZiB0aGUgb3JpZ2luYWwgZGVjbGFyZSgpXG5cdFx0XHQvLyAxKSBjYWxsIHR3byB0eXBlcyBvZiB0aGUgcHJlYW1ibGVcblx0XHRcdGlmKGN0b3JTcGVjaWFsICYmIChhMCAmJiBhMC5wcmVhbWJsZSB8fCB0aGlzLnByZWFtYmxlKSl7XG5cdFx0XHRcdC8vIGZ1bGwgYmxvd24gcml0dWFsXG5cdFx0XHRcdHByZUFyZ3MgPSBuZXcgQXJyYXkoYmFzZXMubGVuZ3RoKTtcblx0XHRcdFx0Ly8gcHJlcGFyZSBwYXJhbWV0ZXJzXG5cdFx0XHRcdHByZUFyZ3NbMF0gPSBhO1xuXHRcdFx0XHRmb3IoaSA9IDA7Oyl7XG5cdFx0XHRcdFx0Ly8gcHJvY2VzcyB0aGUgcHJlYW1ibGUgb2YgdGhlIDFzdCBhcmd1bWVudFxuXHRcdFx0XHRcdGEwID0gYVswXTtcblx0XHRcdFx0XHRpZihhMCl7XG5cdFx0XHRcdFx0XHRmID0gYTAucHJlYW1ibGU7XG5cdFx0XHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRcdFx0YSA9IGYuYXBwbHkodGhpcywgYSkgfHwgYTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcHJvY2VzcyB0aGUgcHJlYW1ibGUgb2YgdGhpcyBjbGFzc1xuXHRcdFx0XHRcdGYgPSBiYXNlc1tpXS5wcm90b3R5cGU7XG5cdFx0XHRcdFx0ZiA9IGYuaGFzT3duUHJvcGVydHkoXCJwcmVhbWJsZVwiKSAmJiBmLnByZWFtYmxlO1xuXHRcdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdFx0YSA9IGYuYXBwbHkodGhpcywgYSkgfHwgYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gb25lIHBlY3VsaWFyaXR5IG9mIHRoZSBwcmVhbWJsZTpcblx0XHRcdFx0XHQvLyBpdCBpcyBjYWxsZWQgaWYgaXQgaXMgbm90IG5lZWRlZCxcblx0XHRcdFx0XHQvLyBlLmcuLCB0aGVyZSBpcyBubyBjb25zdHJ1Y3RvciB0byBjYWxsXG5cdFx0XHRcdFx0Ly8gbGV0J3Mgd2F0Y2ggZm9yIHRoZSBsYXN0IGNvbnN0cnVjdG9yXG5cdFx0XHRcdFx0Ly8gKHNlZSB0aWNrZXQgIzk3OTUpXG5cdFx0XHRcdFx0aWYoKytpID09IGwpe1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByZUFyZ3NbaV0gPSBhO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyAyKSBjYWxsIGFsbCBub24tdHJpdmlhbCBjb25zdHJ1Y3RvcnMgdXNpbmcgcHJlcGFyZWQgYXJndW1lbnRzXG5cdFx0XHRmb3IoaSA9IGwgLSAxOyBpID49IDA7IC0taSl7XG5cdFx0XHRcdGYgPSBiYXNlc1tpXTtcblx0XHRcdFx0bSA9IGYuX21ldGE7XG5cdFx0XHRcdGYgPSBtID8gbS5jdG9yIDogZjtcblx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0Zi5hcHBseSh0aGlzLCBwcmVBcmdzID8gcHJlQXJnc1tpXSA6IGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyAzKSBjb250aW51ZSB0aGUgb3JpZ2luYWwgcml0dWFsOiBjYWxsIHRoZSBwb3N0c2NyaXB0XG5cdFx0XHRmID0gdGhpcy5wb3N0c2NyaXB0O1xuXHRcdFx0aWYoZil7XG5cdFx0XHRcdGYuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cblx0Ly8gY2hhaW5lZCBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGxlZ2FjeSBkZWNsYXJlKClcblx0ZnVuY3Rpb24gc2luZ2xlQ29uc3RydWN0b3IoY3RvciwgY3RvclNwZWNpYWwpe1xuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHMsIHQgPSBhLCBhMCA9IGFbMF0sIGY7XG5cblx0XHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIGEuY2FsbGVlKSl7XG5cdFx0XHRcdC8vIG5vdCBjYWxsZWQgdmlhIG5ldywgc28gZm9yY2UgaXRcblx0XHRcdFx0cmV0dXJuIGFwcGx5TmV3KGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMuX2luaGVyaXRlZCA9IHt9O1xuXHRcdFx0Ly8gcGVyZm9ybSB0aGUgc2hhbWFuJ3Mgcml0dWFscyBvZiB0aGUgb3JpZ2luYWwgZGVjbGFyZSgpXG5cdFx0XHQvLyAxKSBjYWxsIHR3byB0eXBlcyBvZiB0aGUgcHJlYW1ibGVcblx0XHRcdGlmKGN0b3JTcGVjaWFsKXtcblx0XHRcdFx0Ly8gZnVsbCBibG93biByaXR1YWxcblx0XHRcdFx0aWYoYTApe1xuXHRcdFx0XHRcdC8vIHByb2Nlc3MgdGhlIHByZWFtYmxlIG9mIHRoZSAxc3QgYXJndW1lbnRcblx0XHRcdFx0XHRmID0gYTAucHJlYW1ibGU7XG5cdFx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0XHR0ID0gZi5hcHBseSh0aGlzLCB0KSB8fCB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmID0gdGhpcy5wcmVhbWJsZTtcblx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0Ly8gcHJvY2VzcyB0aGUgcHJlYW1ibGUgb2YgdGhpcyBjbGFzc1xuXHRcdFx0XHRcdGYuYXBwbHkodGhpcywgdCk7XG5cdFx0XHRcdFx0Ly8gb25lIHBlY3VsaWFyaXR5IG9mIHRoZSBwcmVhbWJsZTpcblx0XHRcdFx0XHQvLyBpdCBpcyBjYWxsZWQgZXZlbiBpZiBpdCBpcyBub3QgbmVlZGVkLFxuXHRcdFx0XHRcdC8vIGUuZy4sIHRoZXJlIGlzIG5vIGNvbnN0cnVjdG9yIHRvIGNhbGxcblx0XHRcdFx0XHQvLyBsZXQncyB3YXRjaCBmb3IgdGhlIGxhc3QgY29uc3RydWN0b3Jcblx0XHRcdFx0XHQvLyAoc2VlIHRpY2tldCAjOTc5NSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gMikgY2FsbCBhIGNvbnN0cnVjdG9yXG5cdFx0XHRpZihjdG9yKXtcblx0XHRcdFx0Y3Rvci5hcHBseSh0aGlzLCBhKTtcblx0XHRcdH1cblx0XHRcdC8vIDMpIGNvbnRpbnVlIHRoZSBvcmlnaW5hbCByaXR1YWw6IGNhbGwgdGhlIHBvc3RzY3JpcHRcblx0XHRcdGYgPSB0aGlzLnBvc3RzY3JpcHQ7XG5cdFx0XHRpZihmKXtcblx0XHRcdFx0Zi5hcHBseSh0aGlzLCBhKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gcGxhaW4gdmFuaWxsYSBjb25zdHJ1Y3RvciAoY2FuIHVzZSBpbmhlcml0ZWQoKSB0byBjYWxsIGl0cyBiYXNlIGNvbnN0cnVjdG9yKVxuXHRmdW5jdGlvbiBzaW1wbGVDb25zdHJ1Y3RvcihiYXNlcyl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgYSA9IGFyZ3VtZW50cywgaSA9IDAsIGYsIG07XG5cblx0XHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIGEuY2FsbGVlKSl7XG5cdFx0XHRcdC8vIG5vdCBjYWxsZWQgdmlhIG5ldywgc28gZm9yY2UgaXRcblx0XHRcdFx0cmV0dXJuIGFwcGx5TmV3KGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMuX2luaGVyaXRlZCA9IHt9O1xuXHRcdFx0Ly8gcGVyZm9ybSB0aGUgc2hhbWFuJ3Mgcml0dWFscyBvZiB0aGUgb3JpZ2luYWwgZGVjbGFyZSgpXG5cdFx0XHQvLyAxKSBkbyBub3QgY2FsbCB0aGUgcHJlYW1ibGVcblx0XHRcdC8vIDIpIGNhbGwgdGhlIHRvcCBjb25zdHJ1Y3RvciAoaXQgY2FuIHVzZSB0aGlzLmluaGVyaXRlZCgpKVxuXHRcdFx0Zm9yKDsgZiA9IGJhc2VzW2ldOyArK2kpeyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRcdG0gPSBmLl9tZXRhO1xuXHRcdFx0XHRmID0gbSA/IG0uY3RvciA6IGY7XG5cdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdGYuYXBwbHkodGhpcywgYSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIDMpIGNhbGwgdGhlIHBvc3RzY3JpcHRcblx0XHRcdGYgPSB0aGlzLnBvc3RzY3JpcHQ7XG5cdFx0XHRpZihmKXtcblx0XHRcdFx0Zi5hcHBseSh0aGlzLCBhKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hhaW4obmFtZSwgYmFzZXMsIHJldmVyc2VkKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBiLCBtLCBmLCBpID0gMCwgc3RlcCA9IDE7XG5cdFx0XHRpZihyZXZlcnNlZCl7XG5cdFx0XHRcdGkgPSBiYXNlcy5sZW5ndGggLSAxO1xuXHRcdFx0XHRzdGVwID0gLTE7XG5cdFx0XHR9XG5cdFx0XHRmb3IoOyBiID0gYmFzZXNbaV07IGkgKz0gc3RlcCl7IC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHRcdFx0bSA9IGIuX21ldGE7XG5cdFx0XHRcdGYgPSAobSA/IG0uaGlkZGVuIDogYi5wcm90b3R5cGUpW25hbWVdO1xuXHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gZm9yY2VOZXcoY3Rvcilcblx0Ly8gcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gY3Rvci5wcm90b3R5cGUgYnV0XG5cdC8vIHdpdGhvdXQgYWN0dWFsbHkgcnVubmluZyBjdG9yIG9uIHRoZSBvYmplY3QuXG5cdGZ1bmN0aW9uIGZvcmNlTmV3KGN0b3Ipe1xuXHRcdC8vIGNyZWF0ZSBvYmplY3Qgd2l0aCBjb3JyZWN0IHByb3RvdHlwZSB1c2luZyBhIGRvLW5vdGhpbmdcblx0XHQvLyBjb25zdHJ1Y3RvclxuXHRcdHh0b3IucHJvdG90eXBlID0gY3Rvci5wcm90b3R5cGU7XG5cdFx0dmFyIHQgPSBuZXcgeHRvcjtcblx0XHR4dG9yLnByb3RvdHlwZSA9IG51bGw7XHQvLyBjbGVhbiB1cFxuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0Ly8gYXBwbHlOZXcoYXJncylcblx0Ly8ganVzdCBsaWtlICduZXcgY3RvcigpJyBleGNlcHQgdGhhdCB0aGUgY29uc3RydWN0b3IgYW5kIGl0cyBhcmd1bWVudHMgY29tZVxuXHQvLyBmcm9tIGFyZ3MsIHdoaWNoIG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gYXJndW1lbnRzIG9iamVjdFxuXHRmdW5jdGlvbiBhcHBseU5ldyhhcmdzKXtcblx0XHQvLyBjcmVhdGUgYW4gb2JqZWN0IHdpdGggY3RvcidzIHByb3RvdHlwZSBidXQgd2l0aG91dFxuXHRcdC8vIGNhbGxpbmcgY3RvciBvbiBpdC5cblx0XHR2YXIgY3RvciA9IGFyZ3MuY2FsbGVlLCB0ID0gZm9yY2VOZXcoY3Rvcik7XG5cdFx0Ly8gZXhlY3V0ZSB0aGUgcmVhbCBjb25zdHJ1Y3RvciBvbiB0aGUgbmV3IG9iamVjdFxuXHRcdGN0b3IuYXBwbHkodCwgYXJncyk7XG5cdFx0cmV0dXJuIHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNsYXJlKGNsYXNzTmFtZSwgc3VwZXJjbGFzcywgcHJvcHMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q3JlYXRlIGEgZmVhdHVyZS1yaWNoIGNvbnN0cnVjdG9yIGZyb20gY29tcGFjdCBub3RhdGlvbi5cblx0XHQvLyBjbGFzc05hbWU6IFN0cmluZz9cblx0XHQvL1x0XHRUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgY29uc3RydWN0b3IgKGxvb3NlbHksIGEgXCJjbGFzc1wiKVxuXHRcdC8vXHRcdHN0b3JlZCBpbiB0aGUgXCJkZWNsYXJlZENsYXNzXCIgcHJvcGVydHkgaW4gdGhlIGNyZWF0ZWQgcHJvdG90eXBlLlxuXHRcdC8vXHRcdEl0IHdpbGwgYmUgdXNlZCBhcyBhIGdsb2JhbCBuYW1lIGZvciBhIGNyZWF0ZWQgY29uc3RydWN0b3IuXG5cdFx0Ly8gc3VwZXJjbGFzczogRnVuY3Rpb258RnVuY3Rpb25bXVxuXHRcdC8vXHRcdE1heSBiZSBudWxsLCBhIEZ1bmN0aW9uLCBvciBhbiBBcnJheSBvZiBGdW5jdGlvbnMuIFRoaXMgYXJndW1lbnRcblx0XHQvL1x0XHRzcGVjaWZpZXMgYSBsaXN0IG9mIGJhc2VzICh0aGUgbGVmdC1tb3N0IG9uZSBpcyB0aGUgbW9zdCBkZWVwZXN0XG5cdFx0Ly9cdFx0YmFzZSkuXG5cdFx0Ly8gcHJvcHM6IE9iamVjdFxuXHRcdC8vXHRcdEFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgdG8gdGhlIGNyZWF0ZWQgcHJvdG90eXBlLlxuXHRcdC8vXHRcdEFkZCBhbiBpbnN0YW5jZS1pbml0aWFsaXphdGlvbiBmdW5jdGlvbiBieSBtYWtpbmcgaXQgYSBwcm9wZXJ0eVxuXHRcdC8vXHRcdG5hbWVkIFwiY29uc3RydWN0b3JcIi5cblx0XHQvLyByZXR1cm5zOiBkb2pvL19iYXNlL2RlY2xhcmUuX19EZWNsYXJlQ3JlYXRlZE9iamVjdFxuXHRcdC8vXHRcdE5ldyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRDcmVhdGUgYSBjb25zdHJ1Y3RvciB1c2luZyBhIGNvbXBhY3Qgbm90YXRpb24gZm9yIGluaGVyaXRhbmNlIGFuZFxuXHRcdC8vXHRcdHByb3RvdHlwZSBleHRlbnNpb24uXG5cdFx0Ly9cblx0XHQvL1x0XHRNaXhpbiBhbmNlc3RvcnMgcHJvdmlkZSBhIHR5cGUgb2YgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG5cdFx0Ly9cdFx0UHJvdG90eXBlcyBvZiBtaXhpbiBhbmNlc3RvcnMgYXJlIGNvcGllZCB0byB0aGUgbmV3IGNsYXNzOlxuXHRcdC8vXHRcdGNoYW5nZXMgdG8gbWl4aW4gcHJvdG90eXBlcyB3aWxsIG5vdCBhZmZlY3QgY2xhc3NlcyB0byB3aGljaFxuXHRcdC8vXHRcdHRoZXkgaGF2ZSBiZWVuIG1peGVkIGluLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QW5jZXN0b3JzIGNhbiBiZSBjb21wb3VuZCBjbGFzc2VzIGNyZWF0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mXG5cdFx0Ly9cdFx0ZGVjbGFyZSgpLiBJbiBjb21wbGV4IGNhc2VzIGFsbCBiYXNlIGNsYXNzZXMgYXJlIGdvaW5nIHRvIGJlXG5cdFx0Ly9cdFx0bGluZWFyaXplZCBhY2NvcmRpbmcgdG8gQzMgTVJPIGFsZ29yaXRobVxuXHRcdC8vXHRcdChzZWUgaHR0cDovL3d3dy5weXRob24ub3JnL2Rvd25sb2FkL3JlbGVhc2VzLzIuMy9tcm8vIGZvciBtb3JlXG5cdFx0Ly9cdFx0ZGV0YWlscykuXG5cdFx0Ly9cblx0XHQvL1x0XHRcImNsYXNzTmFtZVwiIGlzIGNhY2hlZCBpbiBcImRlY2xhcmVkQ2xhc3NcIiBwcm9wZXJ0eSBvZiB0aGUgbmV3IGNsYXNzLFxuXHRcdC8vXHRcdGlmIGl0IHdhcyBzdXBwbGllZC4gVGhlIGltbWVkaWF0ZSBzdXBlciBjbGFzcyB3aWxsIGJlIGNhY2hlZCBpblxuXHRcdC8vXHRcdFwic3VwZXJjbGFzc1wiIHByb3BlcnR5IG9mIHRoZSBuZXcgY2xhc3MuXG5cdFx0Ly9cblx0XHQvL1x0XHRNZXRob2RzIGluIFwicHJvcHNcIiB3aWxsIGJlIGNvcGllZCBhbmQgbW9kaWZpZWQ6IFwibm9tXCIgcHJvcGVydHlcblx0XHQvL1x0XHQodGhlIGRlY2xhcmVkIG5hbWUgb2YgdGhlIG1ldGhvZCkgd2lsbCBiZSBhZGRlZCB0byBhbGwgY29waWVkXG5cdFx0Ly9cdFx0ZnVuY3Rpb25zIHRvIGhlbHAgaWRlbnRpZnkgdGhlbSBmb3IgdGhlIGludGVybmFsIG1hY2hpbmVyeS4gQmVcblx0XHQvL1x0XHR2ZXJ5IGNhcmVmdWwsIHdoaWxlIHJldXNpbmcgbWV0aG9kczogaWYgeW91IHVzZSB0aGUgc2FtZVxuXHRcdC8vXHRcdGZ1bmN0aW9uIHVuZGVyIGRpZmZlcmVudCBuYW1lcywgaXQgY2FuIHByb2R1Y2UgZXJyb3JzIGluIHNvbWVcblx0XHQvL1x0XHRjYXNlcy5cblx0XHQvL1xuXHRcdC8vXHRcdEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBjb25zdHJ1Y3RvcnMgY3JlYXRlZCBcIm1hbnVhbGx5XCIgKHdpdGhvdXRcblx0XHQvL1x0XHRkZWNsYXJlKCkpIGFzIGJhc2VzLiBUaGV5IHdpbGwgYmUgY2FsbGVkIGFzIHVzdWFsIGR1cmluZyB0aGVcblx0XHQvL1x0XHRjcmVhdGlvbiBvZiBhbiBpbnN0YW5jZSwgdGhlaXIgbWV0aG9kcyB3aWxsIGJlIGNoYWluZWQsIGFuZCBldmVuXG5cdFx0Ly9cdFx0Y2FsbGVkIGJ5IFwidGhpcy5pbmhlcml0ZWQoKVwiLlxuXHRcdC8vXG5cdFx0Ly9cdFx0U3BlY2lhbCBwcm9wZXJ0eSBcIi1jaGFpbnMtXCIgZ292ZXJucyBob3cgdG8gY2hhaW4gbWV0aG9kcy4gSXQgaXNcblx0XHQvL1x0XHRhIGRpY3Rpb25hcnksIHdoaWNoIHVzZXMgbWV0aG9kIG5hbWVzIGFzIGtleXMsIGFuZCBoaW50IHN0cmluZ3Ncblx0XHQvL1x0XHRhcyB2YWx1ZXMuIElmIGEgaGludCBzdHJpbmcgaXMgXCJhZnRlclwiLCB0aGlzIG1ldGhvZCB3aWxsIGJlXG5cdFx0Ly9cdFx0Y2FsbGVkIGFmdGVyIG1ldGhvZHMgb2YgaXRzIGJhc2UgY2xhc3Nlcy4gSWYgYSBoaW50IHN0cmluZyBpc1xuXHRcdC8vXHRcdFwiYmVmb3JlXCIsIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBtZXRob2RzIG9mIGl0cyBiYXNlXG5cdFx0Ly9cdFx0Y2xhc3Nlcy5cblx0XHQvL1xuXHRcdC8vXHRcdElmIFwiY29uc3RydWN0b3JcIiBpcyBub3QgbWVudGlvbmVkIGluIFwiLWNoYWlucy1cIiBwcm9wZXJ0eSwgaXQgd2lsbFxuXHRcdC8vXHRcdGJlIGNoYWluZWQgdXNpbmcgdGhlIGxlZ2FjeSBtb2RlOiB1c2luZyBcImFmdGVyXCIgY2hhaW5pbmcsXG5cdFx0Ly9cdFx0Y2FsbGluZyBwcmVhbWJsZSgpIG1ldGhvZCBiZWZvcmUgZWFjaCBjb25zdHJ1Y3RvciwgaWYgYXZhaWxhYmxlLFxuXHRcdC8vXHRcdGFuZCBjYWxsaW5nIHBvc3RzY3JpcHQoKSBhZnRlciBhbGwgY29uc3RydWN0b3JzIHdlcmUgZXhlY3V0ZWQuXG5cdFx0Ly9cdFx0SWYgdGhlIGhpbnQgaXMgXCJhZnRlclwiLCBpdCBpcyBjaGFpbmVkIGFzIGEgcmVndWxhciBtZXRob2QsIGJ1dFxuXHRcdC8vXHRcdHBvc3RzY3JpcHQoKSB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgY2hhaW4gb2YgY29uc3RydWN0b3JzLlxuXHRcdC8vXHRcdFwiY29uc3RydWN0b3JcIiBjYW5ub3QgYmUgY2hhaW5lZCBcImJlZm9yZVwiLCBidXQgaXQgYWxsb3dzXG5cdFx0Ly9cdFx0YSBzcGVjaWFsIGhpbnQgc3RyaW5nOiBcIm1hbnVhbFwiLCB3aGljaCBtZWFucyB0aGF0IGNvbnN0cnVjdG9yc1xuXHRcdC8vXHRcdGFyZSBub3QgZ29pbmcgdG8gYmUgY2hhaW5lZCBpbiBhbnkgd2F5LCBhbmQgcHJvZ3JhbW1lciB3aWxsIGNhbGxcblx0XHQvL1x0XHR0aGVtIG1hbnVhbGx5IHVzaW5nIHRoaXMuaW5oZXJpdGVkKCkuIEluIHRoZSBsYXR0ZXIgY2FzZVxuXHRcdC8vXHRcdHBvc3RzY3JpcHQoKSB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgY29uc3RydWN0aW9uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QWxsIGNoYWluaW5nIGhpbnRzIGFyZSBcImluaGVyaXRlZFwiIGZyb20gYmFzZSBjbGFzc2VzIGFuZFxuXHRcdC8vXHRcdHBvdGVudGlhbGx5IGNhbiBiZSBvdmVycmlkZGVuLiBCZSB2ZXJ5IGNhcmVmdWwgd2hlbiBvdmVycmlkaW5nXG5cdFx0Ly9cdFx0aGludHMhIE1ha2Ugc3VyZSB0aGF0IGFsbCBjaGFpbmVkIG1ldGhvZHMgY2FuIHdvcmsgaW4gYSBwcm9wb3NlZFxuXHRcdC8vXHRcdG1hbm5lciBvZiBjaGFpbmluZy5cblx0XHQvL1xuXHRcdC8vXHRcdE9uY2UgYSBtZXRob2Qgd2FzIGNoYWluZWQsIGl0IGlzIGltcG9zc2libGUgdG8gdW5jaGFpbiBpdC4gVGhlXG5cdFx0Ly9cdFx0b25seSBleGNlcHRpb24gaXMgXCJjb25zdHJ1Y3RvclwiLiBZb3UgZG9uJ3QgbmVlZCB0byBkZWZpbmUgYVxuXHRcdC8vXHRcdG1ldGhvZCBpbiBvcmRlciB0byBzdXBwbHkgYSBjaGFpbmluZyBoaW50LlxuXHRcdC8vXG5cdFx0Ly9cdFx0SWYgYSBtZXRob2QgaXMgY2hhaW5lZCwgaXQgY2Fubm90IHVzZSB0aGlzLmluaGVyaXRlZCgpIGJlY2F1c2Vcblx0XHQvL1x0XHRhbGwgb3RoZXIgbWV0aG9kcyBpbiB0aGUgaGllcmFyY2h5IHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkuXG5cdFx0Ly9cblx0XHQvL1x0XHRVc3VhbGx5IGNvbnN0cnVjdG9ycyBhbmQgaW5pdGlhbGl6ZXJzIG9mIGFueSBraW5kIGFyZSBjaGFpbmVkXG5cdFx0Ly9cdFx0dXNpbmcgXCJhZnRlclwiIGFuZCBkZXN0cnVjdG9ycyBvZiBhbnkga2luZCBhcmUgY2hhaW5lZCBhc1xuXHRcdC8vXHRcdFwiYmVmb3JlXCIuIE5vdGUgdGhhdCBjaGFpbmluZyBhc3N1bWVzIHRoYXQgY2hhaW5lZCBtZXRob2RzIGRvIG5vdFxuXHRcdC8vXHRcdHJldHVybiBhbnkgdmFsdWU6IGFueSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGRpc2NhcmRlZC5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdGRlY2xhcmUoXCJteS5jbGFzc2VzLmJhclwiLCBteS5jbGFzc2VzLmZvbywge1xuXHRcdC8vXHR8XHRcdC8vIHByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGNsYXNzIHByb3RvdHlwZVxuXHRcdC8vXHR8XHRcdHNvbWVWYWx1ZTogMixcblx0XHQvL1x0fFx0XHQvLyBpbml0aWFsaXphdGlvbiBmdW5jdGlvblxuXHRcdC8vXHR8XHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0dGhpcy5teUNvbXBsaWNhdGVkT2JqZWN0ID0gbmV3IFJlYWxseUNvbXBsaWNhdGVkT2JqZWN0KCk7XG5cdFx0Ly9cdHxcdFx0fSxcblx0XHQvL1x0fFx0XHQvLyBvdGhlciBmdW5jdGlvbnNcblx0XHQvL1x0fFx0XHRzb21lTWV0aG9kOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0ZG9TdHVmZigpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgTXlCYXNlID0gZGVjbGFyZShudWxsLCB7XG5cdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBNeUNsYXNzMSA9IGRlY2xhcmUoTXlCYXNlLCB7XG5cdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBNeUNsYXNzMiA9IGRlY2xhcmUoTXlCYXNlLCB7XG5cdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdHZhciBNeURpYW1vbmQgPSBkZWNsYXJlKFtNeUNsYXNzMSwgTXlDbGFzczJdLCB7XG5cdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgRiA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nKFwicmF3IGNvbnN0cnVjdG9yXCIpOyB9O1xuXHRcdC8vXHR8XHRGLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdGNvbnNvbGUubG9nKFwicmF3IG1ldGhvZFwiKTtcblx0XHQvL1x0fFx0fTtcblx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKEYsIHtcblx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQS5jb25zdHJ1Y3RvclwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG1ldGhvZDogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiYmVmb3JlIGNhbGxpbmcgRi5tZXRob2QuLi5cIik7XG5cdFx0Ly9cdHxcdFx0XHR0aGlzLmluaGVyaXRlZChhcmd1bWVudHMpO1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCIuLi5iYWNrIGluIEFcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0bmV3IEEoKS5tZXRob2QoKTtcblx0XHQvL1x0fFx0Ly8gd2lsbCBwcmludDpcblx0XHQvL1x0fFx0Ly8gcmF3IGNvbnN0cnVjdG9yXG5cdFx0Ly9cdHxcdC8vIEEuY29uc3RydWN0b3Jcblx0XHQvL1x0fFx0Ly8gYmVmb3JlIGNhbGxpbmcgRi5tZXRob2QuLi5cblx0XHQvL1x0fFx0Ly8gcmF3IG1ldGhvZFxuXHRcdC8vXHR8XHQvLyAuLi5iYWNrIGluIEFcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdHZhciBBID0gZGVjbGFyZShudWxsLCB7XG5cdFx0Ly9cdHxcdFx0XCItY2hhaW5zLVwiOiB7XG5cdFx0Ly9cdHxcdFx0XHRkZXN0cm95OiBcImJlZm9yZVwiXG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQi5jb25zdHJ1Y3RvclwiKTtcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkIuZGVzdHJveVwiKTtcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgQyA9IGRlY2xhcmUoQiwge1xuXHRcdC8vXHR8XHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJDLmNvbnN0cnVjdG9yXCIpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHQvL1x0fFx0XHRcdGNvbnNvbGUubG9nKFwiQy5kZXN0cm95XCIpO1xuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cdHxcdG5ldyBDKCkuZGVzdHJveSgpO1xuXHRcdC8vXHR8XHQvLyBwcmludHM6XG5cdFx0Ly9cdHxcdC8vIEIuY29uc3RydWN0b3Jcblx0XHQvL1x0fFx0Ly8gQy5jb25zdHJ1Y3RvclxuXHRcdC8vXHR8XHQvLyBDLmRlc3Ryb3lcblx0XHQvL1x0fFx0Ly8gQi5kZXN0cm95XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgQSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vXHR8XHRcdFwiLWNoYWlucy1cIjoge1xuXHRcdC8vXHR8XHRcdFx0Y29uc3RydWN0b3I6IFwibWFudWFsXCJcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUoQSwge1xuXHRcdC8vXHR8XHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Ly8gLi4uXG5cdFx0Ly9cdHxcdFx0XHQvLyBjYWxsIHRoZSBiYXNlIGNvbnN0cnVjdG9yIHdpdGggbmV3IHBhcmFtZXRlcnNcblx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cywgWzEsIDIsIDNdKTtcblx0XHQvL1x0fFx0XHRcdC8vIC4uLlxuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR2YXIgQSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vXHR8XHRcdFwiLWNoYWlucy1cIjoge1xuXHRcdC8vXHR8XHRcdFx0bTE6IFwiYmVmb3JlXCJcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJBLm0xXCIpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0bTI6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkEubTJcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHQvL1x0fFx0XHRcIi1jaGFpbnMtXCI6IHtcblx0XHQvL1x0fFx0XHRcdG0yOiBcImFmdGVyXCJcblx0XHQvL1x0fFx0XHR9LFxuXHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe1xuXHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2coXCJCLm0xXCIpO1xuXHRcdC8vXHR8XHRcdH0sXG5cdFx0Ly9cdHxcdFx0bTI6IGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyhcIkIubTJcIik7XG5cdFx0Ly9cdHxcdFx0fVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1x0fFx0dmFyIHggPSBuZXcgQigpO1xuXHRcdC8vXHR8XHR4Lm0xKCk7XG5cdFx0Ly9cdHxcdC8vIHByaW50czpcblx0XHQvL1x0fFx0Ly8gQi5tMVxuXHRcdC8vXHR8XHQvLyBBLm0xXG5cdFx0Ly9cdHxcdHgubTIoKTtcblx0XHQvL1x0fFx0Ly8gcHJpbnRzOlxuXHRcdC8vXHR8XHQvLyBBLm0yXG5cdFx0Ly9cdHxcdC8vIEIubTJcblxuXHRcdC8vIGNyYWNrIHBhcmFtZXRlcnNcblx0XHRpZih0eXBlb2YgY2xhc3NOYW1lICE9IFwic3RyaW5nXCIpe1xuXHRcdFx0cHJvcHMgPSBzdXBlcmNsYXNzO1xuXHRcdFx0c3VwZXJjbGFzcyA9IGNsYXNzTmFtZTtcblx0XHRcdGNsYXNzTmFtZSA9IFwiXCI7XG5cdFx0fVxuXHRcdHByb3BzID0gcHJvcHMgfHwge307XG5cblx0XHR2YXIgcHJvdG8sIGksIHQsIGN0b3IsIG5hbWUsIGJhc2VzLCBjaGFpbnMsIG1peGlucyA9IDEsIHBhcmVudHMgPSBzdXBlcmNsYXNzO1xuXG5cdFx0Ly8gYnVpbGQgYSBwcm90b3R5cGVcblx0XHRpZihvcHRzLmNhbGwoc3VwZXJjbGFzcykgPT0gXCJbb2JqZWN0IEFycmF5XVwiKXtcblx0XHRcdC8vIEMzIE1ST1xuXHRcdFx0YmFzZXMgPSBjM21ybyhzdXBlcmNsYXNzLCBjbGFzc05hbWUpO1xuXHRcdFx0dCA9IGJhc2VzWzBdO1xuXHRcdFx0bWl4aW5zID0gYmFzZXMubGVuZ3RoIC0gdDtcblx0XHRcdHN1cGVyY2xhc3MgPSBiYXNlc1ttaXhpbnNdO1xuXHRcdH1lbHNle1xuXHRcdFx0YmFzZXMgPSBbMF07XG5cdFx0XHRpZihzdXBlcmNsYXNzKXtcblx0XHRcdFx0aWYob3B0cy5jYWxsKHN1cGVyY2xhc3MpID09IFwiW29iamVjdCBGdW5jdGlvbl1cIil7XG5cdFx0XHRcdFx0dCA9IHN1cGVyY2xhc3MuX21ldGE7XG5cdFx0XHRcdFx0YmFzZXMgPSBiYXNlcy5jb25jYXQodCA/IHQuYmFzZXMgOiBzdXBlcmNsYXNzKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0ZXJyKFwiYmFzZSBjbGFzcyBpcyBub3QgYSBjYWxsYWJsZSBjb25zdHJ1Y3Rvci5cIiwgY2xhc3NOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2UgaWYoc3VwZXJjbGFzcyAhPT0gbnVsbCl7XG5cdFx0XHRcdGVycihcInVua25vd24gYmFzZSBjbGFzcy4gRGlkIHlvdSB1c2UgZG9qby5yZXF1aXJlIHRvIHB1bGwgaXQgaW4/XCIsIGNsYXNzTmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHN1cGVyY2xhc3Mpe1xuXHRcdFx0Zm9yKGkgPSBtaXhpbnMgLSAxOzsgLS1pKXtcblx0XHRcdFx0cHJvdG8gPSBmb3JjZU5ldyhzdXBlcmNsYXNzKTtcblx0XHRcdFx0aWYoIWkpe1xuXHRcdFx0XHRcdC8vIHN0b3AgaWYgbm90aGluZyB0byBhZGQgKHRoZSBsYXN0IGJhc2UpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbWl4IGluIHByb3BlcnRpZXNcblx0XHRcdFx0dCA9IGJhc2VzW2ldO1xuXHRcdFx0XHQodC5fbWV0YSA/IG1peE93biA6IG1peCkocHJvdG8sIHQucHJvdG90eXBlKTtcblx0XHRcdFx0Ly8gY2hhaW4gaW4gbmV3IGNvbnN0cnVjdG9yXG5cdFx0XHRcdGlmIChoYXMoXCJjc3AtcmVzdHJpY3Rpb25zXCIpKSB7XG5cdFx0XHRcdFx0Y3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGN0b3IgPSBuZXcgRnVuY3Rpb247XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3Rvci5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcztcblx0XHRcdFx0Y3Rvci5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdFx0c3VwZXJjbGFzcyA9IHByb3RvLmNvbnN0cnVjdG9yID0gY3Rvcjtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdHByb3RvID0ge307XG5cdFx0fVxuXHRcdC8vIGFkZCBhbGwgcHJvcGVydGllc1xuXHRcdGRlY2xhcmUuc2FmZU1peGluKHByb3RvLCBwcm9wcyk7XG5cdFx0Ly8gYWRkIGNvbnN0cnVjdG9yXG5cdFx0dCA9IHByb3BzLmNvbnN0cnVjdG9yO1xuXHRcdGlmKHQgIT09IG9wLmNvbnN0cnVjdG9yKXtcblx0XHRcdHQubm9tID0gY25hbWU7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IHQ7XG5cdFx0fVxuXG5cdFx0Ly8gY29sbGVjdCBjaGFpbnMgYW5kIGZsYWdzXG5cdFx0Zm9yKGkgPSBtaXhpbnMgLSAxOyBpOyAtLWkpeyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHR0ID0gYmFzZXNbaV0uX21ldGE7XG5cdFx0XHRpZih0ICYmIHQuY2hhaW5zKXtcblx0XHRcdFx0Y2hhaW5zID0gbWl4KGNoYWlucyB8fCB7fSwgdC5jaGFpbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihwcm90b1tcIi1jaGFpbnMtXCJdKXtcblx0XHRcdGNoYWlucyA9IG1peChjaGFpbnMgfHwge30sIHByb3RvW1wiLWNoYWlucy1cIl0pO1xuXHRcdH1cblxuXHRcdGlmKHN1cGVyY2xhc3MgJiYgc3VwZXJjbGFzcy5wcm90b3R5cGUgJiYgc3VwZXJjbGFzcy5wcm90b3R5cGVbXCItY2hhaW5zLVwiXSkge1xuXHRcdFx0Y2hhaW5zID0gbWl4KGNoYWlucyB8fCB7fSwgc3VwZXJjbGFzcy5wcm90b3R5cGVbXCItY2hhaW5zLVwiXSk7XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgY3RvclxuXHRcdHQgPSAhY2hhaW5zIHx8ICFjaGFpbnMuaGFzT3duUHJvcGVydHkoY25hbWUpO1xuXHRcdGJhc2VzWzBdID0gY3RvciA9IChjaGFpbnMgJiYgY2hhaW5zLmNvbnN0cnVjdG9yID09PSBcIm1hbnVhbFwiKSA/IHNpbXBsZUNvbnN0cnVjdG9yKGJhc2VzKSA6XG5cdFx0XHQoYmFzZXMubGVuZ3RoID09IDEgPyBzaW5nbGVDb25zdHJ1Y3Rvcihwcm9wcy5jb25zdHJ1Y3RvciwgdCkgOiBjaGFpbmVkQ29uc3RydWN0b3IoYmFzZXMsIHQpKTtcblxuXHRcdC8vIGFkZCBtZXRhIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zdHJ1Y3RvclxuXHRcdGN0b3IuX21ldGEgID0ge2Jhc2VzOiBiYXNlcywgaGlkZGVuOiBwcm9wcywgY2hhaW5zOiBjaGFpbnMsXG5cdFx0XHRwYXJlbnRzOiBwYXJlbnRzLCBjdG9yOiBwcm9wcy5jb25zdHJ1Y3Rvcn07XG5cdFx0Y3Rvci5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcyAmJiBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0XHRjdG9yLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRjdG9yLmNyZWF0ZVN1YmNsYXNzID0gY3JlYXRlU3ViY2xhc3M7XG5cdFx0Y3Rvci5wcm90b3R5cGUgPSBwcm90bztcblx0XHRwcm90by5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cblx0XHQvLyBhZGQgXCJzdGFuZGFyZFwiIG1ldGhvZHMgdG8gdGhlIHByb3RvdHlwZVxuXHRcdHByb3RvLmdldEluaGVyaXRlZCA9IGdldEluaGVyaXRlZDtcblx0XHRwcm90by5pc0luc3RhbmNlT2YgPSBpc0luc3RhbmNlT2Y7XG5cdFx0cHJvdG8uaW5oZXJpdGVkICAgID0gaW5oZXJpdGVkSW1wbDtcblx0XHRwcm90by5fX2luaGVyaXRlZCAgPSBpbmhlcml0ZWQ7XG5cblx0XHQvLyBhZGQgbmFtZSBpZiBzcGVjaWZpZWRcblx0XHRpZihjbGFzc05hbWUpe1xuXHRcdFx0cHJvdG8uZGVjbGFyZWRDbGFzcyA9IGNsYXNzTmFtZTtcblx0XHRcdGxhbmcuc2V0T2JqZWN0KGNsYXNzTmFtZSwgY3Rvcik7XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgY2hhaW5zIGFuZCBhZGQgdGhlbSB0byB0aGUgcHJvdG90eXBlXG5cdFx0aWYoY2hhaW5zKXtcblx0XHRcdGZvcihuYW1lIGluIGNoYWlucyl7XG5cdFx0XHRcdGlmKHByb3RvW25hbWVdICYmIHR5cGVvZiBjaGFpbnNbbmFtZV0gPT0gXCJzdHJpbmdcIiAmJiBuYW1lICE9IGNuYW1lKXtcblx0XHRcdFx0XHR0ID0gcHJvdG9bbmFtZV0gPSBjaGFpbihuYW1lLCBiYXNlcywgY2hhaW5zW25hbWVdID09PSBcImFmdGVyXCIpO1xuXHRcdFx0XHRcdHQubm9tID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjaGFpbmVkIG1ldGhvZHMgZG8gbm90IHJldHVybiB2YWx1ZXNcblx0XHQvLyBubyBuZWVkIHRvIGNoYWluIFwiaW52aXNpYmxlXCIgZnVuY3Rpb25zXG5cblx0XHRyZXR1cm4gY3RvcjtcdC8vIEZ1bmN0aW9uXG5cdH1cblxuXHQvKj09PT09XG5cdGRlY2xhcmUuX19EZWNsYXJlQ3JlYXRlZE9iamVjdCA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGRvam8vX2Jhc2UvZGVjbGFyZSgpIHJldHVybnMgYSBjb25zdHJ1Y3RvciBgQ2AuICAgYG5ldyBDKClgIHJldHVybnMgYW4gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuXHRcdC8vXHRcdG1ldGhvZHMsIGluIGFkZGl0aW9uIHRvIHRoZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHNwZWNpZmllZCB2aWEgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gZGVjbGFyZSgpLlxuXG5cdFx0aW5oZXJpdGVkOiBmdW5jdGlvbihuYW1lLCBjYWxsZXIsIGFyZ3MsIG5ld0FyZ3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbGxzIGEgc3VwZXIgbWV0aG9kLlxuXHRcdFx0Ly8gbmFtZTogU3RyaW5nP1xuXHRcdFx0Ly9cdFx0VGhlIG9wdGlvbmFsIG1ldGhvZCBuYW1lLiBTaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIGNhbGxlcidzXG5cdFx0XHQvL1x0XHRuYW1lLiBVc3VhbGx5IFwibmFtZVwiIGlzIHNwZWNpZmllZCBpbiBjb21wbGV4IGR5bmFtaWMgY2FzZXMsIHdoZW5cblx0XHRcdC8vXHRcdHRoZSBjYWxsaW5nIG1ldGhvZCB3YXMgZHluYW1pY2FsbHkgYWRkZWQsIHVuZGVjb3JhdGVkIGJ5XG5cdFx0XHQvL1x0XHRkZWNsYXJlKCksIGFuZCBpdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cblx0XHRcdC8vIGNhbGxlcjogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRUaGUgcmVmZXJlbmNlIHRvIHRoZSBjYWxsaW5nIGZ1bmN0aW9uLiBSZXF1aXJlZCBvbmx5IGlmIHRoZVxuXHRcdFx0Ly9cdFx0Y2FsbCB0byBcInRoaXMuaW5oZXJpdGVkXCIgb2NjdXJzIGZyb20gd2l0aGluIHN0cmljdC1tb2RlIGNvZGUuXG5cdFx0XHQvL1x0XHRJZiB0aGUgY2FsbGVyIGlzIG9taXR0ZWQgd2l0aGluIHN0cmljdC1tb2RlIGNvZGUsIGFuIGVycm9yIHdpbGxcblx0XHRcdC8vXHRcdGJlIHRocm93bi5cblx0XHRcdC8vXHRcdFRoZSBiZXN0IHdheSB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxpbmcgZnVuY3Rpb24gaXMgdG9cblx0XHRcdC8vXHRcdHVzZSBhIG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb24gKGkuZS4gcGxhY2UgYSBmdW5jdGlvbiBuYW1lXG5cdFx0XHQvL1x0XHRhZnRlciB0aGUgXCJmdW5jdGlvblwiIGtleXdvcmQgYW5kIGJlZm9yZSB0aGUgb3BlbiBwYXJlbiwgYXMgaW5cblx0XHRcdC8vXHRcdFwiZnVuY3Rpb24gZm4oYSwgYilcIikuIElmIHRoZSBmdW5jdGlvbiBpcyBwYXJzZWQgYXMgYW4gZXhwcmVzc2lvblxuXHRcdFx0Ly9cdFx0YW5kIG5vdCBhIHN0YXRlbWVudCAoaS5lLiBpdCdzIG5vdCBieSBpdHNlbGYgb24gaXRzIG93biBsaW5lKSxcblx0XHRcdC8vXHRcdHRoZSBmdW5jdGlvbiBuYW1lIHdpbGwgb25seSBiZSBhY2Nlc3NpYmxlIGFzIGFuIGlkZW50aWZpZXIgZnJvbVxuXHRcdFx0Ly9cdFx0d2l0aGluIHRoZSBib2R5IG9mIHRoZSBmdW5jdGlvbi5cblx0XHRcdC8vIGFyZ3M6IEFyZ3VtZW50c1xuXHRcdFx0Ly9cdFx0VGhlIGNhbGxlciBzdXBwbHkgdGhpcyBhcmd1bWVudCwgd2hpY2ggc2hvdWxkIGJlIHRoZSBvcmlnaW5hbFxuXHRcdFx0Ly9cdFx0XCJhcmd1bWVudHNcIi5cblx0XHRcdC8vIG5ld0FyZ3M6IE9iamVjdD9cblx0XHRcdC8vXHRcdElmIFwidHJ1ZVwiLCB0aGUgZm91bmQgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZCB3aXRob3V0XG5cdFx0XHQvL1x0XHRleGVjdXRpbmcgaXQuXG5cdFx0XHQvL1x0XHRJZiBBcnJheSwgaXQgd2lsbCBiZSB1c2VkIHRvIGNhbGwgYSBzdXBlciBtZXRob2QuIE90aGVyd2lzZVxuXHRcdFx0Ly9cdFx0XCJhcmdzXCIgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFdoYXRldmVyIGlzIHJldHVybmVkIGJ5IGEgc3VwZXIgbWV0aG9kLCBvciBhIHN1cGVyIG1ldGhvZCBpdHNlbGYsXG5cdFx0XHQvL1x0XHRpZiBcInRydWVcIiB3YXMgc3BlY2lmaWVkIGFzIG5ld0FyZ3MuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zaWRlIG1ldGhvZCBvZiBjbGFzc2VzIHByb2R1Y2VkIHdpdGhcblx0XHRcdC8vXHRcdGRlY2xhcmUoKSB0byBjYWxsIGEgc3VwZXIgbWV0aG9kIChuZXh0IGluIHRoZSBjaGFpbikuIEl0IGlzXG5cdFx0XHQvL1x0XHR1c2VkIGZvciBtYW51YWxseSBjb250cm9sbGVkIGNoYWluaW5nLiBDb25zaWRlciB1c2luZyB0aGUgcmVndWxhclxuXHRcdFx0Ly9cdFx0Y2hhaW5pbmcsIGJlY2F1c2UgaXQgaXMgZmFzdGVyLiBVc2UgXCJ0aGlzLmluaGVyaXRlZCgpXCIgb25seSBpblxuXHRcdFx0Ly9cdFx0Y29tcGxleCBjYXNlcy5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRUaGlzIG1ldGhvZCBjYW5ub3QgbWUgY2FsbGVkIGZyb20gYXV0b21hdGljYWxseSBjaGFpbmVkXG5cdFx0XHQvL1x0XHRjb25zdHJ1Y3RvcnMgaW5jbHVkaW5nIHRoZSBjYXNlIG9mIGEgc3BlY2lhbCAobGVnYWN5KVxuXHRcdFx0Ly9cdFx0Y29uc3RydWN0b3IgY2hhaW5pbmcuIEl0IGNhbm5vdCBiZSBjYWxsZWQgZnJvbSBjaGFpbmVkIG1ldGhvZHMuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0SWYgXCJ0aGlzLmluaGVyaXRlZCgpXCIgY2Fubm90IGZpbmQgdGhlIG5leHQtaW4tY2hhaW4gbWV0aG9kLCBpdFxuXHRcdFx0Ly9cdFx0ZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zIFwidW5kZWZpbmVkXCIuIFRoZSBsYXN0IG1ldGhvZCBpbiBjaGFpblxuXHRcdFx0Ly9cdFx0Y2FuIGJlIGEgZGVmYXVsdCBtZXRob2QgaW1wbGVtZW50ZWQgaW4gT2JqZWN0LCB3aGljaCB3aWxsIGJlXG5cdFx0XHQvL1x0XHRjYWxsZWQgbGFzdC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRJZiBcIm5hbWVcIiBpcyBzcGVjaWZpZWQsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbWV0aG9kIHRoYXRcblx0XHRcdC8vXHRcdHJlY2VpdmVkIFwiYXJnc1wiIGlzIHRoZSBwYXJlbnQgbWV0aG9kIGZvciB0aGlzIGNhbGwuIEl0IGlzIGxvb2tlZFxuXHRcdFx0Ly9cdFx0dXAgaW4gdGhlIGNoYWluIGxpc3QgYW5kIGlmIGl0IGlzIGZvdW5kIHRoZSBuZXh0LWluLWNoYWluIG1ldGhvZFxuXHRcdFx0Ly9cdFx0aXMgY2FsbGVkLiBJZiBpdCBpcyBub3QgZm91bmQsIHRoZSBmaXJzdC1pbi1jaGFpbiBtZXRob2QgaXNcblx0XHRcdC8vXHRcdGNhbGxlZC5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRJZiBcIm5hbWVcIiBpcyBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGUgY2FsbGluZ1xuXHRcdFx0Ly9cdFx0bWV0aG9kICh1c2luZyBhIG1ldGhvaWQgcHJvcGVydHkgXCJub21cIikuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUoQSwge1xuXHRcdFx0Ly9cdHxcdFx0bWV0aG9kMTogZnVuY3Rpb24oYSwgYiwgYyl7XG5cdFx0XHQvL1x0fFx0XHRcdHRoaXMuaW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0XHQvL1x0fFx0XHR9LFxuXHRcdFx0Ly9cdHxcdFx0bWV0aG9kMjogZnVuY3Rpb24oYSwgYil7XG5cdFx0XHQvL1x0fFx0XHRcdHJldHVybiB0aGlzLmluaGVyaXRlZChhcmd1bWVudHMsIFthICsgYl0pO1xuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdC8vIG5leHQgbWV0aG9kIGlzIG5vdCBpbiB0aGUgY2hhaW4gbGlzdCBiZWNhdXNlIGl0IGlzIGFkZGVkXG5cdFx0XHQvL1x0fFx0Ly8gbWFudWFsbHkgYWZ0ZXIgdGhlIGNsYXNzIHdhcyBjcmVhdGVkLlxuXHRcdFx0Ly9cdHxcdEIucHJvdG90eXBlLm1ldGhvZDMgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly9cdHxcdFx0Y29uc29sZS5sb2coXCJUaGlzIGlzIGEgZHluYW1pY2FsbHktYWRkZWQgbWV0aG9kLlwiKTtcblx0XHRcdC8vXHR8XHRcdHRoaXMuaW5oZXJpdGVkKFwibWV0aG9kM1wiLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdH07XG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0XHQvL1x0fFx0XHRtZXRob2Q6IGZ1bmN0aW9uKGEsIGIpe1xuXHRcdFx0Ly9cdHxcdFx0XHR2YXIgc3VwZXIgPSB0aGlzLmluaGVyaXRlZChhcmd1bWVudHMsIHRydWUpO1xuXHRcdFx0Ly9cdHxcdFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHRcdFx0aWYoIXN1cGVyKXtcblx0XHRcdC8vXHR8XHRcdFx0XHRjb25zb2xlLmxvZyhcInRoZXJlIGlzIG5vIHN1cGVyIG1ldGhvZFwiKTtcblx0XHRcdC8vXHR8XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0XHRyZXR1cm4gc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHQvL1x0fFx0Ly8gY2xhc3MgaXMgZGVmaW5lZCBpbiBzdHJpY3QtbW9kZSBjb2RlLFxuXHRcdFx0Ly9cdHxcdC8vIHNvIGNhbGxlciBtdXN0IGJlIHBhc3NlZCBiZWZvcmUgYXJndW1lbnRzLlxuXHRcdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShBLCB7XG5cdFx0XHQvL1x0fFx0XHQvLyB1c2luZyBhIG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBcImZuXCIgYXMgdGhlIG5hbWUuXG5cdFx0XHQvL1x0fFx0XHRtZXRob2Q6IGZ1bmN0aW9uIGZuKGEsIGIpIHtcblx0XHRcdC8vXHR8XHRcdFx0dGhpcy5pbmhlcml0ZWQoZm4sIGFyZ3VtZW50cyk7XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHRyZXR1cm5cdHt9O1x0Ly8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdGdldEluaGVyaXRlZDogZnVuY3Rpb24obmFtZSwgY2FsbGVyLCBhcmdzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgc3VwZXIgbWV0aG9kLlxuXHRcdFx0Ly8gbmFtZTogU3RyaW5nP1xuXHRcdFx0Ly9cdFx0VGhlIG9wdGlvbmFsIG1ldGhvZCBuYW1lLiBTaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIGNhbGxlcidzXG5cdFx0XHQvL1x0XHRuYW1lLiBVc3VhbGx5IFwibmFtZVwiIGlzIHNwZWNpZmllZCBpbiBjb21wbGV4IGR5bmFtaWMgY2FzZXMsIHdoZW5cblx0XHRcdC8vXHRcdHRoZSBjYWxsaW5nIG1ldGhvZCB3YXMgZHluYW1pY2FsbHkgYWRkZWQsIHVuZGVjb3JhdGVkIGJ5XG5cdFx0XHQvL1x0XHRkZWNsYXJlKCksIGFuZCBpdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cblx0XHRcdC8vIGNhbGxlcjogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRUaGUgY2FsbGVyIGZ1bmN0aW9uLiBUaGlzIGlzIHJlcXVpcmVkIHdoZW4gcnVubmluZyBpblxuXHRcdFx0Ly9cdFx0c3RyaWN0LW1vZGUgY29kZS4gQSByZWZlcmVuY2UgdG8gdGhlIGNhbGxlciBmdW5jdGlvblxuXHRcdFx0Ly9cdFx0Y2FuIGJlIG9idGFpbmVkIGJ5IHVzaW5nIGEgbmFtZWQgZnVuY3Rpb24gZXhwcmVzc2lvblxuXHRcdFx0Ly9cdFx0KGUuZy4gZnVuY3Rpb24gZm4oYSxiKSB7Li4ufSkuXG5cdFx0XHQvLyBhcmdzOiBBcmd1bWVudHNcblx0XHRcdC8vXHRcdFRoZSBjYWxsZXIgc3VwcGx5IHRoaXMgYXJndW1lbnQsIHdoaWNoIHNob3VsZCBiZSB0aGUgb3JpZ2luYWxcblx0XHRcdC8vXHRcdFwiYXJndW1lbnRzXCIuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIHN1cGVyIG1ldGhvZCAoRnVuY3Rpb24pIG9yIFwidW5kZWZpbmVkXCIuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBcInRoaXMuaW5oZXJpdGVkKClcIi5cblx0XHRcdC8vXHRcdEl0IHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtIGJ1dCBpbnN0ZWFkIG9mIGV4ZWN1dGluZyBhIHN1cGVyXG5cdFx0XHQvL1x0XHRtZXRob2QsIGl0IHJldHVybnMgaXQsIG9yIFwidW5kZWZpbmVkXCIgaWYgbm90IGZvdW5kLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIEIgPSBkZWNsYXJlKEEsIHtcblx0XHRcdC8vXHR8XHRcdG1ldGhvZDogZnVuY3Rpb24oYSwgYil7XG5cdFx0XHQvL1x0fFx0XHRcdHZhciBzdXBlciA9IHRoaXMuZ2V0SW5oZXJpdGVkKGFyZ3VtZW50cyk7XG5cdFx0XHQvL1x0fFx0XHRcdC8vIC4uLlxuXHRcdFx0Ly9cdHxcdFx0XHRpZighc3VwZXIpe1xuXHRcdFx0Ly9cdHxcdFx0XHRcdGNvbnNvbGUubG9nKFwidGhlcmUgaXMgbm8gc3VwZXIgbWV0aG9kXCIpO1xuXHRcdFx0Ly9cdHxcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0Ly9cdHxcdFx0XHR9XG5cdFx0XHQvL1x0fFx0XHRcdHJldHVybiBzdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRcInVzZSBzdHJpY3Q7XCIgLy8gZmlyc3QgbGluZSBvZiBmdW5jdGlvbiBvciBmaWxlXG5cdFx0XHQvL1x0fFx0Ly8uLi5cblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUoQSwge1xuXHRcdFx0Ly9cdHxcdFx0Ly8gVXNpbmcgYSBuYW1lZCBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggXCJmblwiIGFzIHRoZSBuYW1lLFxuXHRcdFx0Ly9cdHxcdFx0Ly8gc2luY2Ugd2UncmUgaW4gc3RyaWN0IG1vZGUuXG5cdFx0XHQvL1x0fFx0XHRtZXRob2Q6IGZ1bmN0aW9uIGZuKGEsIGIpe1xuXHRcdFx0Ly9cdHxcdFx0XHR2YXIgc3VwZXIgPSB0aGlzLmdldEluaGVyaXRlZChmbiwgYXJndW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdFx0aWYoc3VwZXIpe1xuXHRcdFx0Ly9cdHxcdFx0XHRcdHJldHVybiBzdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly9cdHxcdFx0XHR9XG5cdFx0XHQvL1x0fFx0XHR9XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHRyZXR1cm5cdHt9O1x0Ly8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdGlzSW5zdGFuY2VPZjogZnVuY3Rpb24oY2xzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3MgdGhlIGluaGVyaXRhbmNlIGNoYWluIHRvIHNlZSBpZiBpdCBpcyBpbmhlcml0ZWQgZnJvbSB0aGlzXG5cdFx0XHQvL1x0XHRjbGFzcy5cblx0XHRcdC8vIGNsczogRnVuY3Rpb25cblx0XHRcdC8vXHRcdENsYXNzIGNvbnN0cnVjdG9yLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFwidHJ1ZVwiLCBpZiB0aGlzIG9iamVjdCBpcyBpbmhlcml0ZWQgZnJvbSB0aGlzIGNsYXNzLCBcImZhbHNlXCJcblx0XHRcdC8vXHRcdG90aGVyd2lzZS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgaXMgdXNlZCB3aXRoIGluc3RhbmNlcyBvZiBjbGFzc2VzIHByb2R1Y2VkIHdpdGhcblx0XHRcdC8vXHRcdGRlY2xhcmUoKSB0byBkZXRlcm1pbmUgb2YgdGhleSBzdXBwb3J0IGEgY2VydGFpbiBpbnRlcmZhY2Ugb3Jcblx0XHRcdC8vXHRcdG5vdC4gSXQgbW9kZWxzIFwiaW5zdGFuY2VvZlwiIG9wZXJhdG9yLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgQiA9IGRlY2xhcmUobnVsbCwge1xuXHRcdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHRcdC8vXHR8XHRcdC8vIC4uLlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdHZhciBDID0gZGVjbGFyZShbQSwgQl0sIHtcblx0XHRcdC8vXHR8XHRcdC8vIGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBhbmQgbWV0aG9kcyBnbyBoZXJlXG5cdFx0XHQvL1x0fFx0XHQvLyAuLi5cblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgRCA9IGRlY2xhcmUoQSwge1xuXHRcdFx0Ly9cdHxcdFx0Ly8gY29uc3RydWN0b3IsIHByb3BlcnRpZXMsIGFuZCBtZXRob2RzIGdvIGhlcmVcblx0XHRcdC8vXHR8XHRcdC8vIC4uLlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHR2YXIgYSA9IG5ldyBBKCksIGIgPSBuZXcgQigpLCBjID0gbmV3IEMoKSwgZCA9IG5ldyBEKCk7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGEuaXNJbnN0YW5jZU9mKEEpKTsgLy8gdHJ1ZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGIuaXNJbnN0YW5jZU9mKEEpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhjLmlzSW5zdGFuY2VPZihBKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhkLmlzSW5zdGFuY2VPZihBKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYS5pc0luc3RhbmNlT2YoQikpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGIuaXNJbnN0YW5jZU9mKEIpKTsgLy8gdHJ1ZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGMuaXNJbnN0YW5jZU9mKEIpKTsgLy8gdHJ1ZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGQuaXNJbnN0YW5jZU9mKEIpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYS5pc0luc3RhbmNlT2YoQykpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGIuaXNJbnN0YW5jZU9mKEMpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhjLmlzSW5zdGFuY2VPZihDKSk7IC8vIHRydWVcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhkLmlzSW5zdGFuY2VPZihDKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGEuaXNJbnN0YW5jZU9mKEQpKTsgLy8gZmFsc2Vcblx0XHRcdC8vXHR8XHRjb25zb2xlLmxvZyhiLmlzSW5zdGFuY2VPZihEKSk7IC8vIGZhbHNlXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coYy5pc0luc3RhbmNlT2YoRCkpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGQuaXNJbnN0YW5jZU9mKEQpKTsgLy8gdHJ1ZVxuXHRcdFx0cmV0dXJuXHR7fTtcdC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKHNvdXJjZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkcyBhbGwgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiBzb3VyY2UgdG8gY29uc3RydWN0b3Inc1xuXHRcdFx0Ly9cdFx0cHJvdG90eXBlLCBtYWtpbmcgdGhlbSBhdmFpbGFibGUgdG8gYWxsIGluc3RhbmNlcyBjcmVhdGVkIHdpdGhcblx0XHRcdC8vXHRcdGNvbnN0cnVjdG9yLiBUaGlzIG1ldGhvZCBpcyBzcGVjaWZpYyB0byBjb25zdHJ1Y3RvcnMgY3JlYXRlZCB3aXRoXG5cdFx0XHQvL1x0XHRkZWNsYXJlKCkuXG5cdFx0XHQvLyBzb3VyY2U6IE9iamVjdFxuXHRcdFx0Ly9cdFx0U291cmNlIG9iamVjdCB3aGljaCBwcm9wZXJ0aWVzIGFyZSBnb2luZyB0byBiZSBjb3BpZWQgdG8gdGhlXG5cdFx0XHQvL1x0XHRjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0QWRkcyBzb3VyY2UgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEl0IGNhblxuXHRcdFx0Ly9cdFx0b3ZlcnJpZGUgZXhpc3RpbmcgcHJvcGVydGllcy5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRUaGlzIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGRvam8uZXh0ZW5kIGZ1bmN0aW9uLCBidXQgaXQgaXMgc3BlY2lmaWNcblx0XHRcdC8vXHRcdHRvIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSBkZWNsYXJlKCkuIEl0IGlzIGltcGxlbWVudGVkXG5cdFx0XHQvL1x0XHR1c2luZyBkb2pvLnNhZmVNaXhpbiwgYW5kIGl0IHNraXBzIGEgY29uc3RydWN0b3IgcHJvcGVydHksXG5cdFx0XHQvL1x0XHRhbmQgcHJvcGVybHkgZGVjb3JhdGVzIGNvcGllZCBmdW5jdGlvbnMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHR2YXIgQSA9IGRlY2xhcmUobnVsbCwge1xuXHRcdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7fSxcblx0XHRcdC8vXHR8XHRcdHMxOiBcIlBvcG9rYXRlcGV0bFwiXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFx0QS5leHRlbmQoe1xuXHRcdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7fSxcblx0XHRcdC8vXHR8XHRcdG0yOiBmdW5jdGlvbigpe30sXG5cdFx0XHQvL1x0fFx0XHRmMTogdHJ1ZSxcblx0XHRcdC8vXHR8XHRcdGQxOiA0MlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdH0sXG5cblx0XHRjcmVhdGVTdWJjbGFzczogZnVuY3Rpb24obWl4aW5zLCBwcm9wcyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q3JlYXRlIGEgc3ViY2xhc3Mgb2YgdGhlIGRlY2xhcmVkIGNsYXNzIGZyb20gYSBsaXN0IG9mIGJhc2UgY2xhc3Nlcy5cblx0XHRcdC8vIG1peGluczogRnVuY3Rpb25bXVxuXHRcdFx0Ly9cdFx0U3BlY2lmaWVzIGEgbGlzdCBvZiBiYXNlcyAodGhlIGxlZnQtbW9zdCBvbmUgaXMgdGhlIG1vc3QgZGVlcGVzdFxuXHRcdFx0Ly9cdFx0YmFzZSkuXG5cdFx0XHQvLyBwcm9wczogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0QW4gb3B0aW9uYWwgb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGNvcGllZCB0byB0aGUgY3JlYXRlZCBwcm90b3R5cGUuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL19iYXNlL2RlY2xhcmUuX19EZWNsYXJlQ3JlYXRlZE9iamVjdFxuXHRcdFx0Ly9cdFx0TmV3IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRDcmVhdGUgYSBjb25zdHJ1Y3RvciB1c2luZyBhIGNvbXBhY3Qgbm90YXRpb24gZm9yIGluaGVyaXRhbmNlIGFuZFxuXHRcdFx0Ly9cdFx0cHJvdG90eXBlIGV4dGVuc2lvbi5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRNaXhpbiBhbmNlc3RvcnMgcHJvdmlkZSBhIHR5cGUgb2YgbXVsdGlwbGUgaW5oZXJpdGFuY2UuXG5cdFx0XHQvL1x0XHRQcm90b3R5cGVzIG9mIG1peGluIGFuY2VzdG9ycyBhcmUgY29waWVkIHRvIHRoZSBuZXcgY2xhc3M6XG5cdFx0XHQvL1x0XHRjaGFuZ2VzIHRvIG1peGluIHByb3RvdHlwZXMgd2lsbCBub3QgYWZmZWN0IGNsYXNzZXMgdG8gd2hpY2hcblx0XHRcdC8vXHRcdHRoZXkgaGF2ZSBiZWVuIG1peGVkIGluLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIEEgPSBkZWNsYXJlKG51bGwsIHtcblx0XHRcdC8vXHR8XHRcdG0xOiBmdW5jdGlvbigpe30sXG5cdFx0XHQvL1x0fFx0XHRzMTogXCJiYXJcIlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdHZhciBCID0gZGVjbGFyZShudWxsLCB7XG5cdFx0XHQvL1x0fFx0XHRtMjogZnVuY3Rpb24oKXt9LFxuXHRcdFx0Ly9cdHxcdFx0czI6IFwiZm9vXCJcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXHR8XHR2YXIgQyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdHZhciBEMSA9IEEuY3JlYXRlU3ViY2xhc3MoW0IsIENdLCB7XG5cdFx0XHQvL1x0fFx0XHRtMTogZnVuY3Rpb24oKXt9LFxuXHRcdFx0Ly9cdHxcdFx0ZDE6IDQyXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFx0dmFyIGQxID0gbmV3IEQxKCk7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0bzpcblx0XHRcdC8vXHR8XHR2YXIgRDIgPSBkZWNsYXJlKFtBLCBCLCBDXSwge1xuXHRcdFx0Ly9cdHxcdFx0bTE6IGZ1bmN0aW9uKCl7fSxcblx0XHRcdC8vXHR8XHRcdGQxOiA0MlxuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cdHxcdHZhciBkMiA9IG5ldyBEMigpO1xuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdC8vIEZvciBiYWNrLWNvbXBhdCwgcmVtb3ZlIGZvciAyLjBcblx0ZG9qby5zYWZlTWl4aW4gPSBkZWNsYXJlLnNhZmVNaXhpbiA9IHNhZmVNaXhpbjtcblx0ZG9qby5kZWNsYXJlID0gZGVjbGFyZTtcblxuXHRyZXR1cm4gZGVjbGFyZTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi4vb25cIiwgXCIuLi9oYXNcIiwgXCIuLi9kb20tZ2VvbWV0cnlcIl0sIGZ1bmN0aW9uKGRvam8sIG9uLCBoYXMsIGRvbSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9fYmFzZS9ldmVudFxuXG5cdGlmKG9uLl9maXhFdmVudCl7XG5cdFx0dmFyIGZpeEV2ZW50ID0gb24uX2ZpeEV2ZW50O1xuXHRcdG9uLl9maXhFdmVudCA9IGZ1bmN0aW9uKGV2dCwgc2Upe1xuXHRcdFx0Ly8gYWRkIHNvbWUgYWRkaXRpb25hbCBub3JtYWxpemF0aW9uIGZvciBiYWNrLWNvbXBhdCwgdGhpcyBpc24ndCBpbiBvbi5qcyBiZWNhdXNlIGl0IGlzIHNvbWV3aGF0IG1vcmUgZXhwZW5zaXZlXG5cdFx0XHRldnQgPSBmaXhFdmVudChldnQsIHNlKTtcblx0XHRcdGlmKGV2dCl7XG5cdFx0XHRcdGRvbS5ub3JtYWxpemVFdmVudChldnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV2dDtcblx0XHR9O1x0XHRcblx0fVxuXHRcblx0dmFyIHJldCA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgZG9qbyBET00gZXZlbnQgQVBJLiAgIFVzdWFsbHkgeW91IHNob3VsZCB1c2UgZG9qby9vbiwgYW5kIGV2dC5zdG9wUHJvcGFnYXRpb24oKSArXG5cdFx0Ly9cdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCksIHJhdGhlciB0aGFuIHRoaXMgbW9kdWxlLlxuXG5cdFx0Zml4OiBmdW5jdGlvbigvKkV2ZW50Ki8gZXZ0LCAvKkRPTU5vZGUqLyBzZW5kZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdG5vcm1hbGl6ZXMgcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgb2JqZWN0IGluY2x1ZGluZyBldmVudFxuXHRcdFx0Ly9cdFx0YnViYmxpbmcgbWV0aG9kcywga2V5c3Ryb2tlIG5vcm1hbGl6YXRpb24sIGFuZCB4L3kgcG9zaXRpb25zXG5cdFx0XHQvLyBldnQ6IEV2ZW50XG5cdFx0XHQvL1x0XHRuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHQvLyBzZW5kZXI6IERPTU5vZGVcblx0XHRcdC8vXHRcdG5vZGUgdG8gdHJlYXQgYXMgXCJjdXJyZW50VGFyZ2V0XCJcblx0XHRcdGlmKG9uLl9maXhFdmVudCl7XG5cdFx0XHRcdHJldHVybiBvbi5fZml4RXZlbnQoZXZ0LCBzZW5kZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV2dDtcdC8vIEV2ZW50XG5cdFx0fSxcblx0XG5cdFx0c3RvcDogZnVuY3Rpb24oLypFdmVudCovIGV2dCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0cHJldmVudHMgcHJvcGFnYXRpb24gYW5kIGNsb2JiZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGVcblx0XHRcdC8vXHRcdHBhc3NlZCBldmVudFxuXHRcdFx0Ly8gZXZ0OiBFdmVudFxuXHRcdFx0Ly9cdFx0VGhlIGV2ZW50IG9iamVjdC4gSWYgb21pdHRlZCwgd2luZG93LmV2ZW50IGlzIHVzZWQgb24gSUUuXG5cdFx0XHRpZihoYXMoXCJkb20tYWRkZXZlbnRsaXN0ZW5lclwiKSB8fCAoZXZ0ICYmIGV2dC5wcmV2ZW50RGVmYXVsdCkpe1xuXHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0ZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0XHRcdGV2dC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHRcdFx0XHRvbi5fcHJldmVudERlZmF1bHQuY2FsbChldnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRpZihoYXMoXCJleHRlbmQtZG9qb1wiKSl7XG5cdFx0ZG9qby5maXhFdmVudCA9IHJldC5maXg7XG5cdFx0ZG9qby5zdG9wRXZlbnQgPSByZXQuc3RvcDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59KTtcbiIsImRlZmluZShbXCIuLi9nbG9iYWxcIiwgXCIuLi9oYXNcIiwgXCIuL2NvbmZpZ1wiLCBcInJlcXVpcmVcIiwgXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGdsb2JhbCwgaGFzLCBjb25maWcsIHJlcXVpcmUsIG1vZHVsZSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9fYmFzZS9rZXJuZWxcblxuXHQvLyBUaGlzIG1vZHVsZSBpcyB0aGUgZm91bmRhdGlvbmFsIG1vZHVsZSBvZiB0aGUgZG9qbyBib290IHNlcXVlbmNlOyBpdCBkZWZpbmVzIHRoZSBkb2pvIG9iamVjdC5cblxuXHR2YXJcblx0XHQvLyBsb29wIHZhcmlhYmxlcyBmb3IgdGhpcyBtb2R1bGVcblx0XHRpLCBwLFxuXG5cdFx0Ly8gY3JlYXRlIGRvam8sIGRpaml0LCBhbmQgZG9qb3hcblx0XHQvLyBGSVhNRTogaW4gMi4wIHJlbW92ZSBkaWppdCwgZG9qb3ggYmVpbmcgY3JlYXRlZCBieSBkb2pvXG5cdFx0ZGlqaXQgPSB7fSxcblx0XHRkb2pveCA9IHt9LFxuXHRcdGRvam8gPSB7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGhpcyBtb2R1bGUgaXMgdGhlIGZvdW5kYXRpb25hbCBtb2R1bGUgb2YgdGhlIGRvam8gYm9vdCBzZXF1ZW5jZTsgaXQgZGVmaW5lcyB0aGUgZG9qbyBvYmplY3QuXG5cblx0XHRcdC8vIG5vdGljZSBkb2pvIHRha2VzIG93bmVyc2hpcCBvZiB0aGUgdmFsdWUgb2YgdGhlIGNvbmZpZyBtb2R1bGVcblx0XHRcdGNvbmZpZzpjb25maWcsXG5cdFx0XHRnbG9iYWw6Z2xvYmFsLFxuXHRcdFx0ZGlqaXQ6ZGlqaXQsXG5cdFx0XHRkb2pveDpkb2pveFxuXHRcdH07XG5cblxuXHQvLyBDb25maWd1cmUgdGhlIHNjb3BlIG1hcC4gRm9yIGEgMTAwJSBBTUQgYXBwbGljYXRpb24sIHRoZSBzY29wZSBtYXAgaXMgbm90IG5lZWRlZCBvdGhlciB0aGFuIHRvIHByb3ZpZGVcblx0Ly8gYSBfc2NvcGVOYW1lIHByb3BlcnR5IGZvciB0aGUgZG9qbywgZGlqaXQsIGFuZCBkb2pveCByb290IG9iamVjdCBzbyB0aG9zZSBwYWNrYWdlcyBjYW4gY3JlYXRlXG5cdC8vIHVuaXF1ZSBuYW1lcyBpbiB0aGUgZ2xvYmFsIHNwYWNlLlxuXHQvL1xuXHQvLyBCdWlsdCwgbGVnYWN5IG1vZHVsZXMgdXNlIHRoZSBzY29wZSBtYXAgdG8gYWxsb3cgdGhvc2UgbW9kdWxlcyB0byBiZSBleHByZXNzZWQgYXMgaWYgZG9qbywgZGlqaXQsIGFuZCBkb2pveCxcblx0Ly8gd2hlcmUgZ2xvYmFsIHdoZW4gaW4gZmFjdCB0aGV5IGFyZSBlaXRoZXIgZ2xvYmFsIHVuZGVyIGRpZmZlcmVudCBuYW1lcyBvciBub3QgZ2xvYmFsIGF0IGFsbC4gSW4gdjEuNi0sIHRoZVxuXHQvLyBjb25maWcgdmFyaWFibGUgXCJzY29wZU1hcFwiIHdhcyB1c2VkIHRvIG1hcCBuYW1lcyBhcyB1c2VkIHdpdGhpbiBhIG1vZHVsZSB0byBnbG9iYWwgbmFtZXMuIFRoaXMgaGFzIGJlZW5cblx0Ly8gc3Vic3VtZWQgYnkgdGhlIEFNRCBtYXAgY29uZmlndXJhdGlvbiB2YXJpYWJsZSB3aGljaCBjYW4gcmVsb2NhdGUgcGFja2FnZXMgdG8gZGlmZmVyZW50IG5hbWVzLiBGb3IgYmFja2NvbXBhdCxcblx0Ly8gb25seSB0aGUgXCIqXCIgbWFwcGluZyBpcyBzdXBwb3J0ZWQuIFNlZSBodHRwOi8vbGl2ZWRvY3MuZG9qb3Rvb2xraXQub3JnL2RldmVsb3Blci9kZXNpZ24vbG9hZGVyI2xlZ2FjeS1jcm9zcy1kb21haW4tbW9kZSBmb3IgZGV0YWlscy5cblx0Ly9cblx0Ly8gVGhlIGZvbGxvd2luZyBjb21wdXRhdGlvbnMgY29udG9ydCB0aGUgcGFja2FnZU1hcCBmb3IgdGhpcyBkb2pvIGluc3RhbmNlIGludG8gYSBzY29wZU1hcC5cblx0dmFyIHNjb3BlTWFwID1cblx0XHRcdC8vIGEgbWFwIGZyb20gYSBuYW1lIHVzZWQgaW4gYSBsZWdhY3kgbW9kdWxlIHRvIHRoZSAoZ2xvYmFsIHZhcmlhYmxlIG5hbWUsIG9iamVjdCBhZGRyZXNzZWQgYnkgdGhhdCBuYW1lKVxuXHRcdFx0Ly8gYWx3YXlzIG1hcCBkb2pvLCBkaWppdCwgYW5kIGRvam94XG5cdFx0XHR7XG5cdFx0XHRcdGRvam86W1wiZG9qb1wiLCBkb2pvXSxcblx0XHRcdFx0ZGlqaXQ6W1wiZGlqaXRcIiwgZGlqaXRdLFxuXHRcdFx0XHRkb2pveDpbXCJkb2pveFwiLCBkb2pveF1cblx0XHRcdH0sXG5cblx0XHRwYWNrYWdlTWFwID1cblx0XHRcdC8vIHRoZSBwYWNrYWdlIG1hcCBmb3IgdGhpcyBkb2pvIGluc3RhbmNlOyBub3RlLCBhIGZvcmVpZ24gbG9hZGVyIG9yIG5vIHBhY2FrZ2VNYXAgcmVzdWx0cyBpbiB0aGUgYWJvdmUgZGVmYXVsdCBjb25maWdcblx0XHRcdChyZXF1aXJlLm1hcCAmJiByZXF1aXJlLm1hcFttb2R1bGUuaWQubWF0Y2goL1teXFwvXSsvKVswXV0pLFxuXG5cdFx0aXRlbTtcblxuXG5cdC8vIHByb2Nlc3MgYWxsIG1hcHBlZCB0b3AtbGV2ZWwgbmFtZXMgZm9yIHRoaXMgaW5zdGFuY2Ugb2YgZG9qb1xuXHRmb3IocCBpbiBwYWNrYWdlTWFwKXtcblx0XHRpZihzY29wZU1hcFtwXSl7XG5cdFx0XHQvLyBtYXBwZWQgZG9qbywgZGlqaXQsIG9yIGRvam94XG5cdFx0XHRzY29wZU1hcFtwXVswXSA9IHBhY2thZ2VNYXBbcF07XG5cdFx0fWVsc2V7XG5cdFx0XHQvLyBzb21lIG90aGVyIHRvcC1sZXZlbCBuYW1lXG5cdFx0XHRzY29wZU1hcFtwXSA9IFtwYWNrYWdlTWFwW3BdLCB7fV07XG5cdFx0fVxuXHR9XG5cblx0Ly8gcHVibGlzaCB0aG9zZSBuYW1lcyB0byBfc2NvcGVOYW1lIGFuZCwgb3B0aW9uYWxseSwgdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0Zm9yKHAgaW4gc2NvcGVNYXApe1xuXHRcdGl0ZW0gPSBzY29wZU1hcFtwXTtcblx0XHRpdGVtWzFdLl9zY29wZU5hbWUgPSBpdGVtWzBdO1xuXHRcdGlmKCFjb25maWcubm9HbG9iYWxzKXtcblx0XHRcdGdsb2JhbFtpdGVtWzBdXSA9IGl0ZW1bMV07XG5cdFx0fVxuXHR9XG5cdGRvam8uc2NvcGVNYXAgPSBzY29wZU1hcDtcblxuXHQvKj09PT09IGRvam8uX19kb2NQYXJzZXJDb25maWd1cmVTY29wZU1hcChzY29wZU1hcCk7ID09PT09Ki9cblxuXHQvLyBGSVhNRTogZG9qby5iYXNlVXJsIGFuZCBkb2pvLmNvbmZpZy5iYXNlVXJsIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cdGRvam8uYmFzZVVybCA9IGRvam8uY29uZmlnLmJhc2VVcmwgPSByZXF1aXJlLmJhc2VVcmw7XG5cdGRvam8uaXNBc3luYyA9ICFoYXMoXCJkb2pvLWxvYWRlclwiKSB8fCByZXF1aXJlLmFzeW5jO1xuXHRkb2pvLmxvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cblx0dmFyIHJldiA9IFwiJFJldjokXCIubWF0Y2goL1swLTlhLWZdezcsfS8pO1xuXHRkb2pvLnZlcnNpb24gPSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRWZXJzaW9uIG51bWJlciBvZiB0aGUgRG9qbyBUb29sa2l0XG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SGFzaCBhYm91dCB0aGUgdmVyc2lvbiwgaW5jbHVkaW5nXG5cdFx0Ly9cblx0XHQvL1x0XHQtIG1ham9yOiBJbnRlZ2VyOiBNYWpvciB2ZXJzaW9uLiBJZiB0b3RhbCB2ZXJzaW9uIGlzIFwiMS4yLjBiZXRhMVwiLCB3aWxsIGJlIDFcblx0XHQvL1x0XHQtIG1pbm9yOiBJbnRlZ2VyOiBNaW5vciB2ZXJzaW9uLiBJZiB0b3RhbCB2ZXJzaW9uIGlzIFwiMS4yLjBiZXRhMVwiLCB3aWxsIGJlIDJcblx0XHQvL1x0XHQtIHBhdGNoOiBJbnRlZ2VyOiBQYXRjaCB2ZXJzaW9uLiBJZiB0b3RhbCB2ZXJzaW9uIGlzIFwiMS4yLjBiZXRhMVwiLCB3aWxsIGJlIDBcblx0XHQvL1x0XHQtIGZsYWc6IFN0cmluZzogRGVzY3JpcHRvciBmbGFnLiBJZiB0b3RhbCB2ZXJzaW9uIGlzIFwiMS4yLjBiZXRhMVwiLCB3aWxsIGJlIFwiYmV0YTFcIlxuXHRcdC8vXHRcdC0gcmV2aXNpb246IE51bWJlcjogVGhlIEdpdCByZXYgZnJvbSB3aGljaCBkb2pvIHdhcyBwdWxsZWRcblxuXHRcdG1ham9yOiAxLCBtaW5vcjogMTYsIHBhdGNoOiA1LCBmbGFnOiBcIlwiLFxuXHRcdHJldmlzaW9uOiByZXYgPyByZXZbMF0gOiBOYU4sXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdiA9IGRvam8udmVyc2lvbjtcblx0XHRcdHJldHVybiB2Lm1ham9yICsgXCIuXCIgKyB2Lm1pbm9yICsgXCIuXCIgKyB2LnBhdGNoICsgdi5mbGFnICsgXCIgKFwiICsgdi5yZXZpc2lvbiArIFwiKVwiO1x0Ly8gU3RyaW5nXG5cdFx0fVxuXHR9O1xuXG5cdC8vIElmIGhhcyhcImV4dGVuZC1kb2pvXCIpIGlzIHRydXRoeSwgdGhlbiBhcyBhIGRvam8gbW9kdWxlIGlzIGRlZmluZWQgaXQgc2hvdWxkIHB1c2ggaXQncyBkZWZpbml0aW9uc1xuXHQvLyBpbnRvIHRoZSBkb2pvIG9iamVjdCwgYW5kIGNvbnZlcnNlbHkuIEluIDIuMCwgaXQgd2lsbCBsaWtlbHkgYmUgdW51c3VhbCB0byBhdWdtZW50IGFub3RoZXIgb2JqZWN0XG5cdC8vIGFzIGEgcmVzdWx0IG9mIGRlZmluaW5nIGEgbW9kdWxlLiBUaGlzIGhhcyBmZWF0dXJlIGdpdmVzIGEgd2F5IHRvIGZvcmNlIDIuMCBiZWhhdmlvciBhcyB0aGUgY29kZVxuXHQvLyBpcyBtaWdyYXRlZC4gQWJzZW50IHNwZWNpZmljIGFkdmljZSBvdGhlcndpc2UsIHNldCBleHRlbmQtZG9qbyB0byB0cnV0aHkuXG5cdGhhcy5hZGQoXCJleHRlbmQtZG9qb1wiLCAxKTtcblxuXHRpZighaGFzKFwiY3NwLXJlc3RyaWN0aW9uc1wiKSl7XG5cdFx0KEZ1bmN0aW9uKFwiZFwiLCBcImQuZXZhbCA9IGZ1bmN0aW9uKCl7cmV0dXJuIGQuZ2xvYmFsLmV2YWwgPyBkLmdsb2JhbC5ldmFsKGFyZ3VtZW50c1swXSkgOiBldmFsKGFyZ3VtZW50c1swXSk7fVwiKSkoZG9qbyk7XG5cdH1cblx0Lyo9PT09PVxuXHRkb2pvLmV2YWwgPSBmdW5jdGlvbihzY3JpcHRUZXh0KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgbGVnYWN5IG1ldGhvZCBjcmVhdGVkIGZvciB1c2UgZXhjbHVzaXZlbHkgYnkgaW50ZXJuYWwgRG9qbyBtZXRob2RzLiBEbyBub3QgdXNlIHRoaXMgbWV0aG9kXG5cdFx0Ly9cdFx0ZGlyZWN0bHkgdW5sZXNzIHlvdSB1bmRlcnN0YW5kIGl0cyBwb3NzaWJseS1kaWZmZXJlbnQgaW1wbGljYXRpb25zIG9uIHRoZSBwbGF0Zm9ybXMgeW91ciBhcmUgdGFyZ2V0aW5nLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdE1ha2VzIGFuIGF0dGVtcHQgdG8gZXZhbHVhdGUgc2NyaXB0VGV4dCBpbiB0aGUgZ2xvYmFsIHNjb3BlLiBUaGUgZnVuY3Rpb24gd29ya3MgY29ycmVjdGx5IGZvciBicm93c2Vyc1xuXHRcdC8vXHRcdHRoYXQgc3VwcG9ydCBpbmRpcmVjdCBldmFsLlxuXHRcdC8vXG5cdFx0Ly9cdFx0QXMgdXN1YWwsIElFIGRvZXMgbm90LiBPbiBJRSwgdGhlIG9ubHkgd2F5IHRvIGltcGxlbWVudCBnbG9iYWwgZXZhbCBpcyB0b1xuXHRcdC8vXHRcdHVzZSBleGVjU2NyaXB0LiBVbmZvcnR1bmF0ZWx5LCBleGVjU2NyaXB0IGRvZXMgbm90IHJldHVybiBhIHZhbHVlIGFuZCBicmVha3Mgc29tZSBjdXJyZW50IHVzYWdlcyBvZiBkb2pvLmV2YWwuXG5cdFx0Ly9cdFx0VGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB0ZWNobmlxdWUgb2YgZXhlY3V0aW5nIGV2YWwgaW4gdGhlIHNjb3BlIG9mIGEgZnVuY3Rpb24gdGhhdCBpcyBhIHNpbmdsZSBzY29wZVxuXHRcdC8vXHRcdGZyYW1lIGJlbG93IHRoZSBnbG9iYWwgc2NvcGU7IHRoZXJlYnkgY29taW5nIGNsb3NlIHRvIHRoZSBnbG9iYWwgc2NvcGUuIE5vdGUgY2FyZWZ1bGx5IHRoYXRcblx0XHQvL1xuXHRcdC8vXHRcdGRvam8uZXZhbChcInZhciBwaSA9IDMuMTQ7XCIpO1xuXHRcdC8vXG5cdFx0Ly9cdFx0d2lsbCBkZWZpbmUgZ2xvYmFsIHBpIGluIG5vbi1JRSBlbnZpcm9ubWVudHMsIGJ1dCBkZWZpbmUgcGkgb25seSBpbiBhIHRlbXBvcmFyeSBsb2NhbCBzY29wZSBmb3IgSUUuIElmIHlvdSB3YW50XG5cdFx0Ly9cdFx0dG8gZGVmaW5lIGEgZ2xvYmFsIHZhcmlhYmxlIHVzaW5nIGRvam8uZXZhbCwgd3JpdGUgc29tZXRoaW5nIGxpa2Vcblx0XHQvL1xuXHRcdC8vXHRcdGRvam8uZXZhbChcIndpbmRvdy5waSA9IDMuMTQ7XCIpXG5cdFx0Ly8gc2NyaXB0VGV4dDpcblx0XHQvL1x0XHRUaGUgdGV4dCB0byBldmFsdWF0aW9uLlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0VGhlIHJlc3VsdCBvZiB0aGUgZXZhbHVhdGlvbi4gT2Z0ZW4gYHVuZGVmaW5lZGBcblx0fTtcblx0PT09PT0qL1xuXG5cblx0aWYoaGFzKFwiaG9zdC1yaGlub1wiKSl7XG5cdFx0ZG9qby5leGl0ID0gZnVuY3Rpb24oZXhpdGNvZGUpe1xuXHRcdFx0cXVpdChleGl0Y29kZSk7XG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0ZG9qby5leGl0ID0gZnVuY3Rpb24oKXtcblx0XHR9O1xuXHR9XG5cblx0aWYoIWhhcyhcImhvc3Qtd2Vid29ya2VyXCIpKXtcblx0XHQvLyBjb25zb2xlIGlzIGltbXV0YWJsZSBpbiBGRjMwKywgaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTgxMDBcblx0XHRoYXMuYWRkKFwiZG9qby1ndWFyYW50ZWUtY29uc29sZVwiLFxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgY29uc29sZS5sb2csIGNvbnNvbGUud2FybiwgZXRjLiBhcmUgZGVmaW5lZFxuXHRcdFx0MVxuXHRcdCk7XG5cdH1cblxuXHRpZihoYXMoXCJkb2pvLWd1YXJhbnRlZS1jb25zb2xlXCIpKXtcblx0XHQvLyBJRSA5IGJ1ZzogaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTgxOTdcblx0XHRoYXMuYWRkKFwiY29uc29sZS1hcy1vYmplY3RcIiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSBcIm9iamVjdFwiO1xuXHRcdH0pO1xuXG5cdFx0dHlwZW9mIGNvbnNvbGUgIT0gXCJ1bmRlZmluZWRcIiB8fCAoY29uc29sZSA9IHt9KTsgIC8vIGludGVudGlvbmFsIGFzc2lnbm1lbnRcblx0XHQvL1x0QmUgY2FyZWZ1bCB0byBsZWF2ZSAnbG9nJyBhbHdheXMgYXQgdGhlIGVuZFxuXHRcdHZhciBjbiA9IFtcblx0XHRcdFwiYXNzZXJ0XCIsIFwiY291bnRcIiwgXCJkZWJ1Z1wiLCBcImRpclwiLCBcImRpcnhtbFwiLCBcImVycm9yXCIsIFwiZ3JvdXBcIixcblx0XHRcdFwiZ3JvdXBFbmRcIiwgXCJpbmZvXCIsIFwicHJvZmlsZVwiLCBcInByb2ZpbGVFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiLFxuXHRcdFx0XCJ0cmFjZVwiLCBcIndhcm5cIiwgXCJsb2dcIlxuXHRcdF07XG5cdFx0dmFyIHRuO1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlKCh0biA9IGNuW2krK10pKXtcblx0XHRcdGlmKCFjb25zb2xlW3RuXSl7XG5cdFx0XHRcdChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciB0Y24gPSB0biArIFwiXCI7XG5cdFx0XHRcdFx0Y29uc29sZVt0Y25dID0gKCdsb2cnIGluIGNvbnNvbGUpID8gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdHZhciBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGEudW5zaGlmdCh0Y24gKyBcIjpcIik7XG5cdFx0XHRcdFx0XHRjb25zb2xlW1wibG9nXCJdKGEuam9pbihcIiBcIikpO1xuXHRcdFx0XHRcdH0gOiBmdW5jdGlvbigpe307XG5cdFx0XHRcdFx0Y29uc29sZVt0Y25dLl9mYWtlID0gdHJ1ZTtcblx0XHRcdFx0fSkoKTtcblx0XHRcdH1lbHNlIGlmKGhhcyhcImNvbnNvbGUtYXMtb2JqZWN0XCIpKXtcblx0XHRcdFx0Y29uc29sZVt0bl0gPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGVbdG5dLCBjb25zb2xlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRoYXMuYWRkKFwiZG9qby1kZWJ1Zy1tZXNzYWdlc1wiLFxuXHRcdC8vIGluY2x1ZGUgZG9qby5kZXByZWNhdGVkL2Rvam8uZXhwZXJpbWVudGFsIGltcGxlbWVudGF0aW9uc1xuXHRcdCEhY29uZmlnLmlzRGVidWdcblx0KTtcblx0ZG9qby5kZXByZWNhdGVkID0gZG9qby5leHBlcmltZW50YWwgPSAgZnVuY3Rpb24oKXt9O1xuXHRpZihoYXMoXCJkb2pvLWRlYnVnLW1lc3NhZ2VzXCIpKXtcblx0XHRkb2pvLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbigvKlN0cmluZyovIGJlaGF2aW91ciwgLypTdHJpbmc/Ki8gZXh0cmEsIC8qU3RyaW5nPyovIHJlbW92YWwpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdExvZyBhIGRlYnVnIG1lc3NhZ2UgdG8gaW5kaWNhdGUgdGhhdCBhIGJlaGF2aW9yIGhhcyBiZWVuXG5cdFx0XHQvL1x0XHRkZXByZWNhdGVkLlxuXHRcdFx0Ly8gYmVoYXZpb3VyOiBTdHJpbmdcblx0XHRcdC8vXHRcdFRoZSBBUEkgb3IgYmVoYXZpb3IgYmVpbmcgZGVwcmVjYXRlZC4gVXN1YWxseSBpbiB0aGUgZm9ybVxuXHRcdFx0Ly9cdFx0b2YgXCJteUFwcC5zb21lRnVuY3Rpb24oKVwiLlxuXHRcdFx0Ly8gZXh0cmE6IFN0cmluZz9cblx0XHRcdC8vXHRcdFRleHQgdG8gYXBwZW5kIHRvIHRoZSBtZXNzYWdlLiBPZnRlbiBwcm92aWRlcyBhZHZpY2Ugb24gYVxuXHRcdFx0Ly9cdFx0bmV3IGZ1bmN0aW9uIG9yIGZhY2lsaXR5IHRvIGFjaGlldmUgdGhlIHNhbWUgZ29hbCBkdXJpbmdcblx0XHRcdC8vXHRcdHRoZSBkZXByZWNhdGlvbiBwZXJpb2QuXG5cdFx0XHQvLyByZW1vdmFsOiBTdHJpbmc/XG5cdFx0XHQvL1x0XHRUZXh0IHRvIGluZGljYXRlIHdoZW4gaW4gdGhlIGZ1dHVyZSB0aGUgYmVoYXZpb3Igd2lsbCBiZVxuXHRcdFx0Ly9cdFx0cmVtb3ZlZC4gVXN1YWxseSBhIHZlcnNpb24gbnVtYmVyLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IGRvam8uZGVwcmVjYXRlZChcIm15QXBwLmdldFRlbXAoKVwiLCBcInVzZSBteUFwcC5nZXRMb2NhbGVUZW1wKCkgaW5zdGVhZFwiLCBcIjEuMFwiKTtcblxuXHRcdFx0dmFyIG1lc3NhZ2UgPSBcIkRFUFJFQ0FURUQ6IFwiICsgYmVoYXZpb3VyO1xuXHRcdFx0aWYoZXh0cmEpeyBtZXNzYWdlICs9IFwiIFwiICsgZXh0cmE7IH1cblx0XHRcdGlmKHJlbW92YWwpeyBtZXNzYWdlICs9IFwiIC0tIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uOiBcIiArIHJlbW92YWw7IH1cblx0XHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcblx0XHR9O1xuXG5cdFx0ZG9qby5leHBlcmltZW50YWwgPSBmdW5jdGlvbigvKiBTdHJpbmcgKi8gbW9kdWxlTmFtZSwgLyogU3RyaW5nPyAqLyBleHRyYSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0TWFya3MgY29kZSBhcyBleHBlcmltZW50YWwuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFyayBhIGZ1bmN0aW9uLCBmaWxlLCBvciBtb2R1bGUgYXNcblx0XHRcdC8vXHRcdGV4cGVyaW1lbnRhbC5cdCBFeHBlcmltZW50YWwgY29kZSBpcyBub3QgcmVhZHkgdG8gYmUgdXNlZCwgYW5kIHRoZVxuXHRcdFx0Ly9cdFx0QVBJcyBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXHRFeHBlcmltZW50YWwgY29kZSBtYXkgYmVcblx0XHRcdC8vXHRcdGNvbXBsZXRlZCBkZWxldGVkIHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGRlcHJlY2F0aW9uXG5cdFx0XHQvL1x0XHRwcm9jZXNzLlxuXHRcdFx0Ly8gbW9kdWxlTmFtZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRUaGUgbmFtZSBvZiBhIG1vZHVsZSwgb3IgdGhlIG5hbWUgb2YgYSBtb2R1bGUgZmlsZSBvciBhIHNwZWNpZmljXG5cdFx0XHQvL1x0XHRmdW5jdGlvblxuXHRcdFx0Ly8gZXh0cmE6IFN0cmluZz9cblx0XHRcdC8vXHRcdHNvbWUgYWRkaXRpb25hbCBtZXNzYWdlIGZvciB0aGUgdXNlclxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IGRvam8uZXhwZXJpbWVudGFsKFwiZG9qby5kYXRhLlJlc3VsdFwiKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fCBkb2pvLmV4cGVyaW1lbnRhbChcImRvam8ud2VhdGhlci50b0tlbHZpbigpXCIsIFwiUEVORElORyBhcHByb3ZhbCBmcm9tIE5PQUFcIik7XG5cblx0XHRcdHZhciBtZXNzYWdlID0gXCJFWFBFUklNRU5UQUw6IFwiICsgbW9kdWxlTmFtZSArIFwiIC0tIEFQSXMgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXCI7XG5cdFx0XHRpZihleHRyYSl7IG1lc3NhZ2UgKz0gXCIgXCIgKyBleHRyYTsgfVxuXHRcdFx0Y29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXHRcdH07XG5cdH1cblxuXHRoYXMuYWRkKFwiZG9qby1tb2R1bGVQYXRoc1wiLFxuXHRcdC8vIGNvbnN1bWUgZG9qby5tb2R1bGVQYXRocyBwcm9jZXNzaW5nXG5cdFx0MVxuXHQpO1xuXHRpZihoYXMoXCJkb2pvLW1vZHVsZVBhdGhzXCIpKXtcblx0XHQvLyBub3RpY2UgdGhhdCBtb2R1bGVQYXRocyB3b24ndCBiZSBhcHBsaWVkIHRvIGFueSByZXF1aXJlJ3MgYmVmb3JlIHRoZSBkb2pvL19iYXNlL2tlcm5lbCBmYWN0b3J5IGlzIHJ1bjtcblx0XHQvLyB0aGlzIGlzIHRoZSB2MS42LSBiZWhhdmlvci5cblx0XHRpZihjb25maWcubW9kdWxlUGF0aHMpe1xuXHRcdFx0ZG9qby5kZXByZWNhdGVkKFwiZG9qby5tb2R1bGVQYXRoc1wiLCBcInVzZSBwYXRocyBjb25maWd1cmF0aW9uXCIpO1xuXHRcdFx0dmFyIHBhdGhzID0ge307XG5cdFx0XHRmb3IocCBpbiBjb25maWcubW9kdWxlUGF0aHMpe1xuXHRcdFx0XHRwYXRoc1twLnJlcGxhY2UoL1xcLi9nLCBcIi9cIildID0gY29uZmlnLm1vZHVsZVBhdGhzW3BdO1xuXHRcdFx0fVxuXHRcdFx0cmVxdWlyZSh7cGF0aHM6cGF0aHN9KTtcblx0XHR9XG5cdH1cblxuXHRoYXMuYWRkKFwiZG9qby1tb2R1bGVVcmxcIixcblx0XHQvLyBpbmNsdWRlIGRvam8ubW9kdWxlVXJsXG5cdFx0MVxuXHQpO1xuXHRpZihoYXMoXCJkb2pvLW1vZHVsZVVybFwiKSl7XG5cdFx0ZG9qby5tb2R1bGVVcmwgPSBmdW5jdGlvbigvKlN0cmluZyovbW9kdWxlLCAvKlN0cmluZz8qL3VybCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIFVSTCByZWxhdGl2ZSB0byBhIG1vZHVsZS5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0dmFyIHBuZ1BhdGggPSBkb2pvLm1vZHVsZVVybChcImFjbWVcIixcImltYWdlcy9zbWFsbC5wbmdcIik7XG5cdFx0XHQvL1x0fFx0Y29uc29sZS5kaXIocG5nUGF0aCk7IC8vIGxpc3QgdGhlIG9iamVjdCBwcm9wZXJ0aWVzXG5cdFx0XHQvL1x0fFx0Ly8gY3JlYXRlIGFuIGltYWdlIGFuZCBzZXQgaXQncyBzb3VyY2UgdG8gcG5nUGF0aCdzIHZhbHVlOlxuXHRcdFx0Ly9cdHxcdHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0Ly9cdHxcdGltZy5zcmMgPSBwbmdQYXRoO1xuXHRcdFx0Ly9cdHxcdC8vIGFkZCBvdXIgaW1hZ2UgdG8gdGhlIGRvY3VtZW50XG5cdFx0XHQvL1x0fFx0ZG9qby5ib2R5KCkuYXBwZW5kQ2hpbGQoaW1nKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR5b3UgbWF5IGRlLXJlZmVyZW5jZSBhcyBmYXIgYXMgeW91IGxpa2UgZG93biB0aGUgcGFja2FnZVxuXHRcdFx0Ly9cdFx0aGllcmFyY2h5LiAgVGhpcyBpcyBzb21ldGltZXMgaGFuZHkgdG8gYXZvaWQgbGVuZ3RoeSByZWxhdGl2ZVxuXHRcdFx0Ly9cdFx0dXJscyBvciBmb3IgYnVpbGRpbmcgcG9ydGFibGUgc3ViLXBhY2thZ2VzLiBJbiB0aGlzIGV4YW1wbGUsXG5cdFx0XHQvL1x0XHR0aGUgYGFjbWUud2lkZ2V0YCBhbmQgYGFjbWUudXRpbGAgZGlyZWN0b3JpZXMgbWF5IGJlIGxvY2F0ZWRcblx0XHRcdC8vXHRcdHVuZGVyIGRpZmZlcmVudCByb290cyAoc2VlIGBkb2pvLnJlZ2lzdGVyTW9kdWxlUGF0aGApIGJ1dCB0aGVcblx0XHRcdC8vXHRcdHRoZSBtb2R1bGVzIHdoaWNoIHJlZmVyZW5jZSB0aGVtIGNhbiBiZSB1bmF3YXJlIG9mIHRoZWlyXG5cdFx0XHQvL1x0XHRyZWxhdGl2ZSBsb2NhdGlvbnMgb24gdGhlIGZpbGVzeXN0ZW06XG5cdFx0XHQvL1x0fFx0Ly8gc29tZXdoZXJlIGluIGEgY29uZmlndXJhdGlvbiBibG9ja1xuXHRcdFx0Ly9cdHxcdGRvam8ucmVnaXN0ZXJNb2R1bGVQYXRoKFwiYWNtZS53aWRnZXRcIiwgXCIuLi8uLi9hY21lL3dpZGdldFwiKTtcblx0XHRcdC8vXHR8XHRkb2pvLnJlZ2lzdGVyTW9kdWxlUGF0aChcImFjbWUudXRpbFwiLCBcIi4uLy4uL3V0aWxcIik7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdC8vIC4uLlxuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8XHQvLyBjb2RlIGluIGEgbW9kdWxlIHVzaW5nIGFjbWUgcmVzb3VyY2VzXG5cdFx0XHQvL1x0fFx0dmFyIHRtcGx0UGF0aCA9IGRvam8ubW9kdWxlVXJsKFwiYWNtZS53aWRnZXRcIixcInRlbXBsYXRlcy90ZW1wbGF0ZS5odG1sXCIpO1xuXHRcdFx0Ly9cdHxcdHZhciBkYXRhUGF0aCA9IGRvam8ubW9kdWxlVXJsKFwiYWNtZS51dGlsXCIsXCJyZXNvdXJjZXMvZGF0YS5qc29uXCIpO1xuXG5cdFx0XHRkb2pvLmRlcHJlY2F0ZWQoXCJkb2pvLm1vZHVsZVVybCgpXCIsIFwidXNlIHJlcXVpcmUudG9VcmxcIiwgXCIyLjBcIik7XG5cblx0XHRcdC8vIHJlcXVpcmUudG9VcmwgcmVxdWlyZXMgYSBmaWxldHlwZTsgdGhlcmVmb3JlLCBqdXN0IGFwcGVuZCB0aGUgc3VmZml4IFwiLyouKlwiIHRvIGd1YXJhbnRlZSBhIGZpbGV0eXBlLCB0aGVuXG5cdFx0XHQvLyByZW1vdmUgdGhlIHN1ZmZpeCBmcm9tIHRoZSByZXN1bHQuIFRoaXMgd2F5IGNsaWVudHMgY2FuIHJlcXVlc3QgYSB1cmwgdy9vdXQgYSBmaWxldHlwZS4gVGhpcyBzaG91bGQgYmVcblx0XHRcdC8vIHJhcmUsIGJ1dCBpdCBtYWludGFpbnMgYmFja2NvbXBhdCBmb3IgdGhlIHYxLnggbGluZSAobm90ZTogZG9qby5tb2R1bGVVcmwgd2lsbCBiZSByZW1vdmVkIGluIHYyLjApLlxuXHRcdFx0Ly8gTm90aWNlICogaXMgYW4gaWxsZWdhbCBmaWxlbmFtZSBzbyBpdCB3b24ndCBjb25mbGljdCB3aXRoIGFueSByZWFsIHBhdGggbWFwIHRoYXQgbWF5IGV4aXN0IHRoZSBwYXRocyBjb25maWcuXG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0XHRcdGlmKG1vZHVsZSl7XG5cdFx0XHRcdHJlc3VsdCA9IHJlcXVpcmUudG9VcmwobW9kdWxlLnJlcGxhY2UoL1xcLi9nLCBcIi9cIikgKyAodXJsID8gKFwiL1wiICsgdXJsKSA6IFwiXCIpICsgXCIvKi4qXCIpLnJlcGxhY2UoL1xcL1xcKlxcLlxcKi8sIFwiXCIpICsgKHVybCA/IFwiXCIgOiBcIi9cIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH1cblxuXHRkb2pvLl9oYXNSZXNvdXJjZSA9IHt9OyAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGxheWVycyBidWlsdCB3aXRoIDEuNiB0b29saW5nXG5cblx0cmV0dXJuIGRvam87XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4uL2hhc1wiLCBcIi4uL3NuaWZmXCJdLCBmdW5jdGlvbihkb2pvLCBoYXMpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vX2Jhc2UvbGFuZ1xuXG5cdGhhcy5hZGQoXCJidWctZm9yLWluLXNraXBzLXNoYWRvd2VkXCIsIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gaWYgdHJ1ZSwgdGhlIGZvci1pbiBpdGVyYXRvciBza2lwcyBvYmplY3QgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIE9iamVjdCdzIHByb3RvdHlwZSAoSUUgNiAtID8pXG5cdFx0Zm9yKHZhciBpIGluIHt0b1N0cmluZzogMX0pe1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdHJldHVybiAxO1xuXHR9KTtcblxuXHQvLyBIZWxwZXIgbWV0aG9kc1xuXHR2YXIgX2V4dHJhTmFtZXMgPVxuXHRcdFx0aGFzKFwiYnVnLWZvci1pbi1za2lwcy1zaGFkb3dlZFwiKSA/XG5cdFx0XHRcdFwiaGFzT3duUHJvcGVydHkudmFsdWVPZi5pc1Byb3RvdHlwZU9mLnByb3BlcnR5SXNFbnVtZXJhYmxlLnRvTG9jYWxlU3RyaW5nLnRvU3RyaW5nLmNvbnN0cnVjdG9yXCIuc3BsaXQoXCIuXCIpIDogW10sXG5cblx0XHRfZXh0cmFMZW4gPSBfZXh0cmFOYW1lcy5sZW5ndGgsXG5cblx0XHRnZXRQcm9wID0gZnVuY3Rpb24oLypBcnJheSovcGFydHMsIC8qQm9vbGVhbiovY3JlYXRlLCAvKk9iamVjdCovY29udGV4dCl7XG5cdFx0XHRpZighY29udGV4dCl7XG5cdFx0XHRcdGlmKHBhcnRzWzBdICYmIGRvam8uc2NvcGVNYXBbcGFydHNbMF1dKSB7XG5cdFx0XHRcdFx0Ly8gVm9vZG9vIGNvZGUgZnJvbSB0aGUgb2xkIGRheXMgd2hlcmUgXCJkb2pvXCIgb3IgXCJkaWppdFwiIG1hcHMgdG8gc29tZSBzcGVjaWFsIG9iamVjdFxuXHRcdFx0XHRcdC8vIHJhdGhlciB0aGFuIGp1c3Qgd2luZG93LmRvam9cblx0XHRcdFx0XHRjb250ZXh0ID0gZG9qby5zY29wZU1hcFtwYXJ0cy5zaGlmdCgpXVsxXTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGRvam8uZ2xvYmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRyeXtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHR2YXIgcCA9IHBhcnRzW2ldO1xuXHRcdFx0XHRcdC8vIEZpeCBmb3IgcHJvdG90eXBlIHBvbGx1dGlvbiBDVkUtMjAyMS0yMzQ1MFxuXHRcdFx0XHRcdGlmIChwID09PSAnX19wcm90b19fJyB8fCBwID09PSAnY29uc3RydWN0b3InKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCEocCBpbiBjb250ZXh0KSl7XG5cdFx0XHRcdFx0XHRpZihjcmVhdGUpe1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0W3BdID0ge307XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1x0XHQvLyByZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb250ZXh0OyAvLyBtaXhlZFxuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHQvLyBcInAgaW4gY29udGV4dFwiIHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBjb250ZXh0IGlzIGEgbnVtYmVyLCBib29sZWFuLCBldGMuIHJhdGhlciB0aGFuIGFuIG9iamVjdCxcblx0XHRcdFx0Ly8gc28gaW4gdGhhdCBjb3JuZXIgY2FzZSBqdXN0IHJldHVybiB1bmRlZmluZWQgKGJ5IGhhdmluZyBubyByZXR1cm4gc3RhdGVtZW50KVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvcHRzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcblxuXHRcdGVmZmljaWVudCA9IGZ1bmN0aW9uKG9iaiwgb2Zmc2V0LCBzdGFydFdpdGgpe1xuXHRcdFx0cmV0dXJuIChzdGFydFdpdGh8fFtdKS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCBvZmZzZXR8fDApKTtcblx0XHR9LFxuXG5cdFx0X3BhdHRlcm4gPSAvXFx7KFteXFx9XSspXFx9L2c7XG5cblx0Ly8gTW9kdWxlIGV4cG9ydFxuXHR2YXIgbGFuZyA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgSmF2YXNjcmlwdCBsYW5ndWFnZSBleHRlbnNpb25zLlxuXG5cdFx0Ly8gX2V4dHJhTmFtZXM6IFN0cmluZ1tdXG5cdFx0Ly9cdFx0TGlzdHMgcHJvcGVydHkgbmFtZXMgdGhhdCBtdXN0IGJlIGV4cGxpY2l0bHkgcHJvY2Vzc2VkIGR1cmluZyBmb3ItaW4gaXRlcmF0aW9uXG5cdFx0Ly9cdFx0aW4gZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBoYXMoXCJidWctZm9yLWluLXNraXBzLXNoYWRvd2VkXCIpIHRydWUuXG5cdFx0X2V4dHJhTmFtZXM6X2V4dHJhTmFtZXMsXG5cblx0XHRfbWl4aW46IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSwgY29weUZ1bmMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvcGllcy9hZGRzIGFsbCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSB0byBkZXN0OyByZXR1cm5zIGRlc3QuXG5cdFx0XHQvLyBkZXN0OiBPYmplY3Rcblx0XHRcdC8vXHRcdFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gY29weS9hZGQgYWxsIHByb3BlcnRpZXMgY29udGFpbmVkIGluIHNvdXJjZS5cblx0XHRcdC8vIHNvdXJjZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gZHJhdyBhbGwgcHJvcGVydGllcyB0byBjb3B5IGludG8gZGVzdC5cblx0XHRcdC8vIGNvcHlGdW5jOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdFRoZSBwcm9jZXNzIHVzZWQgdG8gY29weS9hZGQgYSBwcm9wZXJ0eSBpbiBzb3VyY2U7IGRlZmF1bHRzIHRvIHRoZSBKYXZhc2NyaXB0IGFzc2lnbm1lbnQgb3BlcmF0b3IuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0ZGVzdCwgYXMgbW9kaWZpZWRcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0QWxsIHByb3BlcnRpZXMsIGluY2x1ZGluZyBmdW5jdGlvbnMgKHNvbWV0aW1lcyB0ZXJtZWQgXCJtZXRob2RzXCIpLCBleGNsdWRpbmcgYW55IG5vbi1zdGFuZGFyZCBleHRlbnNpb25zXG5cdFx0XHQvL1x0XHRmb3VuZCBpbiBPYmplY3QucHJvdG90eXBlLCBhcmUgY29waWVkL2FkZGVkIHRvIGRlc3QuIENvcHlpbmcvYWRkaW5nIGVhY2ggcGFydGljdWxhciBwcm9wZXJ0eSBpc1xuXHRcdFx0Ly9cdFx0ZGVsZWdhdGVkIHRvIGNvcHlGdW5jIChpZiBhbnkpOyBjb3B5RnVuYyBkZWZhdWx0cyB0byB0aGUgSmF2YXNjcmlwdCBhc3NpZ25tZW50IG9wZXJhdG9yIGlmIG5vdCBwcm92aWRlZC5cblx0XHRcdC8vXHRcdE5vdGljZSB0aGF0IGJ5IGRlZmF1bHQsIF9taXhpbiBleGVjdXRlcyBhIHNvLWNhbGxlZCBcInNoYWxsb3cgY29weVwiIGFuZCBhZ2dyZWdhdGUgdHlwZXMgYXJlIGNvcGllZC9hZGRlZCBieSByZWZlcmVuY2UuXG5cdFx0XHR2YXIgbmFtZSwgcywgaSwgZW1wdHkgPSB7fTtcblx0XHRcdGZvcihuYW1lIGluIHNvdXJjZSl7XG5cdFx0XHRcdC8vIHRoZSAoIShuYW1lIGluIGVtcHR5KSB8fCBlbXB0eVtuYW1lXSAhPT0gcykgY29uZGl0aW9uIGF2b2lkcyBjb3B5aW5nIHByb3BlcnRpZXMgaW4gXCJzb3VyY2VcIlxuXHRcdFx0XHQvLyBpbmhlcml0ZWQgZnJvbSBPYmplY3QucHJvdG90eXBlLlx0IEZvciBleGFtcGxlLCBpZiBkZXN0IGhhcyBhIGN1c3RvbSB0b1N0cmluZygpIG1ldGhvZCxcblx0XHRcdFx0Ly8gZG9uJ3Qgb3ZlcndyaXRlIGl0IHdpdGggdGhlIHRvU3RyaW5nKCkgbWV0aG9kIHRoYXQgc291cmNlIGluaGVyaXRlZCBmcm9tIE9iamVjdC5wcm90b3R5cGVcblx0XHRcdFx0cyA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdFx0aWYoIShuYW1lIGluIGRlc3QpIHx8IChkZXN0W25hbWVdICE9PSBzICYmICghKG5hbWUgaW4gZW1wdHkpIHx8IGVtcHR5W25hbWVdICE9PSBzKSkpe1xuXHRcdFx0XHRcdGRlc3RbbmFtZV0gPSBjb3B5RnVuYyA/IGNvcHlGdW5jKHMpIDogcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihoYXMoXCJidWctZm9yLWluLXNraXBzLXNoYWRvd2VkXCIpKXtcblx0XHRcdFx0aWYoc291cmNlKXtcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBfZXh0cmFMZW47ICsraSl7XG5cdFx0XHRcdFx0XHRuYW1lID0gX2V4dHJhTmFtZXNbaV07XG5cdFx0XHRcdFx0XHRzID0gc291cmNlW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYoIShuYW1lIGluIGRlc3QpIHx8IChkZXN0W25hbWVdICE9PSBzICYmICghKG5hbWUgaW4gZW1wdHkpIHx8IGVtcHR5W25hbWVdICE9PSBzKSkpe1xuXHRcdFx0XHRcdFx0XHRkZXN0W25hbWVdID0gY29weUZ1bmMgPyBjb3B5RnVuYyhzKSA6IHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZXN0OyAvLyBPYmplY3Rcblx0XHR9LFxuXG5cdFx0bWl4aW46IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZXMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENvcGllcy9hZGRzIGFsbCBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZXMgdG8gZGVzdDsgcmV0dXJucyBkZXN0LlxuXHRcdFx0Ly8gZGVzdDogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgb2JqZWN0IHRvIHdoaWNoIHRvIGNvcHkvYWRkIGFsbCBwcm9wZXJ0aWVzIGNvbnRhaW5lZCBpbiBzb3VyY2UuIElmIGRlc3QgaXMgZmFsc3ksIHRoZW5cblx0XHRcdC8vXHRcdGEgbmV3IG9iamVjdCBpcyBtYW51ZmFjdHVyZWQgYmVmb3JlIGNvcHlpbmcvYWRkaW5nIHByb3BlcnRpZXMgYmVnaW5zLlxuXHRcdFx0Ly8gc291cmNlczogT2JqZWN0Li4uXG5cdFx0XHQvL1x0XHRPbmUgb2YgbW9yZSBvYmplY3RzIGZyb20gd2hpY2ggdG8gZHJhdyBhbGwgcHJvcGVydGllcyB0byBjb3B5IGludG8gZGVzdC4gc291cmNlcyBhcmUgcHJvY2Vzc2VkXG5cdFx0XHQvL1x0XHRsZWZ0LXRvLXJpZ2h0IGFuZCBpZiBtb3JlIHRoYW4gb25lIG9mIHRoZXNlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBwcm9wZXJ0eSBuYW1lLCB0aGUgcmlnaHQtbW9zdFxuXHRcdFx0Ly9cdFx0dmFsdWUgXCJ3aW5zXCIuXG5cdFx0XHQvLyByZXR1cm5zOiBPYmplY3Rcblx0XHRcdC8vXHRcdGRlc3QsIGFzIG1vZGlmaWVkXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFsbCBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgZnVuY3Rpb25zIChzb21ldGltZXMgdGVybWVkIFwibWV0aG9kc1wiKSwgZXhjbHVkaW5nIGFueSBub24tc3RhbmRhcmQgZXh0ZW5zaW9uc1xuXHRcdFx0Ly9cdFx0Zm91bmQgaW4gT2JqZWN0LnByb3RvdHlwZSwgYXJlIGNvcGllZC9hZGRlZCBmcm9tIHNvdXJjZXMgdG8gZGVzdC4gc291cmNlcyBhcmUgcHJvY2Vzc2VkIGxlZnQgdG8gcmlnaHQuXG5cdFx0XHQvL1x0XHRUaGUgSmF2YXNjcmlwdCBhc3NpZ25tZW50IG9wZXJhdG9yIGlzIHVzZWQgdG8gY29weS9hZGQgZWFjaCBwcm9wZXJ0eTsgdGhlcmVmb3JlLCBieSBkZWZhdWx0LCBtaXhpblxuXHRcdFx0Ly9cdFx0ZXhlY3V0ZXMgYSBzby1jYWxsZWQgXCJzaGFsbG93IGNvcHlcIiBhbmQgYWdncmVnYXRlIHR5cGVzIGFyZSBjb3BpZWQvYWRkZWQgYnkgcmVmZXJlbmNlLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdG1ha2UgYSBzaGFsbG93IGNvcHkgb2YgYW4gb2JqZWN0XG5cdFx0XHQvL1x0fFx0dmFyIGNvcHkgPSBsYW5nLm1peGluKHt9LCBzb3VyY2UpO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdG1hbnkgY2xhc3MgY29uc3RydWN0b3JzIG9mdGVuIHRha2UgYW4gb2JqZWN0IHdoaWNoIHNwZWNpZmllc1xuXHRcdFx0Ly9cdFx0dmFsdWVzIHRvIGJlIGNvbmZpZ3VyZWQgb24gdGhlIG9iamVjdC4gSW4gdGhpcyBjYXNlLCBpdCBpc1xuXHRcdFx0Ly9cdFx0b2Z0ZW4gc2ltcGxlc3QgdG8gY2FsbCBgbGFuZy5taXhpbmAgb24gdGhlIGB0aGlzYCBvYmplY3Q6XG5cdFx0XHQvL1x0fFx0ZGVjbGFyZShcImFjbWUuQmFzZVwiLCBudWxsLCB7XG5cdFx0XHQvL1x0fFx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ocHJvcGVydGllcyl7XG5cdFx0XHQvL1x0fFx0XHRcdC8vIHByb3BlcnR5IGNvbmZpZ3VyYXRpb246XG5cdFx0XHQvL1x0fFx0XHRcdGxhbmcubWl4aW4odGhpcywgcHJvcGVydGllcyk7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdFx0XHRjb25zb2xlLmxvZyh0aGlzLnF1aXApO1xuXHRcdFx0Ly9cdHxcdFx0XHQvL1x0Li4uXG5cdFx0XHQvL1x0fFx0XHR9LFxuXHRcdFx0Ly9cdHxcdFx0cXVpcDogXCJJIHdhc24ndCBib3JuIHllc3RlcmRheSwgeW91IGtub3cgLSBJJ3ZlIHNlZW4gbW92aWVzLlwiLFxuXHRcdFx0Ly9cdHxcdFx0Ly8gLi4uXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdC8vIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgYW5kIGNvbmZpZ3VyZSBpdFxuXHRcdFx0Ly9cdHxcdHZhciBiID0gbmV3IGFjbWUuQmFzZSh7cXVpcDogXCJUaGF0J3Mgd2hhdCBpdCBkb2VzIVwiIH0pO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdGNvcHkgaW4gcHJvcGVydGllcyBmcm9tIG11bHRpcGxlIG9iamVjdHNcblx0XHRcdC8vXHR8XHR2YXIgZmxhdHRlbmVkID0gbGFuZy5taXhpbihcblx0XHRcdC8vXHR8XHRcdHtcblx0XHRcdC8vXHR8XHRcdFx0bmFtZTogXCJGcnlsb2NrXCIsXG5cdFx0XHQvL1x0fFx0XHRcdGJyYWNlczogdHJ1ZVxuXHRcdFx0Ly9cdHxcdFx0fSxcblx0XHRcdC8vXHR8XHRcdHtcblx0XHRcdC8vXHR8XHRcdFx0bmFtZTogXCJDYXJsIEJydXRhbmFuYW5hZGlsZXdza2lcIlxuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cdHxcdCk7XG5cdFx0XHQvL1x0fFxuXHRcdFx0Ly9cdHxcdC8vIHdpbGwgcHJpbnQgXCJDYXJsIEJydXRhbmFuYW5hZGlsZXdza2lcIlxuXHRcdFx0Ly9cdHxcdGNvbnNvbGUubG9nKGZsYXR0ZW5lZC5uYW1lKTtcblx0XHRcdC8vXHR8XHQvLyB3aWxsIHByaW50IFwidHJ1ZVwiXG5cdFx0XHQvL1x0fFx0Y29uc29sZS5sb2coZmxhdHRlbmVkLmJyYWNlcyk7XG5cblx0XHRcdGlmKCFkZXN0KXsgZGVzdCA9IHt9OyB9XG5cdFx0XHRmb3IodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdGxhbmcuX21peGluKGRlc3QsIGFyZ3VtZW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVzdDsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdHNldE9iamVjdDogZnVuY3Rpb24obmFtZSwgdmFsdWUsIGNvbnRleHQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNldCBhIHByb3BlcnR5IGZyb20gYSBkb3Qtc2VwYXJhdGVkIHN0cmluZywgc3VjaCBhcyBcIkEuQi5DXCJcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VXNlZnVsIGZvciBsb25nZXIgYXBpIGNoYWlucyB3aGVyZSB5b3UgaGF2ZSB0byB0ZXN0IGVhY2ggb2JqZWN0IGluXG5cdFx0XHQvL1x0XHR0aGUgY2hhaW4sIG9yIHdoZW4geW91IGhhdmUgYW4gb2JqZWN0IHJlZmVyZW5jZSBpbiBzdHJpbmcgZm9ybWF0LlxuXHRcdFx0Ly9cdFx0T2JqZWN0cyBhcmUgY3JlYXRlZCBhcyBuZWVkZWQgYWxvbmcgYHBhdGhgLiBSZXR1cm5zIHRoZSBwYXNzZWRcblx0XHRcdC8vXHRcdHZhbHVlIGlmIHNldHRpbmcgaXMgc3VjY2Vzc2Z1bCBvciBgdW5kZWZpbmVkYCBpZiBub3QuXG5cdFx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHRcdC8vXHRcdFBhdGggdG8gYSBwcm9wZXJ0eSwgaW4gdGhlIGZvcm0gXCJBLkIuQ1wiLlxuXHRcdFx0Ly8gdmFsdWU6IGFueXRoaW5nXG5cdFx0XHQvL1x0XHR2YWx1ZSBvciBvYmplY3QgdG8gcGxhY2UgYXQgbG9jYXRpb24gZ2l2ZW4gYnkgbmFtZVxuXHRcdFx0Ly8gY29udGV4dDogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwuIE9iamVjdCB0byB1c2UgYXMgcm9vdCBvZiBwYXRoLiBEZWZhdWx0cyB0b1xuXHRcdFx0Ly9cdFx0YGRvam8uZ2xvYmFsYC5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRzZXQgdGhlIHZhbHVlIG9mIGBmb28uYmFyLmJhemAsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlclxuXHRcdFx0Ly9cdFx0aW50ZXJtZWRpYXRlIG9iamVjdHMgYWxyZWFkeSBleGlzdDpcblx0XHRcdC8vXHR8IGxhbmcuc2V0T2JqZWN0KFwiZm9vLmJhci5iYXpcIiwgdmFsdWUpO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdHdpdGhvdXQgYGxhbmcuc2V0T2JqZWN0YCwgd2Ugb2Z0ZW4gc2VlIGNvZGUgbGlrZSB0aGlzOlxuXHRcdFx0Ly9cdHwgLy8gZW5zdXJlIHRoYXQgaW50ZXJtZWRpYXRlIG9iamVjdHMgYXJlIGF2YWlsYWJsZVxuXHRcdFx0Ly9cdHwgaWYoIW9ialtcInBhcmVudFwiXSl7IG9iai5wYXJlbnQgPSB7fTsgfVxuXHRcdFx0Ly9cdHwgaWYoIW9iai5wYXJlbnRbXCJjaGlsZFwiXSl7IG9iai5wYXJlbnQuY2hpbGQgPSB7fTsgfVxuXHRcdFx0Ly9cdHwgLy8gbm93IHdlIGNhbiBzYWZlbHkgc2V0IHRoZSBwcm9wZXJ0eVxuXHRcdFx0Ly9cdHwgb2JqLnBhcmVudC5jaGlsZC5wcm9wID0gXCJzb21lIHZhbHVlXCI7XG5cdFx0XHQvL1x0XHR3aGVyZWFzIHdpdGggYGxhbmcuc2V0T2JqZWN0YCwgd2UgY2FuIHNob3J0ZW4gdGhhdCB0bzpcblx0XHRcdC8vXHR8IGxhbmcuc2V0T2JqZWN0KFwicGFyZW50LmNoaWxkLnByb3BcIiwgXCJzb21lIHZhbHVlXCIsIG9iaik7XG5cblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIuXCIpLCBwID0gcGFydHMucG9wKCksIG9iaiA9IGdldFByb3AocGFydHMsIHRydWUsIGNvbnRleHQpO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBwID8gKG9ialtwXSA9IHZhbHVlKSA6IHVuZGVmaW5lZDsgLy8gT2JqZWN0XG5cdFx0fSxcblxuXHRcdGdldE9iamVjdDogZnVuY3Rpb24obmFtZSwgY3JlYXRlLCBjb250ZXh0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRHZXQgYSBwcm9wZXJ0eSBmcm9tIGEgZG90LXNlcGFyYXRlZCBzdHJpbmcsIHN1Y2ggYXMgXCJBLkIuQ1wiXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFVzZWZ1bCBmb3IgbG9uZ2VyIGFwaSBjaGFpbnMgd2hlcmUgeW91IGhhdmUgdG8gdGVzdCBlYWNoIG9iamVjdCBpblxuXHRcdFx0Ly9cdFx0dGhlIGNoYWluLCBvciB3aGVuIHlvdSBoYXZlIGFuIG9iamVjdCByZWZlcmVuY2UgaW4gc3RyaW5nIGZvcm1hdC5cblx0XHRcdC8vIG5hbWU6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0UGF0aCB0byBhbiBwcm9wZXJ0eSwgaW4gdGhlIGZvcm0gXCJBLkIuQ1wiLlxuXHRcdFx0Ly8gY3JlYXRlOiBCb29sZWFuP1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwuIERlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCwgT2JqZWN0cyB3aWxsIGJlXG5cdFx0XHQvL1x0XHRjcmVhdGVkIGF0IGFueSBwb2ludCBhbG9uZyB0aGUgJ3BhdGgnIHRoYXQgaXMgdW5kZWZpbmVkLlxuXHRcdFx0Ly8gY29udGV4dDogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwuIE9iamVjdCB0byB1c2UgYXMgcm9vdCBvZiBwYXRoLiBEZWZhdWx0cyB0b1xuXHRcdFx0Ly9cdFx0J2Rvam8uZ2xvYmFsJy4gTnVsbCBtYXkgYmUgcGFzc2VkLlxuXHRcdFx0cmV0dXJuICFuYW1lID8gY29udGV4dCA6IGdldFByb3AobmFtZS5zcGxpdChcIi5cIiksIGNyZWF0ZSwgY29udGV4dCk7IC8vIE9iamVjdFxuXHRcdH0sXG5cblx0XHRleGlzdHM6IGZ1bmN0aW9uKG5hbWUsIG9iail7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0ZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBzdXBwb3J0cyBhIGdpdmVuIG1ldGhvZFxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHR1c2VmdWwgZm9yIGxvbmdlciBhcGkgY2hhaW5zIHdoZXJlIHlvdSBoYXZlIHRvIHRlc3QgZWFjaCBvYmplY3QgaW5cblx0XHRcdC8vXHRcdHRoZSBjaGFpbi4gVXNlZnVsIGZvciBvYmplY3QgYW5kIG1ldGhvZCBkZXRlY3Rpb24uXG5cdFx0XHQvLyBuYW1lOiBTdHJpbmdcblx0XHRcdC8vXHRcdFBhdGggdG8gYW4gb2JqZWN0LCBpbiB0aGUgZm9ybSBcIkEuQi5DXCIuXG5cdFx0XHQvLyBvYmo6IE9iamVjdD9cblx0XHRcdC8vXHRcdE9iamVjdCB0byB1c2UgYXMgcm9vdCBvZiBwYXRoLiBEZWZhdWx0cyB0b1xuXHRcdFx0Ly9cdFx0J2Rvam8uZ2xvYmFsJy4gTnVsbCBtYXkgYmUgcGFzc2VkLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8IC8vIGRlZmluZSBhbiBvYmplY3Rcblx0XHRcdC8vXHR8IHZhciBmb28gPSB7XG5cdFx0XHQvL1x0fFx0XHRiYXI6IHsgfVxuXHRcdFx0Ly9cdHwgfTtcblx0XHRcdC8vXHR8XG5cdFx0XHQvL1x0fCAvLyBzZWFyY2ggdGhlIGdsb2JhbCBzY29wZVxuXHRcdFx0Ly9cdHwgbGFuZy5leGlzdHMoXCJmb28uYmFyXCIpOyAvLyB0cnVlXG5cdFx0XHQvL1x0fCBsYW5nLmV4aXN0cyhcImZvby5iYXIuYmF6XCIpOyAvLyBmYWxzZVxuXHRcdFx0Ly9cdHxcblx0XHRcdC8vXHR8IC8vIHNlYXJjaCBmcm9tIGEgcGFydGljdWxhciBzY29wZVxuXHRcdFx0Ly9cdHwgbGFuZy5leGlzdHMoXCJiYXJcIiwgZm9vKTsgLy8gdHJ1ZVxuXHRcdFx0Ly9cdHwgbGFuZy5leGlzdHMoXCJiYXIuYmF6XCIsIGZvbyk7IC8vIGZhbHNlXG5cdFx0XHRyZXR1cm4gbGFuZy5nZXRPYmplY3QobmFtZSwgZmFsc2UsIG9iaikgIT09IHVuZGVmaW5lZDsgLy8gQm9vbGVhblxuXHRcdH0sXG5cblx0XHQvLyBDcm9ja2ZvcmQgKGlzaCkgZnVuY3Rpb25zXG5cblx0XHRpc1N0cmluZzogZnVuY3Rpb24oaXQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0cnVlIGlmIGl0IGlzIGEgU3RyaW5nXG5cdFx0XHQvLyBpdDogYW55dGhpbmdcblx0XHRcdC8vXHRcdEl0ZW0gdG8gdGVzdC5cblx0XHRcdHJldHVybiAodHlwZW9mIGl0ID09IFwic3RyaW5nXCIgfHwgaXQgaW5zdGFuY2VvZiBTdHJpbmcpOyAvLyBCb29sZWFuXG5cdFx0fSxcblxuXHRcdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oaXQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0cnVlIGlmIGl0IGlzIGFuIEFycmF5LlxuXHRcdFx0Ly8gaXQ6IGFueXRoaW5nXG5cdFx0XHQvL1x0XHRJdGVtIHRvIHRlc3QuXG5cdFx0XHRyZXR1cm4gb3B0cy5jYWxsKGl0KSA9PSBcIltvYmplY3QgQXJyYXldXCI7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0aXNGdW5jdGlvbjogZnVuY3Rpb24oaXQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybiB0cnVlIGlmIGl0IGlzIGEgRnVuY3Rpb25cblx0XHRcdC8vIGl0OiBhbnl0aGluZ1xuXHRcdFx0Ly9cdFx0SXRlbSB0byB0ZXN0LlxuXHRcdFx0cmV0dXJuIG9wdHMuY2FsbChpdCkgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcblx0XHR9LFxuXG5cdFx0aXNPYmplY3Q6IGZ1bmN0aW9uKGl0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRydWUgaWYgaXQgaXMgYSBKYXZhU2NyaXB0IG9iamVjdCAob3IgYW4gQXJyYXksIGEgRnVuY3Rpb25cblx0XHRcdC8vXHRcdG9yIG51bGwpXG5cdFx0XHQvLyBpdDogYW55dGhpbmdcblx0XHRcdC8vXHRcdEl0ZW0gdG8gdGVzdC5cblx0XHRcdHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdChpdCA9PT0gbnVsbCB8fCB0eXBlb2YgaXQgPT0gXCJvYmplY3RcIiB8fCBsYW5nLmlzQXJyYXkoaXQpIHx8IGxhbmcuaXNGdW5jdGlvbihpdCkpOyAvLyBCb29sZWFuXG5cdFx0fSxcblxuXHRcdGlzQXJyYXlMaWtlOiBmdW5jdGlvbihpdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0c2ltaWxhciB0byBpc0FycmF5KCkgYnV0IG1vcmUgcGVybWlzc2l2ZVxuXHRcdFx0Ly8gaXQ6IGFueXRoaW5nXG5cdFx0XHQvL1x0XHRJdGVtIHRvIHRlc3QuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0SWYgaXQgd2Fsa3MgbGlrZSBhIGR1Y2sgYW5kIHF1YWNrcyBsaWtlIGEgZHVjaywgcmV0dXJuIGB0cnVlYFxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHREb2Vzbid0IHN0cm9uZ2x5IHRlc3QgZm9yIFwiYXJyYXluZXNzXCIuICBJbnN0ZWFkLCBzZXR0bGVzIGZvciBcImlzbid0XG5cdFx0XHQvL1x0XHRhIHN0cmluZyBvciBudW1iZXIgYW5kIGhhcyBhIGxlbmd0aCBwcm9wZXJ0eVwiLiBBcmd1bWVudHMgb2JqZWN0c1xuXHRcdFx0Ly9cdFx0YW5kIERPTSBjb2xsZWN0aW9ucyB3aWxsIHJldHVybiB0cnVlIHdoZW4gcGFzc2VkIHRvXG5cdFx0XHQvL1x0XHRpc0FycmF5TGlrZSgpLCBidXQgd2lsbCByZXR1cm4gZmFsc2Ugd2hlbiBwYXNzZWQgdG9cblx0XHRcdC8vXHRcdGlzQXJyYXkoKS5cblx0XHRcdHJldHVybiAhIWl0ICYmIC8vIEJvb2xlYW5cblx0XHRcdFx0Ly8ga2VlcCBvdXQgYnVpbHQtaW4gY29uc3RydWN0b3JzIChOdW1iZXIsIFN0cmluZywgLi4uKSB3aGljaCBoYXZlIGxlbmd0aFxuXHRcdFx0XHQvLyBwcm9wZXJ0aWVzXG5cdFx0XHRcdCFsYW5nLmlzU3RyaW5nKGl0KSAmJiAhbGFuZy5pc0Z1bmN0aW9uKGl0KSAmJlxuXHRcdFx0XHQhKGl0LnRhZ05hbWUgJiYgaXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdmb3JtJykgJiZcblx0XHRcdFx0KGxhbmcuaXNBcnJheShpdCkgfHwgaXNGaW5pdGUoaXQubGVuZ3RoKSk7XG5cdFx0fSxcblxuXHRcdGlzQWxpZW46IGZ1bmN0aW9uKGl0KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIHRydWUgaWYgaXQgaXMgYSBidWlsdC1pbiBmdW5jdGlvbiBvciBzb21lIG90aGVyIGtpbmQgb2Zcblx0XHRcdC8vXHRcdG9kZGJhbGwgdGhhdCAqc2hvdWxkKiByZXBvcnQgYXMgYSBmdW5jdGlvbiBidXQgZG9lc24ndFxuXHRcdFx0cmV0dXJuIGl0ICYmICFsYW5nLmlzRnVuY3Rpb24oaXQpICYmIC9cXHtcXHMqXFxbbmF0aXZlIGNvZGVcXF1cXHMqXFx9Ly50ZXN0KFN0cmluZyhpdCkpOyAvLyBCb29sZWFuXG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oY3RvciwgcHJvcHMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgYWxsIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgcHJvcHMgdG8gY29uc3RydWN0b3Inc1xuXHRcdFx0Ly9cdFx0cHJvdG90eXBlLCBtYWtpbmcgdGhlbSBhdmFpbGFibGUgdG8gYWxsIGluc3RhbmNlcyBjcmVhdGVkIHdpdGhcblx0XHRcdC8vXHRcdGNvbnN0cnVjdG9yLlxuXHRcdFx0Ly8gY3RvcjogT2JqZWN0XG5cdFx0XHQvL1x0XHRUYXJnZXQgY29uc3RydWN0b3IgdG8gZXh0ZW5kLlxuXHRcdFx0Ly8gcHJvcHM6IE9iamVjdFxuXHRcdFx0Ly9cdFx0T25lIG9yIG1vcmUgb2JqZWN0cyB0byBtaXggaW50byBjdG9yLnByb3RvdHlwZVxuXHRcdFx0Zm9yKHZhciBpPTEsIGw9YXJndW1lbnRzLmxlbmd0aDsgaTxsOyBpKyspe1xuXHRcdFx0XHRsYW5nLl9taXhpbihjdG9yLnByb3RvdHlwZSwgYXJndW1lbnRzW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjdG9yOyAvLyBPYmplY3Rcblx0XHR9LFxuXG5cdFx0X2hpdGNoQXJnczogZnVuY3Rpb24oc2NvcGUsIG1ldGhvZCl7XG5cdFx0XHR2YXIgcHJlID0gbGFuZy5fdG9BcnJheShhcmd1bWVudHMsIDIpO1xuXHRcdFx0dmFyIG5hbWVkID0gbGFuZy5pc1N0cmluZyhtZXRob2QpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIGFycmF5aWZ5IGFyZ3VtZW50c1xuXHRcdFx0XHR2YXIgYXJncyA9IGxhbmcuX3RvQXJyYXkoYXJndW1lbnRzKTtcblx0XHRcdFx0Ly8gbG9jYXRlIG91ciBtZXRob2Rcblx0XHRcdFx0dmFyIGYgPSBuYW1lZCA/IChzY29wZXx8ZG9qby5nbG9iYWwpW21ldGhvZF0gOiBtZXRob2Q7XG5cdFx0XHRcdC8vIGludm9rZSB3aXRoIGNvbGxlY3RlZCBhcmdzXG5cdFx0XHRcdHJldHVybiBmICYmIGYuYXBwbHkoc2NvcGUgfHwgdGhpcywgcHJlLmNvbmNhdChhcmdzKSk7IC8vIG1peGVkXG5cdFx0XHR9OyAvLyBGdW5jdGlvblxuXHRcdH0sXG5cblx0XHRoaXRjaDogZnVuY3Rpb24oc2NvcGUsIG1ldGhvZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGV2ZXIgZXhlY3V0ZSBpbiB0aGUgZ2l2ZW4gc2NvcGUuXG5cdFx0XHQvL1x0XHRUaGlzIGFsbG93cyBmb3IgZWFzeSB1c2Ugb2Ygb2JqZWN0IG1lbWJlciBmdW5jdGlvbnNcblx0XHRcdC8vXHRcdGluIGNhbGxiYWNrcyBhbmQgb3RoZXIgcGxhY2VzIGluIHdoaWNoIHRoZSBcInRoaXNcIiBrZXl3b3JkIG1heVxuXHRcdFx0Ly9cdFx0b3RoZXJ3aXNlIG5vdCByZWZlcmVuY2UgdGhlIGV4cGVjdGVkIHNjb3BlLlxuXHRcdFx0Ly9cdFx0QW55IG51bWJlciBvZiBkZWZhdWx0IHBvc2l0aW9uYWwgYXJndW1lbnRzIG1heSBiZSBwYXNzZWQgYXMgcGFyYW1ldGVyc1xuXHRcdFx0Ly9cdFx0YmV5b25kIFwibWV0aG9kXCIuXG5cdFx0XHQvL1x0XHRFYWNoIG9mIHRoZXNlIHZhbHVlcyB3aWxsIGJlIHVzZWQgdG8gXCJwbGFjZWhvbGRcIiAoc2ltaWxhciB0byBjdXJyeSlcblx0XHRcdC8vXHRcdGZvciB0aGUgaGl0Y2hlZCBmdW5jdGlvbi5cblx0XHRcdC8vIHNjb3BlOiBPYmplY3Rcblx0XHRcdC8vXHRcdFRoZSBzY29wZSB0byB1c2Ugd2hlbiBtZXRob2QgZXhlY3V0ZXMuIElmIG1ldGhvZCBpcyBhIHN0cmluZyxcblx0XHRcdC8vXHRcdHNjb3BlIGlzIGFsc28gdGhlIG9iamVjdCBjb250YWluaW5nIG1ldGhvZC5cblx0XHRcdC8vIG1ldGhvZDogRnVuY3Rpb258U3RyaW5nLi4uXG5cdFx0XHQvL1x0XHRBIGZ1bmN0aW9uIHRvIGJlIGhpdGNoZWQgdG8gc2NvcGUsIG9yIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgaW5cblx0XHRcdC8vXHRcdHNjb3BlIHRvIGJlIGhpdGNoZWQuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdGxhbmcuaGl0Y2goZm9vLCBcImJhclwiKSgpO1xuXHRcdFx0Ly9cdFx0cnVucyBmb28uYmFyKCkgaW4gdGhlIHNjb3BlIG9mIGZvb1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHRsYW5nLmhpdGNoKGZvbywgbXlGdW5jdGlvbik7XG5cdFx0XHQvL1x0XHRyZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBydW5zIG15RnVuY3Rpb24gaW4gdGhlIHNjb3BlIG9mIGZvb1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEV4cGFuc2lvbiBvbiB0aGUgZGVmYXVsdCBwb3NpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgYWxvbmcgZnJvbVxuXHRcdFx0Ly9cdFx0aGl0Y2guIFBhc3NlZCBhcmdzIGFyZSBtaXhlZCBmaXJzdCwgYWRkaXRpb25hbCBhcmdzIGFmdGVyLlxuXHRcdFx0Ly9cdHxcdHZhciBmb28gPSB7IGJhcjogZnVuY3Rpb24oYSwgYiwgYyl7IGNvbnNvbGUubG9nKGEsIGIsIGMpOyB9IH07XG5cdFx0XHQvL1x0fFx0dmFyIGZuID0gbGFuZy5oaXRjaChmb28sIFwiYmFyXCIsIDEsIDIpO1xuXHRcdFx0Ly9cdHxcdGZuKDMpOyAvLyBsb2dzIFwiMSwgMiwgM1wiXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBmb28gPSB7IGJhcjogMiB9O1xuXHRcdFx0Ly9cdHxcdGxhbmcuaGl0Y2goZm9vLCBmdW5jdGlvbigpeyB0aGlzLmJhciA9IDEwOyB9KSgpO1xuXHRcdFx0Ly9cdFx0ZXhlY3V0ZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gaW4gc2NvcGUgb2YgZm9vXG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMil7XG5cdFx0XHRcdHJldHVybiBsYW5nLl9oaXRjaEFyZ3MuYXBwbHkoZG9qbywgYXJndW1lbnRzKTsgLy8gRnVuY3Rpb25cblx0XHRcdH1cblx0XHRcdGlmKCFtZXRob2Qpe1xuXHRcdFx0XHRtZXRob2QgPSBzY29wZTtcblx0XHRcdFx0c2NvcGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYobGFuZy5pc1N0cmluZyhtZXRob2QpKXtcblx0XHRcdFx0c2NvcGUgPSBzY29wZSB8fCBkb2pvLmdsb2JhbDtcblx0XHRcdFx0aWYoIXNjb3BlW21ldGhvZF0peyB0aHJvdyhbJ2xhbmcuaGl0Y2g6IHNjb3BlW1wiJywgbWV0aG9kLCAnXCJdIGlzIG51bGwgKHNjb3BlPVwiJywgc2NvcGUsICdcIiknXS5qb2luKCcnKSk7IH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBzY29wZVttZXRob2RdLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMgfHwgW10pOyB9OyAvLyBGdW5jdGlvblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICFzY29wZSA/IG1ldGhvZCA6IGZ1bmN0aW9uKCl7IHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyB8fCBbXSk7IH07IC8vIEZ1bmN0aW9uXG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlOiAoZnVuY3Rpb24oKXtcblx0XHRcdC8vIGJvb2RtYW4vY3JvY2tmb3JkIGRlbGVnYXRpb24gdy8gY29ybmZvcmQgb3B0aW1pemF0aW9uXG5cdFx0XHRmdW5jdGlvbiBUTVAoKXt9XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ob2JqLCBwcm9wcyl7XG5cdFx0XHRcdFRNUC5wcm90b3R5cGUgPSBvYmo7XG5cdFx0XHRcdHZhciB0bXAgPSBuZXcgVE1QKCk7XG5cdFx0XHRcdFRNUC5wcm90b3R5cGUgPSBudWxsO1xuXHRcdFx0XHRpZihwcm9wcyl7XG5cdFx0XHRcdFx0bGFuZy5fbWl4aW4odG1wLCBwcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRtcDsgLy8gT2JqZWN0XG5cdFx0XHR9O1xuXHRcdH0pKCksXG5cdFx0Lyo9PT09PVxuXHRcdGRlbGVnYXRlOiBmdW5jdGlvbihvYmosIHByb3BzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IG9iamVjdCB3aGljaCBcImxvb2tzXCIgdG8gb2JqIGZvciBwcm9wZXJ0aWVzIHdoaWNoIGl0XG5cdFx0XHQvL1x0XHRkb2VzIG5vdCBoYXZlIGEgdmFsdWUgZm9yLiBPcHRpb25hbGx5IHRha2VzIGEgYmFnIG9mIHByb3BlcnRpZXMgdG9cblx0XHRcdC8vXHRcdHNlZWQgdGhlIHJldHVybmVkIG9iamVjdCB3aXRoIGluaXRpYWxseS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBpcyBhIHNtYWxsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBCb29kbWFuL0Nyb2NrZm9yZCBkZWxlZ2F0aW9uXG5cdFx0XHQvL1x0XHRwYXR0ZXJuIGluIEphdmFTY3JpcHQuIEFuIGludGVybWVkaWF0ZSBvYmplY3QgY29uc3RydWN0b3IgbWVkaWF0ZXNcblx0XHRcdC8vXHRcdHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHRoZSByZXR1cm5lZCBvYmplY3QsIHVzaW5nIGl0IHRvIGRlbGVnYXRlXG5cdFx0XHQvL1x0XHRkb3duIHRvIG9iaiBmb3IgcHJvcGVydHkgbG9va3VwIHdoZW4gb2JqZWN0LWxvY2FsIGxvb2t1cCBmYWlscy5cblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHRob3VnaHQgb2Ygc2ltaWxhcmx5IHRvIEVTNCdzIFwid3JhcFwiLCBzYXZlIHRoYXQgaXQgZG9lc1xuXHRcdFx0Ly9cdFx0bm90IGFjdCBvbiB0eXBlcyBidXQgcmF0aGVyIG9uIHB1cmUgb2JqZWN0cy5cblx0XHRcdC8vIG9iajogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgb2JqZWN0IHRvIGRlbGVnYXRlIHRvIGZvciBwcm9wZXJ0aWVzIG5vdCBmb3VuZCBkaXJlY3RseSBvbiB0aGVcblx0XHRcdC8vXHRcdHJldHVybiBvYmplY3Qgb3IgaW4gcHJvcHMuXG5cdFx0XHQvLyBwcm9wczogT2JqZWN0Li4uXG5cdFx0XHQvL1x0XHRhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgcmV0dXJuZWQgb2JqZWN0XG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0YW4gT2JqZWN0IG9mIGFub255bW91cyB0eXBlXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHZhciBmb28gPSB7IGJhcjogXCJiYXpcIiB9O1xuXHRcdFx0Ly9cdHxcdHZhciB0aGluZ2VyID0gbGFuZy5kZWxlZ2F0ZShmb28sIHsgdGh1ZDogXCJ4eXp6eVwifSk7XG5cdFx0XHQvL1x0fFx0dGhpbmdlci5iYXIgPT0gXCJiYXpcIjsgLy8gZGVsZWdhdGVkIHRvIGZvb1xuXHRcdFx0Ly9cdHxcdGZvby50aHVkID09IHVuZGVmaW5lZDsgLy8gYnkgZGVmaW5pdGlvblxuXHRcdFx0Ly9cdHxcdHRoaW5nZXIudGh1ZCA9PSBcInh5enp5XCI7IC8vIG1peGVkIGluIGZyb20gcHJvcHNcblx0XHRcdC8vXHR8XHRmb28uYmFyID0gXCJ0aG9ua1wiO1xuXHRcdFx0Ly9cdHxcdHRoaW5nZXIuYmFyID09IFwidGhvbmtcIjsgLy8gc3RpbGwgZGVsZWdhdGVkIHRvIGZvbydzIGJhclxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0X3RvQXJyYXk6IGhhcyhcImllXCIpID9cblx0XHRcdChmdW5jdGlvbigpe1xuXHRcdFx0XHRmdW5jdGlvbiBzbG93KG9iaiwgb2Zmc2V0LCBzdGFydFdpdGgpe1xuXHRcdFx0XHRcdHZhciBhcnIgPSBzdGFydFdpdGh8fFtdO1xuXHRcdFx0XHRcdGZvcih2YXIgeCA9IG9mZnNldCB8fCAwOyB4IDwgb2JqLmxlbmd0aDsgeCsrKXtcblx0XHRcdFx0XHRcdGFyci5wdXNoKG9ialt4XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iail7XG5cdFx0XHRcdFx0cmV0dXJuICgob2JqLml0ZW0pID8gc2xvdyA6IGVmZmljaWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pKCkgOiBlZmZpY2llbnQsXG5cdFx0Lyo9PT09PVxuXHRcdCBfdG9BcnJheTogZnVuY3Rpb24ob2JqLCBvZmZzZXQsIHN0YXJ0V2l0aCl7XG5cdFx0XHQgLy8gc3VtbWFyeTpcblx0XHRcdCAvL1x0XHRDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoaS5lLiBhcmd1bWVudHMsIERPTUNvbGxlY3Rpb24pIHRvIGFuXG5cdFx0XHQgLy9cdFx0YXJyYXkuIFJldHVybnMgYSBuZXcgQXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgb2Ygb2JqLlxuXHRcdFx0IC8vIG9iajogT2JqZWN0XG5cdFx0XHQgLy9cdFx0dGhlIG9iamVjdCB0byBcImFycmF5aWZ5XCIuIFdlIGV4cGVjdCB0aGUgb2JqZWN0IHRvIGhhdmUsIGF0IGFcblx0XHRcdCAvL1x0XHRtaW5pbXVtLCBhIGxlbmd0aCBwcm9wZXJ0eSB3aGljaCBjb3JyZXNwb25kcyB0byBpbnRlZ2VyLWluZGV4ZWRcblx0XHRcdCAvL1x0XHRwcm9wZXJ0aWVzLlxuXHRcdFx0IC8vIG9mZnNldDogTnVtYmVyP1xuXHRcdFx0IC8vXHRcdHRoZSBsb2NhdGlvbiBpbiBvYmogdG8gc3RhcnQgaXRlcmF0aW5nIGZyb20uIERlZmF1bHRzIHRvIDAuXG5cdFx0XHQgLy9cdFx0T3B0aW9uYWwuXG5cdFx0XHQgLy8gc3RhcnRXaXRoOiBBcnJheT9cblx0XHRcdCAvL1x0XHRBbiBhcnJheSB0byBwYWNrIHdpdGggdGhlIHByb3BlcnRpZXMgb2Ygb2JqLiBJZiBwcm92aWRlZCxcblx0XHRcdCAvL1x0XHRwcm9wZXJ0aWVzIGluIG9iaiBhcmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBvZiBzdGFydFdpdGggYW5kXG5cdFx0XHQgLy9cdFx0c3RhcnRXaXRoIGlzIHRoZSByZXR1cm5lZCBhcnJheS5cblx0XHQgfSxcblx0XHQgPT09PT0qL1xuXG5cdFx0cGFydGlhbDogZnVuY3Rpb24oLypGdW5jdGlvbnxTdHJpbmcqLyBtZXRob2QgLyosIC4uLiovKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRzaW1pbGFyIHRvIGhpdGNoKCkgZXhjZXB0IHRoYXQgdGhlIHNjb3BlIG9iamVjdCBpcyBsZWZ0IHRvIGJlXG5cdFx0XHQvL1x0XHR3aGF0ZXZlciB0aGUgZXhlY3V0aW9uIGNvbnRleHQgZXZlbnR1YWxseSBiZWNvbWVzLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRDYWxsaW5nIGxhbmcucGFydGlhbCBpcyB0aGUgZnVuY3Rpb25hbCBlcXVpdmFsZW50IG9mIGNhbGxpbmc6XG5cdFx0XHQvL1x0XHR8XHRsYW5nLmhpdGNoKG51bGwsIGZ1bmNOYW1lLCAuLi4pO1xuXHRcdFx0Ly8gbWV0aG9kOlxuXHRcdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIHRvIFwid3JhcFwiXG5cdFx0XHR2YXIgYXJyID0gWyBudWxsIF07XG5cdFx0XHRyZXR1cm4gbGFuZy5oaXRjaC5hcHBseShkb2pvLCBhcnIuY29uY2F0KGxhbmcuX3RvQXJyYXkoYXJndW1lbnRzKSkpOyAvLyBGdW5jdGlvblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oLyphbnl0aGluZyovIHNyYyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2xvbmVzIG9iamVjdHMgKGluY2x1ZGluZyBET00gbm9kZXMpIGFuZCBhbGwgY2hpbGRyZW4uXG5cdFx0XHQvL1x0XHRXYXJuaW5nOiBkbyBub3QgY2xvbmUgY3ljbGljIHN0cnVjdHVyZXMuXG5cdFx0XHQvLyBzcmM6XG5cdFx0XHQvL1x0XHRUaGUgb2JqZWN0IHRvIGNsb25lXG5cdFx0XHRpZighc3JjIHx8IHR5cGVvZiBzcmMgIT0gXCJvYmplY3RcIiB8fCBsYW5nLmlzRnVuY3Rpb24oc3JjKSl7XG5cdFx0XHRcdC8vIG51bGwsIHVuZGVmaW5lZCwgYW55IG5vbi1vYmplY3QsIG9yIGZ1bmN0aW9uXG5cdFx0XHRcdHJldHVybiBzcmM7XHQvLyBhbnl0aGluZ1xuXHRcdFx0fVxuXHRcdFx0aWYoc3JjLm5vZGVUeXBlICYmIFwiY2xvbmVOb2RlXCIgaW4gc3JjKXtcblx0XHRcdFx0Ly8gRE9NIE5vZGVcblx0XHRcdFx0cmV0dXJuIHNyYy5jbG9uZU5vZGUodHJ1ZSk7IC8vIE5vZGVcblx0XHRcdH1cblx0XHRcdGlmKHNyYyBpbnN0YW5jZW9mIERhdGUpe1xuXHRcdFx0XHQvLyBEYXRlXG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZShzcmMuZ2V0VGltZSgpKTtcdC8vIERhdGVcblx0XHRcdH1cblx0XHRcdGlmKHNyYyBpbnN0YW5jZW9mIFJlZ0V4cCl7XG5cdFx0XHRcdC8vIFJlZ0V4cFxuXHRcdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cChzcmMpOyAgIC8vIFJlZ0V4cFxuXHRcdFx0fVxuXHRcdFx0dmFyIHIsIGksIGw7XG5cdFx0XHRpZihsYW5nLmlzQXJyYXkoc3JjKSl7XG5cdFx0XHRcdC8vIGFycmF5XG5cdFx0XHRcdHIgPSBbXTtcblx0XHRcdFx0Zm9yKGkgPSAwLCBsID0gc3JjLmxlbmd0aDsgaSA8IGw7ICsraSl7XG5cdFx0XHRcdFx0aWYoaSBpbiBzcmMpe1xuXHRcdFx0XHRcdFx0cltpXSA9IGxhbmcuY2xvbmUoc3JjW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gd2UgZG9uJ3QgY2xvbmUgZnVuY3Rpb25zIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG5cdFx0XHRcdC8vXHRcdH1lbHNlIGlmKGQuaXNGdW5jdGlvbihzcmMpKXtcblx0XHRcdFx0Ly9cdFx0XHQvLyBmdW5jdGlvblxuXHRcdFx0XHQvL1x0XHRcdHIgPSBmdW5jdGlvbigpeyByZXR1cm4gc3JjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gZ2VuZXJpYyBvYmplY3RzXG5cdFx0XHRcdHIgPSBzcmMuY29uc3RydWN0b3IgPyBuZXcgc3JjLmNvbnN0cnVjdG9yKCkgOiB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsYW5nLl9taXhpbihyLCBzcmMsIGxhbmcuY2xvbmUpO1xuXHRcdH0sXG5cblxuXHRcdHRyaW06IFN0cmluZy5wcm90b3R5cGUudHJpbSA/XG5cdFx0XHRmdW5jdGlvbihzdHIpeyByZXR1cm4gc3RyLnRyaW0oKTsgfSA6XG5cdFx0XHRmdW5jdGlvbihzdHIpeyByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpOyB9LFxuXHRcdC8qPT09PT1cblx0XHQgdHJpbTogZnVuY3Rpb24oc3RyKXtcblx0XHRcdCAvLyBzdW1tYXJ5OlxuXHRcdFx0IC8vXHRcdFRyaW1zIHdoaXRlc3BhY2UgZnJvbSBib3RoIHNpZGVzIG9mIHRoZSBzdHJpbmdcblx0XHRcdCAvLyBzdHI6IFN0cmluZ1xuXHRcdFx0IC8vXHRcdFN0cmluZyB0byBiZSB0cmltbWVkXG5cdFx0XHQgLy8gcmV0dXJuczogU3RyaW5nXG5cdFx0XHQgLy9cdFx0UmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmdcblx0XHRcdCAvLyBkZXNjcmlwdGlvbjpcblx0XHRcdCAvL1x0XHRUaGlzIHZlcnNpb24gb2YgdHJpbSgpIHdhcyBzZWxlY3RlZCBmb3IgaW5jbHVzaW9uIGludG8gdGhlIGJhc2UgZHVlXG5cdFx0XHQgLy9cdFx0dG8gaXRzIGNvbXBhY3Qgc2l6ZSBhbmQgcmVsYXRpdmVseSBnb29kIHBlcmZvcm1hbmNlXG5cdFx0XHQgLy9cdFx0KHNlZSBbU3RldmVuIExldml0aGFuJ3MgYmxvZ10oaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHQpXG5cdFx0XHQgLy9cdFx0VXNlcyBTdHJpbmcucHJvdG90eXBlLnRyaW0gaW5zdGVhZCwgaWYgYXZhaWxhYmxlLlxuXHRcdFx0IC8vXHRcdFRoZSBmYXN0ZXN0IGJ1dCBsb25nZXN0IHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiBpcyBsb2NhdGVkIGF0XG5cdFx0XHQgLy9cdFx0bGFuZy5zdHJpbmcudHJpbSgpXG5cdFx0IH0sXG5cdFx0ID09PT09Ki9cblxuXHRcdHJlcGxhY2U6IGZ1bmN0aW9uKHRtcGwsIG1hcCwgcGF0dGVybil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UGVyZm9ybXMgcGFyYW1ldGVyaXplZCBzdWJzdGl0dXRpb25zIG9uIGEgc3RyaW5nLiBUaHJvd3MgYW5cblx0XHRcdC8vXHRcdGV4Y2VwdGlvbiBpZiBhbnkgcGFyYW1ldGVyIGlzIHVubWF0Y2hlZC5cblx0XHRcdC8vIHRtcGw6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0U3RyaW5nIHRvIGJlIHVzZWQgYXMgYSB0ZW1wbGF0ZS5cblx0XHRcdC8vIG1hcDogT2JqZWN0fEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRJZiBhbiBvYmplY3QsIGl0IGlzIHVzZWQgYXMgYSBkaWN0aW9uYXJ5IHRvIGxvb2sgdXAgc3Vic3RpdHV0aW9ucy5cblx0XHRcdC8vXHRcdElmIGEgZnVuY3Rpb24sIGl0IGlzIGNhbGxlZCBmb3IgZXZlcnkgc3Vic3RpdHV0aW9uIHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdFx0XHQvL1x0XHRhIHdob2xlIG1hdGNoLCBhIG5hbWUsIGFuIG9mZnNldCwgYW5kIHRoZSB3aG9sZSB0ZW1wbGF0ZVxuXHRcdFx0Ly9cdFx0c3RyaW5nIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGxhY2Vcblx0XHRcdC8vXHRcdGZvciBtb3JlIGRldGFpbHMpLlxuXHRcdFx0Ly8gcGF0dGVybjogUmVnRXg/XG5cdFx0XHQvL1x0XHRPcHRpb25hbCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0cyB0aGF0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBwYXR0ZXJuLlxuXHRcdFx0Ly9cdFx0TXVzdCBiZSBnbG9iYWwgYW5kIG1hdGNoIG9uZSBpdGVtLiBUaGUgZGVmYXVsdCBpczogL1xceyhbXlxcfV0rKVxcfS9nLFxuXHRcdFx0Ly9cdFx0d2hpY2ggbWF0Y2hlcyBwYXR0ZXJucyBsaWtlIHRoYXQ6IFwie3h4eH1cIiwgd2hlcmUgXCJ4eHhcIiBpcyBhbnkgc2VxdWVuY2Vcblx0XHRcdC8vXHRcdG9mIGNoYXJhY3RlcnMsIHdoaWNoIGRvZXNuJ3QgaW5jbHVkZSBcIn1cIi5cblx0XHRcdC8vIHJldHVybnM6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgc3Vic3RpdHV0ZWQgc3RyaW5nLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyB1c2VzIGEgZGljdGlvbmFyeSBmb3Igc3Vic3RpdHV0aW9uczpcblx0XHRcdC8vXHR8XHRsYW5nLnJlcGxhY2UoXCJIZWxsbywge25hbWUuZmlyc3R9IHtuYW1lLmxhc3R9IEFLQSB7bmlja30hXCIsXG5cdFx0XHQvL1x0fFx0XHR7XG5cdFx0XHQvL1x0fFx0XHRcdG5pY2s6IFwiQm9iXCIsXG5cdFx0XHQvL1x0fFx0XHRcdG5hbWU6IHtcblx0XHRcdC8vXHR8XHRcdFx0XHRmaXJzdDpcdFwiUm9iZXJ0XCIsXG5cdFx0XHQvL1x0fFx0XHRcdFx0bWlkZGxlOiBcIlhcIixcblx0XHRcdC8vXHR8XHRcdFx0XHRsYXN0Olx0XHRcIkNyaW5nZWx5XCJcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0fSk7XG5cdFx0XHQvL1x0fFx0Ly8gcmV0dXJuczogSGVsbG8sIFJvYmVydCBDcmluZ2VseSBBS0EgQm9iIVxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyB1c2VzIGFuIGFycmF5IGZvciBzdWJzdGl0dXRpb25zOlxuXHRcdFx0Ly9cdHxcdGxhbmcucmVwbGFjZShcIkhlbGxvLCB7MH0gezJ9IVwiLFxuXHRcdFx0Ly9cdHxcdFx0W1wiUm9iZXJ0XCIsIFwiWFwiLCBcIkNyaW5nZWx5XCJdKTtcblx0XHRcdC8vXHR8XHQvLyByZXR1cm5zOiBIZWxsbywgUm9iZXJ0IENyaW5nZWx5IVxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHR8XHQvLyB1c2VzIGEgZnVuY3Rpb24gZm9yIHN1YnN0aXR1dGlvbnM6XG5cdFx0XHQvL1x0fFx0ZnVuY3Rpb24gc3VtKGEpe1xuXHRcdFx0Ly9cdHxcdFx0dmFyIHQgPSAwO1xuXHRcdFx0Ly9cdHxcdFx0YXJyYXlmb3JFYWNoKGEsIGZ1bmN0aW9uKHgpeyB0ICs9IHg7IH0pO1xuXHRcdFx0Ly9cdHxcdFx0cmV0dXJuIHQ7XG5cdFx0XHQvL1x0fFx0fVxuXHRcdFx0Ly9cdHxcdGxhbmcucmVwbGFjZShcblx0XHRcdC8vXHR8XHRcdFwie2NvdW50fSBwYXltZW50cyBhdmVyYWdpbmcge2F2Z30gVVNEIHBlciBwYXltZW50LlwiLFxuXHRcdFx0Ly9cdHxcdFx0bGFuZy5oaXRjaChcblx0XHRcdC8vXHR8XHRcdFx0eyBwYXltZW50czogWzExLCAxNiwgMTJdIH0sXG5cdFx0XHQvL1x0fFx0XHRcdGZ1bmN0aW9uKF8sIGtleSl7XG5cdFx0XHQvL1x0fFx0XHRcdFx0c3dpdGNoKGtleSl7XG5cdFx0XHQvL1x0fFx0XHRcdFx0XHRjYXNlIFwiY291bnRcIjogcmV0dXJuIHRoaXMucGF5bWVudHMubGVuZ3RoO1xuXHRcdFx0Ly9cdHxcdFx0XHRcdFx0Y2FzZSBcIm1pblwiOlx0XHRyZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgdGhpcy5wYXltZW50cyk7XG5cdFx0XHQvL1x0fFx0XHRcdFx0XHRjYXNlIFwibWF4XCI6XHRcdHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLnBheW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdFx0XHRcdGNhc2UgXCJzdW1cIjpcdFx0cmV0dXJuIHN1bSh0aGlzLnBheW1lbnRzKTtcblx0XHRcdC8vXHR8XHRcdFx0XHRcdGNhc2UgXCJhdmdcIjpcdFx0cmV0dXJuIHN1bSh0aGlzLnBheW1lbnRzKSAvIHRoaXMucGF5bWVudHMubGVuZ3RoO1xuXHRcdFx0Ly9cdHxcdFx0XHRcdH1cblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0KVxuXHRcdFx0Ly9cdHxcdCk7XG5cdFx0XHQvL1x0fFx0Ly8gcHJpbnRzOiAzIHBheW1lbnRzIGF2ZXJhZ2luZyAxMyBVU0QgcGVyIHBheW1lbnQuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdC8vIHVzZXMgYW4gYWx0ZXJuYXRpdmUgUEhQLWxpa2UgcGF0dGVybiBmb3Igc3Vic3RpdHV0aW9uczpcblx0XHRcdC8vXHR8XHRsYW5nLnJlcGxhY2UoXCJIZWxsbywgJHswfSAkezJ9IVwiLFxuXHRcdFx0Ly9cdHxcdFx0W1wiUm9iZXJ0XCIsIFwiWFwiLCBcIkNyaW5nZWx5XCJdLCAvXFwkXFx7KFteXFx9XSspXFx9L2cpO1xuXHRcdFx0Ly9cdHxcdC8vIHJldHVybnM6IEhlbGxvLCBSb2JlcnQgQ3JpbmdlbHkhXG5cblx0XHRcdHJldHVybiB0bXBsLnJlcGxhY2UocGF0dGVybiB8fCBfcGF0dGVybiwgbGFuZy5pc0Z1bmN0aW9uKG1hcCkgP1xuXHRcdFx0XHRtYXAgOiBmdW5jdGlvbihfLCBrKXsgcmV0dXJuIGxhbmcuZ2V0T2JqZWN0KGssIGZhbHNlLCBtYXApOyB9KTtcblx0XHR9XG5cdH07XG5cblx0aGFzKFwiZXh0ZW5kLWRvam9cIikgJiYgbGFuZy5taXhpbihkb2pvLCBsYW5nKTtcblxuXHRyZXR1cm4gbGFuZztcbn0pO1xuIiwiZGVmaW5lKFtcIi4va2VybmVsXCIsIFwiLi9sYW5nXCIsIFwiLi4vc25pZmZcIl0sIGZ1bmN0aW9uKGRvam8sIGxhbmcsIGhhcyl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9fYmFzZS9zbmlmZlxuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdERlcHJlY2F0ZWQuICAgTmV3IGNvZGUgc2hvdWxkIHVzZSBkb2pvL3NuaWZmLlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIHBvcHVsYXRlcyB0aGUgZG9qbyBicm93c2VyIHZlcnNpb24gc25pZmZpbmcgcHJvcGVydGllcyBsaWtlIGRvam8uaXNJRS5cblx0fTtcblx0PT09PT0qL1xuXG5cdGlmKCFoYXMoXCJob3N0LWJyb3dzZXJcIikpe1xuXHRcdHJldHVybiBoYXM7XG5cdH1cblxuXHQvLyBubyBpZGVhIHdoYXQgdGhpcyBpcyBmb3IsIG9yIGlmIGl0J3MgdXNlZFxuXHRkb2pvLl9uYW1lID0gXCJicm93c2VyXCI7XG5cblx0bGFuZy5taXhpbihkb2pvLCB7XG5cdFx0Ly8gaXNCcm93c2VyOiBCb29sZWFuXG5cdFx0Ly9cdFx0VHJ1ZSBpZiB0aGUgY2xpZW50IGlzIGEgd2ViLWJyb3dzZXJcblx0XHRpc0Jyb3dzZXI6IHRydWUsXG5cblx0XHQvLyBpc0ZGOiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgRmlyZUZveC4gdW5kZWZpbmVkIG90aGVyd2lzZS4gQ29ycmVzcG9uZHMgdG9cblx0XHQvL1x0XHRtYWpvciBkZXRlY3RlZCBGaXJlRm94IHZlcnNpb24gKDEuNSwgMiwgMywgZXRjLilcblx0XHRpc0ZGOiBoYXMoXCJmZlwiKSxcblxuXHRcdC8vIGlzSUU6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBNU0lFKFBDKS4gdW5kZWZpbmVkIG90aGVyd2lzZS4gQ29ycmVzcG9uZHMgdG9cblx0XHQvL1x0XHRtYWpvciBkZXRlY3RlZCBJRSB2ZXJzaW9uICg2LCA3LCA4LCBldGMuKVxuXHRcdGlzSUU6IGhhcyhcImllXCIpLFxuXG5cdFx0Ly8gaXNLaHRtbDogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIGEgS0hUTUwgYnJvd3Nlci4gdW5kZWZpbmVkIG90aGVyd2lzZS4gQ29ycmVzcG9uZHMgdG8gbWFqb3Jcblx0XHQvL1x0XHRkZXRlY3RlZCB2ZXJzaW9uLlxuXHRcdGlzS2h0bWw6IGhhcyhcImtodG1sXCIpLFxuXG5cdFx0Ly8gaXNXZWJLaXQ6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBhIFdlYktpdC1kZXJpdmVkIGJyb3dzZXIgKEtvbnF1ZXJvcixcblx0XHQvL1x0XHRTYWZhcmksIENocm9tZSwgZXRjLikuIHVuZGVmaW5lZCBvdGhlcndpc2UuXG5cdFx0aXNXZWJLaXQ6IGhhcyhcIndlYmtpdFwiKSxcblxuXHRcdC8vIGlzTW96aWxsYTogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIGEgTW96aWxsYS1iYXNlZCBicm93c2VyIChGaXJlZm94LFxuXHRcdC8vXHRcdFNlYU1vbmtleSkuIHVuZGVmaW5lZCBvdGhlcndpc2UuIENvcnJlc3BvbmRzIHRvIG1ham9yIGRldGVjdGVkIHZlcnNpb24uXG5cdFx0aXNNb3ppbGxhOiBoYXMoXCJtb3ppbGxhXCIpLFxuXHRcdC8vIGlzTW96OiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgYSBNb3ppbGxhLWJhc2VkIGJyb3dzZXIgKEZpcmVmb3gsXG5cdFx0Ly9cdFx0U2VhTW9ua2V5KS4gdW5kZWZpbmVkIG90aGVyd2lzZS4gQ29ycmVzcG9uZHMgdG8gbWFqb3IgZGV0ZWN0ZWQgdmVyc2lvbi5cblx0XHRpc01vejogaGFzKFwibW96aWxsYVwiKSxcblxuXHRcdC8vIGlzT3BlcmE6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBPcGVyYS4gdW5kZWZpbmVkIG90aGVyd2lzZS4gQ29ycmVzcG9uZHMgdG9cblx0XHQvL1x0XHRtYWpvciBkZXRlY3RlZCB2ZXJzaW9uLlxuXHRcdGlzT3BlcmE6IGhhcyhcIm9wZXJhXCIpLFxuXG5cdFx0Ly8gaXNTYWZhcmk6IE51bWJlcnx1bmRlZmluZWRcblx0XHQvL1x0XHRWZXJzaW9uIGFzIGEgTnVtYmVyIGlmIGNsaWVudCBpcyBTYWZhcmkgb3IgaVBob25lLiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuXHRcdGlzU2FmYXJpOiBoYXMoXCJzYWZhcmlcIiksXG5cblx0XHQvLyBpc0Nocm9tZTogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIENocm9tZSBicm93c2VyLiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuXHRcdGlzQ2hyb21lOiBoYXMoXCJjaHJvbWVcIiksXG5cblx0XHQvLyBpc01hYzogQm9vbGVhblxuXHRcdC8vXHRcdFRydWUgaWYgdGhlIGNsaWVudCBydW5zIG9uIE1hY1xuXHRcdGlzTWFjOiBoYXMoXCJtYWNcIiksXG5cblx0XHQvLyBpc0lvczogTnVtYmVyfHVuZGVmaW5lZFxuXHRcdC8vXHRcdFZlcnNpb24gYXMgYSBOdW1iZXIgaWYgY2xpZW50IGlzIGlQaG9uZSwgaVBvZCwgb3IgaVBhZC4gdW5kZWZpbmVkIG90aGVyd2lzZS5cblx0XHRpc0lvczogaGFzKFwiaW9zXCIpLFxuXG5cdFx0Ly8gaXNBbmRyb2lkOiBOdW1iZXJ8dW5kZWZpbmVkXG5cdFx0Ly9cdFx0VmVyc2lvbiBhcyBhIE51bWJlciBpZiBjbGllbnQgaXMgYW5kcm9pZCBicm93c2VyLiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuXHRcdGlzQW5kcm9pZDogaGFzKFwiYW5kcm9pZFwiKSxcblxuXHRcdC8vIGlzV2lpOiBCb29sZWFuXG5cdFx0Ly9cdFx0VHJ1ZSBpZiBjbGllbnQgaXMgV2lpXG5cdFx0aXNXaWk6IGhhcyhcIndpaVwiKSxcblxuXHRcdC8vIGlzUXVpcmtzOiBCb29sZWFuXG5cdFx0Ly9cdFx0UGFnZSBpcyBpbiBxdWlya3MgbW9kZS5cblx0XHRpc1F1aXJrczogaGFzKFwicXVpcmtzXCIpLFxuXG5cdFx0Ly8gaXNBaXI6IEJvb2xlYW5cblx0XHQvL1x0XHRUcnVlIGlmIGNsaWVudCBpcyBBZG9iZSBBaXJcblx0XHRpc0FpcjogaGFzKFwiYWlyXCIpXG5cdH0pO1xuXG5cdHJldHVybiBoYXM7XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiXSwgZnVuY3Rpb24oZG9qbyl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby91cmxcblxuXHR2YXJcblx0XHRvcmUgPSBuZXcgUmVnRXhwKFwiXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSk/JFwiKSxcblx0XHRpcmUgPSBuZXcgUmVnRXhwKFwiXigoKFteXFxcXFs6XSspOik/KFteQF0rKUApPyhcXFxcWyhbXlxcXFxdXSspXFxcXF18KFteXFxcXFs6XSopKSg6KFswLTldKykpPyRcIiksXG5cdFx0X1VybCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgbiA9IG51bGwsXG5cdFx0XHRcdF9hID0gYXJndW1lbnRzLFxuXHRcdFx0XHR1cmkgPSBbX2FbMF1dO1xuXHRcdFx0Ly8gcmVzb2x2ZSB1cmkgY29tcG9uZW50cyByZWxhdGl2ZSB0byBlYWNoIG90aGVyXG5cdFx0XHRmb3IodmFyIGkgPSAxOyBpPF9hLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYoIV9hW2ldKXsgY29udGludWU7IH1cblxuXHRcdFx0XHQvLyBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IHRoaXMuY29uc3RydWN0b3Igc28gd2UgaGF2ZSB0byBiZSBleHBsaWNpdFxuXHRcdFx0XHQvLyBGSVhNRTogVHJhY2tlZCAoYW5kIGZpeGVkKSBpbiBXZWJraXQgYnVnIDM1MzcuXG5cdFx0XHRcdC8vXHRcdGh0dHA6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM1Mzdcblx0XHRcdFx0dmFyIHJlbG9iaiA9IG5ldyBfVXJsKF9hW2ldK1wiXCIpLFxuXHRcdFx0XHRcdHVyaW9iaiA9IG5ldyBfVXJsKHVyaVswXStcIlwiKTtcblxuXHRcdFx0XHRpZihcblx0XHRcdFx0XHRyZWxvYmoucGF0aCA9PSBcIlwiICYmXG5cdFx0XHRcdFx0IXJlbG9iai5zY2hlbWUgJiZcblx0XHRcdFx0XHQhcmVsb2JqLmF1dGhvcml0eSAmJlxuXHRcdFx0XHRcdCFyZWxvYmoucXVlcnlcblx0XHRcdFx0KXtcblx0XHRcdFx0XHRpZihyZWxvYmouZnJhZ21lbnQgIT0gbil7XG5cdFx0XHRcdFx0XHR1cmlvYmouZnJhZ21lbnQgPSByZWxvYmouZnJhZ21lbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbG9iaiA9IHVyaW9iajtcblx0XHRcdFx0fWVsc2UgaWYoIXJlbG9iai5zY2hlbWUpe1xuXHRcdFx0XHRcdHJlbG9iai5zY2hlbWUgPSB1cmlvYmouc2NoZW1lO1xuXG5cdFx0XHRcdFx0aWYoIXJlbG9iai5hdXRob3JpdHkpe1xuXHRcdFx0XHRcdFx0cmVsb2JqLmF1dGhvcml0eSA9IHVyaW9iai5hdXRob3JpdHk7XG5cblx0XHRcdFx0XHRcdGlmKHJlbG9iai5wYXRoLmNoYXJBdCgwKSAhPSBcIi9cIil7XG5cdFx0XHRcdFx0XHRcdHZhciBwYXRoID0gdXJpb2JqLnBhdGguc3Vic3RyaW5nKDAsXG5cdFx0XHRcdFx0XHRcdFx0dXJpb2JqLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyByZWxvYmoucGF0aDtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc2VncyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgc2Vncy5sZW5ndGg7IGorKyl7XG5cdFx0XHRcdFx0XHRcdFx0aWYoc2Vnc1tqXSA9PSBcIi5cIil7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmbGF0dGVuIFwiLi9cIiByZWZlcmVuY2VzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihqID09IHNlZ3MubGVuZ3RoIC0gMSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlZ3Nbal0gPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlZ3Muc3BsaWNlKGosIDEpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRqLS07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fWVsc2UgaWYoaiA+IDAgJiYgIShqID09IDEgJiYgc2Vnc1swXSA9PSBcIlwiKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0c2Vnc1tqXSA9PSBcIi4uXCIgJiYgc2Vnc1tqLTFdICE9IFwiLi5cIil7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmbGF0dGVuIFwiLi4vXCIgcmVmZXJlbmNlc1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoaiA9PSAoc2Vncy5sZW5ndGggLSAxKSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlZ3Muc3BsaWNlKGosIDEpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWdzW2ogLSAxXSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2Vncy5zcGxpY2UoaiAtIDEsIDIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRqIC09IDI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJlbG9iai5wYXRoID0gc2Vncy5qb2luKFwiL1wiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cmkgPSBbXTtcblx0XHRcdFx0aWYocmVsb2JqLnNjaGVtZSl7XG5cdFx0XHRcdFx0dXJpLnB1c2gocmVsb2JqLnNjaGVtZSwgXCI6XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJlbG9iai5hdXRob3JpdHkpe1xuXHRcdFx0XHRcdHVyaS5wdXNoKFwiLy9cIiwgcmVsb2JqLmF1dGhvcml0eSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dXJpLnB1c2gocmVsb2JqLnBhdGgpO1xuXHRcdFx0XHRpZihyZWxvYmoucXVlcnkpe1xuXHRcdFx0XHRcdHVyaS5wdXNoKFwiP1wiLCByZWxvYmoucXVlcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJlbG9iai5mcmFnbWVudCl7XG5cdFx0XHRcdFx0dXJpLnB1c2goXCIjXCIsIHJlbG9iai5mcmFnbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cmkgPSB1cmkuam9pbihcIlwiKTtcblxuXHRcdFx0Ly8gYnJlYWsgdGhlIHVyaSBpbnRvIGl0cyBtYWluIGNvbXBvbmVudHNcblx0XHRcdHZhciByID0gdGhpcy51cmkubWF0Y2gob3JlKTtcblxuXHRcdFx0dGhpcy5zY2hlbWUgPSByWzJdIHx8IChyWzFdID8gXCJcIiA6IG4pO1xuXHRcdFx0dGhpcy5hdXRob3JpdHkgPSByWzRdIHx8IChyWzNdID8gXCJcIiA6IG4pO1xuXHRcdFx0dGhpcy5wYXRoID0gcls1XTsgLy8gY2FuIG5ldmVyIGJlIHVuZGVmaW5lZFxuXHRcdFx0dGhpcy5xdWVyeSA9IHJbN10gfHwgKHJbNl0gPyBcIlwiIDogbik7XG5cdFx0XHR0aGlzLmZyYWdtZW50XHQgPSByWzldIHx8IChyWzhdID8gXCJcIiA6IG4pO1xuXG5cdFx0XHRpZih0aGlzLmF1dGhvcml0eSAhPSBuKXtcblx0XHRcdFx0Ly8gc2VydmVyIGJhc2VkIG5hbWluZyBhdXRob3JpdHlcblx0XHRcdFx0ciA9IHRoaXMuYXV0aG9yaXR5Lm1hdGNoKGlyZSk7XG5cblx0XHRcdFx0dGhpcy51c2VyID0gclszXSB8fCBuO1xuXHRcdFx0XHR0aGlzLnBhc3N3b3JkID0gcls0XSB8fCBuO1xuXHRcdFx0XHR0aGlzLmhvc3QgPSByWzZdIHx8IHJbN107IC8vIGlwdjYgfHwgaXB2NFxuXHRcdFx0XHR0aGlzLnBvcnQgPSByWzldIHx8IG47XG5cdFx0XHR9XG5cdFx0fTtcblx0X1VybC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy51cmk7IH07XG5cblx0cmV0dXJuIGRvam8uX1VybCA9IF9Vcmw7XG59KTtcbiIsImRlZmluZShbXCIuL2tlcm5lbFwiLCBcIi4vbGFuZ1wiLCBcIi4uL3NuaWZmXCJdLCBmdW5jdGlvbihkb2pvLCBsYW5nLCBoYXMpe1xuLy8gbW9kdWxlOlxuLy9cdFx0ZG9qby9fYmFzZS93aW5kb3dcblxudmFyIHJldCA9IHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0QVBJIHRvIHNhdmUvc2V0L3Jlc3RvcmUgdGhlIGdsb2JhbC9kb2N1bWVudCBzY29wZS5cblxuXHRnbG9iYWw6IGRvam8uZ2xvYmFsLFxuXHQvKj09PT09XG5cdCBnbG9iYWw6IHtcblx0XHQgLy8gc3VtbWFyeTpcblx0XHQgLy9cdFx0QWxpYXMgZm9yIHRoZSBjdXJyZW50IHdpbmRvdy4gJ2dsb2JhbCcgY2FuIGJlIG1vZGlmaWVkXG5cdFx0IC8vXHRcdGZvciB0ZW1wb3JhcnkgY29udGV4dCBzaGlmdGluZy4gU2VlIGFsc28gd2l0aEdsb2JhbCgpLlxuXHRcdCAvLyBkZXNjcmlwdGlvbjpcblx0XHQgLy9cdFx0VXNlIHRoaXMgcmF0aGVyIHRoYW4gcmVmZXJyaW5nIHRvICd3aW5kb3cnIHRvIGVuc3VyZSB5b3VyIGNvZGUgcnVuc1xuXHRcdCAvL1x0XHRjb3JyZWN0bHkgaW4gbWFuYWdlZCBjb250ZXh0cy5cblx0IH0sXG5cdCA9PT09PSovXG5cblx0ZG9jOiBkb2pvLmdsb2JhbFtcImRvY3VtZW50XCJdIHx8IG51bGwsXG5cdC8qPT09PT1cblx0ZG9jOiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBbGlhcyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuICdkb2MnIGNhbiBiZSBtb2RpZmllZFxuXHRcdC8vXHRcdGZvciB0ZW1wb3JhcnkgY29udGV4dCBzaGlmdGluZy4gU2VlIGFsc28gd2l0aERvYygpLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFVzZSB0aGlzIHJhdGhlciB0aGFuIHJlZmVycmluZyB0byAnd2luZG93LmRvY3VtZW50JyB0byBlbnN1cmUgeW91ciBjb2RlIHJ1bnNcblx0XHQvL1x0XHRjb3JyZWN0bHkgaW4gbWFuYWdlZCBjb250ZXh0cy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHRuLmFwcGVuZENoaWxkKGRvam8uZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcblx0fSxcblx0PT09PT0qL1xuXG5cdGJvZHk6IGZ1bmN0aW9uKC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybiB0aGUgYm9keSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQgb3Igb2YgZG9qby9fYmFzZS93aW5kb3c6OmRvYy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHR3aW4uYm9keSgpLmFwcGVuZENoaWxkKGRvam8uZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcblxuXHRcdC8vIE5vdGU6IGRvY3VtZW50LmJvZHkgaXMgbm90IGRlZmluZWQgZm9yIGEgc3RyaWN0IHhodG1sIGRvY3VtZW50XG5cdFx0Ly8gV291bGQgbGlrZSB0byBtZW1vaXplIHRoaXMsIGJ1dCBkb2pvLmRvYyBjYW4gY2hhbmdlIHZpIGRvam8ud2l0aERvYygpLlxuXHRcdGRvYyA9IGRvYyB8fCBkb2pvLmRvYztcblx0XHRyZXR1cm4gZG9jLmJvZHkgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTsgLy8gTm9kZVxuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKC8qT2JqZWN0Ki8gZ2xvYmFsT2JqZWN0LCAvKkRvY3VtZW50RWxlbWVudCovIGdsb2JhbERvY3VtZW50KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIG1hbnkgY29yZSBEb2pvIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aFxuXHRcdC8vXHRcdG5hbWVzcGFjZSBhbmQgRE9NIGxvb2t1cCwgY2hhbmdpbmcgdGhlbSB0byB3b3JrIGluIGEgbmV3IGdsb2JhbFxuXHRcdC8vXHRcdGNvbnRleHQgKGUuZy4sIGFuIGlmcmFtZSkuIFRoZSB2YXJpYmxlcyBkb2pvLmdsb2JhbCBhbmQgZG9qby5kb2Ncblx0XHQvL1x0XHRhcmUgbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0IG9mXG5cdFx0Ly9cdFx0YGRvam8uYm9keSgpYCBsaWtld2lzZSBkaWZmZXJzLlxuXHRcdGRvam8uZ2xvYmFsID0gcmV0Lmdsb2JhbCA9IGdsb2JhbE9iamVjdDtcblx0XHRkb2pvLmRvYyA9IHJldC5kb2MgPSBnbG9iYWxEb2N1bWVudDtcblx0fSxcblxuXHR3aXRoR2xvYmFsOiBmdW5jdGlvbihcdC8qT2JqZWN0Ki8gZ2xvYmFsT2JqZWN0LFxuXHRcdFx0XHRcdFx0XHQvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssXG5cdFx0XHRcdFx0XHRcdC8qT2JqZWN0PyovIHRoaXNPYmplY3QsXG5cdFx0XHRcdFx0XHRcdC8qQXJyYXk/Ki8gY2JBcmd1bWVudHMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0SW52b2tlIGNhbGxiYWNrIHdpdGggZ2xvYmFsT2JqZWN0IGFzIGRvam8uZ2xvYmFsIGFuZFxuXHRcdC8vXHRcdGdsb2JhbE9iamVjdC5kb2N1bWVudCBhcyBkb2pvLmRvYy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRJbnZva2UgY2FsbGJhY2sgd2l0aCBnbG9iYWxPYmplY3QgYXMgZG9qby5nbG9iYWwgYW5kXG5cdFx0Ly9cdFx0Z2xvYmFsT2JqZWN0LmRvY3VtZW50IGFzIGRvam8uZG9jLiBJZiBwcm92aWRlZCwgZ2xvYmFsT2JqZWN0XG5cdFx0Ly9cdFx0d2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiBvYmplY3QgdGhpc09iamVjdFxuXHRcdC8vXHRcdFdoZW4gY2FsbGJhY2soKSByZXR1cm5zIG9yIHRocm93cyBhbiBlcnJvciwgdGhlIGRvam8uZ2xvYmFsXG5cdFx0Ly9cdFx0YW5kIGRvam8uZG9jIHdpbGwgYmUgcmVzdG9yZWQgdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuXG5cdFx0dmFyIG9sZEdsb2IgPSBkb2pvLmdsb2JhbDtcblx0XHR0cnl7XG5cdFx0XHRkb2pvLmdsb2JhbCA9IHJldC5nbG9iYWwgPSBnbG9iYWxPYmplY3Q7XG5cdFx0XHRyZXR1cm4gcmV0LndpdGhEb2MuY2FsbChudWxsLCBnbG9iYWxPYmplY3QuZG9jdW1lbnQsIGNhbGxiYWNrLCB0aGlzT2JqZWN0LCBjYkFyZ3VtZW50cyk7XG5cdFx0fWZpbmFsbHl7XG5cdFx0XHRkb2pvLmdsb2JhbCA9IHJldC5nbG9iYWwgPSBvbGRHbG9iO1xuXHRcdH1cblx0fSxcblxuXHR3aXRoRG9jOiBmdW5jdGlvbihcdC8qRG9jdW1lbnRFbGVtZW50Ki8gZG9jdW1lbnRPYmplY3QsXG5cdFx0XHRcdFx0XHQvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssXG5cdFx0XHRcdFx0XHQvKk9iamVjdD8qLyB0aGlzT2JqZWN0LFxuXHRcdFx0XHRcdFx0LypBcnJheT8qLyBjYkFyZ3VtZW50cyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRJbnZva2UgY2FsbGJhY2sgd2l0aCBkb2N1bWVudE9iamVjdCBhcyBkb2pvL19iYXNlL3dpbmRvdzo6ZG9jLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEludm9rZSBjYWxsYmFjayB3aXRoIGRvY3VtZW50T2JqZWN0IGFzIGRvam8vX2Jhc2Uvd2luZG93Ojpkb2MuIElmIHByb3ZpZGVkLFxuXHRcdC8vXHRcdGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2Ygb2JqZWN0IHRoaXNPYmplY3Rcblx0XHQvL1x0XHRXaGVuIGNhbGxiYWNrKCkgcmV0dXJucyBvciB0aHJvd3MgYW4gZXJyb3IsIHRoZSBkb2pvL19iYXNlL3dpbmRvdzo6ZG9jIHdpbGxcblx0XHQvL1x0XHRiZSByZXN0b3JlZCB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG5cblx0XHR2YXIgb2xkRG9jID0gcmV0LmRvYyxcblx0XHRcdG9sZFEgPSBoYXMoXCJxdWlya3NcIiksXG5cdFx0XHRvbGRJRSA9IGhhcyhcImllXCIpLCBpc0lFLCBtb2RlLCBwd2luO1xuXG5cdFx0dHJ5e1xuXHRcdFx0ZG9qby5kb2MgPSByZXQuZG9jID0gZG9jdW1lbnRPYmplY3Q7XG5cdFx0XHQvLyB1cGRhdGUgZG9qby5pc1F1aXJrcyBhbmQgdGhlIHZhbHVlIG9mIHRoZSBoYXMgZmVhdHVyZSBcInF1aXJrc1wiLlxuXHRcdFx0Ly8gcmVtb3ZlIHNldHRpbmcgZG9qby5pc1F1aXJrcyBhbmQgZG9qby5pc0lFIGZvciAyLjBcblx0XHRcdGRvam8uaXNRdWlya3MgPSBoYXMuYWRkKFwicXVpcmtzXCIsIGRvam8uZG9jLmNvbXBhdE1vZGUgPT0gXCJCYWNrQ29tcGF0XCIsIHRydWUsIHRydWUpOyAvLyBubyBuZWVkIHRvIGNoZWNrIGZvciBRdWlya3NNb2RlIHdoaWNoIHdhcyBPcGVyYSA3IG9ubHlcblxuXHRcdFx0aWYoaGFzKFwiaWVcIikpe1xuXHRcdFx0XHRpZigocHdpbiA9IGRvY3VtZW50T2JqZWN0LnBhcmVudFdpbmRvdykgJiYgcHdpbi5uYXZpZ2F0b3Ipe1xuXHRcdFx0XHRcdC8vIHJlLXJ1biBJRSBkZXRlY3Rpb24gbG9naWMgYW5kIHVwZGF0ZSBkb2pvLmlzSUUgLyBoYXMoXCJpZVwiKVxuXHRcdFx0XHRcdC8vICh0aGUgb25seSB0aW1lIHBhcmVudFdpbmRvdy9uYXZpZ2F0b3Igd291bGRuJ3QgZXhpc3QgaXMgaWYgd2Ugd2VyZSBub3Rcblx0XHRcdFx0XHQvLyBwYXNzZWQgYW4gYWN0dWFsIGxlZ2l0aW1hdGUgZG9jdW1lbnQgb2JqZWN0KVxuXHRcdFx0XHRcdGlzSUUgPSBwYXJzZUZsb2F0KHB3aW4ubmF2aWdhdG9yLmFwcFZlcnNpb24uc3BsaXQoXCJNU0lFIFwiKVsxXSkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdG1vZGUgPSBkb2N1bWVudE9iamVjdC5kb2N1bWVudE1vZGU7XG5cdFx0XHRcdFx0aWYobW9kZSAmJiBtb2RlICE9IDUgJiYgTWF0aC5mbG9vcihpc0lFKSAhPSBtb2RlKXtcblx0XHRcdFx0XHRcdGlzSUUgPSBtb2RlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb2pvLmlzSUUgPSBoYXMuYWRkKFwiaWVcIiwgaXNJRSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYodGhpc09iamVjdCAmJiB0eXBlb2YgY2FsbGJhY2sgPT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdGNhbGxiYWNrID0gdGhpc09iamVjdFtjYWxsYmFja107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzT2JqZWN0LCBjYkFyZ3VtZW50cyB8fCBbXSk7XG5cdFx0fWZpbmFsbHl7XG5cdFx0XHRkb2pvLmRvYyA9IHJldC5kb2MgPSBvbGREb2M7XG5cdFx0XHRkb2pvLmlzUXVpcmtzID0gaGFzLmFkZChcInF1aXJrc1wiLCBvbGRRLCB0cnVlLCB0cnVlKTtcblx0XHRcdGRvam8uaXNJRSA9IGhhcy5hZGQoXCJpZVwiLCBvbGRJRSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG59O1xuXG5oYXMoXCJleHRlbmQtZG9qb1wiKSAmJiBsYW5nLm1peGluKGRvam8sIHJldCk7XG5cbnJldHVybiByZXQ7XG5cbn0pO1xuIiwiZGVmaW5lKFtdLCBmdW5jdGlvbigpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9hc3BlY3RcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIHVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gYWR2aXNlKGRpc3BhdGNoZXIsIHR5cGUsIGFkdmljZSwgcmVjZWl2ZUFyZ3VtZW50cyl7XG5cdFx0dmFyIHByZXZpb3VzID0gZGlzcGF0Y2hlclt0eXBlXTtcblx0XHR2YXIgYXJvdW5kID0gdHlwZSA9PSBcImFyb3VuZFwiO1xuXHRcdHZhciBzaWduYWw7XG5cdFx0aWYoYXJvdW5kKXtcblx0XHRcdHZhciBhZHZpc2VkID0gYWR2aWNlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJldHVybiBwcmV2aW91cy5hZHZpY2UodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH0pO1xuXHRcdFx0c2lnbmFsID0ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYoYWR2aXNlZCl7XG5cdFx0XHRcdFx0XHRhZHZpc2VkID0gZGlzcGF0Y2hlciA9IGFkdmljZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRhZHZpY2U6IGZ1bmN0aW9uKHRhcmdldCwgYXJncyl7XG5cdFx0XHRcdFx0cmV0dXJuIGFkdmlzZWQgP1xuXHRcdFx0XHRcdFx0YWR2aXNlZC5hcHBseSh0YXJnZXQsIGFyZ3MpIDogIC8vIGNhbGxlZCB0aGUgYWR2aXNlZCBmdW5jdGlvblxuXHRcdFx0XHRcdFx0cHJldmlvdXMuYWR2aWNlKHRhcmdldCwgYXJncyk7IC8vIGNhbmNlbGxlZCwgc2tpcCB0byBuZXh0IG9uZVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gY3JlYXRlIHRoZSByZW1vdmUgaGFuZGxlclxuXHRcdFx0c2lnbmFsID0ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYoc2lnbmFsLmFkdmljZSl7XG5cdFx0XHRcdFx0XHR2YXIgcHJldmlvdXMgPSBzaWduYWwucHJldmlvdXM7XG5cdFx0XHRcdFx0XHR2YXIgbmV4dCA9IHNpZ25hbC5uZXh0O1xuXHRcdFx0XHRcdFx0aWYoIW5leHQgJiYgIXByZXZpb3VzKXtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGRpc3BhdGNoZXJbdHlwZV07XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0aWYocHJldmlvdXMpe1xuXHRcdFx0XHRcdFx0XHRcdHByZXZpb3VzLm5leHQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRkaXNwYXRjaGVyW3R5cGVdID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihuZXh0KXtcblx0XHRcdFx0XHRcdFx0XHRuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBhZHZpY2UgdG8gc2lnbmFsIHRoYXQgdGhpcyBzaWduYWwgaGFzIGJlZW4gcmVtb3ZlZFxuXHRcdFx0XHRcdFx0ZGlzcGF0Y2hlciA9IGFkdmljZSA9IHNpZ25hbC5hZHZpY2UgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0aWQ6IGRpc3BhdGNoZXIubmV4dElkKyssXG5cdFx0XHRcdGFkdmljZTogYWR2aWNlLFxuXHRcdFx0XHRyZWNlaXZlQXJndW1lbnRzOiByZWNlaXZlQXJndW1lbnRzXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZihwcmV2aW91cyAmJiAhYXJvdW5kKXtcblx0XHRcdGlmKHR5cGUgPT0gXCJhZnRlclwiKXtcblx0XHRcdFx0Ly8gYWRkIHRoZSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cdFx0XHRcdC8vIG5vdGUgdGhhdCB3ZSBoYWQgdG8gY2hhbmdlIHRoaXMgbG9vcCBhIGxpdHRsZSBiaXQgdG8gd29ya2Fyb3VuZCBhIGJpemFycmUgSUUxMCBKSVQgYnVnXG5cdFx0XHRcdHdoaWxlKHByZXZpb3VzLm5leHQgJiYgKHByZXZpb3VzID0gcHJldmlvdXMubmV4dCkpe31cblx0XHRcdFx0cHJldmlvdXMubmV4dCA9IHNpZ25hbDtcblx0XHRcdFx0c2lnbmFsLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHR9ZWxzZSBpZih0eXBlID09IFwiYmVmb3JlXCIpe1xuXHRcdFx0XHQvLyBhZGQgdG8gYmVnaW5uaW5nXG5cdFx0XHRcdGRpc3BhdGNoZXJbdHlwZV0gPSBzaWduYWw7XG5cdFx0XHRcdHNpZ25hbC5uZXh0ID0gcHJldmlvdXM7XG5cdFx0XHRcdHByZXZpb3VzLnByZXZpb3VzID0gc2lnbmFsO1xuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0Ly8gYXJvdW5kIG9yIGZpcnN0IG9uZSBqdXN0IHJlcGxhY2VzXG5cdFx0XHRkaXNwYXRjaGVyW3R5cGVdID0gc2lnbmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gc2lnbmFsO1xuXHR9XG5cdGZ1bmN0aW9uIGFzcGVjdCh0eXBlKXtcblx0XHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBtZXRob2ROYW1lLCBhZHZpY2UsIHJlY2VpdmVBcmd1bWVudHMpe1xuXHRcdFx0dmFyIGV4aXN0aW5nID0gdGFyZ2V0W21ldGhvZE5hbWVdLCBkaXNwYXRjaGVyO1xuXHRcdFx0aWYoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLnRhcmdldCAhPSB0YXJnZXQpe1xuXHRcdFx0XHQvLyBubyBkaXNwYXRjaGVyIGluIHBsYWNlXG5cdFx0XHRcdHRhcmdldFttZXRob2ROYW1lXSA9IGRpc3BhdGNoZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciBleGVjdXRpb25JZCA9IGRpc3BhdGNoZXIubmV4dElkO1xuXHRcdFx0XHRcdC8vIGJlZm9yZSBhZHZpY2Vcblx0XHRcdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHR2YXIgYmVmb3JlID0gZGlzcGF0Y2hlci5iZWZvcmU7XG5cdFx0XHRcdFx0d2hpbGUoYmVmb3JlKXtcblx0XHRcdFx0XHRcdGlmKGJlZm9yZS5hZHZpY2Upe1xuXHRcdFx0XHRcdFx0XHRhcmdzID0gYmVmb3JlLmFkdmljZS5hcHBseSh0aGlzLCBhcmdzKSB8fCBhcmdzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YmVmb3JlID0gYmVmb3JlLm5leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGFyb3VuZCBhZHZpY2Vcblx0XHRcdFx0XHRpZihkaXNwYXRjaGVyLmFyb3VuZCl7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0cyA9IGRpc3BhdGNoZXIuYXJvdW5kLmFkdmljZSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gYWZ0ZXIgYWR2aWNlXG5cdFx0XHRcdFx0dmFyIGFmdGVyID0gZGlzcGF0Y2hlci5hZnRlcjtcblx0XHRcdFx0XHR3aGlsZShhZnRlciAmJiBhZnRlci5pZCA8IGV4ZWN1dGlvbklkKXtcblx0XHRcdFx0XHRcdGlmKGFmdGVyLmFkdmljZSl7XG5cdFx0XHRcdFx0XHRcdGlmKGFmdGVyLnJlY2VpdmVBcmd1bWVudHMpe1xuXHRcdFx0XHRcdFx0XHRcdHZhciBuZXdSZXN1bHRzID0gYWZ0ZXIuYWR2aWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIGNoYW5nZSB0aGUgcmV0dXJuIHZhbHVlIG9ubHkgaWYgYSBuZXcgdmFsdWUgd2FzIHJldHVybmVkXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cyA9IG5ld1Jlc3VsdHMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdHMgOiBuZXdSZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzID0gYWZ0ZXIuYWR2aWNlLmNhbGwodGhpcywgcmVzdWx0cywgYXJncyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFmdGVyID0gYWZ0ZXIubmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmKGV4aXN0aW5nKXtcblx0XHRcdFx0XHRkaXNwYXRjaGVyLmFyb3VuZCA9IHthZHZpY2U6IGZ1bmN0aW9uKHRhcmdldCwgYXJncyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhpc3RpbmcuYXBwbHkodGFyZ2V0LCBhcmdzKTtcblx0XHRcdFx0XHR9fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaXNwYXRjaGVyLnRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0ZGlzcGF0Y2hlci5uZXh0SWQgPSBkaXNwYXRjaGVyLm5leHRJZCB8fCAwO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdHMgPSBhZHZpc2UoKGRpc3BhdGNoZXIgfHwgZXhpc3RpbmcpLCB0eXBlLCBhZHZpY2UsIHJlY2VpdmVBcmd1bWVudHMpO1xuXHRcdFx0YWR2aWNlID0gbnVsbDtcblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cdH1cblxuXHQvLyBUT0RPQzogYWZ0ZXIvYmVmb3JlL2Fyb3VuZCByZXR1cm4gb2JqZWN0XG5cblx0dmFyIGFmdGVyID0gYXNwZWN0KFwiYWZ0ZXJcIik7XG5cdC8qPT09PT1cblx0YWZ0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIG1ldGhvZE5hbWUsIGFkdmljZSwgcmVjZWl2ZUFyZ3VtZW50cyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGUgXCJhZnRlclwiIGV4cG9ydCBvZiB0aGUgYXNwZWN0IG1vZHVsZSBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXR0YWNoXG5cdFx0Ly9cdFx0XCJhZnRlclwiIGFkdmljZSB0byBhIG1ldGhvZC4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0XHQvL1x0XHRpcyBleGVjdXRlZC4gQnkgZGVmYXVsdCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCwgdGhlIHJldHVyblxuXHRcdC8vXHRcdHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBtZXRob2QsIG9yIHRoZSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYXN0IGV4ZWN1dGVkIGFkdmljZSAoaWYgYSBwcmV2aW91cyBvbmUgZXhpc3RzKS5cblx0XHQvL1x0XHRUaGUgZm91cnRoIChvcHRpb25hbCkgYXJndW1lbnQgY2FuIGJlIHNldCB0byB0cnVlIHRvIHNvIHRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgb3JpZ2luYWxcblx0XHQvL1x0XHRhcmd1bWVudHMgKGZyb20gd2hlbiB0aGUgb3JpZ2luYWwgbWV0aG9kIHdhcyBjYWxsZWQpIHJhdGhlciB0aGFuIHRoZSByZXR1cm4gdmFsdWUuXG5cdFx0Ly9cdFx0SWYgdGhlcmUgYXJlIG11bHRpcGxlIFwiYWZ0ZXJcIiBhZHZpc29ycywgdGhleSBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdC8vIHRhcmdldDogT2JqZWN0XG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgdGFyZ2V0IG9iamVjdFxuXHRcdC8vIG1ldGhvZE5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBhdHRhY2ggdG8uXG5cdFx0Ly8gYWR2aWNlOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoaXMgaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0XHQvLyByZWNlaXZlQXJndW1lbnRzOiBCb29sZWFuP1xuXHRcdC8vXHRcdElmIHRoaXMgaXMgc2V0IHRvIHRydWUsIHRoZSBhZHZpY2UgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG9yaWdpbmFsIGFyZ3VtZW50cyAoZnJvbSB3aGVuIHRoZSBvcmlnaW5hbCBtZWh0b2Rcblx0XHQvL1x0XHR3YXMgY2FsbGVkKSByYXRoZXIgdGhhbiB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBvcmlnaW5hbC9wcmV2aW91cyBtZXRob2QuXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHRBIHNpZ25hbCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFkdmljZS4gSWYgcmVtb3ZlKCkgaXMgY2FsbGVkIG9uIHRoaXMgc2lnbmFsIG9iamVjdCwgaXQgd2lsbFxuXHRcdC8vXHRcdHN0b3AgdGhlIGFkdmljZSBmdW5jdGlvbiBmcm9tIGJlaW5nIGV4ZWN1dGVkLlxuXHR9O1xuXHQ9PT09PSovXG5cblx0dmFyIGJlZm9yZSA9IGFzcGVjdChcImJlZm9yZVwiKTtcblx0Lyo9PT09PVxuXHRiZWZvcmUgPSBmdW5jdGlvbih0YXJnZXQsIG1ldGhvZE5hbWUsIGFkdmljZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGUgXCJiZWZvcmVcIiBleHBvcnQgb2YgdGhlIGFzcGVjdCBtb2R1bGUgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0dGFjaFxuXHRcdC8vXHRcdFwiYmVmb3JlXCIgYWR2aWNlIHRvIGEgbWV0aG9kLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0XHQvL1x0XHRpcyBleGVjdXRlZC4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBhcmd1bWVudHMgdXNlZCB0byBjYWxsIHRoZSBtZXRob2QuXG5cdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYW4gYXJyYXkgYXMgdGhlIG5ldyBhcmd1bWVudHMgdG8gdXNlIHRvIGNhbGxcblx0XHQvL1x0XHR0aGUgb3JpZ2luYWwgbWV0aG9kIChvciB0aGUgcHJldmlvdXMsIG5leHQtdG8tZXhlY3V0ZSBiZWZvcmUgYWR2aWNlLCBpZiBvbmUgZXhpc3RzKS5cblx0XHQvL1x0XHRJZiB0aGUgYmVmb3JlIG1ldGhvZCBkb2Vzbid0IHJldHVybiBhbnl0aGluZyAocmV0dXJucyB1bmRlZmluZWQpIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHQvL1x0XHR3aWxsIGJlIHByZXNlcnZlZC5cblx0XHQvL1x0XHRJZiB0aGVyZSBhcmUgbXVsdGlwbGUgXCJiZWZvcmVcIiBhZHZpc29ycywgdGhleSBhcmUgZXhlY3V0ZWQgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG5cdFx0Ly8gdGFyZ2V0OiBPYmplY3Rcblx0XHQvL1x0XHRUaGlzIGlzIHRoZSB0YXJnZXQgb2JqZWN0XG5cdFx0Ly8gbWV0aG9kTmFtZTogU3RyaW5nXG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGF0dGFjaCB0by5cblx0XHQvLyBhZHZpY2U6IEZ1bmN0aW9uXG5cdFx0Ly9cdFx0VGhpcyBpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYmVmb3JlIHRoZSBvcmlnaW5hbCBtZXRob2Rcblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciBhcm91bmQgPSBhc3BlY3QoXCJhcm91bmRcIik7XG5cdC8qPT09PT1cblx0IGFyb3VuZCA9IGZ1bmN0aW9uKHRhcmdldCwgbWV0aG9kTmFtZSwgYWR2aWNlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoZSBcImFyb3VuZFwiIGV4cG9ydCBvZiB0aGUgYXNwZWN0IG1vZHVsZSBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXR0YWNoXG5cdFx0Ly9cdFx0XCJhcm91bmRcIiBhZHZpY2UgdG8gYSBtZXRob2QuIFRoZSBhZHZpc29yIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGV4ZWN1dGVkIHdoZW5cblx0XHQvL1x0XHR0aGUgYXJvdW5kKCkgaXMgY2FsbGVkLCBpcyBwYXNzZWQgYSBzaW5nbGUgYXJndW1lbnQgdGhhdCBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG5cdFx0Ly9cdFx0Y2FsbGVkIHRvIGNvbnRpbnVlIGV4ZWN1dGlvbiBvZiB0aGUgb3JpZ2luYWwgbWV0aG9kIChvciB0aGUgbmV4dCBhcm91bmQgYWR2aXNvcikuXG5cdFx0Ly9cdFx0VGhlIGFkdmlzb3IgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uLCBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlclxuXHRcdC8vXHRcdHRoZSBtZXRob2QgaXMgY2FsbGVkLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBhcmd1bWVudHMgdXNlZCB0byBjYWxsIHRoZSBtZXRob2QuXG5cdFx0Ly9cdFx0V2hhdGV2ZXIgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHdpbGwgYmUgcmV0dXJuZWQgYXMgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgKHVubGVzcyBhZnRlciBhZHZpc2UgY2hhbmdlcyBpdCkuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRJZiB0aGVyZSBhcmUgbXVsdGlwbGUgXCJhcm91bmRcIiBhZHZpc29ycywgdGhlIG1vc3QgcmVjZW50IG9uZSBpcyBleGVjdXRlZCBmaXJzdCxcblx0XHQvL1x0XHR3aGljaCBjYW4gdGhlbiBkZWxlZ2F0ZSB0byB0aGUgbmV4dCBvbmUgYW5kIHNvIG9uLiBGb3IgZXhhbXBsZTpcblx0XHQvL1x0XHR8XHRhcm91bmQob2JqLCBcImZvb1wiLCBmdW5jdGlvbihvcmlnaW5hbEZvbyl7XG5cdFx0Ly9cdFx0fFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQvL1x0XHR8XHRcdFx0dmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0Ly9cdFx0fFx0XHRcdHZhciByZXN1bHRzID0gb3JpZ2luYWxGb28uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgb3JpZ2luYWxcblx0XHQvL1x0XHR8XHRcdFx0dmFyIGVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdC8vXHRcdHxcdFx0XHRjb25zb2xlLmxvZyhcImZvbyBleGVjdXRpb24gdG9vayBcIiArIChlbmQgLSBzdGFydCkgKyBcIiBtc1wiKTtcblx0XHQvL1x0XHR8XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0Ly9cdFx0fFx0XHR9O1xuXHRcdC8vXHRcdHxcdH0pO1xuXHRcdC8vIHRhcmdldDogT2JqZWN0XG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgdGFyZ2V0IG9iamVjdFxuXHRcdC8vIG1ldGhvZE5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBhdHRhY2ggdG8uXG5cdFx0Ly8gYWR2aWNlOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoaXMgaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFyb3VuZCB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cdH07XG5cdD09PT09Ki9cblxuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0cHJvdmlkZXMgYXNwZWN0IG9yaWVudGVkIHByb2dyYW1taW5nIGZ1bmN0aW9uYWxpdHksIGFsbG93aW5nIGZvclxuXHRcdC8vXHRcdG9uZSB0byBhZGQgYmVmb3JlLCBhcm91bmQsIG9yIGFmdGVyIGFkdmljZSBvbiBleGlzdGluZyBtZXRob2RzLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdGRlZmluZShbXCJkb2pvL2FzcGVjdFwiXSwgZnVuY3Rpb24oYXNwZWN0KXtcblx0XHQvL1x0fFx0XHR2YXIgc2lnbmFsID0gYXNwZWN0LmFmdGVyKHRhcmdldE9iamVjdCwgXCJtZXRob2ROYW1lXCIsIGZ1bmN0aW9uKHNvbWVBcmd1bWVudCl7XG5cdFx0Ly9cdHxcdFx0XHR0aGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGFyZ2V0T2JqZWN0Lm1ldGhvZE5hbWUoKSBpcyBjYWxsZWQsIGFmdGVyIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyBjYWxsZWRcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFRoZSByZXR1cm5lZCBzaWduYWwgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYWR2aWNlLlxuXHRcdC8vXHR8XHRzaWduYWwucmVtb3ZlKCk7IC8vIHRoaXMgd2lsbCBzdG9wIHRoZSBhZHZpY2UgZnJvbSBiZWluZyBleGVjdXRlZCBhbnltb3JlXG5cdFx0Ly9cdHxcdGFzcGVjdC5iZWZvcmUodGFyZ2V0T2JqZWN0LCBcIm1ldGhvZE5hbWVcIiwgZnVuY3Rpb24oc29tZUFyZ3VtZW50KXtcblx0XHQvL1x0fFx0XHQvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGFyZ2V0T2JqZWN0Lm1ldGhvZE5hbWUoKSBpcyBjYWxsZWQsIGJlZm9yZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaXMgY2FsbGVkXG5cdFx0Ly9cdHxcdCB9KTtcblxuXHRcdGJlZm9yZTogYmVmb3JlLFxuXHRcdGFyb3VuZDogYXJvdW5kLFxuXHRcdGFmdGVyOiBhZnRlclxuXHR9O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL3RleHRcIl0sIGZ1bmN0aW9uKGRvam8pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vY2FjaGVcblxuXHQvLyBkb2pvLmNhY2hlIGlzIGRlZmluZWQgaW4gZG9qby90ZXh0XG5cdHJldHVybiBkb2pvLmNhY2hlO1xufSk7XG4iLCJkZWZpbmUoW1wiLi4vX2Jhc2UvbGFuZ1wiLCBcIi4uL19iYXNlL2FycmF5XCJdLCBmdW5jdGlvbihsYW5nLCBhcnJheSl7XG5cbi8vIG1vZHVsZTpcbi8vXHRcdGRvam8vZGF0ZS9zdGFtcFxuXG52YXIgc3RhbXAgPSB7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRPRE9DXG59O1xubGFuZy5zZXRPYmplY3QoXCJkb2pvLmRhdGUuc3RhbXBcIiwgc3RhbXApO1xuXG4vLyBNZXRob2RzIHRvIGNvbnZlcnQgZGF0ZXMgdG8gb3IgZnJvbSBhIHdpcmUgKHN0cmluZykgZm9ybWF0IHVzaW5nIHdlbGwta25vd24gY29udmVudGlvbnNcblxuc3RhbXAuZnJvbUlTT1N0cmluZyA9IGZ1bmN0aW9uKC8qU3RyaW5nKi8gZm9ybWF0dGVkU3RyaW5nLCAvKk51bWJlcj8qLyBkZWZhdWx0VGltZSl7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFJldHVybnMgYSBEYXRlIG9iamVjdCBnaXZlbiBhIHN0cmluZyBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIGEgc3Vic2V0IG9mIHRoZSBJU08tODYwMSBzdGFuZGFyZC5cblx0Ly9cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdEFjY2VwdHMgYSBzdHJpbmcgZm9ybWF0dGVkIGFjY29yZGluZyB0byBhIHByb2ZpbGUgb2YgSVNPODYwMSBhcyBkZWZpbmVkIGJ5XG5cdC8vXHRcdFtSRkMzMzM5XShodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzMzM5LnR4dCksIGV4Y2VwdCB0aGF0IHBhcnRpYWwgaW5wdXQgaXMgYWxsb3dlZC5cblx0Ly9cdFx0Q2FuIGFsc28gcHJvY2VzcyBkYXRlcyBhcyBzcGVjaWZpZWQgW2J5IHRoZSBXM0NdKGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWUpXG5cdC8vXHRcdFRoZSBmb2xsb3dpbmcgY29tYmluYXRpb25zIGFyZSB2YWxpZDpcblx0Ly9cblx0Ly9cdFx0LSBkYXRlcyBvbmx5XG5cdC8vXHRcdFx0LSB5eXl5XG5cdC8vXHRcdFx0LSB5eXl5LU1NXG5cdC8vXHRcdFx0LSB5eXl5LU1NLWRkXG5cdC8vXHRcdC0gdGltZXMgb25seSwgd2l0aCBhbiBvcHRpb25hbCB0aW1lIHpvbmUgYXBwZW5kZWRcblx0Ly9cdFx0XHQtIFRISDptbVxuXHQvL1x0XHRcdC0gVEhIOm1tOnNzXG5cdC8vXHRcdFx0LSBUSEg6bW06c3MuU1NTXG5cdC8vXHRcdC0gYW5kIFwiZGF0ZXRpbWVzXCIgd2hpY2ggY291bGQgYmUgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZVxuXHQvL1xuXHQvL1x0XHR0aW1lem9uZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBaIChmb3IgVVRDKSBvciArLy0gZm9sbG93ZWQgYnkgYSB0aW1lIGV4cHJlc3Npb24gSEg6bW1cblx0Ly9cdFx0QXNzdW1lcyB0aGUgbG9jYWwgdGltZSB6b25lIGlmIG5vdCBzcGVjaWZpZWQuICBEb2VzIG5vdCB2YWxpZGF0ZS4gIEltcHJvcGVybHkgZm9ybWF0dGVkXG5cdC8vXHRcdGlucHV0IG1heSByZXR1cm4gbnVsbC4gIEFyZ3VtZW50cyB3aGljaCBhcmUgb3V0IG9mIGJvdW5kcyB3aWxsIGJlIGhhbmRsZWRcblx0Ly9cdFx0YnkgdGhlIERhdGUgY29uc3RydWN0b3IgKGUuZy4gSmFudWFyeSAzMm5kIHR5cGljYWxseSBnZXRzIHJlc29sdmVkIHRvIEZlYnJ1YXJ5IDFzdClcblx0Ly9cdFx0T25seSB5ZWFycyBiZXR3ZWVuIDEwMCBhbmQgOTk5OSBhcmUgc3VwcG9ydGVkLlxuICBcdC8vIGZvcm1hdHRlZFN0cmluZzpcblx0Ly9cdFx0QSBzdHJpbmcgc3VjaCBhcyAyMDA1LTA2LTMwVDA4OjA1OjAwLTA3OjAwIG9yIDIwMDUtMDYtMzAgb3IgVDA4OjA1OjAwXG5cdC8vIGRlZmF1bHRUaW1lOlxuXHQvL1x0XHRVc2VkIGZvciBkZWZhdWx0cyBmb3IgZmllbGRzIG9taXR0ZWQgaW4gdGhlIGZvcm1hdHRlZFN0cmluZy5cblx0Ly9cdFx0VXNlcyAxOTcwLTAxLTAxVDAwOjAwOjAwLjBaIGJ5IGRlZmF1bHQuXG5cblx0aWYoIXN0YW1wLl9pc29SZWdFeHApe1xuXHRcdHN0YW1wLl9pc29SZWdFeHAgPVxuLy9UT0RPOiBjb3VsZCBiZSBtb3JlIHJlc3RyaWN0aXZlIGFuZCBjaGVjayBmb3IgMDAtNTksIGV0Yy5cblx0XHRcdC9eKD86KFxcZHs0fSkoPzotKFxcZHsyfSkoPzotKFxcZHsyfSkpPyk/KT8oPzpUKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoLlxcZCspPyk/KCg/OlsrLV0oXFxkezJ9KTooXFxkezJ9KSl8Wik/KT8kLztcblx0fVxuXG5cdHZhciBtYXRjaCA9IHN0YW1wLl9pc29SZWdFeHAuZXhlYyhmb3JtYXR0ZWRTdHJpbmcpLFxuXHRcdHJlc3VsdCA9IG51bGw7XG5cblx0aWYobWF0Y2gpe1xuXHRcdG1hdGNoLnNoaWZ0KCk7XG5cdFx0aWYobWF0Y2hbMV0pe21hdGNoWzFdLS07fSAvLyBKYXZhc2NyaXB0IERhdGUgbW9udGhzIGFyZSAwLWJhc2VkXG5cdFx0aWYobWF0Y2hbNl0pe21hdGNoWzZdICo9IDEwMDA7fSAvLyBKYXZhc2NyaXB0IERhdGUgZXhwZWN0cyBmcmFjdGlvbmFsIHNlY29uZHMgYXMgbWlsbGlzZWNvbmRzXG5cblx0XHRpZihkZWZhdWx0VGltZSl7XG5cdFx0XHQvLyBtaXggaW4gZGVmYXVsdFRpbWUuICBSZWxhdGl2ZWx5IGV4cGVuc2l2ZSwgc28gdXNlIHx8IG9wZXJhdG9ycyBmb3IgdGhlIGZhc3QgcGF0aCBvZiBkZWZhdWx0VGltZSA9PT0gMFxuXHRcdFx0ZGVmYXVsdFRpbWUgPSBuZXcgRGF0ZShkZWZhdWx0VGltZSk7XG5cdFx0XHRhcnJheS5mb3JFYWNoKGFycmF5Lm1hcChbXCJGdWxsWWVhclwiLCBcIk1vbnRoXCIsIFwiRGF0ZVwiLCBcIkhvdXJzXCIsIFwiTWludXRlc1wiLCBcIlNlY29uZHNcIiwgXCJNaWxsaXNlY29uZHNcIl0sIGZ1bmN0aW9uKHByb3Ape1xuXHRcdFx0XHRyZXR1cm4gZGVmYXVsdFRpbWVbXCJnZXRcIiArIHByb3BdKCk7XG5cdFx0XHR9KSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KXtcblx0XHRcdFx0bWF0Y2hbaW5kZXhdID0gbWF0Y2hbaW5kZXhdIHx8IHZhbHVlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJlc3VsdCA9IG5ldyBEYXRlKG1hdGNoWzBdfHwxOTcwLCBtYXRjaFsxXXx8MCwgbWF0Y2hbMl18fDEsIG1hdGNoWzNdfHwwLCBtYXRjaFs0XXx8MCwgbWF0Y2hbNV18fDAsIG1hdGNoWzZdfHwwKTsgLy9UT0RPOiBVVEMgZGVmYXVsdHNcblx0XHRpZihtYXRjaFswXSA8IDEwMCl7XG5cdFx0XHRyZXN1bHQuc2V0RnVsbFllYXIobWF0Y2hbMF0gfHwgMTk3MCk7XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldCA9IDAsXG5cdFx0XHR6b25lU2lnbiA9IG1hdGNoWzddICYmIG1hdGNoWzddLmNoYXJBdCgwKTtcblx0XHRpZih6b25lU2lnbiAhPSAnWicpe1xuXHRcdFx0b2Zmc2V0ID0gKChtYXRjaFs4XSB8fCAwKSAqIDYwKSArIChOdW1iZXIobWF0Y2hbOV0pIHx8IDApO1xuXHRcdFx0aWYoem9uZVNpZ24gIT0gJy0nKXsgb2Zmc2V0ICo9IC0xOyB9XG5cdFx0fVxuXHRcdGlmKHpvbmVTaWduKXtcblx0XHRcdG9mZnNldCAtPSByZXN1bHQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblx0XHR9XG5cdFx0aWYob2Zmc2V0KXtcblx0XHRcdHJlc3VsdC5zZXRUaW1lKHJlc3VsdC5nZXRUaW1lKCkgKyBvZmZzZXQgKiA2MDAwMCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDsgLy8gRGF0ZSBvciBudWxsXG59O1xuXG4vKj09PT09XG52YXIgX19PcHRpb25zID0ge1xuXHQvLyBzZWxlY3RvcjogU3RyaW5nXG5cdC8vXHRcdFwiZGF0ZVwiIG9yIFwidGltZVwiIGZvciBwYXJ0aWFsIGZvcm1hdHRpbmcgb2YgdGhlIERhdGUgb2JqZWN0LlxuXHQvL1x0XHRCb3RoIGRhdGUgYW5kIHRpbWUgd2lsbCBiZSBmb3JtYXR0ZWQgYnkgZGVmYXVsdC5cblx0Ly8genVsdTogQm9vbGVhblxuXHQvL1x0XHRpZiB0cnVlLCBVVEMvR01UIGlzIHVzZWQgZm9yIGEgdGltZXpvbmVcblx0Ly8gbWlsbGlzZWNvbmRzOiBCb29sZWFuXG5cdC8vXHRcdGlmIHRydWUsIG91dHB1dCBtaWxsaXNlY29uZHNcbn07XG49PT09PSovXG5cbnN0YW1wLnRvSVNPU3RyaW5nID0gZnVuY3Rpb24oLypEYXRlKi8gZGF0ZU9iamVjdCwgLypfX09wdGlvbnM/Ki8gb3B0aW9ucyl7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdEZvcm1hdCBhIERhdGUgb2JqZWN0IGFzIGEgc3RyaW5nIGFjY29yZGluZyBhIHN1YnNldCBvZiB0aGUgSVNPLTg2MDEgc3RhbmRhcmRcblx0Ly9cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdFdoZW4gb3B0aW9ucy5zZWxlY3RvciBpcyBvbWl0dGVkLCBvdXRwdXQgZm9sbG93cyBbUkZDMzMzOV0oaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpXG5cdC8vXHRcdFRoZSBsb2NhbCB0aW1lIHpvbmUgaXMgaW5jbHVkZWQgYXMgYW4gb2Zmc2V0IGZyb20gR01ULCBleGNlcHQgd2hlbiBzZWxlY3Rvcj09J3RpbWUnICh0aW1lIHdpdGhvdXQgYSBkYXRlKVxuXHQvL1x0XHREb2VzIG5vdCBjaGVjayBib3VuZHMuICBPbmx5IHllYXJzIGJldHdlZW4gMTAwIGFuZCA5OTk5IGFyZSBzdXBwb3J0ZWQuXG5cdC8vXG5cdC8vIGRhdGVPYmplY3Q6XG5cdC8vXHRcdEEgRGF0ZSBvYmplY3RcblxuXHR2YXIgXyA9IGZ1bmN0aW9uKG4peyByZXR1cm4gKG4gPCAxMCkgPyBcIjBcIiArIG4gOiBuOyB9O1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0dmFyIGZvcm1hdHRlZERhdGUgPSBbXSxcblx0XHRnZXR0ZXIgPSBvcHRpb25zLnp1bHUgPyBcImdldFVUQ1wiIDogXCJnZXRcIixcblx0XHRkYXRlID0gXCJcIjtcblx0aWYob3B0aW9ucy5zZWxlY3RvciAhPSBcInRpbWVcIil7XG5cdFx0dmFyIHllYXIgPSBkYXRlT2JqZWN0W2dldHRlcitcIkZ1bGxZZWFyXCJdKCk7XG5cdFx0ZGF0ZSA9IFtcIjAwMDBcIi5zdWJzdHIoKHllYXIrXCJcIikubGVuZ3RoKSt5ZWFyLCBfKGRhdGVPYmplY3RbZ2V0dGVyK1wiTW9udGhcIl0oKSsxKSwgXyhkYXRlT2JqZWN0W2dldHRlcitcIkRhdGVcIl0oKSldLmpvaW4oJy0nKTtcblx0fVxuXHRmb3JtYXR0ZWREYXRlLnB1c2goZGF0ZSk7XG5cdGlmKG9wdGlvbnMuc2VsZWN0b3IgIT0gXCJkYXRlXCIpe1xuXHRcdHZhciB0aW1lID0gW18oZGF0ZU9iamVjdFtnZXR0ZXIrXCJIb3Vyc1wiXSgpKSwgXyhkYXRlT2JqZWN0W2dldHRlcitcIk1pbnV0ZXNcIl0oKSksIF8oZGF0ZU9iamVjdFtnZXR0ZXIrXCJTZWNvbmRzXCJdKCkpXS5qb2luKCc6Jyk7XG5cdFx0dmFyIG1pbGxpcyA9IGRhdGVPYmplY3RbZ2V0dGVyK1wiTWlsbGlzZWNvbmRzXCJdKCk7XG5cdFx0aWYob3B0aW9ucy5taWxsaXNlY29uZHMpe1xuXHRcdFx0dGltZSArPSBcIi5cIisgKG1pbGxpcyA8IDEwMCA/IFwiMFwiIDogXCJcIikgKyBfKG1pbGxpcyk7XG5cdFx0fVxuXHRcdGlmKG9wdGlvbnMuenVsdSl7XG5cdFx0XHR0aW1lICs9IFwiWlwiO1xuXHRcdH1lbHNlIGlmKG9wdGlvbnMuc2VsZWN0b3IgIT0gXCJ0aW1lXCIpe1xuXHRcdFx0dmFyIHRpbWV6b25lT2Zmc2V0ID0gZGF0ZU9iamVjdC5nZXRUaW1lem9uZU9mZnNldCgpO1xuXHRcdFx0dmFyIGFic09mZnNldCA9IE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KTtcblx0XHRcdHRpbWUgKz0gKHRpbWV6b25lT2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCIpICtcblx0XHRcdFx0XyhNYXRoLmZsb29yKGFic09mZnNldC82MCkpICsgXCI6XCIgKyBfKGFic09mZnNldCU2MCk7XG5cdFx0fVxuXHRcdGZvcm1hdHRlZERhdGUucHVzaCh0aW1lKTtcblx0fVxuXHRyZXR1cm4gZm9ybWF0dGVkRGF0ZS5qb2luKCdUJyk7IC8vIFN0cmluZ1xufTtcblxucmV0dXJuIHN0YW1wO1xufSk7XG4iLCJkZWZpbmUoW1wiZXhwb3J0c1wiLCBcIi4vc25pZmZcIiwgXCIuL19iYXNlL2xhbmdcIiwgXCIuL2RvbVwiLCBcIi4vZG9tLXN0eWxlXCIsIFwiLi9kb20tcHJvcFwiXSxcblx0XHRmdW5jdGlvbihleHBvcnRzLCBoYXMsIGxhbmcsIGRvbSwgc3R5bGUsIHByb3Ape1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZG9tLWF0dHJcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBhdHRyaWJ1dGVzIEFQSS5cblxuXHQvLyBUT0RPQzogc3VtbWFyeSBub3Qgc2hvd2luZyB1cCBpbiBvdXRwdXQgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc25vdmVyL2pzLWRvYy1wYXJzZS9pc3N1ZXMvNDJcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBFbGVtZW50IGF0dHJpYnV0ZSBGdW5jdGlvbnNcblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHQvLyBUaGlzIG1vZHVsZSB3aWxsIGJlIG9ic29sZXRlIHNvb24uIFVzZSBkb2pvL3Byb3AgaW5zdGVhZC5cblxuXHQvLyBkb2pvL2RvbS1hdHRyLmdldCgpIHNob3VsZCBjb25mb3JtIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUNvcmUvXG5cblx0Ly8gYXR0cmlidXRlLXJlbGF0ZWQgZnVuY3Rpb25zICh0byBiZSBvYnNvbGV0ZSBzb29uKVxuXHR2YXIgZm9yY2VQcm9wTmFtZXMgPSB7XG5cdFx0XHRpbm5lckhUTUw6XHQxLFxuXHRcdFx0dGV4dENvbnRlbnQ6MSxcblx0XHRcdGNsYXNzTmFtZTpcdDEsXG5cdFx0XHRodG1sRm9yOlx0aGFzKFwiaWVcIikgPyAxIDogMCxcblx0XHRcdHZhbHVlOlx0XHQxXG5cdFx0fSxcblx0XHRhdHRyTmFtZXMgPSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBhdHRyaWJ1dGUgbmFtZXNcblx0XHRcdGNsYXNzbmFtZTogXCJjbGFzc1wiLFxuXHRcdFx0aHRtbGZvcjogXCJmb3JcIixcblx0XHRcdC8vIGZvciBJRVxuXHRcdFx0dGFiaW5kZXg6IFwidGFiSW5kZXhcIixcblx0XHRcdHJlYWRvbmx5OiBcInJlYWRPbmx5XCJcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIF9oYXNBdHRyKG5vZGUsIG5hbWUpe1xuXHRcdHZhciBhdHRyID0gbm9kZS5nZXRBdHRyaWJ1dGVOb2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlTm9kZShuYW1lKTtcblx0XHRyZXR1cm4gISFhdHRyICYmIGF0dHIuc3BlY2lmaWVkOyAvLyBCb29sZWFuXG5cdH1cblx0XG5cdC8vIFRoZXJlIGlzIGEgZGlmZmVyZW5jZSBpbiB0aGUgcHJlc2VuY2Ugb2YgY2VydGFpbiBwcm9wZXJ0aWVzIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xuXHQvLyBiZXR3ZWVuIGJyb3dzZXJzLiBGb3IgZXhhbXBsZSwgb24gSUUgXCJkaXNhYmxlZFwiIGlzIHByZXNlbnQgb24gYWxsIGVsZW1lbnRzLFxuXHQvLyBidXQgaXQgaXMgdmFsdWUgaXMgXCJmYWxzZVwiOyBcInRhYkluZGV4XCIgb2YgPGRpdj4gcmV0dXJucyAwIGJ5IGRlZmF1bHQgb24gSUUsIHlldCBvdGhlciBicm93c2Vyc1xuXHQvLyBjYW4gcmV0dXJuIC0xLlxuXG5cdGV4cG9ydHMuaGFzID0gZnVuY3Rpb24gaGFzQXR0cigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWQgb24gdGhlXG5cdFx0Ly9cdFx0Z2l2ZW4gZWxlbWVudCwgYW5kIGZhbHNlIG90aGVyd2lzZS5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBjaGVja1xuXHRcdC8vIG5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcblx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cdFx0Ly9cdFx0dHJ1ZSBpZiB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWQgb24gdGhlXG5cdFx0Ly9cdFx0Z2l2ZW4gZWxlbWVudCwgYW5kIGZhbHNlIG90aGVyd2lzZVxuXG5cdFx0dmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAhIWZvcmNlUHJvcE5hbWVzW3Byb3AubmFtZXNbbGNdIHx8IG5hbWVdIHx8IF9oYXNBdHRyKGRvbS5ieUlkKG5vZGUpLCBhdHRyTmFtZXNbbGNdIHx8IG5hbWUpO1x0Ly8gQm9vbGVhblxuXHR9O1xuXG5cdGV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0QXR0cigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEdldHMgYW4gYXR0cmlidXRlIG9uIGFuIEhUTUwgZWxlbWVudC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRIYW5kbGVzIG5vcm1hbGl6ZWQgZ2V0dGluZyBvZiBhdHRyaWJ1dGVzIG9uIERPTSBOb2Rlcy5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBnZXQgdGhlIGF0dHJpYnV0ZSBvblxuXHRcdC8vIG5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0LlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0dGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgYXR0cmlidXRlIG9yIG51bGwgaWYgdGhhdCBhdHRyaWJ1dGUgZG9lcyBub3QgaGF2ZSBhIHNwZWNpZmllZCBvclxuXHRcdC8vXHRcdGRlZmF1bHQgdmFsdWU7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHQvLyBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFwiZm9vXCIgYXR0cmlidXRlIG9uIGEgbm9kZVxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWF0dHJcIiwgXCJkb2pvL2RvbVwiXSwgZnVuY3Rpb24oZG9tQXR0ciwgZG9tKXtcblx0XHQvL1x0fFx0XHRkb21BdHRyLmdldChkb20uYnlJZChcIm5vZGVJZFwiKSwgXCJmb29cIik7XG5cdFx0Ly9cdHxcdFx0Ly8gb3Igd2UgY2FuIGp1c3QgcGFzcyB0aGUgaWQ6XG5cdFx0Ly9cdHxcdFx0ZG9tQXR0ci5nZXQoXCJub2RlSWRcIiwgXCJmb29cIik7XG5cdFx0Ly9cdHxcdH0pO1x0XG5cdFx0Ly9cdHxcdFxuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdHZhciBsYyA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdHByb3BOYW1lID0gcHJvcC5uYW1lc1tsY10gfHwgbmFtZSxcblx0XHRcdGZvcmNlUHJvcCA9IGZvcmNlUHJvcE5hbWVzW3Byb3BOYW1lXSxcblx0XHRcdHZhbHVlID0gbm9kZVtwcm9wTmFtZV07XHRcdC8vIHNob3VsZCB3ZSBhY2Nlc3MgdGhpcyBhdHRyaWJ1dGUgdmlhIGEgcHJvcGVydHkgb3IgdmlhIGdldEF0dHJpYnV0ZSgpP1xuXG5cdFx0aWYoZm9yY2VQcm9wICYmIHR5cGVvZiB2YWx1ZSAhPSBcInVuZGVmaW5lZFwiKXtcblx0XHRcdC8vIG5vZGUncyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHZhbHVlO1x0Ly8gQW55dGhpbmdcblx0XHR9XG5cdFx0XG5cdFx0aWYocHJvcE5hbWUgPT0gXCJ0ZXh0Q29udGVudFwiKXtcblx0XHRcdHJldHVybiBwcm9wLmdldChub2RlLCBwcm9wTmFtZSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmKHByb3BOYW1lICE9IFwiaHJlZlwiICYmICh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIgfHwgbGFuZy5pc0Z1bmN0aW9uKHZhbHVlKSkpe1xuXHRcdFx0Ly8gbm9kZSdzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdmFsdWU7XHQvLyBBbnl0aGluZ1xuXHRcdH1cblx0XHQvLyBub2RlJ3MgYXR0cmlidXRlXG5cdFx0Ly8gd2UgbmVlZCBfaGFzQXR0cigpIGhlcmUgdG8gZ3VhcmQgYWdhaW5zdCBJRSByZXR1cm5pbmcgYSBkZWZhdWx0IHZhbHVlXG5cdFx0dmFyIGF0dHJOYW1lID0gYXR0ck5hbWVzW2xjXSB8fCBuYW1lO1xuXHRcdHJldHVybiBfaGFzQXR0cihub2RlLCBhdHRyTmFtZSkgPyBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgOiBudWxsOyAvLyBBbnl0aGluZ1xuXHR9O1xuXG5cdGV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gc2V0QXR0cigvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmd8T2JqZWN0Ki8gbmFtZSwgLypTdHJpbmc/Ki8gdmFsdWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2V0cyBhbiBhdHRyaWJ1dGUgb24gYW4gSFRNTCBlbGVtZW50LlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEhhbmRsZXMgbm9ybWFsaXplZCBzZXR0aW5nIG9mIGF0dHJpYnV0ZXMgb24gRE9NIE5vZGVzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0V2hlbiBwYXNzaW5nIGZ1bmN0aW9ucyBhcyB2YWx1ZXMsIG5vdGUgdGhhdCB0aGV5IHdpbGwgbm90IGJlXG5cdFx0Ly9cdFx0ZGlyZWN0bHkgYXNzaWduZWQgdG8gc2xvdHMgb24gdGhlIG5vZGUsIGJ1dCByYXRoZXIgdGhlIGRlZmF1bHRcblx0XHQvL1x0XHRiZWhhdmlvciB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBuZXcgYmVoYXZpb3Igd2lsbCBiZSBhZGRlZFxuXHRcdC8vXHRcdHVzaW5nIGBkb2pvLmNvbm5lY3QoKWAsIG1lYW5pbmcgdGhhdCBldmVudCBoYW5kbGVyIHByb3BlcnRpZXNcblx0XHQvL1x0XHR3aWxsIGJlIG5vcm1hbGl6ZWQgYW5kIHRoYXQgc29tZSBjYXZlYXRzIHdpdGggcmVnYXJkcyB0b1xuXHRcdC8vXHRcdG5vbi1zdGFuZGFyZCBiZWhhdmlvcnMgZm9yIG9uc3VibWl0IGFwcGx5LiBOYW1lbHkgdGhhdCB5b3Vcblx0XHQvL1x0XHRzaG91bGQgY2FuY2VsIGZvcm0gc3VibWlzc2lvbiB1c2luZyBgZG9qby5zdG9wRXZlbnQoKWAgb24gdGhlXG5cdFx0Ly9cdFx0cGFzc2VkIGV2ZW50IG9iamVjdCBpbnN0ZWFkIG9mIHJldHVybmluZyBhIGJvb2xlYW4gdmFsdWUgZnJvbVxuXHRcdC8vXHRcdHRoZSBoYW5kbGVyIGl0c2VsZi5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBvblxuXHRcdC8vIG5hbWU6IFN0cmluZ3xPYmplY3Rcblx0XHQvL1x0XHR0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldCwgb3IgYSBoYXNoIG9mIGtleS12YWx1ZSBwYWlycyB0byBzZXQuXG5cdFx0Ly8gdmFsdWU6IFN0cmluZz9cblx0XHQvL1x0XHR0aGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgYXR0cmlidXRlLCBpZiB0aGUgbmFtZSBpcyBhIHN0cmluZy5cblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdHRoZSBET00gbm9kZVxuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0Ly8gdXNlIGF0dHIoKSB0byBzZXQgdGhlIHRhYiBpbmRleFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWF0dHJcIl0sIGZ1bmN0aW9uKGRvbUF0dHIpe1xuXHRcdC8vXHR8XHRcdGRvbUF0dHIuc2V0KFwibm9kZUlkXCIsIFwidGFiSW5kZXhcIiwgMyk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0U2V0IG11bHRpcGxlIHZhbHVlcyBhdCBvbmNlLCBpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnM6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tYXR0clwiXSxcblx0XHQvL1x0fFx0ZnVuY3Rpb24oZG9tQXR0cil7XG5cdFx0Ly9cdHxcdFx0ZG9tQXR0ci5zZXQoXCJmb3JtSWRcIiwge1xuXHRcdC8vXHR8XHRcdFx0XCJmb29cIjogXCJiYXJcIixcblx0XHQvL1x0fFx0XHRcdFwidGFiSW5kZXhcIjogLTEsXG5cdFx0Ly9cdHxcdFx0XHRcIm1ldGhvZFwiOiBcIlBPU1RcIlxuXHRcdC8vXHR8XHRcdH1cblx0XHQvL1x0fFx0fSk7XG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAyKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0Ly8gdGhlIG9iamVjdCBmb3JtIG9mIHNldHRlcjogdGhlIDJuZCBhcmd1bWVudCBpcyBhIGRpY3Rpb25hcnlcblx0XHRcdGZvcih2YXIgeCBpbiBuYW1lKXtcblx0XHRcdFx0ZXhwb3J0cy5zZXQobm9kZSwgeCwgbmFtZVt4XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHR2YXIgbGMgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRwcm9wTmFtZSA9IHByb3AubmFtZXNbbGNdIHx8IG5hbWUsXG5cdFx0XHRmb3JjZVByb3AgPSBmb3JjZVByb3BOYW1lc1twcm9wTmFtZV07XG5cdFx0aWYocHJvcE5hbWUgPT0gXCJzdHlsZVwiICYmIHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBzZXR0aW5nIGEgc3R5bGVcblx0XHRcdHN0eWxlLnNldChub2RlLCB2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHRpZihmb3JjZVByb3AgfHwgdHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiIHx8IGxhbmcuaXNGdW5jdGlvbih2YWx1ZSkpe1xuXHRcdFx0cmV0dXJuIHByb3Auc2V0KG5vZGUsIG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdFx0Ly8gbm9kZSdzIGF0dHJpYnV0ZVxuXHRcdG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lc1tsY10gfHwgbmFtZSwgdmFsdWUpO1xuXHRcdHJldHVybiBub2RlOyAvLyBEb21Ob2RlXG5cdH07XG5cblx0ZXhwb3J0cy5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmVBdHRyKC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZyovIG5hbWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBIVE1MIGVsZW1lbnQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZnJvbVxuXHRcdC8vIG5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlXG5cblx0XHRkb20uYnlJZChub2RlKS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbmFtZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5nZXROb2RlUHJvcCA9IGZ1bmN0aW9uIGdldE5vZGVQcm9wKC8qRG9tTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZyovIG5hbWUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBhbiBlZmZlY3RpdmUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZnJvbVxuXHRcdC8vIG5hbWU6IFN0cmluZ1xuXHRcdC8vXHRcdHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpLCBwcm9wTmFtZSA9IHByb3AubmFtZXNbbGNdIHx8IG5hbWU7XG5cdFx0aWYoKHByb3BOYW1lIGluIG5vZGUpICYmIHByb3BOYW1lICE9IFwiaHJlZlwiKXtcblx0XHRcdC8vIG5vZGUncyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIG5vZGVbcHJvcE5hbWVdO1x0Ly8gQW55dGhpbmdcblx0XHR9XG5cdFx0Ly8gbm9kZSdzIGF0dHJpYnV0ZVxuXHRcdHZhciBhdHRyTmFtZSA9IGF0dHJOYW1lc1tsY10gfHwgbmFtZTtcblx0XHRyZXR1cm4gX2hhc0F0dHIobm9kZSwgYXR0ck5hbWUpID8gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpIDogbnVsbDsgLy8gQW55dGhpbmdcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2UvbGFuZ1wiLCBcIi4vX2Jhc2UvYXJyYXlcIiwgXCIuL2RvbVwiXSwgZnVuY3Rpb24obGFuZywgYXJyYXksIGRvbSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9kb20tY2xhc3NcblxuXHR2YXIgY2xhc3NOYW1lID0gXCJjbGFzc05hbWVcIjtcblxuXHQvKiBQYXJ0IEkgb2YgY2xhc3NMaXN0LWJhc2VkIGltcGxlbWVudGF0aW9uIGlzIHByZXNlcnZlZCBoZXJlIGZvciBwb3N0ZXJpdHlcblx0dmFyIGNsYXNzTGlzdCA9IFwiY2xhc3NMaXN0XCI7XG5cdGhhcy5hZGQoXCJkb20tY2xhc3NMaXN0XCIsIGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIGNsYXNzTGlzdCBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcblx0fSk7XG5cdCovXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gKENTUykgQ2xhc3MgRnVuY3Rpb25zXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblx0dmFyIGNscywgLy8gZXhwb3J0cyBvYmplY3Rcblx0XHRzcGFjZXMgPSAvXFxzKy8sIGExID0gW1wiXCJdO1xuXG5cdGZ1bmN0aW9uIHN0cjJhcnJheShzKXtcblx0XHRpZih0eXBlb2YgcyA9PSBcInN0cmluZ1wiIHx8IHMgaW5zdGFuY2VvZiBTdHJpbmcpe1xuXHRcdFx0aWYocyAmJiAhc3BhY2VzLnRlc3Qocykpe1xuXHRcdFx0XHRhMVswXSA9IHM7XG5cdFx0XHRcdHJldHVybiBhMTtcblx0XHRcdH1cblx0XHRcdHZhciBhID0gcy5zcGxpdChzcGFjZXMpO1xuXHRcdFx0aWYoYS5sZW5ndGggJiYgIWFbMF0pe1xuXHRcdFx0XHRhLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0XHRpZihhLmxlbmd0aCAmJiAhYVthLmxlbmd0aCAtIDFdKXtcblx0XHRcdFx0YS5wb3AoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH1cblx0XHQvLyBhc3N1bWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0aWYoIXMpe1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXkuZmlsdGVyKHMsIGZ1bmN0aW9uKHgpeyByZXR1cm4geDsgfSk7XG5cdH1cblxuXHQvKiBQYXJ0IElJIG9mIGNsYXNzTGlzdC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3IgcG9zdGVyaXR5XG5cdGlmKGhhcyhcImRvbS1jbGFzc0xpc3RcIikpe1xuXHRcdC8vIG5ldyBjbGFzc0xpc3QgdmVyc2lvblxuXHRcdGNscyA9IHtcblx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWluc0NsYXNzKG5vZGUsIGNsYXNzU3RyKXtcblx0XHRcdFx0dmFyIGNsc2xzdCA9IGNsYXNzU3RyICYmIGRvbS5ieUlkKG5vZGUpW2NsYXNzTGlzdF07XG5cdFx0XHRcdHJldHVybiBjbHNsc3QgJiYgY2xzbHN0LmNvbnRhaW5zKGNsYXNzU3RyKTsgLy8gQm9vbGVhblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkOiBmdW5jdGlvbiBhZGRDbGFzcyhub2RlLCBjbGFzc1N0cil7XG5cdFx0XHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRcdFx0Y2xhc3NTdHIgPSBzdHIyYXJyYXkoY2xhc3NTdHIpO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBjbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0bm9kZVtjbGFzc0xpc3RdLmFkZChjbGFzc1N0cltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NTdHIpe1xuXHRcdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRcdGlmKGNsYXNzU3RyID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRcdG5vZGVbY2xhc3NOYW1lXSA9IFwiXCI7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGNsYXNzU3RyID0gc3RyMmFycmF5KGNsYXNzU3RyKTtcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBjbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0XHRub2RlW2NsYXNzTGlzdF0ucmVtb3ZlKGNsYXNzU3RyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2VDbGFzcyhub2RlLCBhZGRDbGFzc1N0ciwgcmVtb3ZlQ2xhc3NTdHIpe1xuXHRcdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRcdGlmKHJlbW92ZUNsYXNzU3RyID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRcdG5vZGVbY2xhc3NOYW1lXSA9IFwiXCI7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHJlbW92ZUNsYXNzU3RyID0gc3RyMmFycmF5KHJlbW92ZUNsYXNzU3RyKTtcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSByZW1vdmVDbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0XHRub2RlW2NsYXNzTGlzdF0ucmVtb3ZlKHJlbW92ZUNsYXNzU3RyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YWRkQ2xhc3NTdHIgPSBzdHIyYXJyYXkoYWRkQ2xhc3NTdHIpO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGxlbiA9IGFkZENsYXNzU3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcblx0XHRcdFx0XHRub2RlW2NsYXNzTGlzdF0uYWRkKGFkZENsYXNzU3RyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0dG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhub2RlLCBjbGFzc1N0ciwgY29uZGl0aW9uKXtcblx0XHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0XHRpZihjb25kaXRpb24gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdFx0Y2xhc3NTdHIgPSBzdHIyYXJyYXkoY2xhc3NTdHIpO1xuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IGNsYXNzU3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKXtcblx0XHRcdFx0XHRcdG5vZGVbY2xhc3NMaXN0XS50b2dnbGUoY2xhc3NTdHJbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Y2xzW2NvbmRpdGlvbiA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShub2RlLCBjbGFzc1N0cik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbmRpdGlvbjsgICAvLyBCb29sZWFuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdCovXG5cblx0Ly8gcmVndWxhciBET00gdmVyc2lvblxuXHR2YXIgZmFrZU5vZGUgPSB7fTsgIC8vIGZvciBlZmZlY3RpdmUgcmVwbGFjZW1lbnRcblx0Y2xzID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBjbGFzcyBBUEkuXG5cblx0XHRjb250YWluczogZnVuY3Rpb24gY29udGFpbnNDbGFzcygvKkRvbU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBjbGFzc1N0cil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3BlY2lmaWVkIGNsYXNzZXMgYXJlIGEgcG9ydGlvbiBvZiB0aGVcblx0XHRcdC8vXHRcdGNsYXNzIGxpc3QgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlIG5vZGUuXG5cdFx0XHQvLyBub2RlOiBTdHJpbmd8RE9NTm9kZVxuXHRcdFx0Ly9cdFx0U3RyaW5nIElEIG9yIERvbU5vZGUgcmVmZXJlbmNlIHRvIGNoZWNrIHRoZSBjbGFzcyBmb3IuXG5cdFx0XHQvLyBjbGFzc1N0cjogU3RyaW5nXG5cdFx0XHQvL1x0XHRBIHN0cmluZyBjbGFzcyBuYW1lIHRvIGxvb2sgZm9yLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdERvIHNvbWV0aGluZyBpZiBhIG5vZGUgd2l0aCBpZD1cInNvbWVOb2RlXCIgaGFzIGNsYXNzPVwiYVNpbGx5Q2xhc3NOYW1lXCIgcHJlc2VudFxuXHRcdFx0Ly9cdHxcdGlmKGRvbUNsYXNzLmNvbnRhaW5zKFwic29tZU5vZGVcIixcImFTaWxseUNsYXNzTmFtZVwiKSl7IC4uLiB9XG5cblx0XHRcdHJldHVybiAoKFwiIFwiICsgZG9tLmJ5SWQobm9kZSlbY2xhc3NOYW1lXSArIFwiIFwiKS5pbmRleE9mKFwiIFwiICsgY2xhc3NTdHIgKyBcIiBcIikgPj0gMCk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiBhZGRDbGFzcygvKkRvbU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmd8QXJyYXkqLyBjbGFzc1N0cil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkcyB0aGUgc3BlY2lmaWVkIGNsYXNzZXMgdG8gdGhlIGVuZCBvZiB0aGUgY2xhc3MgbGlzdCBvbiB0aGVcblx0XHRcdC8vXHRcdHBhc3NlZCBub2RlLiBXaWxsIG5vdCByZS1hcHBseSBkdXBsaWNhdGUgY2xhc3Nlcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBub2RlOiBTdHJpbmd8RE9NTm9kZVxuXHRcdFx0Ly9cdFx0U3RyaW5nIElEIG9yIERvbU5vZGUgcmVmZXJlbmNlIHRvIGFkZCBhIGNsYXNzIHN0cmluZyB0b29cblx0XHRcdC8vXG5cdFx0XHQvLyBjbGFzc1N0cjogU3RyaW5nfEFycmF5XG5cdFx0XHQvL1x0XHRBIFN0cmluZyBjbGFzcyBuYW1lIHRvIGFkZCwgb3Igc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgY2xhc3MgbmFtZXMsXG5cdFx0XHQvL1x0XHRvciBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QWRkIGEgY2xhc3MgdG8gc29tZSBub2RlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLmFkZChcInNvbWVOb2RlXCIsIFwiYW5ld0NsYXNzXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRBZGQgdHdvIGNsYXNzZXMgYXQgb25jZTpcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNsYXNzXCJdLCBmdW5jdGlvbihkb21DbGFzcyl7XG5cdFx0XHQvL1x0fFx0XHRkb21DbGFzcy5hZGQoXCJzb21lTm9kZVwiLCBcImZpcnN0Q2xhc3Mgc2Vjb25kQ2xhc3NcIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEFkZCB0d28gY2xhc3NlcyBhdCBvbmNlICh1c2luZyBhcnJheSk6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MuYWRkKFwic29tZU5vZGVcIiwgW1wiZmlyc3RDbGFzc1wiLCBcInNlY29uZENsYXNzXCJdKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0QXZhaWxhYmxlIGluIGBkb2pvL05vZGVMaXN0YCBmb3IgbXVsdGlwbGUgYWRkaXRpb25zXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcInVsID4gbGlcIikuYWRkQ2xhc3MoXCJmaXJzdExldmVsXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXG5cdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRjbGFzc1N0ciA9IHN0cjJhcnJheShjbGFzc1N0cik7XG5cdFx0XHR2YXIgY2xzID0gbm9kZVtjbGFzc05hbWVdLCBvbGRMZW47XG5cdFx0XHRjbHMgPSBjbHMgPyBcIiBcIiArIGNscyArIFwiIFwiIDogXCIgXCI7XG5cdFx0XHRvbGRMZW4gPSBjbHMubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gY2xhc3NTdHIubGVuZ3RoLCBjOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRjID0gY2xhc3NTdHJbaV07XG5cdFx0XHRcdGlmKGMgJiYgY2xzLmluZGV4T2YoXCIgXCIgKyBjICsgXCIgXCIpIDwgMCl7XG5cdFx0XHRcdFx0Y2xzICs9IGMgKyBcIiBcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYob2xkTGVuIDwgY2xzLmxlbmd0aCl7XG5cdFx0XHRcdG5vZGVbY2xhc3NOYW1lXSA9IGNscy5zdWJzdHIoMSwgY2xzLmxlbmd0aCAtIDIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKC8qRG9tTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZ3xBcnJheT8qLyBjbGFzc1N0cil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGNsYXNzZXMgZnJvbSBub2RlLiBObyBgY29udGFpbnMoKWBcblx0XHRcdC8vXHRcdGNoZWNrIGlzIHJlcXVpcmVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIG5vZGU6IFN0cmluZ3xET01Ob2RlXG5cdFx0XHQvL1x0XHRTdHJpbmcgSUQgb3IgRG9tTm9kZSByZWZlcmVuY2UgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGNsYXNzU3RyOiBTdHJpbmd8QXJyYXlcblx0XHRcdC8vXHRcdEFuIG9wdGlvbmFsIFN0cmluZyBjbGFzcyBuYW1lIHRvIHJlbW92ZSwgb3Igc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWRcblx0XHRcdC8vXHRcdGNsYXNzIG5hbWVzLCBvciBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcy4gSWYgb21pdHRlZCwgYWxsIGNsYXNzIG5hbWVzXG5cdFx0XHQvL1x0XHR3aWxsIGJlIGRlbGV0ZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFJlbW92ZSBhIGNsYXNzIGZyb20gc29tZSBub2RlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlbW92ZShcInNvbWVOb2RlXCIsIFwiZmlyc3RDbGFzc1wiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0UmVtb3ZlIHR3byBjbGFzc2VzIGZyb20gc29tZSBub2RlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlbW92ZShcInNvbWVOb2RlXCIsIFwiZmlyc3RDbGFzcyBzZWNvbmRDbGFzc1wiKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0UmVtb3ZlIHR3byBjbGFzc2VzIGZyb20gc29tZSBub2RlICh1c2luZyBhcnJheSk6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MucmVtb3ZlKFwic29tZU5vZGVcIiwgW1wiZmlyc3RDbGFzc1wiLCBcInNlY29uZENsYXNzXCJdKTtcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0UmVtb3ZlIGFsbCBjbGFzc2VzIGZyb20gc29tZSBub2RlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY2xhc3NcIl0sIGZ1bmN0aW9uKGRvbUNsYXNzKXtcblx0XHRcdC8vXHR8XHRcdGRvbUNsYXNzLnJlbW92ZShcInNvbWVOb2RlXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRBdmFpbGFibGUgaW4gYGRvam8vTm9kZUxpc3RgIGZvciBtdWx0aXBsZSByZW1vdmFsXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcInVsID4gbGlcIikucmVtb3ZlQ2xhc3MoXCJmb29cIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRcdHZhciBjbHM7XG5cdFx0XHRpZihjbGFzc1N0ciAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0Y2xhc3NTdHIgPSBzdHIyYXJyYXkoY2xhc3NTdHIpO1xuXHRcdFx0XHRjbHMgPSBcIiBcIiArIG5vZGVbY2xhc3NOYW1lXSArIFwiIFwiO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsZW4gPSBjbGFzc1N0ci5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG5cdFx0XHRcdFx0Y2xzID0gY2xzLnJlcGxhY2UoXCIgXCIgKyBjbGFzc1N0cltpXSArIFwiIFwiLCBcIiBcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xzID0gbGFuZy50cmltKGNscyk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Y2xzID0gXCJcIjtcblx0XHRcdH1cblx0XHRcdGlmKG5vZGVbY2xhc3NOYW1lXSAhPSBjbHMpeyBub2RlW2NsYXNzTmFtZV0gPSBjbHM7IH1cblx0XHR9LFxuXG5cdFx0cmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZUNsYXNzKC8qRG9tTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZ3xBcnJheSovIGFkZENsYXNzU3RyLCAvKlN0cmluZ3xBcnJheT8qLyByZW1vdmVDbGFzc1N0cil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVwbGFjZXMgb25lIG9yIG1vcmUgY2xhc3NlcyBvbiBhIG5vZGUgaWYgbm90IHByZXNlbnQuXG5cdFx0XHQvL1x0XHRPcGVyYXRlcyBtb3JlIHF1aWNrbHkgdGhhbiBjYWxsaW5nIGRvbUNsYXNzLnJlbW92ZSBhbmQgZG9tQ2xhc3MuYWRkXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbm9kZTogU3RyaW5nfERPTU5vZGVcblx0XHRcdC8vXHRcdFN0cmluZyBJRCBvciBEb21Ob2RlIHJlZmVyZW5jZSB0byByZW1vdmUgdGhlIGNsYXNzIGZyb20uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gYWRkQ2xhc3NTdHI6IFN0cmluZ3xBcnJheVxuXHRcdFx0Ly9cdFx0QSBTdHJpbmcgY2xhc3MgbmFtZSB0byBhZGQsIG9yIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWVzLFxuXHRcdFx0Ly9cdFx0b3IgYW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gcmVtb3ZlQ2xhc3NTdHI6IFN0cmluZ3xBcnJheT9cblx0XHRcdC8vXHRcdEEgU3RyaW5nIGNsYXNzIG5hbWUgdG8gcmVtb3ZlLCBvciBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCBjbGFzcyBuYW1lcyxcblx0XHRcdC8vXHRcdG9yIGFuIGFycmF5IG9mIGNsYXNzIG5hbWVzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MucmVwbGFjZShcInNvbWVOb2RlXCIsIFwiYWRkMSBhZGQyXCIsIFwicmVtb3ZlMSByZW1vdmUyXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0UmVwbGFjZSBhbGwgY2xhc3NlcyB3aXRoIGFkZE1lXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MucmVwbGFjZShcInNvbWVOb2RlXCIsIFwiYWRkTWVcIik7XG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRBdmFpbGFibGUgaW4gYGRvam8vTm9kZUxpc3RgIGZvciBtdWx0aXBsZSB0b2dnbGVzXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcIi5maW5kTWVcIikucmVwbGFjZUNsYXNzKFwiYWRkTWVcIiwgXCJyZW1vdmVNZVwiKTtcblx0XHRcdC8vXHR8XHR9KTtcblxuXHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0ZmFrZU5vZGVbY2xhc3NOYW1lXSA9IG5vZGVbY2xhc3NOYW1lXTtcblx0XHRcdGNscy5yZW1vdmUoZmFrZU5vZGUsIHJlbW92ZUNsYXNzU3RyKTtcblx0XHRcdGNscy5hZGQoZmFrZU5vZGUsIGFkZENsYXNzU3RyKTtcblx0XHRcdGlmKG5vZGVbY2xhc3NOYW1lXSAhPT0gZmFrZU5vZGVbY2xhc3NOYW1lXSl7XG5cdFx0XHRcdG5vZGVbY2xhc3NOYW1lXSA9IGZha2VOb2RlW2NsYXNzTmFtZV07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoLypEb21Ob2RlfFN0cmluZyovIG5vZGUsIC8qU3RyaW5nfEFycmF5Ki8gY2xhc3NTdHIsIC8qQm9vbGVhbj8qLyBjb25kaXRpb24pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgYSBjbGFzcyB0byBub2RlIGlmIG5vdCBwcmVzZW50LCBvciByZW1vdmVzIGlmIHByZXNlbnQuXG5cdFx0XHQvL1x0XHRQYXNzIGEgYm9vbGVhbiBjb25kaXRpb24gaWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBhZGQgb3IgcmVtb3ZlLlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0aGUgY29uZGl0aW9uIHRoYXQgd2FzIHNwZWNpZmllZCBkaXJlY3RseSBvciBpbmRpcmVjdGx5LlxuXHRcdFx0Ly9cblx0XHRcdC8vIG5vZGU6IFN0cmluZ3xET01Ob2RlXG5cdFx0XHQvL1x0XHRTdHJpbmcgSUQgb3IgRG9tTm9kZSByZWZlcmVuY2UgdG8gdG9nZ2xlIGEgY2xhc3Mgc3RyaW5nXG5cdFx0XHQvL1xuXHRcdFx0Ly8gY2xhc3NTdHI6IFN0cmluZ3xBcnJheVxuXHRcdFx0Ly9cdFx0QSBTdHJpbmcgY2xhc3MgbmFtZSB0byB0b2dnbGUsIG9yIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWVzLFxuXHRcdFx0Ly9cdFx0b3IgYW4gYXJyYXkgb2YgY2xhc3MgbmFtZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gY29uZGl0aW9uOlxuXHRcdFx0Ly9cdFx0SWYgcGFzc2VkLCB0cnVlIG1lYW5zIHRvIGFkZCB0aGUgY2xhc3MsIGZhbHNlIG1lYW5zIHRvIHJlbW92ZS5cblx0XHRcdC8vXHRcdE90aGVyd2lzZSBkb21DbGFzcy5jb250YWlucyhub2RlLCBjbGFzc1N0cikgaXMgdXNlZCB0byBkZXRlY3QgdGhlIGNsYXNzIHByZXNlbmNlLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MudG9nZ2xlKFwic29tZU5vZGVcIiwgXCJob3ZlcmVkXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRGb3JjZWZ1bGx5IGFkZCBhIGNsYXNzXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jbGFzc1wiXSwgZnVuY3Rpb24oZG9tQ2xhc3Mpe1xuXHRcdFx0Ly9cdHxcdFx0ZG9tQ2xhc3MudG9nZ2xlKFwic29tZU5vZGVcIiwgXCJob3ZlcmVkXCIsIHRydWUpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRBdmFpbGFibGUgaW4gYGRvam8vTm9kZUxpc3RgIGZvciBtdWx0aXBsZSB0b2dnbGVzXG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcIi50b2dnbGVNZVwiKS50b2dnbGVDbGFzcyhcInRvZ2dsZU1lXCIpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXG5cdFx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0XHRpZihjb25kaXRpb24gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGNsYXNzU3RyID0gc3RyMmFycmF5KGNsYXNzU3RyKTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMCwgbGVuID0gY2xhc3NTdHIubGVuZ3RoLCBjOyBpIDwgbGVuOyArK2kpe1xuXHRcdFx0XHRcdGMgPSBjbGFzc1N0cltpXTtcblx0XHRcdFx0XHRjbHNbY2xzLmNvbnRhaW5zKG5vZGUsIGMpID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJdKG5vZGUsIGMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Y2xzW2NvbmRpdGlvbiA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShub2RlLCBjbGFzc1N0cik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29uZGl0aW9uOyAgIC8vIEJvb2xlYW5cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGNscztcbn0pO1xuIiwiZGVmaW5lKFtcImV4cG9ydHNcIiwgXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vc25pZmZcIiwgXCIuL19iYXNlL3dpbmRvd1wiLCBcIi4vZG9tXCIsIFwiLi9kb20tYXR0clwiXSxcblx0XHRmdW5jdGlvbihleHBvcnRzLCBkb2pvLCBoYXMsIHdpbiwgZG9tLCBhdHRyKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2RvbS1jb25zdHJ1Y3Rcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBjb25zdHJ1Y3Rpb24gQVBJLlxuXG5cdC8vIFRPRE9DOiBzdW1tYXJ5IG5vdCBzaG93aW5nIHVwIGluIG91dHB1dCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc25vdmVyL2pzLWRvYy1wYXJzZS9pc3N1ZXMvNDJcblxuXHQvLyBzdXBwb3J0IHN0dWZmIGZvciB0b0RvbSgpXG5cdHZhciB0YWdXcmFwID0ge1xuXHRcdFx0b3B0aW9uOiBbXCJzZWxlY3RcIl0sXG5cdFx0XHR0Ym9keTogW1widGFibGVcIl0sXG5cdFx0XHR0aGVhZDogW1widGFibGVcIl0sXG5cdFx0XHR0Zm9vdDogW1widGFibGVcIl0sXG5cdFx0XHR0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcblx0XHRcdHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG5cdFx0XHR0aDogW1widGFibGVcIiwgXCJ0aGVhZFwiLCBcInRyXCJdLFxuXHRcdFx0bGVnZW5kOiBbXCJmaWVsZHNldFwiXSxcblx0XHRcdGNhcHRpb246IFtcInRhYmxlXCJdLFxuXHRcdFx0Y29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuXHRcdFx0Y29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuXHRcdFx0bGk6IFtcInVsXCJdXG5cdFx0fSxcblx0XHRyZVRhZyA9IC88XFxzKihbXFx3XFw6XSspLyxcblx0XHRtYXN0ZXJOb2RlID0ge30sIG1hc3Rlck51bSA9IDAsXG5cdFx0bWFzdGVyTmFtZSA9IFwiX19cIiArIGRvam8uX3Njb3BlTmFtZSArIFwiVG9Eb21JZFwiO1xuXG5cdC8vIGdlbmVyYXRlIHN0YXJ0L2VuZCB0YWcgc3RyaW5ncyB0byB1c2Vcblx0Ly8gZm9yIHRoZSBpbmplY3Rpb24gZm9yIGVhY2ggc3BlY2lhbCB0YWcgd3JhcCBjYXNlLlxuXHRmb3IodmFyIHBhcmFtIGluIHRhZ1dyYXApe1xuXHRcdGlmKHRhZ1dyYXAuaGFzT3duUHJvcGVydHkocGFyYW0pKXtcblx0XHRcdHZhciB0dyA9IHRhZ1dyYXBbcGFyYW1dO1xuXHRcdFx0dHcucHJlID0gcGFyYW0gPT0gXCJvcHRpb25cIiA/ICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nIDogXCI8XCIgKyB0dy5qb2luKFwiPjxcIikgKyBcIj5cIjtcblx0XHRcdHR3LnBvc3QgPSBcIjwvXCIgKyB0dy5yZXZlcnNlKCkuam9pbihcIj48L1wiKSArIFwiPlwiO1xuXHRcdFx0Ly8gdGhlIGxhc3QgbGluZSBpcyBkZXN0cnVjdGl2ZTogaXQgcmV2ZXJzZXMgdGhlIGFycmF5LFxuXHRcdFx0Ly8gYnV0IHdlIGRvbid0IGNhcmUgYXQgdGhpcyBwb2ludFxuXHRcdH1cblx0fVxuXG5cdHZhciBodG1sNWRvbWZpeDtcblx0aWYoaGFzKFwiaWVcIikgPD0gOCl7XG5cdFx0aHRtbDVkb21maXggPSBmdW5jdGlvbihkb2Mpe1xuXHRcdFx0ZG9jLl9fZG9qb19odG1sNV90ZXN0ZWQgPSBcInllc1wiO1xuXHRcdFx0dmFyIGRpdiA9IGNyZWF0ZSgnZGl2Jywge2lubmVySFRNTDogXCI8bmF2PmE8L25hdj5cIiwgc3R5bGU6IHt2aXNpYmlsaXR5OiBcImhpZGRlblwifX0sIGRvYy5ib2R5KTtcblx0XHRcdGlmKGRpdi5jaGlsZE5vZGVzLmxlbmd0aCAhPT0gMSl7XG5cdFx0XHRcdCgnYWJiciBhcnRpY2xlIGFzaWRlIGF1ZGlvIGNhbnZhcyBkZXRhaWxzIGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBoZWFkZXIgJyArXG5cdFx0XHRcdCdoZ3JvdXAgbWFyayBtZXRlciBuYXYgb3V0cHV0IHByb2dyZXNzIHNlY3Rpb24gc3VtbWFyeSB0aW1lIHZpZGVvJykucmVwbGFjZShcblx0XHRcdFx0XHQvXFxiXFx3K1xcYi9nLCBmdW5jdGlvbihuKXtcblx0XHRcdFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50KG4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGRlc3Ryb3koZGl2KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfaW5zZXJ0QmVmb3JlKC8qRG9tTm9kZSovIG5vZGUsIC8qRG9tTm9kZSovIHJlZil7XG5cdFx0dmFyIHBhcmVudCA9IHJlZi5wYXJlbnROb2RlO1xuXHRcdGlmKHBhcmVudCl7XG5cdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2luc2VydEFmdGVyKC8qRG9tTm9kZSovIG5vZGUsIC8qRG9tTm9kZSovIHJlZil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcnkgdG8gaW5zZXJ0IG5vZGUgYWZ0ZXIgcmVmXG5cdFx0dmFyIHBhcmVudCA9IHJlZi5wYXJlbnROb2RlO1xuXHRcdGlmKHBhcmVudCl7XG5cdFx0XHRpZihwYXJlbnQubGFzdENoaWxkID09IHJlZil7XG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZi5uZXh0U2libGluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZXhwb3J0cy50b0RvbSA9IGZ1bmN0aW9uIHRvRG9tKGZyYWcsIGRvYyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRpbnN0YW50aWF0ZXMgYW4gSFRNTCBmcmFnbWVudCByZXR1cm5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgRE9NLlxuXHRcdC8vIGZyYWc6IFN0cmluZ1xuXHRcdC8vXHRcdHRoZSBIVE1MIGZyYWdtZW50XG5cdFx0Ly8gZG9jOiBEb2N1bWVudE5vZGU/XG5cdFx0Ly9cdFx0b3B0aW9uYWwgZG9jdW1lbnQgdG8gdXNlIHdoZW4gY3JlYXRpbmcgRE9NIG5vZGVzLCBkZWZhdWx0cyB0b1xuXHRcdC8vXHRcdGRvam8vX2Jhc2Uvd2luZG93LmRvYyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRcdC8vIHJldHVybnM6XG5cdFx0Ly9cdFx0RG9jdW1lbnQgZnJhZ21lbnQsIHVubGVzcyBpdCdzIGEgc2luZ2xlIG5vZGUgaW4gd2hpY2ggY2FzZSBpdCByZXR1cm5zIHRoZSBub2RlIGl0c2VsZlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0Q3JlYXRlIGEgdGFibGUgcm93OlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0KXtcblx0XHQvL1x0fFx0XHR2YXIgdHIgPSBkb21Db25zdHJ1Y3QudG9Eb20oXCI8dHI+PHRkPkZpcnN0ITwvdGQ+PC90cj5cIik7XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0ZG9jID0gZG9jIHx8IHdpbi5kb2M7XG5cdFx0dmFyIG1hc3RlcklkID0gZG9jW21hc3Rlck5hbWVdO1xuXHRcdGlmKCFtYXN0ZXJJZCl7XG5cdFx0XHRkb2NbbWFzdGVyTmFtZV0gPSBtYXN0ZXJJZCA9ICsrbWFzdGVyTnVtICsgXCJcIjtcblx0XHRcdG1hc3Rlck5vZGVbbWFzdGVySWRdID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0fVxuXG5cdFx0aWYoaGFzKFwiaWVcIikgPD0gOCl7XG5cdFx0XHRpZighZG9jLl9fZG9qb19odG1sNV90ZXN0ZWQgJiYgZG9jLmJvZHkpe1xuXHRcdFx0XHRodG1sNWRvbWZpeChkb2MpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG1ha2Ugc3VyZSB0aGUgZnJhZyBpcyBhIHN0cmluZy5cblx0XHRmcmFnICs9IFwiXCI7XG5cblx0XHQvLyBmaW5kIHRoZSBzdGFydGluZyB0YWcsIGFuZCBnZXQgbm9kZSB3cmFwcGVyXG5cdFx0dmFyIG1hdGNoID0gZnJhZy5tYXRjaChyZVRhZyksXG5cdFx0XHR0YWcgPSBtYXRjaCA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuXHRcdFx0bWFzdGVyID0gbWFzdGVyTm9kZVttYXN0ZXJJZF0sXG5cdFx0XHR3cmFwLCBpLCBmYywgZGY7XG5cdFx0aWYobWF0Y2ggJiYgdGFnV3JhcFt0YWddKXtcblx0XHRcdHdyYXAgPSB0YWdXcmFwW3RhZ107XG5cdFx0XHRtYXN0ZXIuaW5uZXJIVE1MID0gd3JhcC5wcmUgKyBmcmFnICsgd3JhcC5wb3N0O1xuXHRcdFx0Zm9yKGkgPSB3cmFwLmxlbmd0aDsgaTsgLS1pKXtcblx0XHRcdFx0bWFzdGVyID0gbWFzdGVyLmZpcnN0Q2hpbGQ7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRtYXN0ZXIuaW5uZXJIVE1MID0gZnJhZztcblx0XHR9XG5cblx0XHQvLyBvbmUgbm9kZSBzaG9ydGN1dCA9PiByZXR1cm4gdGhlIG5vZGUgaXRzZWxmXG5cdFx0aWYobWFzdGVyLmNoaWxkTm9kZXMubGVuZ3RoID09IDEpe1xuXHRcdFx0cmV0dXJuIG1hc3Rlci5yZW1vdmVDaGlsZChtYXN0ZXIuZmlyc3RDaGlsZCk7IC8vIERPTU5vZGVcblx0XHR9XG5cblx0XHQvLyByZXR1cm4gbXVsdGlwbGUgbm9kZXMgYXMgYSBkb2N1bWVudCBmcmFnbWVudFxuXHRcdGRmID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR3aGlsZSgoZmMgPSBtYXN0ZXIuZmlyc3RDaGlsZCkpeyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRkZi5hcHBlbmRDaGlsZChmYyk7XG5cdFx0fVxuXHRcdHJldHVybiBkZjsgLy8gRG9jdW1lbnRGcmFnbWVudFxuXHR9O1xuXG5cdGV4cG9ydHMucGxhY2UgPSBmdW5jdGlvbiBwbGFjZShub2RlLCByZWZOb2RlLCBwb3NpdGlvbil7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBdHRlbXB0IHRvIGluc2VydCBub2RlIGludG8gdGhlIERPTSwgY2hvb3NpbmcgZnJvbSB2YXJpb3VzIHBvc2l0aW9uaW5nIG9wdGlvbnMuXG5cdFx0Ly9cdFx0UmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcmVzb2x2ZWQgdG8gYSBET00gbm9kZS5cblx0XHQvLyBub2RlOiBET01Ob2RlfERvY3VtZW50RnJhZ21lbnR8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3Igbm9kZSByZWZlcmVuY2UsIG9yIEhUTUwgZnJhZ21lbnQgc3RhcnRpbmcgd2l0aCBcIjxcIiB0byBwbGFjZSByZWxhdGl2ZSB0byByZWZOb2RlXG5cdFx0Ly8gcmVmTm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciBub2RlIHJlZmVyZW5jZSB0byB1c2UgYXMgYmFzaXMgZm9yIHBsYWNlbWVudFxuXHRcdC8vIHBvc2l0aW9uOiBTdHJpbmd8TnVtYmVyP1xuXHRcdC8vXHRcdHN0cmluZyBub3RpbmcgdGhlIHBvc2l0aW9uIG9mIG5vZGUgcmVsYXRpdmUgdG8gcmVmTm9kZSBvciBhXG5cdFx0Ly9cdFx0bnVtYmVyIGluZGljYXRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBjaGlsZE5vZGVzIGNvbGxlY3Rpb24gb2YgcmVmTm9kZS5cblx0XHQvL1x0XHRBY2NlcHRlZCBzdHJpbmcgdmFsdWVzIGFyZTpcblx0XHQvL1xuXHRcdC8vXHRcdC0gYmVmb3JlXG5cdFx0Ly9cdFx0LSBhZnRlclxuXHRcdC8vXHRcdC0gcmVwbGFjZVxuXHRcdC8vXHRcdC0gb25seVxuXHRcdC8vXHRcdC0gZmlyc3Rcblx0XHQvL1x0XHQtIGxhc3Rcblx0XHQvL1xuXHRcdC8vXHRcdFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgaW5kaWNhdGUgcG9zaXRpb25zIGFzIGNoaWxkcmVuIG9mIHJlZk5vZGUsIFwicmVwbGFjZVwiIHJlcGxhY2VzIHJlZk5vZGUsXG5cdFx0Ly9cdFx0XCJvbmx5XCIgcmVwbGFjZXMgYWxsIGNoaWxkcmVuLiAgcG9zaXRpb24gZGVmYXVsdHMgdG8gXCJsYXN0XCIgaWYgbm90IHNwZWNpZmllZFxuXHRcdC8vIHJldHVybnM6IERPTU5vZGVcblx0XHQvL1x0XHRSZXR1cm5lZCB2YWx1ZXMgaXMgdGhlIGZpcnN0IGFyZ3VtZW50IHJlc29sdmVkIHRvIGEgRE9NIG5vZGUuXG5cdFx0Ly9cblx0XHQvL1x0XHQucGxhY2UoKSBpcyBhbHNvIGEgbWV0aG9kIG9mIGBkb2pvL05vZGVMaXN0YCwgYWxsb3dpbmcgYGRvam8vcXVlcnlgIG5vZGUgbG9va3Vwcy5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFBsYWNlIGEgbm9kZSBieSBzdHJpbmcgaWQgYXMgdGhlIGxhc3QgY2hpbGQgb2YgYW5vdGhlciBub2RlIGJ5IHN0cmluZyBpZDpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCl7XG5cdFx0Ly9cdHxcdFx0ZG9tQ29uc3RydWN0LnBsYWNlKFwic29tZU5vZGVcIiwgXCJhbm90aGVyTm9kZVwiKTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQbGFjZSBhIG5vZGUgYnkgc3RyaW5nIGlkIGJlZm9yZSBhbm90aGVyIG5vZGUgYnkgc3RyaW5nIGlkXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5wbGFjZShcInNvbWVOb2RlXCIsIFwiYW5vdGhlck5vZGVcIiwgXCJiZWZvcmVcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0Q3JlYXRlIGEgTm9kZSwgYW5kIHBsYWNlIGl0IGluIHRoZSBib2R5IGVsZW1lbnQgKGxhc3QgY2hpbGQpOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiLCBcImRvam8vX2Jhc2Uvd2luZG93XCJcblx0XHQvL1x0fFx0XSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0LCB3aW4pe1xuXHRcdC8vXHR8XHRcdGRvbUNvbnN0cnVjdC5wbGFjZShcIjxkaXY+PC9kaXY+XCIsIHdpbi5ib2R5KCkpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFB1dCBhIG5ldyBMSSBhcyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBsaXN0IGJ5IGlkOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiXSwgZnVuY3Rpb24oZG9tQ29uc3RydWN0KXtcblx0XHQvL1x0fFx0XHRkb21Db25zdHJ1Y3QucGxhY2UoXCI8bGk+PC9saT5cIiwgXCJzb21lVWxcIiwgXCJmaXJzdFwiKTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRyZWZOb2RlID0gZG9tLmJ5SWQocmVmTm9kZSk7XG5cdFx0aWYodHlwZW9mIG5vZGUgPT0gXCJzdHJpbmdcIil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdG5vZGUgPSAvXlxccyo8Ly50ZXN0KG5vZGUpID8gZXhwb3J0cy50b0RvbShub2RlLCByZWZOb2RlLm93bmVyRG9jdW1lbnQpIDogZG9tLmJ5SWQobm9kZSk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBwb3NpdGlvbiA9PSBcIm51bWJlclwiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0dmFyIGNuID0gcmVmTm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0aWYoIWNuLmxlbmd0aCB8fCBjbi5sZW5ndGggPD0gcG9zaXRpb24pe1xuXHRcdFx0XHRyZWZOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdF9pbnNlcnRCZWZvcmUobm9kZSwgY25bcG9zaXRpb24gPCAwID8gMCA6IHBvc2l0aW9uXSk7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRzd2l0Y2gocG9zaXRpb24pe1xuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0X2luc2VydEJlZm9yZShub2RlLCByZWZOb2RlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCI6XG5cdFx0XHRcdFx0X2luc2VydEFmdGVyKG5vZGUsIHJlZk5vZGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicmVwbGFjZVwiOlxuXHRcdFx0XHRcdHJlZk5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgcmVmTm9kZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJvbmx5XCI6XG5cdFx0XHRcdFx0ZXhwb3J0cy5lbXB0eShyZWZOb2RlKTtcblx0XHRcdFx0XHRyZWZOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRpZihyZWZOb2RlLmZpcnN0Q2hpbGQpe1xuXHRcdFx0XHRcdFx0X2luc2VydEJlZm9yZShub2RlLCByZWZOb2RlLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGVsc2UgZmFsbHRocm91Z2guLi5cblx0XHRcdFx0ZGVmYXVsdDogLy8gYWthOiBsYXN0XG5cdFx0XHRcdFx0cmVmTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7IC8vIERvbU5vZGVcblx0fTtcblxuXHR2YXIgY3JlYXRlID0gZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoLypET01Ob2RlfFN0cmluZyovIHRhZywgLypPYmplY3QqLyBhdHRycywgLypET01Ob2RlfFN0cmluZz8qLyByZWZOb2RlLCAvKlN0cmluZz8qLyBwb3Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q3JlYXRlIGFuIGVsZW1lbnQsIGFsbG93aW5nIGZvciBvcHRpb25hbCBhdHRyaWJ1dGUgZGVjb3JhdGlvblxuXHRcdC8vXHRcdGFuZCBwbGFjZW1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0QSBET00gRWxlbWVudCBjcmVhdGlvbiBmdW5jdGlvbi4gQSBzaG9ydGhhbmQgbWV0aG9kIGZvciBjcmVhdGluZyBhIG5vZGUgb3Jcblx0XHQvL1x0XHRhIGZyYWdtZW50LCBhbmQgYWxsb3dpbmcgZm9yIGEgY29udmVuaWVudCBvcHRpb25hbCBhdHRyaWJ1dGUgc2V0dGluZyBzdGVwLFxuXHRcdC8vXHRcdGFzIHdlbGwgYXMgYW4gb3B0aW9uYWwgRE9NIHBsYWNlbWVudCByZWZlcmVuY2UuXG5cdFx0Ly9cblx0XHQvL1x0XHRBdHRyaWJ1dGVzIGFyZSBzZXQgYnkgcGFzc2luZyB0aGUgb3B0aW9uYWwgb2JqZWN0IHRocm91Z2ggYGRvam8vZG9tLWF0dHIuc2V0YC5cblx0XHQvL1x0XHRTZWUgYGRvam8vZG9tLWF0dHIuc2V0YCBmb3Igbm90ZWQgY2F2ZWF0cyBhbmQgbnVhbmNlcywgYW5kIEFQSSBpZiBhcHBsaWNhYmxlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0UGxhY2VtZW50IGlzIGRvbmUgdmlhIGBkb2pvL2RvbS1jb25zdHJ1Y3QucGxhY2VgLCBhc3N1bWluZyB0aGUgbmV3IG5vZGUgdG8gYmVcblx0XHQvL1x0XHR0aGUgYWN0aW9uIG5vZGUsIHBhc3NpbmcgYWxvbmcgdGhlIG9wdGlvbmFsIHJlZmVyZW5jZSBub2RlIGFuZCBwb3NpdGlvbi5cblx0XHQvLyB0YWc6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0QSBzdHJpbmcgb2YgdGhlIGVsZW1lbnQgdG8gY3JlYXRlIChlZzogXCJkaXZcIiwgXCJhXCIsIFwicFwiLCBcImxpXCIsIFwic2NyaXB0XCIsIFwiYnJcIiksXG5cdFx0Ly9cdFx0b3IgYW4gZXhpc3RpbmcgRE9NIG5vZGUgdG8gcHJvY2Vzcy5cblx0XHQvLyBhdHRyczogT2JqZWN0XG5cdFx0Ly9cdFx0QW4gb2JqZWN0LWhhc2ggb2YgYXR0cmlidXRlcyB0byBzZXQgb24gdGhlIG5ld2x5IGNyZWF0ZWQgbm9kZS5cblx0XHQvL1x0XHRDYW4gYmUgbnVsbCwgaWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGFueSBhdHRyaWJ1dGVzL3N0eWxlcy5cblx0XHQvL1x0XHRTZWU6IGBkb2pvL2RvbS1hdHRyLnNldGAgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIGF0dHJpYnV0ZXMuXG5cdFx0Ly8gcmVmTm9kZTogRE9NTm9kZXxTdHJpbmc/XG5cdFx0Ly9cdFx0T3B0aW9uYWwgcmVmZXJlbmNlIG5vZGUuIFVzZWQgYnkgYGRvam8vZG9tLWNvbnN0cnVjdC5wbGFjZWAgdG8gcGxhY2UgdGhlIG5ld2x5IGNyZWF0ZWRcblx0XHQvL1x0XHRub2RlIHNvbWV3aGVyZSBpbiB0aGUgZG9tIHJlbGF0aXZlIHRvIHJlZk5vZGUuIENhbiBiZSBhIERvbU5vZGUgcmVmZXJlbmNlXG5cdFx0Ly9cdFx0b3IgU3RyaW5nIElEIG9mIGEgbm9kZS5cblx0XHQvLyBwb3M6IFN0cmluZz9cblx0XHQvL1x0XHRPcHRpb25hbCBwb3NpdGlvbmFsIHJlZmVyZW5jZS4gRGVmYXVsdHMgdG8gXCJsYXN0XCIgYnkgd2F5IG9mIGBkb2pvL2RvbUNvbnN0cnVjdC5wbGFjZWAsXG5cdFx0Ly9cdFx0dGhvdWdoIGNhbiBiZSBzZXQgdG8gXCJmaXJzdFwiLFwiYWZ0ZXJcIixcImJlZm9yZVwiLFwibGFzdFwiLCBcInJlcGxhY2VcIiBvciBcIm9ubHlcIlxuXHRcdC8vXHRcdHRvIGZ1cnRoZXIgY29udHJvbCB0aGUgcGxhY2VtZW50IG9mIHRoZSBuZXcgbm9kZSByZWxhdGl2ZSB0byB0aGUgcmVmTm9kZS5cblx0XHQvL1x0XHQncmVmTm9kZScgaXMgcmVxdWlyZWQgaWYgYSAncG9zJyBpcyBzcGVjaWZpZWQuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRDcmVhdGUgYSBESVY6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdHZhciBuID0gZG9tQ29uc3RydWN0LmNyZWF0ZShcImRpdlwiKTtcblx0XHQvL1x0fFx0fSk7XG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdENyZWF0ZSBhIERJViB3aXRoIGNvbnRlbnQ6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3Qpe1xuXHRcdC8vXHR8XHRcdHZhciBuID0gZG9tQ29uc3RydWN0LmNyZWF0ZShcImRpdlwiLCB7IGlubmVySFRNTDpcIjxwPmhpPC9wPlwiIH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0UGxhY2UgYSBuZXcgRElWIGluIHRoZSBCT0RZLCB3aXRoIG5vIGF0dHJpYnV0ZXMgc2V0XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCIsIFwiZG9qby9fYmFzZS93aW5kb3dcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCwgd2luKXtcblx0XHQvL1x0fFx0XHR2YXIgbiA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJkaXZcIiwgbnVsbCwgd2luLmJvZHkoKSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRDcmVhdGUgYW4gVUwsIGFuZCBwb3B1bGF0ZSBpdCB3aXRoIExJJ3MuIFBsYWNlIHRoZSBsaXN0IGFzIHRoZSBmaXJzdC1jaGlsZCBvZiBhXG5cdFx0Ly9cdFx0bm9kZSB3aXRoIGlkPVwic29tZUlkXCI6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tY29uc3RydWN0XCIsIFwiZG9qby9fYmFzZS9hcnJheVwiXSxcblx0XHQvL1x0fFx0ZnVuY3Rpb24oZG9tQ29uc3RydWN0LCBhcnJheVV0aWwpe1xuXHRcdC8vXHR8XHRcdHZhciB1bCA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJ1bFwiLCBudWxsLCBcInNvbWVJZFwiLCBcImZpcnN0XCIpO1xuXHRcdC8vXHR8XHRcdHZhciBpdGVtcyA9IFtcIm9uZVwiLCBcInR3b1wiLCBcInRocmVlXCIsIFwiZm91clwiXTtcblx0XHQvL1x0fFx0XHRhcnJheVV0aWwuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24oZGF0YSl7XG5cdFx0Ly9cdHxcdFx0XHRkb21Db25zdHJ1Y3QuY3JlYXRlKFwibGlcIiwgeyBpbm5lckhUTUw6IGRhdGEgfSwgdWwpO1xuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0Q3JlYXRlIGFuIGFuY2hvciwgd2l0aCBhbiBocmVmLiBQbGFjZSBpbiBCT0RZOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLWNvbnN0cnVjdFwiLCBcImRvam8vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihkb21Db25zdHJ1Y3QsIHdpbil7XG5cdFx0Ly9cdHxcdFx0ZG9tQ29uc3RydWN0LmNyZWF0ZShcImFcIiwgeyBocmVmOlwiZm9vLmh0bWxcIiwgdGl0bGU6XCJHb3RvIEZPTyFcIiB9LCB3aW4uYm9keSgpKTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHR2YXIgZG9jID0gd2luLmRvYztcblx0XHRpZihyZWZOb2RlKXtcblx0XHRcdHJlZk5vZGUgPSBkb20uYnlJZChyZWZOb2RlKTtcblx0XHRcdGRvYyA9IHJlZk5vZGUub3duZXJEb2N1bWVudDtcblx0XHR9XG5cdFx0aWYodHlwZW9mIHRhZyA9PSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0dGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0XHR9XG5cdFx0aWYoYXR0cnMpeyBhdHRyLnNldCh0YWcsIGF0dHJzKTsgfVxuXHRcdGlmKHJlZk5vZGUpeyBleHBvcnRzLnBsYWNlKHRhZywgcmVmTm9kZSwgcG9zKTsgfVxuXHRcdHJldHVybiB0YWc7IC8vIERvbU5vZGVcblx0fTtcblxuXHRmdW5jdGlvbiBfZW1wdHkoLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHRoaXMgaWYoKSBibG9jayBpbiAyLjAgd2hlbiB3ZSBubyBsb25nZXIgaGF2ZSB0byB3b3JyeSBhYm91dCBJRSBtZW1vcnkgbGVha3MsXG5cdFx0Ly8gYW5kIHRoZW4gdW5jb21tZW50IHRoZSBlbXB0eUdyYW5kY2hpbGRyZW4oKSB0ZXN0IGNhc2UgZnJvbSBodG1sLmh0bWwuXG5cdFx0Ly8gTm90ZSB0aGF0IGJlc2lkZXMgZml4aW5nICMxNjk1NywgdXNpbmcgcmVtb3ZlQ2hpbGQoKSBpcyBhY3R1YWxseSBmYXN0ZXIgdGhhbiBzZXR0aW5nIG5vZGUuaW5uZXJIVE1MLFxuXHRcdC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jbGVhci1kb20tbm9kZS5cblx0XHRpZihcImlubmVySFRNTFwiIGluIG5vZGUpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHQvLyBmYXN0IHBhdGhcblx0XHRcdFx0bm9kZS5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdC8vIGlubmVySFRNTCBpcyByZWFkT25seSAoZS5nLiBUQUJMRSAoc3ViKWVsZW1lbnRzIGluIHF1aXJrcyBtb2RlKVxuXHRcdFx0XHQvLyBGYWxsIHRocm91Z2ggKHNhdmVzIGJ5dGVzKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNWRy9zdHJpY3QgZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lckhUTUxcblx0XHRmb3IodmFyIGM7IGMgPSBub2RlLmxhc3RDaGlsZDspeyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRub2RlLnJlbW92ZUNoaWxkKGMpO1xuXHRcdH1cblx0fVxuXG5cdGV4cG9ydHMuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRzYWZlbHkgcmVtb3ZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIG5vZGUuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRhIHJlZmVyZW5jZSB0byBhIERPTSBub2RlIG9yIGFuIGlkLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0RGVzdHJveSBub2RlJ3MgY2hpbGRyZW4gYnlJZDpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCl7XG5cdFx0Ly9cdHxcdFx0ZG9tQ29uc3RydWN0LmVtcHR5KFwic29tZUlkXCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdF9lbXB0eShkb20uYnlJZChub2RlKSk7XG5cdH07XG5cblxuXHRmdW5jdGlvbiBfZGVzdHJveSgvKkRvbU5vZGUqLyBub2RlLCAvKkRvbU5vZGUqLyBwYXJlbnQpe1xuXHRcdC8vIGluIElFIHF1aXJrcywgbm9kZS5jYW5IYXZlQ2hpbGRyZW4gY2FuIGJlIGZhbHNlIGJ1dCBmaXJzdENoaWxkIGNhbiBiZSBub24tbnVsbCAoT0JKRUNUL0FQUExFVClcblx0XHRpZihub2RlLmZpcnN0Q2hpbGQpe1xuXHRcdFx0X2VtcHR5KG5vZGUpO1xuXHRcdH1cblx0XHRpZihwYXJlbnQpe1xuXHRcdFx0Ly8gcmVtb3ZlTm9kZShmYWxzZSkgZG9lc24ndCBsZWFrIGluIElFIDYrLCBidXQgcmVtb3ZlQ2hpbGQoKSBhbmQgcmVtb3ZlTm9kZSh0cnVlKSBhcmUga25vd24gdG8gbGVhayB1bmRlciBJRSA4LSB3aGlsZSA5KyBpcyBUQkQuXG5cdFx0XHQvLyBJbiBJRSBxdWlya3MgbW9kZSwgUEFSQU0gbm9kZXMgYXMgY2hpbGRyZW4gb2YgT0JKRUNUL0FQUExFVCBub2RlcyBoYXZlIGEgcmVtb3ZlTm9kZSBtZXRob2QgdGhhdCBkb2VzIG5vdGhpbmcgYW5kXG5cdFx0XHQvLyB0aGUgcGFyZW50IG5vZGUgaGFzIGNhbkhhdmVDaGlsZHJlbj1mYWxzZSBldmVuIHRob3VnaCByZW1vdmVDaGlsZCBjb3JyZWN0bHkgcmVtb3ZlcyB0aGUgUEFSQU0gY2hpbGRyZW4uXG5cdFx0XHQvLyBJbiBJRSwgU1ZHL3N0cmljdCBub2RlcyBkb24ndCBoYXZlIGEgcmVtb3ZlTm9kZSBtZXRob2Qgbm9yIGEgY2FuSGF2ZUNoaWxkcmVuIGJvb2xlYW4uXG5cdFx0XHRoYXMoXCJpZVwiKSAmJiBwYXJlbnQuY2FuSGF2ZUNoaWxkcmVuICYmIFwicmVtb3ZlTm9kZVwiIGluIG5vZGUgPyBub2RlLnJlbW92ZU5vZGUoZmFsc2UpIDogcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdH1cblx0fVxuXHR2YXIgZGVzdHJveSA9IGV4cG9ydHMuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koLypET01Ob2RlfFN0cmluZyovIG5vZGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmVtb3ZlcyBhIG5vZGUgZnJvbSBpdHMgcGFyZW50LCBjbG9iYmVyaW5nIGl0IGFuZCBhbGwgb2YgaXRzXG5cdFx0Ly9cdFx0Y2hpbGRyZW4uXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZW1vdmVzIGEgbm9kZSBmcm9tIGl0cyBwYXJlbnQsIGNsb2JiZXJpbmcgaXQgYW5kIGFsbCBvZiBpdHNcblx0XHQvL1x0XHRjaGlsZHJlbi4gRnVuY3Rpb24gb25seSB3b3JrcyB3aXRoIERvbU5vZGVzLCBhbmQgcmV0dXJucyBub3RoaW5nLlxuXHRcdC8vXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRBIFN0cmluZyBJRCBvciBEb21Ob2RlIHJlZmVyZW5jZSBvZiB0aGUgZWxlbWVudCB0byBiZSBkZXN0cm95ZWRcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0RGVzdHJveSBhIG5vZGUgYnlJZDpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIl0sIGZ1bmN0aW9uKGRvbUNvbnN0cnVjdCl7XG5cdFx0Ly9cdHxcdFx0ZG9tQ29uc3RydWN0LmRlc3Ryb3koXCJzb21lSWRcIik7XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdGlmKCFub2RlKXsgcmV0dXJuOyB9XG5cdFx0X2Rlc3Ryb3kobm9kZSwgbm9kZS5wYXJlbnROb2RlKTtcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vc25pZmZcIiwgXCIuL19iYXNlL3dpbmRvd1wiLFwiLi9kb21cIiwgXCIuL2RvbS1zdHlsZVwiXSxcblx0XHRmdW5jdGlvbihoYXMsIHdpbiwgZG9tLCBzdHlsZSl7XG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9kb20tZ2VvbWV0cnlcblxuXHQvLyB0aGUgcmVzdWx0IG9iamVjdFxuXHR2YXIgZ2VvbSA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgdGhlIGNvcmUgZG9qbyBET00gZ2VvbWV0cnkgQVBJLlxuXHR9O1xuXG5cdC8vIEJveCBmdW5jdGlvbnMgd2lsbCBhc3N1bWUgdGhpcyBtb2RlbC5cblx0Ly8gT24gSUUvT3BlcmEsIEJPUkRFUl9CT1ggd2lsbCBiZSBzZXQgaWYgdGhlIHByaW1hcnkgZG9jdW1lbnQgaXMgaW4gcXVpcmtzIG1vZGUuXG5cdC8vIENhbiBiZSBzZXQgdG8gY2hhbmdlIGJlaGF2aW9yIG9mIGJveCBzZXR0ZXJzLlxuXG5cdC8vIGNhbiBiZSBlaXRoZXI6XG5cdC8vXHRcImJvcmRlci1ib3hcIlxuXHQvL1x0XCJjb250ZW50LWJveFwiIChkZWZhdWx0KVxuXHRnZW9tLmJveE1vZGVsID0gXCJjb250ZW50LWJveFwiO1xuXG5cdC8vIFdlIHB1bnQgcGVyLW5vZGUgYm94IG1vZGUgdGVzdGluZyBjb21wbGV0ZWx5LlxuXHQvLyBJZiBhbnlib2R5IGNhcmVzLCB3ZSBjYW4gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIChvcHRpb25hbCkgdW5pdFxuXHQvLyB0aGF0IG92ZXJyaWRlcyBleGlzdGluZyBjb2RlIHRvIGluY2x1ZGUgcGVyLW5vZGUgYm94IHNlbnNpdGl2aXR5LlxuXG5cdC8vIE9wZXJhIGRvY3VtZW50YXRpb24gY2xhaW1zIHRoYXQgT3BlcmEgOSB1c2VzIGJvcmRlci1ib3ggaW4gQmFja0NvbXBhdCBtb2RlLlxuXHQvLyBidXQgZXhwZXJpbWVudHMgKE9wZXJhIDkuMTAuODY3OSBvbiBXaW5kb3dzIFZpc3RhKSBpbmRpY2F0ZSB0aGF0IGl0IGFjdHVhbGx5IGNvbnRpbnVlcyB0byB1c2UgY29udGVudC1ib3guXG5cdC8vIElJUkMsIGVhcmxpZXIgdmVyc2lvbnMgb2YgT3BlcmEgZGlkIGluIGZhY3QgdXNlIGJvcmRlci1ib3guXG5cdC8vIE9wZXJhIGd1eXMsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZy4gT3BlcmEgYmVpbmcgYnJva2VuIGluIHF1aXJrcyBtb2RlIGlzIG5vdCBvdXIgZmF1bHQuXG5cblx0aWYoaGFzKFwiaWVcIikgLyp8fCBoYXMoXCJvcGVyYVwiKSovKXtcblx0XHQvLyBjbGllbnQgY29kZSBtYXkgaGF2ZSB0byBhZGp1c3QgaWYgY29tcGF0TW9kZSB2YXJpZXMgYWNyb3NzIGlmcmFtZXNcblx0XHRnZW9tLmJveE1vZGVsID0gZG9jdW1lbnQuY29tcGF0TW9kZSA9PSBcIkJhY2tDb21wYXRcIiA/IFwiYm9yZGVyLWJveFwiIDogXCJjb250ZW50LWJveFwiO1xuXHR9XG5cblx0Z2VvbS5nZXRQYWRFeHRlbnRzID0gZnVuY3Rpb24gZ2V0UGFkRXh0ZW50cygvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBvYmplY3Qgd2l0aCBzcGVjaWFsIHZhbHVlcyBzcGVjaWZpY2FsbHkgdXNlZnVsIGZvciBub2RlXG5cdFx0Ly9cdFx0Zml0dGluZy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB3YCwgYGhgLCBgbGAsIGB0YCBwcm9wZXJ0aWVzOlxuXHRcdC8vXHR8XHRcdGwvdC9yL2IgPSBsZWZ0L3RvcC9yaWdodC9ib3R0b20gcGFkZGluZyAocmVzcGVjdGl2ZWx5KVxuXHRcdC8vXHR8XHRcdHcgPSB0aGUgdG90YWwgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHBhZGRpbmdcblx0XHQvL1x0fFx0XHRoID0gdGhlIHRvdGFsIG9mIHRoZSB0b3AgYW5kIGJvdHRvbSBwYWRkaW5nXG5cdFx0Ly9cdFx0SWYgJ25vZGUnIGhhcyBwb3NpdGlvbiwgbC90IGZvcm1zIHRoZSBvcmlnaW4gZm9yIGNoaWxkIG5vZGVzLlxuXHRcdC8vXHRcdFRoZSB3L2ggYXJlIHVzZWQgZm9yIGNhbGN1bGF0aW5nIGJveGVzLlxuXHRcdC8vXHRcdE5vcm1hbGx5IGFwcGxpY2F0aW9uIGNvZGUgd2lsbCBub3QgbmVlZCB0byBpbnZva2UgdGhpc1xuXHRcdC8vXHRcdGRpcmVjdGx5LCBhbmQgd2lsbCB1c2UgdGhlIC4uLmJveC4uLiBmdW5jdGlvbnMgaW5zdGVhZC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgcyA9IGNvbXB1dGVkU3R5bGUgfHwgc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSwgcHggPSBzdHlsZS50b1BpeGVsVmFsdWUsXG5cdFx0XHRsID0gcHgobm9kZSwgcy5wYWRkaW5nTGVmdCksIHQgPSBweChub2RlLCBzLnBhZGRpbmdUb3ApLCByID0gcHgobm9kZSwgcy5wYWRkaW5nUmlnaHQpLCBiID0gcHgobm9kZSwgcy5wYWRkaW5nQm90dG9tKTtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0dmFyIG5vbmUgPSBcIm5vbmVcIjtcblxuXHRnZW9tLmdldEJvcmRlckV4dGVudHMgPSBmdW5jdGlvbiBnZXRCb3JkZXJFeHRlbnRzKC8qRG9tTm9kZSovIG5vZGUsIC8qT2JqZWN0Ki8gY29tcHV0ZWRTdHlsZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRyZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdXNlZnVsIGZvciBub3RpbmcgdGhlIGJvcmRlclxuXHRcdC8vXHRcdGRpbWVuc2lvbnMuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0LSBsL3Qvci9iID0gdGhlIHN1bSBvZiBsZWZ0L3RvcC9yaWdodC9ib3R0b20gYm9yZGVyIChyZXNwZWN0aXZlbHkpXG5cdFx0Ly9cdFx0LSB3ID0gdGhlIHN1bSBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgYm9yZGVyXG5cdFx0Ly9cdFx0LSBoID0gdGhlIHN1bSBvZiB0aGUgdG9wIGFuZCBib3R0b20gYm9yZGVyXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLCBzID0gY29tcHV0ZWRTdHlsZSB8fCBzdHlsZS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLFxuXHRcdFx0bCA9IHMuYm9yZGVyTGVmdFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBzLmJvcmRlckxlZnRXaWR0aCkgOiAwLFxuXHRcdFx0dCA9IHMuYm9yZGVyVG9wU3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyVG9wV2lkdGgpIDogMCxcblx0XHRcdHIgPSBzLmJvcmRlclJpZ2h0U3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyUmlnaHRXaWR0aCkgOiAwLFxuXHRcdFx0YiA9IHMuYm9yZGVyQm90dG9tU3R5bGUgIT0gbm9uZSA/IHB4KG5vZGUsIHMuYm9yZGVyQm90dG9tV2lkdGgpIDogMDtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0Z2VvbS5nZXRQYWRCb3JkZXJFeHRlbnRzID0gZnVuY3Rpb24gZ2V0UGFkQm9yZGVyRXh0ZW50cygvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHVzZWZ1bCBmb3IgYm94IGZpdHRpbmcgd2l0aFxuXHRcdC8vXHRcdHJlZ2FyZHMgdG8gcGFkZGluZy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHQtIGwvdC9yL2IgPSB0aGUgc3VtIG9mIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSBwYWRkaW5nIGFuZCBsZWZ0L3RvcC9yaWdodC9ib3R0b20gYm9yZGVyIChyZXNwZWN0aXZlbHkpXG5cdFx0Ly9cdFx0LSB3ID0gdGhlIHN1bSBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFkZGluZyBhbmQgYm9yZGVyXG5cdFx0Ly9cdFx0LSBoID0gdGhlIHN1bSBvZiB0aGUgdG9wIGFuZCBib3R0b20gcGFkZGluZyBhbmQgYm9yZGVyXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksXG5cdFx0XHRwID0gZ2VvbS5nZXRQYWRFeHRlbnRzKG5vZGUsIHMpLFxuXHRcdFx0YiA9IGdlb20uZ2V0Qm9yZGVyRXh0ZW50cyhub2RlLCBzKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bDogcC5sICsgYi5sLFxuXHRcdFx0dDogcC50ICsgYi50LFxuXHRcdFx0cjogcC5yICsgYi5yLFxuXHRcdFx0YjogcC5iICsgYi5iLFxuXHRcdFx0dzogcC53ICsgYi53LFxuXHRcdFx0aDogcC5oICsgYi5oXG5cdFx0fTtcblx0fTtcblxuXHRnZW9tLmdldE1hcmdpbkV4dGVudHMgPSBmdW5jdGlvbiBnZXRNYXJnaW5FeHRlbnRzKG5vZGUsIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0cmV0dXJucyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHVzZWZ1bCBmb3IgYm94IGZpdHRpbmcgd2l0aFxuXHRcdC8vXHRcdHJlZ2FyZHMgdG8gYm94IG1hcmdpbnMgKGkuZS4sIHRoZSBvdXRlci1ib3gpLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBsL3QgPSBtYXJnaW5MZWZ0LCBtYXJnaW5Ub3AsIHJlc3BlY3RpdmVseVxuXHRcdC8vXHRcdC0gdyA9IHRvdGFsIHdpZHRoLCBtYXJnaW4gaW5jbHVzaXZlXG5cdFx0Ly9cdFx0LSBoID0gdG90YWwgaGVpZ2h0LCBtYXJnaW4gaW5jbHVzaXZlXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgdy9oIGFyZSB1c2VkIGZvciBjYWxjdWxhdGluZyBib3hlcy5cblx0XHQvL1x0XHROb3JtYWxseSBhcHBsaWNhdGlvbiBjb2RlIHdpbGwgbm90IG5lZWQgdG8gaW52b2tlIHRoaXNcblx0XHQvL1x0XHRkaXJlY3RseSwgYW5kIHdpbGwgdXNlIHRoZSAuLi5ib3guLi4gZnVuY3Rpb25zIGluc3RlYWQuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLFxuXHRcdFx0bCA9IHB4KG5vZGUsIHMubWFyZ2luTGVmdCksIHQgPSBweChub2RlLCBzLm1hcmdpblRvcCksIHIgPSBweChub2RlLCBzLm1hcmdpblJpZ2h0KSwgYiA9IHB4KG5vZGUsIHMubWFyZ2luQm90dG9tKTtcblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHI6IHIsIGI6IGIsIHc6IGwgKyByLCBoOiB0ICsgYn07XG5cdH07XG5cblx0Ly8gQm94IGdldHRlcnMgd29yayBpbiBhbnkgYm94IGNvbnRleHQgYmVjYXVzZSBvZmZzZXRXaWR0aC9jbGllbnRXaWR0aFxuXHQvLyBhcmUgaW52YXJpYW50IHdydCBib3ggY29udGV4dFxuXHQvL1xuXHQvLyBUaGV5IGRvICpub3QqIHdvcmsgZm9yIGRpc3BsYXk6IGlubGluZSBvYmplY3RzIHRoYXQgaGF2ZSBwYWRkaW5nIHN0eWxlc1xuXHQvLyBiZWNhdXNlIHRoZSB1c2VyIGFnZW50IGlnbm9yZXMgcGFkZGluZyAoaXQncyBib2d1cyBzdHlsaW5nIGluIGFueSBjYXNlKVxuXHQvL1xuXHQvLyBCZSBjYXJlZnVsIHdpdGggSU1HcyBiZWNhdXNlIHRoZXkgYXJlIGlubGluZSBvciBibG9jayBkZXBlbmRpbmcgb25cblx0Ly8gYnJvd3NlciBhbmQgYnJvd3NlciBtb2RlLlxuXG5cdC8vIEFsdGhvdWdoIGl0IHdvdWxkIGJlIGVhc2llciB0byByZWFkLCB0aGVyZSBhcmUgbm90IHNlcGFyYXRlIHZlcnNpb25zIG9mXG5cdC8vIF9nZXRNYXJnaW5Cb3ggZm9yIGVhY2ggYnJvd3NlciBiZWNhdXNlOlxuXHQvLyAxLiB0aGUgYnJhbmNoaW5nIGlzIG5vdCBleHBlbnNpdmVcblx0Ly8gMi4gZmFjdG9yaW5nIHRoZSBzaGFyZWQgY29kZSB3YXN0ZXMgY3ljbGVzIChmdW5jdGlvbiBjYWxsIG92ZXJoZWFkKVxuXHQvLyAzLiBkdXBsaWNhdGluZyB0aGUgc2hhcmVkIGNvZGUgd2FzdGVzIGJ5dGVzXG5cblx0Z2VvbS5nZXRNYXJnaW5Cb3ggPSBmdW5jdGlvbiBnZXRNYXJnaW5Cb3goLypEb21Ob2RlKi8gbm9kZSwgLypPYmplY3QqLyBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHJldHVybnMgYW4gb2JqZWN0IHRoYXQgZW5jb2RlcyB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCBhbmQgdG9wXG5cdFx0Ly9cdFx0cG9zaXRpb25zIG9mIHRoZSBub2RlJ3MgbWFyZ2luIGJveC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgcyA9IGNvbXB1dGVkU3R5bGUgfHwgc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSwgbWUgPSBnZW9tLmdldE1hcmdpbkV4dGVudHMobm9kZSwgcyksXG5cdFx0XHRsID0gbm9kZS5vZmZzZXRMZWZ0IC0gbWUubCwgdCA9IG5vZGUub2Zmc2V0VG9wIC0gbWUudCwgcCA9IG5vZGUucGFyZW50Tm9kZSwgcHggPSBzdHlsZS50b1BpeGVsVmFsdWUsIHBjcztcblxuXHRcdGlmKChoYXMoXCJpZVwiKSA9PSA4ICYmICFoYXMoXCJxdWlya3NcIikpKXtcblx0XHRcdC8vIElFIDggb2Zmc2V0TGVmdC9Ub3AgaW5jbHVkZXMgdGhlIHBhcmVudCdzIGJvcmRlclxuXHRcdFx0aWYocCl7XG5cdFx0XHRcdHBjcyA9IHN0eWxlLmdldENvbXB1dGVkU3R5bGUocCk7XG5cdFx0XHRcdGwgLT0gcGNzLmJvcmRlckxlZnRTdHlsZSAhPSBub25lID8gcHgobm9kZSwgcGNzLmJvcmRlckxlZnRXaWR0aCkgOiAwO1xuXHRcdFx0XHR0IC09IHBjcy5ib3JkZXJUb3BTdHlsZSAhPSBub25lID8gcHgobm9kZSwgcGNzLmJvcmRlclRvcFdpZHRoKSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7bDogbCwgdDogdCwgdzogbm9kZS5vZmZzZXRXaWR0aCArIG1lLncsIGg6IG5vZGUub2Zmc2V0SGVpZ2h0ICsgbWUuaH07XG5cdH07XG5cblx0Z2VvbS5nZXRDb250ZW50Qm94ID0gZnVuY3Rpb24gZ2V0Q29udGVudEJveChub2RlLCBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgYW4gb2JqZWN0IHRoYXQgZW5jb2RlcyB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCBhbmQgdG9wXG5cdFx0Ly9cdFx0cG9zaXRpb25zIG9mIHRoZSBub2RlJ3MgY29udGVudCBib3gsIGlycmVzcGVjdGl2ZSBvZiB0aGVcblx0XHQvL1x0XHRjdXJyZW50IGJveCBtb2RlbC5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdC8vIGNsaWVudFdpZHRoL0hlaWdodCBhcmUgaW1wb3J0YW50IHNpbmNlIHRoZSBhdXRvbWF0aWNhbGx5IGFjY291bnQgZm9yIHNjcm9sbGJhcnNcblx0XHQvLyBmYWxsYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgZm9yIHNwZWNpYWwgY2FzZXMgKHNlZSAjMzM3OClcblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHcgPSBub2RlLmNsaWVudFdpZHRoLCBoLFxuXHRcdFx0cGUgPSBnZW9tLmdldFBhZEV4dGVudHMobm9kZSwgcyksIGJlID0gZ2VvbS5nZXRCb3JkZXJFeHRlbnRzKG5vZGUsIHMpLCBsID0gbm9kZS5vZmZzZXRMZWZ0ICsgcGUubCArIGJlLmwsXG5cdFx0XHR0ID0gbm9kZS5vZmZzZXRUb3AgKyBwZS50ICsgYmUudDtcblx0XHRpZighdyl7XG5cdFx0XHR3ID0gbm9kZS5vZmZzZXRXaWR0aCAtIGJlLnc7XG5cdFx0XHRoID0gbm9kZS5vZmZzZXRIZWlnaHQgLSBiZS5oO1xuXHRcdH1lbHNle1xuXHRcdFx0aCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuXHRcdH1cblxuXHRcdGlmKChoYXMoXCJpZVwiKSA9PSA4ICYmICFoYXMoXCJxdWlya3NcIikpKXtcblx0XHRcdC8vIElFIDggb2Zmc2V0TGVmdC9Ub3AgaW5jbHVkZXMgdGhlIHBhcmVudCdzIGJvcmRlclxuXHRcdFx0dmFyIHAgPSBub2RlLnBhcmVudE5vZGUsIHB4ID0gc3R5bGUudG9QaXhlbFZhbHVlLCBwY3M7XG5cdFx0XHRpZihwKXtcblx0XHRcdFx0cGNzID0gc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShwKTtcblx0XHRcdFx0bCAtPSBwY3MuYm9yZGVyTGVmdFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBwY3MuYm9yZGVyTGVmdFdpZHRoKSA6IDA7XG5cdFx0XHRcdHQgLT0gcGNzLmJvcmRlclRvcFN0eWxlICE9IG5vbmUgPyBweChub2RlLCBwY3MuYm9yZGVyVG9wV2lkdGgpIDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge2w6IGwsIHQ6IHQsIHc6IHcgLSBwZS53LCBoOiBoIC0gcGUuaH07XG5cdH07XG5cblx0Ly8gQm94IHNldHRlcnMgZGVwZW5kIG9uIGJveCBjb250ZXh0IGJlY2F1c2UgaW50ZXJwcmV0YXRpb24gb2Ygd2lkdGgvaGVpZ2h0IHN0eWxlc1xuXHQvLyB2YXJ5IHdydCBib3ggY29udGV4dC5cblx0Ly9cblx0Ly8gVGhlIHZhbHVlIG9mIGJveE1vZGVsIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGJveCBjb250ZXh0LlxuXHQvLyBib3hNb2RlbCBjYW4gYmUgc2V0IGRpcmVjdGx5IHRvIGNoYW5nZSBiZWhhdmlvci5cblx0Ly9cblx0Ly8gQmV3YXJlIG9mIGRpc3BsYXk6IGlubGluZSBvYmplY3RzIHRoYXQgaGF2ZSBwYWRkaW5nIHN0eWxlc1xuXHQvLyBiZWNhdXNlIHRoZSB1c2VyIGFnZW50IGlnbm9yZXMgcGFkZGluZyAoaXQncyBhIGJvZ3VzIHNldHVwIGFueXdheSlcblx0Ly9cblx0Ly8gQmUgY2FyZWZ1bCB3aXRoIElNR3MgYmVjYXVzZSB0aGV5IGFyZSBpbmxpbmUgb3IgYmxvY2sgZGVwZW5kaW5nIG9uXG5cdC8vIGJyb3dzZXIgYW5kIGJyb3dzZXIgbW9kZS5cblx0Ly9cblx0Ly8gRWxlbWVudHMgb3RoZXIgdGhhbiBESVYgbWF5IGhhdmUgc3BlY2lhbCBxdWlya3MsIGxpa2UgYnVpbHQtaW5cblx0Ly8gbWFyZ2lucyBvciBwYWRkaW5nLCBvciB2YWx1ZXMgbm90IGRldGVjdGFibGUgdmlhIGNvbXB1dGVkU3R5bGUuXG5cdC8vIEluIHBhcnRpY3VsYXIsIG1hcmdpbnMgb24gVEFCTEUgZG8gbm90IHNlZW1zIHRvIGFwcGVhclxuXHQvLyBhdCBhbGwgaW4gY29tcHV0ZWRTdHlsZSBvbiBNb3ppbGxhLlxuXG5cdGZ1bmN0aW9uIHNldEJveCgvKkRvbU5vZGUqLyBub2RlLCAvKk51bWJlcj8qLyBsLCAvKk51bWJlcj8qLyB0LCAvKk51bWJlcj8qLyB3LCAvKk51bWJlcj8qLyBoLCAvKlN0cmluZz8qLyB1KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHNldHMgd2lkdGgvaGVpZ2h0L2xlZnQvdG9wIGluIHRoZSBjdXJyZW50IChuYXRpdmUpIGJveC1tb2RlbFxuXHRcdC8vXHRcdGRpbWVuc2lvbnMuIFVzZXMgdGhlIHVuaXQgcGFzc2VkIGluIHUuXG5cdFx0Ly8gbm9kZTpcblx0XHQvL1x0XHRET00gTm9kZSByZWZlcmVuY2UuIElkIHN0cmluZyBub3Qgc3VwcG9ydGVkIGZvciBwZXJmb3JtYW5jZVxuXHRcdC8vXHRcdHJlYXNvbnMuXG5cdFx0Ly8gbDpcblx0XHQvL1x0XHRsZWZ0IG9mZnNldCBmcm9tIHBhcmVudC5cblx0XHQvLyB0OlxuXHRcdC8vXHRcdHRvcCBvZmZzZXQgZnJvbSBwYXJlbnQuXG5cdFx0Ly8gdzpcblx0XHQvL1x0XHR3aWR0aCBpbiBjdXJyZW50IGJveCBtb2RlbC5cblx0XHQvLyBoOlxuXHRcdC8vXHRcdHdpZHRoIGluIGN1cnJlbnQgYm94IG1vZGVsLlxuXHRcdC8vIHU6XG5cdFx0Ly9cdFx0dW5pdCBtZWFzdXJlIHRvIHVzZSBmb3Igb3RoZXIgbWVhc3VyZXMuIERlZmF1bHRzIHRvIFwicHhcIi5cblx0XHR1ID0gdSB8fCBcInB4XCI7XG5cdFx0dmFyIHMgPSBub2RlLnN0eWxlO1xuXHRcdGlmKCFpc05hTihsKSl7XG5cdFx0XHRzLmxlZnQgPSBsICsgdTtcblx0XHR9XG5cdFx0aWYoIWlzTmFOKHQpKXtcblx0XHRcdHMudG9wID0gdCArIHU7XG5cdFx0fVxuXHRcdGlmKHcgPj0gMCl7XG5cdFx0XHRzLndpZHRoID0gdyArIHU7XG5cdFx0fVxuXHRcdGlmKGggPj0gMCl7XG5cdFx0XHRzLmhlaWdodCA9IGggKyB1O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzQnV0dG9uVGFnKC8qRG9tTm9kZSovIG5vZGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VHJ1ZSBpZiB0aGUgbm9kZSBpcyBCVVRUT04gb3IgSU5QVVQudHlwZT1cImJ1dHRvblwiLlxuXHRcdHJldHVybiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImlucHV0XCIgJiYgKG5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09IFwiYnV0dG9uXCI7IC8vIGJvb2xlYW5cblx0fVxuXG5cdGZ1bmN0aW9uIHVzZXNCb3JkZXJCb3goLypEb21Ob2RlKi8gbm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcnVlIGlmIHRoZSBub2RlIHVzZXMgYm9yZGVyLWJveCBsYXlvdXQuXG5cblx0XHQvLyBXZSBjb3VsZCB0ZXN0IHRoZSBjb21wdXRlZCBzdHlsZSBvZiBub2RlIHRvIHNlZSBpZiBhIHBhcnRpY3VsYXIgYm94XG5cdFx0Ly8gaGFzIGJlZW4gc3BlY2lmaWVkLCBidXQgdGhlcmUgYXJlIGRldGFpbHMgYW5kIHdlIGNob29zZSBub3QgdG8gYm90aGVyLlxuXG5cdFx0Ly8gVEFCTEUgYW5kIEJVVFRPTiAoYW5kIElOUFVUIHR5cGU9YnV0dG9uKSBhcmUgYWx3YXlzIGJvcmRlci1ib3ggYnkgZGVmYXVsdC5cblx0XHQvLyBJZiB5b3UgaGF2ZSBhc3NpZ25lZCBhIGRpZmZlcmVudCBib3ggdG8gZWl0aGVyIG9uZSB2aWEgQ1NTIHRoZW5cblx0XHQvLyBib3ggZnVuY3Rpb25zIHdpbGwgYnJlYWsuXG5cblx0XHRyZXR1cm4gZ2VvbS5ib3hNb2RlbCA9PSBcImJvcmRlci1ib3hcIiB8fCBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRhYmxlXCIgfHwgaXNCdXR0b25UYWcobm9kZSk7IC8vIGJvb2xlYW5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgvKkRvbU5vZGUqLyBub2RlKSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRHZXRzIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlIGZvciBhIGRvbSBub2RlLlxuXHRcdC8vIG5vZGU6IERPTU5vZGVcblxuXHRcdC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBub2RlIGlzIGluIHRoZSBkb20sIGFuZFxuXHRcdC8vIHt4OjAsIHk6MCwgd2lkdGg6MCwgaGVpZ2h0OjAsIHRvcDowLCByaWdodDowLCBib3R0b206MCwgbGVmdDowfSBpZiBpdCB0aHJvd3MgYW4gZXJyb3Igb3IgdGhlIG5vZGUgaXMgbm90IG9uIHRoZSBkb21cblx0XHQvLyBUaGlzIHdpbGwgaGFuZGxlIHdoZW4gSUUgdGhyb3dzIGFuIGVycm9yIG9yIEVkZ2UgcmV0dXJucyBhbiBlbXB0eSBvYmplY3Qgd2hlbiBub2RlIGlzIG5vdCBvbiB0aGUgZG9tXG5cblx0XHR2YXIgcmV0RW1wdHkgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9LFxuXHRcdFx0cmV0O1xuXG5cdFx0dHJ5IHtcblx0XHRcdHJldCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgdGhyb3dzIGFuIFVuc3BlY2lmaWVkIEVycm9yIGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgZG9tLiBIYW5kbGUgdGhpcyBieSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggMCB2YWx1ZXNcblx0XHRcdHJldHVybiByZXRFbXB0eTtcblx0XHR9XG5cblx0XHQvLyBFZGdlIHJldHVybnMgYW4gZW1wdHkgb2JqZWN0IGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgZG9tLiBIYW5kbGUgdGhpcyBieSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggMCB2YWx1ZXNcblx0XHRpZiAodHlwZW9mIHJldC5sZWZ0ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiByZXRFbXB0eTsgfVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGdlb20uc2V0Q29udGVudFNpemUgPSBmdW5jdGlvbiBzZXRDb250ZW50U2l6ZSgvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdCovIGJveCwgLypPYmplY3QqLyBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNldHMgdGhlIHNpemUgb2YgdGhlIG5vZGUncyBjb250ZW50cywgaXJyZXNwZWN0aXZlIG9mIG1hcmdpbnMsXG5cdFx0Ly9cdFx0cGFkZGluZywgb3IgYm9yZGVycy5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gYm94OiBPYmplY3Rcblx0XHQvL1x0XHRoYXNoIHdpdGggb3B0aW9uYWwgXCJ3XCIsIGFuZCBcImhcIiBwcm9wZXJ0aWVzIGZvciBcIndpZHRoXCIsIGFuZCBcImhlaWdodFwiXG5cdFx0Ly9cdFx0cmVzcGVjdGl2ZWx5LiBBbGwgc3BlY2lmaWVkIHByb3BlcnRpZXMgc2hvdWxkIGhhdmUgbnVtZXJpYyB2YWx1ZXMgaW4gd2hvbGUgcGl4ZWxzLlxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHcgPSBib3gudywgaCA9IGJveC5oO1xuXHRcdGlmKHVzZXNCb3JkZXJCb3gobm9kZSkpe1xuXHRcdFx0dmFyIHBiID0gZ2VvbS5nZXRQYWRCb3JkZXJFeHRlbnRzKG5vZGUsIGNvbXB1dGVkU3R5bGUpO1xuXHRcdFx0aWYodyA+PSAwKXtcblx0XHRcdFx0dyArPSBwYi53O1xuXHRcdFx0fVxuXHRcdFx0aWYoaCA+PSAwKXtcblx0XHRcdFx0aCArPSBwYi5oO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzZXRCb3gobm9kZSwgTmFOLCBOYU4sIHcsIGgpO1xuXHR9O1xuXG5cdHZhciBuaWxFeHRlbnRzID0ge2w6IDAsIHQ6IDAsIHc6IDAsIGg6IDB9O1xuXG5cdGdlb20uc2V0TWFyZ2luQm94ID0gZnVuY3Rpb24gc2V0TWFyZ2luQm94KC8qRG9tTm9kZSovIG5vZGUsIC8qT2JqZWN0Ki8gYm94LCAvKk9iamVjdCovIGNvbXB1dGVkU3R5bGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0c2V0cyB0aGUgc2l6ZSBvZiB0aGUgbm9kZSdzIG1hcmdpbiBib3ggYW5kIHBsYWNlbWVudFxuXHRcdC8vXHRcdChsZWZ0L3RvcCksIGlycmVzcGVjdGl2ZSBvZiBib3ggbW9kZWwuIFRoaW5rIG9mIGl0IGFzIGFcblx0XHQvL1x0XHRwYXNzdGhyb3VnaCB0byBzZXRCb3ggdGhhdCBoYW5kbGVzIGJveC1tb2RlbCB2YWdhcmllcyBmb3Jcblx0XHQvL1x0XHR5b3UuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdC8vIGJveDogT2JqZWN0XG5cdFx0Ly9cdFx0aGFzaCB3aXRoIG9wdGlvbmFsIFwibFwiLCBcInRcIiwgXCJ3XCIsIGFuZCBcImhcIiBwcm9wZXJ0aWVzIGZvciBcImxlZnRcIiwgXCJyaWdodFwiLCBcIndpZHRoXCIsIGFuZCBcImhlaWdodFwiXG5cdFx0Ly9cdFx0cmVzcGVjdGl2ZWx5LiBBbGwgc3BlY2lmaWVkIHByb3BlcnRpZXMgc2hvdWxkIGhhdmUgbnVtZXJpYyB2YWx1ZXMgaW4gd2hvbGUgcGl4ZWxzLlxuXHRcdC8vIGNvbXB1dGVkU3R5bGU6IE9iamVjdD9cblx0XHQvL1x0XHRUaGlzIHBhcmFtZXRlciBhY2NlcHRzIGNvbXB1dGVkIHN0eWxlcyBvYmplY3QuXG5cdFx0Ly9cdFx0SWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGxcblx0XHQvL1x0XHRkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlIHRvIGdldCBvbmUuIEl0IGlzIGEgYmV0dGVyIHdheSwgY2FsbGluZ1xuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgb25jZSwgYW5kIHRoZW4gcGFzcyB0aGUgcmVmZXJlbmNlIHRvIHRoaXNcblx0XHQvL1x0XHRjb21wdXRlZFN0eWxlIHBhcmFtZXRlci4gV2hlcmV2ZXIgcG9zc2libGUsIHJldXNlIHRoZSByZXR1cm5lZFxuXHRcdC8vXHRcdG9iamVjdCBvZiBkb2pvL2RvbS1zdHlsZS5nZXRDb21wdXRlZFN0eWxlKCkuXG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIHMgPSBjb21wdXRlZFN0eWxlIHx8IHN0eWxlLmdldENvbXB1dGVkU3R5bGUobm9kZSksIHcgPSBib3gudywgaCA9IGJveC5oLFxuXHRcdC8vIFNvbWUgZWxlbWVudHMgaGF2ZSBzcGVjaWFsIHBhZGRpbmcsIG1hcmdpbiwgYW5kIGJveC1tb2RlbCBzZXR0aW5ncy5cblx0XHQvLyBUbyB1c2UgYm94IGZ1bmN0aW9ucyB5b3UgbWF5IG5lZWQgdG8gc2V0IHBhZGRpbmcsIG1hcmdpbiBleHBsaWNpdGx5LlxuXHRcdC8vIENvbnRyb2xsaW5nIGJveC1tb2RlbCBpcyBoYXJkZXIsIGluIGEgcGluY2ggeW91IG1pZ2h0IHNldCBkb2pvL2RvbS1nZW9tZXRyeS5ib3hNb2RlbC5cblx0XHRcdHBiID0gdXNlc0JvcmRlckJveChub2RlKSA/IG5pbEV4dGVudHMgOiBnZW9tLmdldFBhZEJvcmRlckV4dGVudHMobm9kZSwgcyksXG5cdFx0XHRtYiA9IGdlb20uZ2V0TWFyZ2luRXh0ZW50cyhub2RlLCBzKTtcblx0XHRpZihoYXMoXCJ3ZWJraXRcIikpe1xuXHRcdFx0Ly8gb24gU2FmYXJpICgzLjEuMiksIGJ1dHRvbiBub2RlcyB3aXRoIG5vIGV4cGxpY2l0IHNpemUgaGF2ZSBhIGRlZmF1bHQgbWFyZ2luXG5cdFx0XHQvLyBzZXR0aW5nIGFuIGV4cGxpY2l0IHNpemUgZWxpbWluYXRlcyB0aGUgbWFyZ2luLlxuXHRcdFx0Ly8gV2UgaGF2ZSB0byBzd2l6emxlIHRoZSB3aWR0aCB0byBnZXQgY29ycmVjdCBtYXJnaW4gcmVhZGluZy5cblx0XHRcdGlmKGlzQnV0dG9uVGFnKG5vZGUpKXtcblx0XHRcdFx0dmFyIG5zID0gbm9kZS5zdHlsZTtcblx0XHRcdFx0aWYodyA+PSAwICYmICFucy53aWR0aCl7XG5cdFx0XHRcdFx0bnMud2lkdGggPSBcIjRweFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGggPj0gMCAmJiAhbnMuaGVpZ2h0KXtcblx0XHRcdFx0XHRucy5oZWlnaHQgPSBcIjRweFwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHcgPj0gMCl7XG5cdFx0XHR3ID0gTWF0aC5tYXgodyAtIHBiLncgLSBtYi53LCAwKTtcblx0XHR9XG5cdFx0aWYoaCA+PSAwKXtcblx0XHRcdGggPSBNYXRoLm1heChoIC0gcGIuaCAtIG1iLmgsIDApO1xuXHRcdH1cblx0XHRzZXRCb3gobm9kZSwgYm94LmwsIGJveC50LCB3LCBoKTtcblx0fTtcblxuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQvLyBQb3NpdGlvbmluZ1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdGdlb20uaXNCb2R5THRyID0gZnVuY3Rpb24gaXNCb2R5THRyKC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBsYW5ndWFnZSBpcyBsZWZ0LXRvLXJpZ2h0LCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdC8vIGRvYzogRG9jdW1lbnQ/XG5cdFx0Ly9cdFx0T3B0aW9uYWwgZG9jdW1lbnQgdG8gcXVlcnkuICAgSWYgdW5zcGVjaWZpZWQsIHVzZSB3aW4uZG9jLlxuXHRcdC8vIHJldHVybnM6IEJvb2xlYW5cblxuXHRcdGRvYyA9IGRvYyB8fCB3aW4uZG9jO1xuXHRcdHJldHVybiAod2luLmJvZHkoZG9jKS5kaXIgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5kaXIgfHwgXCJsdHJcIikudG9Mb3dlckNhc2UoKSA9PSBcImx0clwiOyAvLyBCb29sZWFuXG5cdH07XG5cblx0Z2VvbS5kb2NTY3JvbGwgPSBmdW5jdGlvbiBkb2NTY3JvbGwoLypEb2N1bWVudD8qLyBkb2Mpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UmV0dXJucyBhbiBvYmplY3Qgd2l0aCB7bm9kZSwgeCwgeX0gd2l0aCBjb3JyZXNwb25kaW5nIG9mZnNldHMuXG5cdFx0Ly8gZG9jOiBEb2N1bWVudD9cblx0XHQvL1x0XHRPcHRpb25hbCBkb2N1bWVudCB0byBxdWVyeS4gICBJZiB1bnNwZWNpZmllZCwgdXNlIHdpbi5kb2MuXG5cdFx0Ly8gcmV0dXJuczogT2JqZWN0XG5cblx0XHRkb2MgPSBkb2MgfHwgd2luLmRvYztcblx0XHR2YXIgbm9kZSA9IGRvYy5wYXJlbnRXaW5kb3cgfHwgZG9jLmRlZmF1bHRWaWV3OyAgIC8vIHVzZSBVSSB3aW5kb3csIG5vdCBkb2pvLmdsb2JhbCB3aW5kb3cuICAgVE9ETzogdXNlIGRvam8vd2luZG93OjpnZXQoKSBleGNlcHQgZm9yIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbVxuXHRcdHJldHVybiBcInBhZ2VYT2Zmc2V0XCIgaW4gbm9kZSA/IHt4OiBub2RlLnBhZ2VYT2Zmc2V0LCB5OiBub2RlLnBhZ2VZT2Zmc2V0IH0gOlxuXHRcdFx0KG5vZGUgPSBoYXMoXCJxdWlya3NcIikgPyB3aW4uYm9keShkb2MpIDogZG9jLmRvY3VtZW50RWxlbWVudCkgJiZcblx0XHRcdFx0e3g6IGdlb20uZml4SWVCaURpU2Nyb2xsTGVmdChub2RlLnNjcm9sbExlZnQgfHwgMCwgZG9jKSwgeTogbm9kZS5zY3JvbGxUb3AgfHwgMCB9O1xuXHR9O1xuXG5cdGdlb20uZ2V0SWVEb2N1bWVudEVsZW1lbnRPZmZzZXQgPSBmdW5jdGlvbigvKkRvY3VtZW50PyovIGRvYyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHREZXByZWNhdGVkIG1ldGhvZCBwcmV2aW91c2x5IHVzZWQgZm9yIElFNi1JRTcuICBOb3csIGp1c3QgcmV0dXJucyBge3g6MCwgeTowfWAuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiAwXG5cdFx0fTtcblx0fTtcblxuXHRnZW9tLmZpeEllQmlEaVNjcm9sbExlZnQgPSBmdW5jdGlvbiBmaXhJZUJpRGlTY3JvbGxMZWZ0KC8qSW50ZWdlciovIHNjcm9sbExlZnQsIC8qRG9jdW1lbnQ/Ki8gZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEluIFJUTCBkaXJlY3Rpb24sIHNjcm9sbExlZnQgc2hvdWxkIGJlIGEgbmVnYXRpdmUgdmFsdWUsIGJ1dCBJRVxuXHRcdC8vXHRcdHJldHVybnMgYSBwb3NpdGl2ZSBvbmUuIEFsbCBjb2RlcyB1c2luZyBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuXHRcdC8vXHRcdG11c3QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGZpeCB0aGlzIGVycm9yLCBvdGhlcndpc2UgdGhlIHBvc2l0aW9uXG5cdFx0Ly9cdFx0d2lsbCBvZmZzZXQgdG8gcmlnaHQgd2hlbiB0aGVyZSBpcyBhIGhvcml6b250YWwgc2Nyb2xsYmFyLlxuXHRcdC8vIHNjcm9sbExlZnQ6IE51bWJlclxuXHRcdC8vIGRvYzogRG9jdW1lbnQ/XG5cdFx0Ly9cdFx0T3B0aW9uYWwgZG9jdW1lbnQgdG8gcXVlcnkuICAgSWYgdW5zcGVjaWZpZWQsIHVzZSB3aW4uZG9jLlxuXHRcdC8vIHJldHVybnM6IE51bWJlclxuXG5cdFx0Ly8gSW4gUlRMIGRpcmVjdGlvbiwgc2Nyb2xsTGVmdCBzaG91bGQgYmUgYSBuZWdhdGl2ZSB2YWx1ZSwgYnV0IElFXG5cdFx0Ly8gcmV0dXJucyBhIHBvc2l0aXZlIG9uZS4gQWxsIGNvZGVzIHVzaW5nIGRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0XG5cdFx0Ly8gbXVzdCBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gZml4IHRoaXMgZXJyb3IsIG90aGVyd2lzZSB0aGUgcG9zaXRpb25cblx0XHQvLyB3aWxsIG9mZnNldCB0byByaWdodCB3aGVuIHRoZXJlIGlzIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIuXG5cblx0XHRkb2MgPSBkb2MgfHwgd2luLmRvYztcblx0XHR2YXIgaWUgPSBoYXMoXCJpZVwiKTtcblx0XHRpZihpZSAmJiAhZ2VvbS5pc0JvZHlMdHIoZG9jKSl7XG5cdFx0XHR2YXIgcWsgPSBoYXMoXCJxdWlya3NcIiksXG5cdFx0XHRcdGRlID0gcWsgPyB3aW4uYm9keShkb2MpIDogZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0cHdpbiA9IHdpbi5nbG9iYWw7XHQvLyBUT0RPOiB1c2Ugd2luVXRpbHMuZ2V0KGRvYykgYWZ0ZXIgcmVzb2x2aW5nIGNpcmN1bGFyIGRlcGVuZGVuY3kgYi93IGRvbS1nZW9tZXRyeS5qcyBhbmQgZG9qby93aW5kb3cuanNcblx0XHRcdGlmKGllID09IDYgJiYgIXFrICYmIHB3aW4uZnJhbWVFbGVtZW50ICYmIGRlLnNjcm9sbEhlaWdodCA+IGRlLmNsaWVudEhlaWdodCl7XG5cdFx0XHRcdHNjcm9sbExlZnQgKz0gZGUuY2xpZW50TGVmdDsgLy8gd29ya2Fyb3VuZCBpZTYrc3RyaWN0K3J0bCtpZnJhbWUrdmVydGljYWwtc2Nyb2xsYmFyIGJ1ZyB3aGVyZSBjbGllbnRXaWR0aCBpcyB0b28gc21hbGwgYnkgY2xpZW50TGVmdCBwaXhlbHNcblx0XHRcdH1cblx0XHRcdHJldHVybiAoaWUgPCA4IHx8IHFrKSA/IChzY3JvbGxMZWZ0ICsgZGUuY2xpZW50V2lkdGggLSBkZS5zY3JvbGxXaWR0aCkgOiAtc2Nyb2xsTGVmdDsgLy8gSW50ZWdlclxuXHRcdH1cblx0XHRyZXR1cm4gc2Nyb2xsTGVmdDsgLy8gSW50ZWdlclxuXHR9O1xuXG5cdGdlb20ucG9zaXRpb24gPSBmdW5jdGlvbigvKkRvbU5vZGUqLyBub2RlLCAvKkJvb2xlYW4/Ki8gaW5jbHVkZVNjcm9sbCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRHZXRzIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgcGFzc2VkIGVsZW1lbnQgcmVsYXRpdmUgdG9cblx0XHQvL1x0XHR0aGUgdmlld3BvcnQgKGlmIGluY2x1ZGVTY3JvbGw9PWZhbHNlKSwgb3IgcmVsYXRpdmUgdG8gdGhlXG5cdFx0Ly9cdFx0ZG9jdW1lbnQgcm9vdCAoaWYgaW5jbHVkZVNjcm9sbD09dHJ1ZSkuXG5cdFx0Ly9cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRSZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgZm9ybTpcblx0XHQvL1x0XHRgeyB4OiAxMDAsIHk6IDMwMCwgdzogMjAsIGg6IDE1IH1gLlxuXHRcdC8vXHRcdElmIGluY2x1ZGVTY3JvbGw9PXRydWUsIHRoZSB4IGFuZCB5IHZhbHVlcyB3aWxsIGluY2x1ZGUgYW55XG5cdFx0Ly9cdFx0ZG9jdW1lbnQgb2Zmc2V0cyB0aGF0IG1heSBhZmZlY3QgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZVxuXHRcdC8vXHRcdHZpZXdwb3J0LlxuXHRcdC8vXHRcdFVzZXMgdGhlIGJvcmRlci1ib3ggbW9kZWwgKGluY2x1c2l2ZSBvZiBib3JkZXIgYW5kIHBhZGRpbmcgYnV0XG5cdFx0Ly9cdFx0bm90IG1hcmdpbikuICBEb2VzIG5vdCBhY3QgYXMgYSBzZXR0ZXIuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvLyBpbmNsdWRlU2Nyb2xsOiBCb29sZWFuP1xuXHRcdC8vIHJldHVybnM6IE9iamVjdFxuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdHZhclx0ZGIgPSB3aW4uYm9keShub2RlLm93bmVyRG9jdW1lbnQpLFxuXHRcdFx0cmV0PSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSk7XG5cdFx0cmV0ID0ge3g6IHJldC5sZWZ0LCB5OiByZXQudG9wLCB3OiByZXQucmlnaHQgLSByZXQubGVmdCwgaDogcmV0LmJvdHRvbSAtIHJldC50b3B9O1xuXG5cdFx0aWYoaGFzKFwiaWVcIikgPCA5KXtcblx0XHRcdC8vIGZpeGVzIHRoZSBwb3NpdGlvbiBpbiBJRSwgcXVpcmtzIG1vZGVcblx0XHRcdHJldC54IC09IChoYXMoXCJxdWlya3NcIikgPyBkYi5jbGllbnRMZWZ0ICsgZGIub2Zmc2V0TGVmdCA6IDApO1xuXHRcdFx0cmV0LnkgLT0gKGhhcyhcInF1aXJrc1wiKSA/IGRiLmNsaWVudFRvcCArIGRiLm9mZnNldFRvcCA6IDApO1xuXHRcdH1cblxuXHRcdC8vIGFjY291bnQgZm9yIGRvY3VtZW50IHNjcm9sbGluZ1xuXHRcdC8vIGlmIG9mZnNldFBhcmVudCBpcyB1c2VkLCByZXQgdmFsdWUgYWxyZWFkeSBpbmNsdWRlcyBzY3JvbGwgcG9zaXRpb25cblx0XHQvLyBzbyB3ZSBtYXkgaGF2ZSB0byBhY3R1YWxseSByZW1vdmUgdGhhdCB2YWx1ZSBpZiAhaW5jbHVkZVNjcm9sbFxuXHRcdGlmKGluY2x1ZGVTY3JvbGwpe1xuXHRcdFx0dmFyIHNjcm9sbCA9IGdlb20uZG9jU2Nyb2xsKG5vZGUub3duZXJEb2N1bWVudCk7XG5cdFx0XHRyZXQueCArPSBzY3JvbGwueDtcblx0XHRcdHJldC55ICs9IHNjcm9sbC55O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7IC8vIE9iamVjdFxuXHR9O1xuXG5cdC8vIHJhbmRvbSBcInByaXZhdGVcIiBmdW5jdGlvbnMgd2lsZGx5IHVzZWQgdGhyb3VnaG91dCB0aGUgdG9vbGtpdFxuXG5cdGdlb20uZ2V0TWFyZ2luU2l6ZSA9IGZ1bmN0aW9uIGdldE1hcmdpblNpemUoLypEb21Ob2RlKi8gbm9kZSwgLypPYmplY3QqLyBjb21wdXRlZFN0eWxlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdHJldHVybnMgYW4gb2JqZWN0IHRoYXQgZW5jb2RlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZlxuXHRcdC8vXHRcdHRoZSBub2RlJ3MgbWFyZ2luIGJveFxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly8gY29tcHV0ZWRTdHlsZTogT2JqZWN0P1xuXHRcdC8vXHRcdFRoaXMgcGFyYW1ldGVyIGFjY2VwdHMgY29tcHV0ZWQgc3R5bGVzIG9iamVjdC5cblx0XHQvL1x0XHRJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCB0aGUgZnVuY3Rpb25zIHdpbGwgY2FsbFxuXHRcdC8vXHRcdGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUgdG8gZ2V0IG9uZS4gSXQgaXMgYSBiZXR0ZXIgd2F5LCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG8gdGhpc1xuXHRcdC8vXHRcdGNvbXB1dGVkU3R5bGUgcGFyYW1ldGVyLiBXaGVyZXZlciBwb3NzaWJsZSwgcmV1c2UgdGhlIHJldHVybmVkXG5cdFx0Ly9cdFx0b2JqZWN0IG9mIGRvam8vZG9tLXN0eWxlLmdldENvbXB1dGVkU3R5bGUoKS5cblxuXHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHR2YXIgbWUgPSBnZW9tLmdldE1hcmdpbkV4dGVudHMobm9kZSwgY29tcHV0ZWRTdHlsZSB8fCBzdHlsZS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpKTtcblx0XHR2YXIgc2l6ZSA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChub2RlKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogKHNpemUucmlnaHQgLSBzaXplLmxlZnQpICsgbWUudyxcblx0XHRcdGg6IChzaXplLmJvdHRvbSAtIHNpemUudG9wKSArIG1lLmhcblx0XHR9O1xuXHR9O1xuXG5cdGdlb20ubm9ybWFsaXplRXZlbnQgPSBmdW5jdGlvbihldmVudCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHROb3JtYWxpemVzIHRoZSBnZW9tZXRyeSBvZiBhIERPTSBldmVudCwgbm9ybWFsaXppbmcgdGhlIHBhZ2VYLCBwYWdlWSxcblx0XHQvL1x0XHRvZmZzZXRYLCBvZmZzZXRZLCBsYXllclgsIGFuZCBsYXllclggcHJvcGVydGllc1xuXHRcdC8vIGV2ZW50OiBPYmplY3Rcblx0XHRpZighKFwibGF5ZXJYXCIgaW4gZXZlbnQpKXtcblx0XHRcdGV2ZW50LmxheWVyWCA9IGV2ZW50Lm9mZnNldFg7XG5cdFx0XHRldmVudC5sYXllclkgPSBldmVudC5vZmZzZXRZO1xuXHRcdH1cblxuXHRcdGlmKCEoXCJwYWdlWFwiIGluIGV2ZW50KSl7XG5cdFx0XHQvLyBGSVhNRTogc2Nyb2xsIHBvc2l0aW9uIHF1ZXJ5IGlzIGR1cGVkIGZyb20gZG9qby9fYmFzZS9odG1sIHRvXG5cdFx0XHQvLyBhdm9pZCBkZXBlbmRlbmN5IG9uIHRoYXQgZW50aXJlIG1vZHVsZS4gTm93IHRoYXQgSFRNTCBpcyBpblxuXHRcdFx0Ly8gQmFzZSwgd2Ugc2hvdWxkIGNvbnZlcnQgYmFjayB0byBzb21ldGhpbmcgc2ltaWxhciB0aGVyZS5cblx0XHRcdHZhciBzZSA9IGV2ZW50LnRhcmdldDtcblx0XHRcdHZhciBkb2MgPSAoc2UgJiYgc2Uub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG5cdFx0XHQvLyBETyBOT1QgcmVwbGFjZSB0aGUgZm9sbG93aW5nIHRvIHVzZSBkb2pvL19iYXNlL3dpbmRvdy5ib2R5KCksIGluIElFLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgc2hvdWxkIGJlIHVzZWRcblx0XHRcdC8vIGhlcmUgcmF0aGVyIHRoYW4gZG9jdW1lbnQuYm9keVxuXHRcdFx0dmFyIGRvY0JvZHkgPSBoYXMoXCJxdWlya3NcIikgPyBkb2MuYm9keSA6IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyBnZW9tLmZpeEllQmlEaVNjcm9sbExlZnQoZG9jQm9keS5zY3JvbGxMZWZ0IHx8IDAsIGRvYyk7XG5cdFx0XHRldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jQm9keS5zY3JvbGxUb3AgfHwgMCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFRPRE86IGV2YWx1YXRlIHNlcGFyYXRlIGdldHRlcnMvc2V0dGVycyBmb3IgcG9zaXRpb24gYW5kIHNpemVzP1xuXG5cdHJldHVybiBnZW9tO1xufSk7XG4iLCJkZWZpbmUoW1wiZXhwb3J0c1wiLCBcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi9zbmlmZlwiLCBcIi4vX2Jhc2UvbGFuZ1wiLCBcIi4vZG9tXCIsIFwiLi9kb20tc3R5bGVcIiwgXCIuL2RvbS1jb25zdHJ1Y3RcIiwgXCIuL19iYXNlL2Nvbm5lY3RcIl0sXG5cdFx0ZnVuY3Rpb24oZXhwb3J0cywgZG9qbywgaGFzLCBsYW5nLCBkb20sIHN0eWxlLCBjdHIsIGNvbm4pe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZG9tLXByb3Bcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBwcm9wZXJ0aWVzIEFQSS5cblxuXHQvLyBUT0RPQzogc3VtbWFyeSBub3Qgc2hvd2luZyB1cCBpbiBvdXRwdXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1kb2MtcGFyc2UvaXNzdWVzLzQyXG5cblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0Ly8gRWxlbWVudCBwcm9wZXJ0aWVzIEZ1bmN0aW9uc1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdC8vIGhlbHBlciB0byBjb25uZWN0IGV2ZW50c1xuXHR2YXIgX2V2dEhkbHJNYXAgPSB7fSwgX2N0ciA9IDEsIF9hdHRySWQgPSBkb2pvLl9zY29wZU5hbWUgKyBcImF0dHJpZFwiO1xuXHRoYXMuYWRkKCdkb20tdGV4dENvbnRlbnQnLCBmdW5jdGlvbiAoZ2xvYmFsLCBkb2MsIGVsZW1lbnQpIHsgcmV0dXJuICd0ZXh0Q29udGVudCcgaW4gZWxlbWVudDsgfSk7XG5cblx0ZXhwb3J0cy5uYW1lcyA9IHtcblx0XHQvLyBwcm9wZXJ0aWVzIHJlbmFtZWQgdG8gYXZvaWQgY2xhc2hlcyB3aXRoIHJlc2VydmVkIHdvcmRzXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdC8vIHByb3BlcnRpZXMgd3JpdHRlbiBhcyBjYW1lbENhc2Vcblx0XHR0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuXHRcdHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG5cdFx0Y29sc3BhbjogXCJjb2xTcGFuXCIsXG5cdFx0ZnJhbWVib3JkZXI6IFwiZnJhbWVCb3JkZXJcIixcblx0XHRyb3dzcGFuOiBcInJvd1NwYW5cIixcblx0XHR0ZXh0Y29udGVudDogXCJ0ZXh0Q29udGVudFwiLFxuXHRcdHZhbHVldHlwZTogXCJ2YWx1ZVR5cGVcIlxuXHR9O1xuXHRcblx0ZnVuY3Rpb24gZ2V0VGV4dCgvKkRPTU5vZGUqL25vZGUpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0cmVjdXJzaW9uIG1ldGhvZCBmb3IgZ2V0KCd0ZXh0Q29udGVudCcpIHRvIHVzZS4gR2V0cyB0ZXh0IHZhbHVlIGZvciBhIG5vZGUuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SnVzZSB1c2VzIG5vZGVkVmFsdWUgc28gdGhpbmdzIGxpa2UgPGJyLz4gdGFncyBkbyBub3QgZW5kIHVwIGluXG5cdFx0Ly9cdFx0dGhlIHRleHQgYXMgYW55IHNvcnQgb2YgbGluZSByZXR1cm4uXG5cdFx0dmFyIHRleHQgPSBcIlwiLCBjaCA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRmb3IodmFyIGkgPSAwLCBuOyBuID0gY2hbaV07IGkrKyl7XG5cdFx0XHQvL1NraXAgY29tbWVudHMuXG5cdFx0XHRpZihuLm5vZGVUeXBlICE9IDgpe1xuXHRcdFx0XHRpZihuLm5vZGVUeXBlID09IDEpe1xuXHRcdFx0XHRcdHRleHQgKz0gZ2V0VGV4dChuKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGV4dCArPSBuLm5vZGVWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdGV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0UHJvcCgvKkRPTU5vZGV8U3RyaW5nKi8gbm9kZSwgLypTdHJpbmcqLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEdldHMgYSBwcm9wZXJ0eSBvbiBhbiBIVE1MIGVsZW1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SGFuZGxlcyBub3JtYWxpemVkIGdldHRpbmcgb2YgcHJvcGVydGllcyBvbiBET00gbm9kZXMuXG5cdFx0Ly9cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBnZXQgdGhlIHByb3BlcnR5IG9uXG5cdFx0Ly8gbmFtZTogU3RyaW5nXG5cdFx0Ly9cdFx0dGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0XHQvLyByZXR1cm5zOlxuXHRcdC8vXHRcdHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IG9yIGl0cyBkZWZhdWx0IHZhbHVlXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHR8XHQvLyBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFwiZm9vXCIgcHJvcGVydHkgb24gYSBub2RlXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tcHJvcFwiLCBcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb21Qcm9wLCBkb20pe1xuXHRcdC8vXHR8XHRcdGRvbVByb3AuZ2V0KGRvbS5ieUlkKFwibm9kZUlkXCIpLCBcImZvb1wiKTtcblx0XHQvL1x0fFx0XHQvLyBvciB3ZSBjYW4ganVzdCBwYXNzIHRoZSBpZDpcblx0XHQvL1x0fFx0XHRkb21Qcm9wLmdldChcIm5vZGVJZFwiLCBcImZvb1wiKTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cdFx0dmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpLCBwcm9wTmFtZSA9IGV4cG9ydHMubmFtZXNbbGNdIHx8IG5hbWU7XG5cdFx0XG5cdFx0aWYocHJvcE5hbWUgPT0gXCJ0ZXh0Q29udGVudFwiICYmICFoYXMoXCJkb20tdGV4dENvbnRlbnRcIikpe1xuXHRcdFx0cmV0dXJuIGdldFRleHQobm9kZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBub2RlW3Byb3BOYW1lXTtcdC8vIEFueXRoaW5nXG5cdH07XG5cblx0ZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiBzZXRQcm9wKC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZ3xPYmplY3QqLyBuYW1lLCAvKlN0cmluZz8qLyB2YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZXRzIGEgcHJvcGVydHkgb24gYW4gSFRNTCBlbGVtZW50LlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEhhbmRsZXMgbm9ybWFsaXplZCBzZXR0aW5nIG9mIHByb3BlcnRpZXMgb24gRE9NIG5vZGVzLlxuXHRcdC8vXG5cdFx0Ly9cdFx0V2hlbiBwYXNzaW5nIGZ1bmN0aW9ucyBhcyB2YWx1ZXMsIG5vdGUgdGhhdCB0aGV5IHdpbGwgbm90IGJlXG5cdFx0Ly9cdFx0ZGlyZWN0bHkgYXNzaWduZWQgdG8gc2xvdHMgb24gdGhlIG5vZGUsIGJ1dCByYXRoZXIgdGhlIGRlZmF1bHRcblx0XHQvL1x0XHRiZWhhdmlvciB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBuZXcgYmVoYXZpb3Igd2lsbCBiZSBhZGRlZFxuXHRcdC8vXHRcdHVzaW5nIGBkb2pvLmNvbm5lY3QoKWAsIG1lYW5pbmcgdGhhdCBldmVudCBoYW5kbGVyIHByb3BlcnRpZXNcblx0XHQvL1x0XHR3aWxsIGJlIG5vcm1hbGl6ZWQgYW5kIHRoYXQgc29tZSBjYXZlYXRzIHdpdGggcmVnYXJkcyB0b1xuXHRcdC8vXHRcdG5vbi1zdGFuZGFyZCBiZWhhdmlvcnMgZm9yIG9uc3VibWl0IGFwcGx5LiBOYW1lbHkgdGhhdCB5b3Vcblx0XHQvL1x0XHRzaG91bGQgY2FuY2VsIGZvcm0gc3VibWlzc2lvbiB1c2luZyBgZG9qby5zdG9wRXZlbnQoKWAgb24gdGhlXG5cdFx0Ly9cdFx0cGFzc2VkIGV2ZW50IG9iamVjdCBpbnN0ZWFkIG9mIHJldHVybmluZyBhIGJvb2xlYW4gdmFsdWUgZnJvbVxuXHRcdC8vXHRcdHRoZSBoYW5kbGVyIGl0c2VsZi5cblx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdC8vXHRcdGlkIG9yIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBzZXQgdGhlIHByb3BlcnR5IG9uXG5cdFx0Ly8gbmFtZTogU3RyaW5nfE9iamVjdFxuXHRcdC8vXHRcdHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQsIG9yIGEgaGFzaCBvYmplY3QgdG8gc2V0XG5cdFx0Ly9cdFx0bXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlLlxuXHRcdC8vIHZhbHVlOiBTdHJpbmc/XG5cdFx0Ly9cdFx0VGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIHByb3BlcnR5XG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHR0aGUgRE9NIG5vZGVcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdHxcdC8vIHVzZSBwcm9wKCkgdG8gc2V0IHRoZSB0YWIgaW5kZXhcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1wcm9wXCJdLCBmdW5jdGlvbihkb21Qcm9wKXtcblx0XHQvL1x0fFx0XHRkb21Qcm9wLnNldChcIm5vZGVJZFwiLCBcInRhYkluZGV4XCIsIDMpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFNldCBtdWx0aXBsZSB2YWx1ZXMgYXQgb25jZSwgaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXByb3BcIl0sIGZ1bmN0aW9uKGRvbVByb3Ape1xuXHRcdC8vXHR8XHRcdGRvbVByb3Auc2V0KFwiZm9ybUlkXCIsIHtcblx0XHQvL1x0fFx0XHRcdFwiZm9vXCI6IFwiYmFyXCIsXG5cdFx0Ly9cdHxcdFx0XHRcInRhYkluZGV4XCI6IC0xLFxuXHRcdC8vXHR8XHRcdFx0XCJtZXRob2RcIjogXCJQT1NUXCIsXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZihsID09IDIgJiYgdHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIil7IC8vIGlubGluZSdkIHR5cGUgY2hlY2tcblx0XHRcdC8vIHRoZSBvYmplY3QgZm9ybSBvZiBzZXR0ZXI6IHRoZSAybmQgYXJndW1lbnQgaXMgYSBkaWN0aW9uYXJ5XG5cdFx0XHRmb3IodmFyIHggaW4gbmFtZSl7XG5cdFx0XHRcdGV4cG9ydHMuc2V0KG5vZGUsIHgsIG5hbWVbeF0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7IC8vIERvbU5vZGVcblx0XHR9XG5cdFx0dmFyIGxjID0gbmFtZS50b0xvd2VyQ2FzZSgpLCBwcm9wTmFtZSA9IGV4cG9ydHMubmFtZXNbbGNdIHx8IG5hbWU7XG5cdFx0aWYocHJvcE5hbWUgPT0gXCJzdHlsZVwiICYmIHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBzZXR0aW5nIGEgc3R5bGVcblx0XHRcdHN0eWxlLnNldChub2RlLCB2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHRpZihwcm9wTmFtZSA9PSBcImlubmVySFRNTFwiKXtcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogYXNzaWduaW5nIEhUTUxcblx0XHRcdC8vIHRoZSBoYXNoIGxpc3RzIGVsZW1lbnRzIHdpdGggcmVhZC1vbmx5IGlubmVySFRNTCBvbiBJRVxuXHRcdFx0aWYoaGFzKFwiaWVcIikgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgaW4ge2NvbDogMSwgY29sZ3JvdXA6IDEsXG5cdFx0XHRcdFx0XHR0YWJsZTogMSwgdGJvZHk6IDEsIHRmb290OiAxLCB0aGVhZDogMSwgdHI6IDEsIHRpdGxlOiAxfSl7XG5cdFx0XHRcdGN0ci5lbXB0eShub2RlKTtcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjdHIudG9Eb20odmFsdWUsIG5vZGUub3duZXJEb2N1bWVudCkpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdG5vZGVbcHJvcE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTsgLy8gRG9tTm9kZVxuXHRcdH1cblx0XHRpZihwcm9wTmFtZSA9PSBcInRleHRDb250ZW50XCIgJiYgIWhhcyhcImRvbS10ZXh0Q29udGVudFwiKSkge1xuXHRcdFx0Y3RyLmVtcHR5KG5vZGUpO1xuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChub2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpKTtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH1cblx0XHRpZihsYW5nLmlzRnVuY3Rpb24odmFsdWUpKXtcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogYXNzaWduaW5nIGFuIGV2ZW50IGhhbmRsZXJcblx0XHRcdC8vIGNsb2JiZXIgaWYgd2UgY2FuXG5cdFx0XHR2YXIgYXR0cklkID0gbm9kZVtfYXR0cklkXTtcblx0XHRcdGlmKCFhdHRySWQpe1xuXHRcdFx0XHRhdHRySWQgPSBfY3RyKys7XG5cdFx0XHRcdG5vZGVbX2F0dHJJZF0gPSBhdHRySWQ7XG5cdFx0XHR9XG5cdFx0XHRpZighX2V2dEhkbHJNYXBbYXR0cklkXSl7XG5cdFx0XHRcdF9ldnRIZGxyTWFwW2F0dHJJZF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdHZhciBoID0gX2V2dEhkbHJNYXBbYXR0cklkXVtwcm9wTmFtZV07XG5cdFx0XHRpZihoKXtcblx0XHRcdFx0Ly9oLnJlbW92ZSgpO1xuXHRcdFx0XHRjb25uLmRpc2Nvbm5lY3QoaCk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdGRlbGV0ZSBub2RlW3Byb3BOYW1lXTtcblx0XHRcdFx0fWNhdGNoKGUpe31cblx0XHRcdH1cblx0XHRcdC8vIGVuc3VyZSB0aGF0IGV2ZW50IG9iamVjdHMgYXJlIG5vcm1hbGl6ZWQsIGV0Yy5cblx0XHRcdGlmKHZhbHVlKXtcblx0XHRcdFx0Ly9fZXZ0SGRsck1hcFthdHRySWRdW3Byb3BOYW1lXSA9IG9uKG5vZGUsIHByb3BOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdF9ldnRIZGxyTWFwW2F0dHJJZF1bcHJvcE5hbWVdID0gY29ubi5jb25uZWN0KG5vZGUsIHByb3BOYW1lLCB2YWx1ZSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0bm9kZVtwcm9wTmFtZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7IC8vIERvbU5vZGVcblx0XHR9XG5cdFx0bm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcblx0XHRyZXR1cm4gbm9kZTtcdC8vIERvbU5vZGVcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vc25pZmZcIiwgXCIuL2RvbVwiLCBcIi4vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihoYXMsIGRvbSwgd2luKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2RvbS1zdHlsZVxuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIFN0eWxlIEZ1bmN0aW9uc1xuXHQvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdC8vIGdldENvbXB1dGVkU3R5bGUgZHJpdmVzIG1vc3Qgb2YgdGhlIHN0eWxlIGNvZGUuXG5cdC8vIFdoZXJldmVyIHBvc3NpYmxlLCByZXVzZSB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuXHQvL1xuXHQvLyBBUEkgZnVuY3Rpb25zIGJlbG93IHRoYXQgbmVlZCB0byBhY2Nlc3MgY29tcHV0ZWQgc3R5bGVzIGFjY2VwdCBhblxuXHQvLyBvcHRpb25hbCBjb21wdXRlZFN0eWxlIHBhcmFtZXRlci5cblx0Ly8gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGNhbGwgZ2V0Q29tcHV0ZWRTdHlsZSB0aGVtc2VsdmVzLlxuXHQvLyBUaGlzIHdheSwgY2FsbGluZyBjb2RlIGNhbiBhY2Nlc3MgY29tcHV0ZWRTdHlsZSBvbmNlLCBhbmQgdGhlbiBwYXNzIHRoZSByZWZlcmVuY2UgdG9cblx0Ly8gbXVsdGlwbGUgQVBJIGZ1bmN0aW9ucy5cblxuXHQvLyBBbHRob3VnaCB3ZSBub3JtYWxseSBlc2NoZXcgYXJndW1lbnQgdmFsaWRhdGlvbiBhdCB0aGlzXG5cdC8vIGxldmVsLCBoZXJlIHdlIHRlc3QgYXJndW1lbnQgJ25vZGUnIGZvciAoZHVjayl0eXBlLFxuXHQvLyBieSB0ZXN0aW5nIG5vZGVUeXBlLCBlY2F1c2UgJ2RvY3VtZW50JyBpcyB0aGUgJ3BhcmVudE5vZGUnIG9mICdib2R5J1xuXHQvLyBpdCBpcyBmcmVxdWVudGx5IHNlbnQgdG8gdGhpcyBmdW5jdGlvbiBldmVuXG5cdC8vIHRob3VnaCBpdCBpcyBub3QgRWxlbWVudC5cblx0dmFyIGdldENvbXB1dGVkU3R5bGUsIHN0eWxlID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBzdHlsZSBBUEkuXG5cdH07XG5cdGlmKGhhcyhcIndlYmtpdFwiKSl7XG5cdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKC8qRG9tTm9kZSovIG5vZGUpe1xuXHRcdFx0dmFyIHM7XG5cdFx0XHRpZihub2RlLm5vZGVUeXBlID09IDEpe1xuXHRcdFx0XHR2YXIgZHYgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHMgPSBkdi5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpO1xuXHRcdFx0XHRpZighcyAmJiBub2RlLnN0eWxlKXtcblx0XHRcdFx0XHRub2RlLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHRcdHMgPSBkdi5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcyB8fCB7fTtcblx0XHR9O1xuXHR9ZWxzZSBpZihoYXMoXCJpZVwiKSAmJiAoaGFzKFwiaWVcIikgPCA5IHx8IGhhcyhcInF1aXJrc1wiKSkpe1xuXHRcdGdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihub2RlKXtcblx0XHRcdC8vIElFIChhcyBvZiA3KSBkb2Vzbid0IGV4cG9zZSBFbGVtZW50IGxpa2Ugc2FuZSBicm93c2Vyc1xuXHRcdFx0Ly8gY3VycmVudFN0eWxlIGNhbiBiZSBudWxsIG9uIElFOCFcblx0XHRcdHJldHVybiBub2RlLm5vZGVUeXBlID09IDEgLyogRUxFTUVOVF9OT0RFKi8gJiYgbm9kZS5jdXJyZW50U3R5bGUgPyBub2RlLmN1cnJlbnRTdHlsZSA6IHt9O1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdGdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihub2RlKXtcblx0XHRcdGlmKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRUxFTUVOVF9OT0RFKi8pe1xuXHRcdFx0XHR2YXIgZHYgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdFx0dyA9IGR2Lm9wZW5lciA/IGR2IDogd2luLmdsb2JhbC53aW5kb3c7XG5cdFx0XHRcdHJldHVybiB3LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fTtcblx0fVxuXHRzdHlsZS5nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZTtcblx0Lyo9PT09PVxuXHRzdHlsZS5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24obm9kZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRSZXR1cm5zIGEgXCJjb21wdXRlZCBzdHlsZVwiIG9iamVjdC5cblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEdldHMgYSBcImNvbXB1dGVkIHN0eWxlXCIgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIHRvIGdhdGhlclxuXHRcdC8vXHRcdGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZW5kZXJlZCBub2RlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgbWF5IGJlaGF2ZSBkaWZmZXJlbnRseSBvbiBkaWZmZXJlbnQgYnJvd3NlcnMuXG5cdFx0Ly9cdFx0VmFsdWVzIG1heSBoYXZlIGRpZmZlcmVudCBmb3JtYXRzIGFuZCB2YWx1ZSBlbmNvZGluZ3MgYWNyb3NzXG5cdFx0Ly9cdFx0YnJvd3NlcnMuXG5cdFx0Ly9cblx0XHQvL1x0XHROb3RlIGFsc28gdGhhdCB0aGlzIG1ldGhvZCBpcyBleHBlbnNpdmUuICBXaGVyZXZlciBwb3NzaWJsZSxcblx0XHQvL1x0XHRyZXVzZSB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0VXNlIHRoZSBkb2pvL2RvbS1zdHlsZS5nZXQoKSBtZXRob2QgZm9yIG1vcmUgY29uc2lzdGVudCAocGl4ZWxpemVkKVxuXHRcdC8vXHRcdHJldHVybiB2YWx1ZXMuXG5cdFx0Ly9cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly9cdFx0QSByZWZlcmVuY2UgdG8gYSBET00gbm9kZS4gRG9lcyBOT1Qgc3VwcG9ydCB0YWtpbmcgYW5cblx0XHQvL1x0XHRJRCBzdHJpbmcgZm9yIHNwZWVkIHJlYXNvbnMuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiLCBcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb21TdHlsZSwgZG9tKXtcblx0XHQvL1x0fFx0XHRkb21TdHlsZS5nZXRDb21wdXRlZFN0eWxlKGRvbS5ieUlkKCdmb28nKSkuYm9yZGVyV2lkdGg7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRSZXVzaW5nIHRoZSByZXR1cm5lZCBvYmplY3QsIGF2b2lkaW5nIG11bHRpcGxlIGxvb2t1cHM6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tc3R5bGVcIiwgXCJkb2pvL2RvbVwiXSwgZnVuY3Rpb24oZG9tU3R5bGUsIGRvbSl7XG5cdFx0Ly9cdHxcdFx0dmFyIGNzID0gZG9tU3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShkb20uYnlJZChcInNvbWVOb2RlXCIpKTtcblx0XHQvL1x0fFx0XHR2YXIgdyA9IGNzLndpZHRoLCBoID0gY3MuaGVpZ2h0O1xuXHRcdC8vXHR8XHR9KTtcblx0XHRyZXR1cm47IC8vIENTUzJQcm9wZXJ0aWVzXG5cdH07XG5cdD09PT09Ki9cblxuXHR2YXIgdG9QaXhlbDtcblx0aWYoIWhhcyhcImllXCIpKXtcblx0XHR0b1BpeGVsID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpe1xuXHRcdFx0Ly8gc3R5bGUgdmFsdWVzIGNhbiBiZSBmbG9hdHMsIGNsaWVudCBjb2RlIG1heSB3YW50XG5cdFx0XHQvLyB0byByb3VuZCBmb3IgaW50ZWdlciBwaXhlbHMuXG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcblx0XHR9O1xuXHR9ZWxzZXtcblx0XHR0b1BpeGVsID0gZnVuY3Rpb24oZWxlbWVudCwgYXZhbHVlKXtcblx0XHRcdGlmKCFhdmFsdWUpeyByZXR1cm4gMDsgfVxuXHRcdFx0Ly8gb24gSUU3LCBtZWRpdW0gaXMgdXN1YWxseSA0IHBpeGVsc1xuXHRcdFx0aWYoYXZhbHVlID09IFwibWVkaXVtXCIpeyByZXR1cm4gNDsgfVxuXHRcdFx0Ly8gc3R5bGUgdmFsdWVzIGNhbiBiZSBmbG9hdHMsIGNsaWVudCBjb2RlIG1heVxuXHRcdFx0Ly8gd2FudCB0byByb3VuZCB0aGlzIHZhbHVlIGZvciBpbnRlZ2VyIHBpeGVscy5cblx0XHRcdGlmKGF2YWx1ZS5zbGljZSAmJiBhdmFsdWUuc2xpY2UoLTIpID09ICdweCcpeyByZXR1cm4gcGFyc2VGbG9hdChhdmFsdWUpOyB9XG5cdFx0XHR2YXIgcyA9IGVsZW1lbnQuc3R5bGUsIHJzID0gZWxlbWVudC5ydW50aW1lU3R5bGUsIGNzID0gZWxlbWVudC5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdHNMZWZ0ID0gcy5sZWZ0LCByc0xlZnQgPSBycy5sZWZ0O1xuXHRcdFx0cnMubGVmdCA9IGNzLmxlZnQ7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdC8vICdhdmFsdWUnIG1heSBiZSBpbmNvbXBhdGlibGUgd2l0aCBzdHlsZS5sZWZ0LCB3aGljaCBjYW4gY2F1c2UgSUUgdG8gdGhyb3dcblx0XHRcdFx0Ly8gdGhpcyBoYXMgYmVlbiBvYnNlcnZlZCBmb3IgYm9yZGVyIHdpZHRocyB1c2luZyBcInRoaW5cIiwgXCJtZWRpdW1cIiwgXCJ0aGlja1wiIGNvbnN0YW50c1xuXHRcdFx0XHQvLyB0aG9zZSBwYXJ0aWN1bGFyIGNvbnN0YW50cyBjb3VsZCBiZSB0cmFwcGVkIGJ5IGEgbG9va3VwXG5cdFx0XHRcdC8vIGJ1dCBwZXJoYXBzIHRoZXJlIGFyZSBtb3JlXG5cdFx0XHRcdHMubGVmdCA9IGF2YWx1ZTtcblx0XHRcdFx0YXZhbHVlID0gcy5waXhlbExlZnQ7XG5cdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdGF2YWx1ZSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRzLmxlZnQgPSBzTGVmdDtcblx0XHRcdHJzLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHRyZXR1cm4gYXZhbHVlO1xuXHRcdH07XG5cdH1cblx0c3R5bGUudG9QaXhlbFZhbHVlID0gdG9QaXhlbDtcblx0Lyo9PT09PVxuXHRzdHlsZS50b1BpeGVsVmFsdWUgPSBmdW5jdGlvbihub2RlLCB2YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRjb252ZXJ0cyBzdHlsZSB2YWx1ZSB0byBwaXhlbHMgb24gSUUgb3IgcmV0dXJuIGEgbnVtZXJpYyB2YWx1ZS5cblx0XHQvLyBub2RlOiBET01Ob2RlXG5cdFx0Ly8gdmFsdWU6IFN0cmluZ1xuXHRcdC8vIHJldHVybnM6IE51bWJlclxuXHR9O1xuXHQ9PT09PSovXG5cblx0Ly8gRklYTUU6IHRoZXJlIG9wYWNpdHkgcXVpcmtzIG9uIEZGIHRoYXQgd2UgaGF2ZW4ndCBwb3J0ZWQgb3Zlci4gSHJtLlxuXG5cdHZhciBhc3RyID0gXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYVwiO1xuXHR2YXIgYWYgPSBmdW5jdGlvbihuLCBmKXtcblx0XHR0cnl7XG5cdFx0XHRyZXR1cm4gbi5maWx0ZXJzLml0ZW0oYXN0cik7XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0cmV0dXJuIGYgPyB7fSA6IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBfZ2V0T3BhY2l0eSA9XG5cdFx0aGFzKFwiaWVcIikgPCA5IHx8IChoYXMoXCJpZVwiKSA8IDEwICYmIGhhcyhcInF1aXJrc1wiKSkgPyBmdW5jdGlvbihub2RlKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0cmV0dXJuIGFmKG5vZGUpLk9wYWNpdHkgLyAxMDA7IC8vIE51bWJlclxuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRyZXR1cm4gMTsgLy8gTnVtYmVyXG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRyZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuXHRcdH07XG5cblx0dmFyIF9zZXRPcGFjaXR5ID1cblx0XHRoYXMoXCJpZVwiKSA8IDkgfHwgKGhhcyhcImllXCIpIDwgMTAgJiYgaGFzKFwicXVpcmtzXCIpKSA/IGZ1bmN0aW9uKC8qRG9tTm9kZSovIG5vZGUsIC8qTnVtYmVyKi8gb3BhY2l0eSl7XG5cdFx0XHRpZihvcGFjaXR5ID09PSBcIlwiKXsgb3BhY2l0eSA9IDE7IH1cblx0XHRcdHZhciBvdiA9IG9wYWNpdHkgKiAxMDAsIGZ1bGx5T3BhcXVlID0gb3BhY2l0eSA9PT0gMTtcblxuXHRcdFx0Ly8gb24gSUU3IEFscGhhKEZpbHRlciBvcGFjaXR5PTEwMCkgbWFrZXMgdGV4dCBsb29rIGZ1enp5IHNvIGRpc2FibGUgaXQgYWx0b2dldGhlciAoYnVnICMyNjYxKSxcblx0XHRcdC8vIGJ1dCBzdGlsbCB1cGRhdGUgdGhlIG9wYWNpdHkgdmFsdWUgc28gd2UgY2FuIGdldCBhIGNvcnJlY3QgcmVhZGluZyBpZiBpdCBpcyByZWFkIGxhdGVyOlxuXHRcdFx0Ly8gYWYobm9kZSwgMSkuRW5hYmxlZCA9ICFmdWxseU9wYXF1ZTtcblxuXHRcdFx0aWYoZnVsbHlPcGFxdWUpe1xuXHRcdFx0XHRub2RlLnN0eWxlLnpvb20gPSBcIlwiO1xuXHRcdFx0XHRpZihhZihub2RlKSl7XG5cdFx0XHRcdFx0bm9kZS5zdHlsZS5maWx0ZXIgPSBub2RlLnN0eWxlLmZpbHRlci5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0bmV3IFJlZ0V4cChcIlxcXFxzKnByb2dpZDpcIiArIGFzdHIgKyBcIlxcXFwoW15cXFxcKV0rP1xcXFwpXCIsIFwiaVwiKSwgXCJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRub2RlLnN0eWxlLnpvb20gPSAxO1xuXHRcdFx0XHRpZihhZihub2RlKSl7XG5cdFx0XHRcdFx0YWYobm9kZSwgMSkuT3BhY2l0eSA9IG92O1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRub2RlLnN0eWxlLmZpbHRlciArPSBcIiBwcm9naWQ6XCIgKyBhc3RyICsgXCIoT3BhY2l0eT1cIiArIG92ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YWYobm9kZSwgMSkuRW5hYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwidHJcIil7XG5cdFx0XHRcdGZvcih2YXIgdGQgPSBub2RlLmZpcnN0Q2hpbGQ7IHRkOyB0ZCA9IHRkLm5leHRTaWJsaW5nKXtcblx0XHRcdFx0XHRpZih0ZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJ0ZFwiKXtcblx0XHRcdFx0XHRcdF9zZXRPcGFjaXR5KHRkLCBvcGFjaXR5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcGFjaXR5O1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKG5vZGUsIG9wYWNpdHkpe1xuXHRcdFx0cmV0dXJuIG5vZGUuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0fTtcblxuXHR2YXIgX3BpeGVsTmFtZXNDYWNoZSA9IHtcblx0XHRsZWZ0OiB0cnVlLCB0b3A6IHRydWVcblx0fTtcblx0dmFyIF9waXhlbFJlZ0V4cCA9IC9tYXJnaW58cGFkZGluZ3x3aWR0aHxoZWlnaHR8bWF4fG1pbnxvZmZzZXQvOyAvLyB8Ym9yZGVyXG5cdGZ1bmN0aW9uIF90b1N0eWxlVmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpe1xuXHRcdC8vVE9ETzogc2hvdWxkIHdlIHJlYWxseSBiZSBkb2luZyBzdHJpbmcgY2FzZSBjb252ZXJzaW9uIGhlcmU/IFNob3VsZCB3ZSBjYWNoZSBpdD8gTmVlZCB0byBwcm9maWxlIVxuXHRcdHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBBZGp1c3RtZW50cyBmb3IgSUUgYW5kIEVkZ2Vcblx0XHRpZih2YWx1ZSA9PSBcImF1dG9cIil7XG5cdFx0XHRpZih0eXBlID09IFwiaGVpZ2h0XCIpeyByZXR1cm4gbm9kZS5vZmZzZXRIZWlnaHQ7IH1cblx0XHRcdGlmKHR5cGUgPT0gXCJ3aWR0aFwiKXsgcmV0dXJuIG5vZGUub2Zmc2V0V2lkdGg7IH1cblx0XHR9XG5cdFx0aWYodHlwZSA9PSBcImZvbnR3ZWlnaHRcIil7XG5cdFx0XHRzd2l0Y2godmFsdWUpe1xuXHRcdFx0XHRjYXNlIDcwMDogcmV0dXJuIFwiYm9sZFwiO1xuXHRcdFx0XHRjYXNlIDQwMDpcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIFwibm9ybWFsXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoISh0eXBlIGluIF9waXhlbE5hbWVzQ2FjaGUpKXtcblx0XHRcdF9waXhlbE5hbWVzQ2FjaGVbdHlwZV0gPSBfcGl4ZWxSZWdFeHAudGVzdCh0eXBlKTtcblx0XHR9XG5cdFx0cmV0dXJuIF9waXhlbE5hbWVzQ2FjaGVbdHlwZV0gPyB0b1BpeGVsKG5vZGUsIHZhbHVlKSA6IHZhbHVlO1xuXHR9XG5cblx0dmFyIF9mbG9hdEFsaWFzZXMgPSB7Y3NzRmxvYXQ6IDEsIHN0eWxlRmxvYXQ6IDEsIFwiZmxvYXRcIjogMX07XG5cblx0Ly8gcHVibGljIEFQSVxuXG5cdHN0eWxlLmdldCA9IGZ1bmN0aW9uIGdldFN0eWxlKC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZz8qLyBuYW1lKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEFjY2Vzc2VzIHN0eWxlcyBvbiBhIG5vZGUuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0R2V0dGluZyB0aGUgc3R5bGUgdmFsdWUgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgZm9yIHRoZSBub2RlLCBzbyB0aGUgdmFsdWVcblx0XHQvL1x0XHR3aWxsIGJlIGEgY2FsY3VsYXRlZCB2YWx1ZSwgbm90IGp1c3QgdGhlIGltbWVkaWF0ZSBub2RlLnN0eWxlIHZhbHVlLlxuXHRcdC8vXHRcdEFsc28gd2hlbiBnZXR0aW5nIHZhbHVlcywgdXNlIHNwZWNpZmljIHN0eWxlIG5hbWVzLFxuXHRcdC8vXHRcdGxpa2UgXCJib3JkZXJCb3R0b21XaWR0aFwiIGluc3RlYWQgb2YgXCJib3JkZXJcIiBzaW5jZSBjb21wb3VuZCB2YWx1ZXMgbGlrZVxuXHRcdC8vXHRcdFwiYm9yZGVyXCIgYXJlIG5vdCBuZWNlc3NhcmlseSByZWZsZWN0ZWQgYXMgZXhwZWN0ZWQuXG5cdFx0Ly9cdFx0SWYgeW91IHdhbnQgdG8gZ2V0IG5vZGUgZGltZW5zaW9ucywgdXNlIGBkb2pvL2RvbS1nZW9tZXRyeS5nZXRNYXJnaW5Cb3goKWAsXG5cdFx0Ly9cdFx0YGRvam8vZG9tLWdlb21ldHJ5LmdldENvbnRlbnRCb3goKWAgb3IgYGRvam8vZG9tLWdlb21ldHJ5LmdldFBvc2l0aW9uKClgLlxuXHRcdC8vIG5vZGU6IERPTU5vZGV8U3RyaW5nXG5cdFx0Ly9cdFx0aWQgb3IgcmVmZXJlbmNlIHRvIG5vZGUgdG8gZ2V0IHN0eWxlIGZvclxuXHRcdC8vIG5hbWU6IFN0cmluZz9cblx0XHQvL1x0XHR0aGUgc3R5bGUgcHJvcGVydHkgdG8gZ2V0XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRQYXNzaW5nIG9ubHkgYW4gSUQgb3Igbm9kZSByZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSBvYmplY3Qgb2Zcblx0XHQvL1x0XHR0aGUgbm9kZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiLCBcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb21TdHlsZSwgZG9tKXtcblx0XHQvL1x0fFx0XHRkb21TdHlsZS5nZXQoXCJ0aGluZ2VyXCIpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFBhc3NpbmcgYSBub2RlIGFuZCBhIHN0eWxlIHByb3BlcnR5IHJldHVybnMgdGhlIGN1cnJlbnRcblx0XHQvL1x0XHRub3JtYWxpemVkLCBjb21wdXRlZCB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiLCBcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb21TdHlsZSwgZG9tKXtcblx0XHQvL1x0fFx0XHRkb21TdHlsZS5nZXQoXCJ0aGluZ2VyXCIsIFwib3BhY2l0eVwiKTsgLy8gMSBieSBkZWZhdWx0XG5cdFx0Ly9cdHxcdH0pO1xuXG5cdFx0dmFyIG4gPSBkb20uYnlJZChub2RlKSwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wID0gKG5hbWUgPT0gXCJvcGFjaXR5XCIpO1xuXHRcdGlmKGwgPT0gMiAmJiBvcCl7XG5cdFx0XHRyZXR1cm4gX2dldE9wYWNpdHkobik7XG5cdFx0fVxuXHRcdG5hbWUgPSBfZmxvYXRBbGlhc2VzW25hbWVdID8gXCJjc3NGbG9hdFwiIGluIG4uc3R5bGUgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIiA6IG5hbWU7XG5cdFx0dmFyIHMgPSBzdHlsZS5nZXRDb21wdXRlZFN0eWxlKG4pO1xuXHRcdHJldHVybiAobCA9PSAxKSA/IHMgOiBfdG9TdHlsZVZhbHVlKG4sIG5hbWUsIHNbbmFtZV0gfHwgbi5zdHlsZVtuYW1lXSk7IC8qIENTUzJQcm9wZXJ0aWVzfHxTdHJpbmd8fE51bWJlciAqL1xuXHR9O1xuXG5cdHN0eWxlLnNldCA9IGZ1bmN0aW9uIHNldFN0eWxlKC8qRE9NTm9kZXxTdHJpbmcqLyBub2RlLCAvKlN0cmluZ3xPYmplY3QqLyBuYW1lLCAvKlN0cmluZz8qLyB2YWx1ZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZXRzIHN0eWxlcyBvbiBhIG5vZGUuXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gbm9kZSB0byBzZXQgc3R5bGUgZm9yXG5cdFx0Ly8gbmFtZTogU3RyaW5nfE9iamVjdFxuXHRcdC8vXHRcdHRoZSBzdHlsZSBwcm9wZXJ0eSB0byBzZXQgaW4gRE9NLWFjY2Vzc29yIGZvcm1hdFxuXHRcdC8vXHRcdChcImJvcmRlcldpZHRoXCIsIG5vdCBcImJvcmRlci13aWR0aFwiKSBvciBhbiBvYmplY3Qgd2l0aCBrZXkvdmFsdWVcblx0XHQvL1x0XHRwYWlycyBzdWl0YWJsZSBmb3Igc2V0dGluZyBlYWNoIHByb3BlcnR5LlxuXHRcdC8vIHZhbHVlOiBTdHJpbmc/XG5cdFx0Ly9cdFx0SWYgcGFzc2VkLCBzZXRzIHZhbHVlIG9uIHRoZSBub2RlIGZvciBzdHlsZSwgaGFuZGxpbmdcblx0XHQvL1x0XHRjcm9zcy1icm93c2VyIGNvbmNlcm5zLiAgV2hlbiBzZXR0aW5nIGEgcGl4ZWwgdmFsdWUsXG5cdFx0Ly9cdFx0YmUgc3VyZSB0byBpbmNsdWRlIFwicHhcIiBpbiB0aGUgdmFsdWUuIEZvciBpbnN0YW5jZSwgdG9wOiBcIjIwMHB4XCIuXG5cdFx0Ly9cdFx0T3RoZXJ3aXNlLCBpbiBzb21lIGNhc2VzLCBzb21lIGJyb3dzZXJzIHdpbGwgbm90IGFwcGx5IHRoZSBzdHlsZS5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0UGFzc2luZyBhIG5vZGUsIGEgc3R5bGUgcHJvcGVydHksIGFuZCBhIHZhbHVlIGNoYW5nZXMgdGhlXG5cdFx0Ly9cdFx0Y3VycmVudCBkaXNwbGF5IG9mIHRoZSBub2RlIGFuZCByZXR1cm5zIHRoZSBuZXcgY29tcHV0ZWQgdmFsdWVcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL2RvbS1zdHlsZVwiXSwgZnVuY3Rpb24oZG9tU3R5bGUpe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLnNldChcInRoaW5nZXJcIiwgXCJvcGFjaXR5XCIsIDAuNSk7IC8vID09IDAuNVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0UGFzc2luZyBhIG5vZGUsIGFuIG9iamVjdC1zdHlsZSBzdHlsZSBwcm9wZXJ0eSBzZXRzIGVhY2ggb2YgdGhlIHZhbHVlcyBpbiB0dXJuIGFuZCByZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSBvYmplY3Qgb2YgdGhlIG5vZGU6XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb20tc3R5bGVcIl0sIGZ1bmN0aW9uKGRvbVN0eWxlKXtcblx0XHQvL1x0fFx0XHRkb21TdHlsZS5zZXQoXCJ0aGluZ2VyXCIsIHtcblx0XHQvL1x0fFx0XHRcdFwib3BhY2l0eVwiOiAwLjUsXG5cdFx0Ly9cdHxcdFx0XHRcImJvcmRlclwiOiBcIjNweCBzb2xpZCBibGFja1wiLFxuXHRcdC8vXHR8XHRcdFx0XCJoZWlnaHRcIjogXCIzMDBweFwiXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRXaGVuIHRoZSBDU1Mgc3R5bGUgcHJvcGVydHkgaXMgaHlwaGVuYXRlZCwgdGhlIEphdmFTY3JpcHQgcHJvcGVydHkgaXMgY2FtZWxDYXNlZC5cblx0XHQvL1x0XHRmb250LXNpemUgYmVjb21lcyBmb250U2l6ZSwgYW5kIHNvIG9uLlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCIsIFwiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbVN0eWxlLCBkb20pe1xuXHRcdC8vXHR8XHRcdGRvbVN0eWxlLnNldChcInRoaW5nZXJcIix7XG5cdFx0Ly9cdHxcdFx0XHRmb250U2l6ZTpcIjE0cHRcIixcblx0XHQvL1x0fFx0XHRcdGxldHRlclNwYWNpbmc6XCIxLjJlbVwiXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRkb2pvL05vZGVMaXN0IGltcGxlbWVudHMgLnN0eWxlKCkgdXNpbmcgdGhlIHNhbWUgc3ludGF4LCBvbWl0dGluZyB0aGUgXCJub2RlXCIgcGFyYW1ldGVyLCBjYWxsaW5nXG5cdFx0Ly9cdFx0ZG9qby9kb20tc3R5bGUuZ2V0KCkgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgbGlzdC4gU2VlOiBgZG9qby9xdWVyeWAgYW5kIGBkb2pvL05vZGVMaXN0YFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tLXN0eWxlXCIsIFwiZG9qby9xdWVyeVwiLCBcImRvam8vTm9kZUxpc3QtZG9tXCJdLFxuXHRcdC8vXHR8XHRmdW5jdGlvbihkb21TdHlsZSwgcXVlcnkpe1xuXHRcdC8vXHR8XHRcdHF1ZXJ5KFwiLnNvbWVDbGFzc05hbWVcIikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIik7XG5cdFx0Ly9cdHxcdFx0Ly8gb3Jcblx0XHQvL1x0fFx0XHRxdWVyeShcIiNiYXogPiBkaXZcIikuc3R5bGUoe1xuXHRcdC8vXHR8XHRcdFx0b3BhY2l0eTowLjc1LFxuXHRcdC8vXHR8XHRcdFx0Zm9udFNpemU6XCIxM3B0XCJcblx0XHQvL1x0fFx0XHR9KTtcblx0XHQvL1x0fFx0fSk7XG5cblx0XHR2YXIgbiA9IGRvbS5ieUlkKG5vZGUpLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgb3AgPSAobmFtZSA9PSBcIm9wYWNpdHlcIik7XG5cdFx0bmFtZSA9IF9mbG9hdEFsaWFzZXNbbmFtZV0gPyBcImNzc0Zsb2F0XCIgaW4gbi5zdHlsZSA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiIDogbmFtZTtcblx0XHRpZihsID09IDMpe1xuXHRcdFx0cmV0dXJuIG9wID8gX3NldE9wYWNpdHkobiwgdmFsdWUpIDogbi5zdHlsZVtuYW1lXSA9IHZhbHVlOyAvLyBOdW1iZXJcblx0XHR9XG5cdFx0Zm9yKHZhciB4IGluIG5hbWUpe1xuXHRcdFx0c3R5bGUuc2V0KG5vZGUsIHgsIG5hbWVbeF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShuKTtcblx0fTtcblxuXHRyZXR1cm4gc3R5bGU7XG59KTtcbiIsImRlZmluZShbXCIuL3NuaWZmXCIsIFwiLi9fYmFzZS93aW5kb3dcIiwgXCIuL19iYXNlL2tlcm5lbFwiXSxcblx0XHRmdW5jdGlvbihoYXMsIHdpbiwga2VybmVsKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2RvbVxuXG5cdC8vIEZJWE1FOiBuZWVkIHRvIGFkZCB1bml0IHRlc3RzIGZvciBhbGwgdGhlIHNlbWktcHVibGljIG1ldGhvZHNcblxuXHRpZihoYXMoXCJpZVwiKSA8PSA3KXtcblx0XHR0cnl7XG5cdFx0XHRkb2N1bWVudC5leGVjQ29tbWFuZChcIkJhY2tncm91bmRJbWFnZUNhY2hlXCIsIGZhbHNlLCB0cnVlKTtcblx0XHR9Y2F0Y2goZSl7XG5cdFx0XHQvLyBzYW5lIGJyb3dzZXJzIGRvbid0IGhhdmUgY2FjaGUgXCJpc3N1ZXNcIlxuXHRcdH1cblx0fVxuXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdC8vIERPTSBGdW5jdGlvbnNcblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHQvLyB0aGUgcmVzdWx0IG9iamVjdFxuXHR2YXIgZG9tID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgY29yZSBkb2pvIERPTSBBUEkuXG5cdH07XG5cblx0aWYoaGFzKFwiaWVcIikpe1xuXHRcdGRvbS5ieUlkID0gZnVuY3Rpb24oaWQsIGRvYyl7XG5cdFx0XHRpZih0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdHJldHVybiBpZCB8fCBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIF9kID0gZG9jIHx8IHdpbi5kb2MsIHRlID0gaWQgJiYgX2QuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0Ly8gYXR0cmlidXRlcy5pZC52YWx1ZSBpcyBiZXR0ZXIgdGhhbiBqdXN0IGlkIGluIGNhc2UgdGhlXG5cdFx0XHQvLyB1c2VyIGhhcyBhIG5hbWU9aWQgaW5zaWRlIGEgZm9ybVxuXHRcdFx0aWYodGUgJiYgKHRlLmF0dHJpYnV0ZXMuaWQudmFsdWUgPT0gaWQgfHwgdGUuaWQgPT0gaWQpKXtcblx0XHRcdFx0cmV0dXJuIHRlO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHZhciBlbGVzID0gX2QuYWxsW2lkXTtcblx0XHRcdFx0aWYoIWVsZXMgfHwgZWxlcy5ub2RlTmFtZSl7XG5cdFx0XHRcdFx0ZWxlcyA9IFtlbGVzXTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBtb3JlIHRoYW4gMSwgY2hvb3NlIGZpcnN0IHdpdGggdGhlIGNvcnJlY3QgaWRcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHR3aGlsZSgodGUgPSBlbGVzW2krK10pKXtcblx0XHRcdFx0XHRpZigodGUuYXR0cmlidXRlcyAmJiB0ZS5hdHRyaWJ1dGVzLmlkICYmIHRlLmF0dHJpYnV0ZXMuaWQudmFsdWUgPT0gaWQpIHx8IHRlLmlkID09IGlkKXtcblx0XHRcdFx0XHRcdHJldHVybiB0ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdGRvbS5ieUlkID0gZnVuY3Rpb24oaWQsIGRvYyl7XG5cdFx0XHQvLyBpbmxpbmUnZCB0eXBlIGNoZWNrLlxuXHRcdFx0Ly8gYmUgc3VyZSB0byByZXR1cm4gbnVsbCBwZXIgZG9jdW1lbnRhdGlvbiwgdG8gbWF0Y2ggSUUgYnJhbmNoLlxuXHRcdFx0cmV0dXJuICgodHlwZW9mIGlkID09IFwic3RyaW5nXCIpID8gKGRvYyB8fCB3aW4uZG9jKS5nZXRFbGVtZW50QnlJZChpZCkgOiBpZCkgfHwgbnVsbDsgLy8gRE9NTm9kZVxuXHRcdH07XG5cdH1cblx0Lyo9PT09PVxuXHQgZG9tLmJ5SWQgPSBmdW5jdGlvbihpZCwgZG9jKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgRE9NIG5vZGUgd2l0aCBtYXRjaGluZyBgaWRgIGF0dHJpYnV0ZSBvciBmYWxzeSB2YWx1ZSAoZXg6IG51bGwgb3IgdW5kZWZpbmVkKVxuXHRcdC8vXHRcdGlmIG5vdCBmb3VuZC4gIElmIGBpZGAgaXMgYSBEb21Ob2RlLCB0aGlzIGZ1bmN0aW9uIGlzIGEgbm8tb3AuXG5cdFx0Ly9cblx0XHQvLyBpZDogU3RyaW5nfERPTU5vZGVcblx0XHQvL1x0XHRBIHN0cmluZyB0byBtYXRjaCBhbiBIVE1MIGlkIGF0dHJpYnV0ZSBvciBhIHJlZmVyZW5jZSB0byBhIERPTSBOb2RlXG5cdFx0Ly9cblx0XHQvLyBkb2M6IERvY3VtZW50P1xuXHRcdC8vXHRcdERvY3VtZW50IHRvIHdvcmsgaW4uIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mXG5cdFx0Ly9cdFx0ZG9qby9fYmFzZS93aW5kb3cuZG9jLiAgQ2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcblx0XHQvL1x0XHRub2RlIHJlZmVyZW5jZXMgZnJvbSBvdGhlciBkb2N1bWVudHMuXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdExvb2sgdXAgYSBub2RlIGJ5IElEOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb20pe1xuXHRcdC8vXHR8XHRcdHZhciBuID0gZG9tLmJ5SWQoXCJmb29cIik7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRDaGVjayBpZiBhIG5vZGUgZXhpc3RzLCBhbmQgdXNlIGl0LlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb20pe1xuXHRcdC8vXHR8XHRcdHZhciBuID0gZG9tLmJ5SWQoXCJiYXJcIik7XG5cdFx0Ly9cdHxcdFx0aWYobil7IGRvU3R1ZmYoKSAuLi4gfVxuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0QWxsb3cgc3RyaW5nIG9yIERvbU5vZGUgcmVmZXJlbmNlcyB0byBiZSBwYXNzZWQgdG8gYSBjdXN0b20gZnVuY3Rpb246XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0Ly9cdHxcdFx0dmFyIGZvbyA9IGZ1bmN0aW9uKG5vZGVPcklkKXtcblx0XHQvL1x0fFx0XHRcdG5vZGVPcklkID0gZG9tLmJ5SWQobm9kZU9ySWQpO1xuXHRcdC8vXHR8XHRcdFx0Ly8gLi4uIG1vcmUgc3R1ZmZcblx0XHQvL1x0fFx0XHR9XG5cdFx0Ly9cdHxcdH0pO1xuXHQgfTtcblx0ID09PT09Ki9cblxuXHQvLyBUZXN0IGZvciBET01Ob2RlLmNvbnRhaW5zKCkgbWV0aG9kLCBhdmFpbGFibGUgZXZlcnl3aGVyZSBleGNlcHQgRkY4LVxuXHQvLyBhbmQgSUU4LSwgd2hlcmUgaXQncyBhdmFpbGFibGUgaW4gZ2VuZXJhbCwgYnV0IG5vdCBvbiBkb2N1bWVudCBpdHNlbGYsXG5cdC8vIGFuZCBhbHNvIHByb2JsZW1zIHdoZW4gZWl0aGVyIGFuY2VzdG9yIG9yIG5vZGUgYXJlIHRleHQgbm9kZXMuXG5cblx0dmFyIGRvYyA9IGtlcm5lbC5nbG9iYWxbXCJkb2N1bWVudFwiXSB8fCBudWxsO1xuXHRoYXMuYWRkKFwiZG9tLWNvbnRhaW5zXCIsICEhKGRvYyAmJiBkb2MuY29udGFpbnMpKTtcblx0ZG9tLmlzRGVzY2VuZGFudCA9IGhhcyhcImRvbS1jb250YWluc1wiKSA/XG5cdFx0Ly8gRkY5KywgSUU5Kywgd2Via2l0LCBvcGVyYSwgaU9TLCBBbmRyb2lkLCBFZGdlLCBldGMuXG5cdFx0ZnVuY3Rpb24oLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qRE9NTm9kZXxTdHJpbmcqLyBhbmNlc3Rvcil7XG5cdFx0XHRyZXR1cm4gISEoIChhbmNlc3RvciA9IGRvbS5ieUlkKGFuY2VzdG9yKSkgJiYgYW5jZXN0b3IuY29udGFpbnMoZG9tLmJ5SWQobm9kZSkpICk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oLypET01Ob2RlfFN0cmluZyovIG5vZGUsIC8qRE9NTm9kZXxTdHJpbmcqLyBhbmNlc3Rvcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBkZXNjZW5kYW50IG9mIGFuY2VzdG9yXG5cdFx0XHQvLyBub2RlOiBET01Ob2RlfFN0cmluZ1xuXHRcdFx0Ly9cdFx0c3RyaW5nIGlkIG9yIG5vZGUgcmVmZXJlbmNlIHRvIHRlc3Rcblx0XHRcdC8vIGFuY2VzdG9yOiBET01Ob2RlfFN0cmluZ1xuXHRcdFx0Ly9cdFx0c3RyaW5nIGlkIG9yIG5vZGUgcmVmZXJlbmNlIG9mIHBvdGVudGlhbCBwYXJlbnQgdG8gdGVzdCBhZ2FpbnN0XG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFRlc3QgaXMgbm9kZSBpZD1cImJhclwiIGlzIGEgZGVzY2VuZGFudCBvZiBub2RlIGlkPVwiZm9vXCJcblx0XHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb20pe1xuXHRcdFx0Ly9cdHxcdFx0aWYoZG9tLmlzRGVzY2VuZGFudChcImJhclwiLCBcImZvb1wiKSl7IC4uLiB9XG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdHRyeXtcblx0XHRcdFx0bm9kZSA9IGRvbS5ieUlkKG5vZGUpO1xuXHRcdFx0XHRhbmNlc3RvciA9IGRvbS5ieUlkKGFuY2VzdG9yKTtcblx0XHRcdFx0d2hpbGUobm9kZSl7XG5cdFx0XHRcdFx0aWYobm9kZSA9PSBhbmNlc3Rvcil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gQm9vbGVhblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZSl7IC8qIHNxdWVsY2gsIHJldHVybiBmYWxzZSAqLyB9XG5cdFx0XHRyZXR1cm4gZmFsc2U7IC8vIEJvb2xlYW5cblx0XHR9O1xuXG5cdC8vIFRPRE86IGRvIHdlIG5lZWQgc2V0U2VsZWN0YWJsZSBpbiB0aGUgYmFzZT9cblxuXHQvLyBBZGQgZmVhdHVyZSB0ZXN0IGZvciB1c2VyLXNlbGVjdCBDU1MgcHJvcGVydHlcblx0Ly8gKGN1cnJlbnRseSBrbm93biB0byB3b3JrIGluIGFsbCBidXQgSUUgPCAxMCBhbmQgT3BlcmEpXG5cdC8vIFRPRE86IFRoZSB1c2VyLXNlbGVjdCBDU1MgcHJvcGVydHkgYXMgb2YgTWF5IDIwMTQgaXMgbm8gbG9uZ2VyIHBhcnQgb2Zcblx0Ly8gYW55IENTUyBzcGVjaWZpY2F0aW9uLiBJbiBJRSwgLW1zLXVzZXItc2VsZWN0IGRvZXMgbm90IGRvIHRoZSBzYW1lIHRoaW5nXG5cdC8vIGFzIHRoZSB1bnNlbGVjdGFibGUgYXR0cmlidXRlIG9uIGVsZW1lbnRzOyBuYW1lbHksIGRpaml0IEVkaXRvciBidXR0b25zXG5cdC8vIGRvIG5vdCBwcm9wZXJseSBwcmV2ZW50IHRoZSBjb250ZW50IG9mIHRoZSBlZGl0YWJsZSBjb250ZW50IGZyYW1lIGZyb21cblx0Ly8gdW5ibHVycmluZy4gQXMgYSByZXN1bHQsIHRoZSAtbXMtIHByZWZpeGVkIHZlcnNpb24gaXMgb21pdHRlZCBoZXJlLlxuXHRoYXMuYWRkKFwiY3NzLXVzZXItc2VsZWN0XCIsIGZ1bmN0aW9uKGdsb2JhbCwgZG9jLCBlbGVtZW50KXtcblx0XHQvLyBBdm9pZCBleGNlcHRpb24gd2hlbiBkb20uanMgaXMgbG9hZGVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50c1xuXHRcdGlmKCFlbGVtZW50KXsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdHZhciBwcmVmaXhlcyA9IFtcIktodG1sXCIsIFwiT1wiLCBcIk1velwiLCBcIldlYmtpdFwiXSxcblx0XHRcdGkgPSBwcmVmaXhlcy5sZW5ndGgsXG5cdFx0XHRuYW1lID0gXCJ1c2VyU2VsZWN0XCIsXG5cdFx0XHRwcmVmaXg7XG5cblx0XHQvLyBJdGVyYXRlIHByZWZpeGVzIGZyb20gbW9zdCB0byBsZWFzdCBsaWtlbHlcblx0XHRkb3tcblx0XHRcdGlmKHR5cGVvZiBzdHlsZVtuYW1lXSAhPT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRcdC8vIFN1cHBvcnRlZDsgcmV0dXJuIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0XHR9XG5cdFx0fXdoaWxlKGktLSAmJiAobmFtZSA9IHByZWZpeGVzW2ldICsgXCJVc2VyU2VsZWN0XCIpKTtcblxuXHRcdC8vIE5vdCBzdXBwb3J0ZWQgaWYgd2UgZGlkbid0IHJldHVybiBiZWZvcmUgbm93XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KTtcblxuXHQvKj09PT09XG5cdGRvbS5zZXRTZWxlY3RhYmxlID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0YWJsZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRFbmFibGUgb3IgZGlzYWJsZSBzZWxlY3Rpb24gb24gYSBub2RlXG5cdFx0Ly8gbm9kZTogRE9NTm9kZXxTdHJpbmdcblx0XHQvL1x0XHRpZCBvciByZWZlcmVuY2UgdG8gbm9kZVxuXHRcdC8vIHNlbGVjdGFibGU6IEJvb2xlYW5cblx0XHQvL1x0XHRzdGF0ZSB0byBwdXQgdGhlIG5vZGUgaW4uIGZhbHNlIGluZGljYXRlcyB1bnNlbGVjdGFibGUsIHRydWVcblx0XHQvL1x0XHRhbGxvd3Mgc2VsZWN0aW9uLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0TWFrZSB0aGUgbm9kZSBpZD1cImJhclwiIHVuc2VsZWN0YWJsZVxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vZG9tXCJdLCBmdW5jdGlvbihkb20pe1xuXHRcdC8vXHR8XHRcdGRvbS5zZXRTZWxlY3RhYmxlKFwiYmFyXCIpO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdE1ha2UgdGhlIG5vZGUgaWQ9XCJiYXJcIiBzZWxlY3RhYmxlXG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9kb21cIl0sIGZ1bmN0aW9uKGRvbSl7XG5cdFx0Ly9cdHxcdFx0ZG9tLnNldFNlbGVjdGFibGUoXCJiYXJcIiwgdHJ1ZSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHR9O1xuXHQ9PT09PSovXG5cblx0dmFyIGNzc1VzZXJTZWxlY3QgPSBoYXMoXCJjc3MtdXNlci1zZWxlY3RcIik7XG5cdGRvbS5zZXRTZWxlY3RhYmxlID0gY3NzVXNlclNlbGVjdCA/IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdGFibGUpe1xuXHRcdC8vIGNzcy11c2VyLXNlbGVjdCByZXR1cm5zIGEgKHBvc3NpYmx5IHZlbmRvci1wcmVmaXhlZCkgQ1NTIHByb3BlcnR5IG5hbWVcblx0XHRkb20uYnlJZChub2RlKS5zdHlsZVtjc3NVc2VyU2VsZWN0XSA9IHNlbGVjdGFibGUgPyBcIlwiIDogXCJub25lXCI7XG5cdH0gOiBmdW5jdGlvbihub2RlLCBzZWxlY3RhYmxlKXtcblx0XHRub2RlID0gZG9tLmJ5SWQobm9kZSk7XG5cblx0XHQvLyAoSUUgPCAxMCAvIE9wZXJhKSBGYWxsIGJhY2sgdG8gc2V0dGluZy9yZW1vdmluZyB0aGVcblx0XHQvLyB1bnNlbGVjdGFibGUgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuXG5cdFx0dmFyIG5vZGVzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIiksXG5cdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuXG5cdFx0aWYoc2VsZWN0YWJsZSl7XG5cdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShcInVuc2VsZWN0YWJsZVwiKTtcblx0XHRcdHdoaWxlKGktLSl7XG5cdFx0XHRcdG5vZGVzW2ldLnJlbW92ZUF0dHJpYnV0ZShcInVuc2VsZWN0YWJsZVwiKTtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKFwidW5zZWxlY3RhYmxlXCIsIFwib25cIik7XG5cdFx0XHR3aGlsZShpLS0pe1xuXHRcdFx0XHRub2Rlc1tpXS5zZXRBdHRyaWJ1dGUoXCJ1bnNlbGVjdGFibGVcIiwgXCJvblwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGRvbTtcbn0pO1xuIiwiZGVmaW5lKFsnLi9nbG9iYWwnLCAnLi9oYXMnXSwgZnVuY3Rpb24oZ2xvYmFsLCBoYXMpe1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0cmVhZHlTdGF0ZXMgPSB7ICdsb2FkZWQnOiAxLCAnY29tcGxldGUnOiAxIH0sXG5cdFx0Zml4UmVhZHlTdGF0ZSA9IHR5cGVvZiBkb2MucmVhZHlTdGF0ZSAhPSBcInN0cmluZ1wiLFxuXHRcdHJlYWR5ID0gISFyZWFkeVN0YXRlc1tkb2MucmVhZHlTdGF0ZV0sXG5cdFx0cmVhZHlRID0gW10sXG5cdFx0cmVjdXJzaXZlR3VhcmQ7XG5cblx0ZnVuY3Rpb24gZG9tUmVhZHkoY2FsbGJhY2spe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UGx1Z2luIHRvIGRlbGF5IHJlcXVpcmUoKS9kZWZpbmUoKSBjYWxsYmFjayBmcm9tIGZpcmluZyB1bnRpbCB0aGUgRE9NIGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuXHRcdHJlYWR5US5wdXNoKGNhbGxiYWNrKTtcblx0XHRpZihyZWFkeSl7IHByb2Nlc3NRKCk7IH1cblx0fVxuXHRkb21SZWFkeS5sb2FkID0gZnVuY3Rpb24oaWQsIHJlcSwgbG9hZCl7XG5cdFx0ZG9tUmVhZHkobG9hZCk7XG5cdH07XG5cblx0Ly8gRXhwb3J0IHF1ZXVlIHNvIHRoYXQgcmVhZHkoKSBjYW4gY2hlY2sgaWYgaXQncyBlbXB0eSBvciBub3QuXG5cdGRvbVJlYWR5Ll9RID0gcmVhZHlRO1xuXHRkb21SZWFkeS5fb25RRW1wdHkgPSBmdW5jdGlvbigpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0UHJpdmF0ZSBtZXRob2Qgb3ZlcnJpZGRlbiBieSBkb2pvL3JlYWR5LCB0byBub3RpZnkgd2hlbiBldmVyeXRoaW5nIGluIHRoZVxuXHRcdC8vXHRcdGRvbVJlYWR5IHF1ZXVlIGhhcyBiZWVuIHByb2Nlc3NlZC4gIERvIG5vdCB1c2UgZGlyZWN0bHkuXG5cdFx0Ly9cdFx0V2lsbCBiZSByZW1vdmVkIGluIDIuMCwgYWxvbmcgd2l0aCBkb21SZWFkeS5fUS5cblx0fTtcblxuXHQvLyBGb3IgRkYgPD0gMy41XG5cdGlmKGZpeFJlYWR5U3RhdGUpeyBkb2MucmVhZHlTdGF0ZSA9IFwibG9hZGluZ1wiOyB9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc1EoKXtcblx0XHQvLyBDYWxscyBhbGwgZnVuY3Rpb25zIGluIHRoZSBxdWV1ZSBpbiBvcmRlciwgdW5sZXNzIHByb2Nlc3NRKCkgaXMgYWxyZWFkeSBydW5uaW5nLCBpbiB3aGljaCBjYXNlIGp1c3QgcmV0dXJuXG5cblx0XHRpZihyZWN1cnNpdmVHdWFyZCl7IHJldHVybjsgfVxuXHRcdHJlY3Vyc2l2ZUd1YXJkID0gdHJ1ZTtcblxuXHRcdHdoaWxlKHJlYWR5US5sZW5ndGgpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHQocmVhZHlRLnNoaWZ0KCkpKGRvYyk7XG5cdFx0XHR9Y2F0Y2goZXJyKXtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIsIFwiaW4gZG9tUmVhZHkgY2FsbGJhY2tcIiwgZXJyLnN0YWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZWN1cnNpdmVHdWFyZCA9IGZhbHNlO1xuXG5cdFx0Ly8gTm90aWZpY2F0aW9uIGZvciBkb2pvL3JlYWR5LiAgUmVtb3ZlIGZvciAyLjAuXG5cdFx0Ly8gTm90ZSB0aGF0IHRoaXMgY291bGQgYWRkIG1vcmUgdGFza3MgdG8gdGhlIHJlYWR5IHF1ZXVlLlxuXHRcdGRvbVJlYWR5Ll9vblFFbXB0eSgpO1xuXHR9XG5cblx0aWYoIXJlYWR5KXtcblx0XHR2YXIgdGVzdHMgPSBbXSxcblx0XHRcdGRldGVjdFJlYWR5ID0gZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0ZXZ0ID0gZXZ0IHx8IGdsb2JhbC5ldmVudDtcblx0XHRcdFx0aWYocmVhZHkgfHwgKGV2dC50eXBlID09IFwicmVhZHlzdGF0ZWNoYW5nZVwiICYmICFyZWFkeVN0YXRlc1tkb2MucmVhZHlTdGF0ZV0pKXsgcmV0dXJuOyB9XG5cblx0XHRcdFx0Ly8gRm9yIEZGIDw9IDMuNVxuXHRcdFx0XHRpZihmaXhSZWFkeVN0YXRlKXsgZG9jLnJlYWR5U3RhdGUgPSBcImNvbXBsZXRlXCI7IH1cblxuXHRcdFx0XHRyZWFkeSA9IDE7XG5cdFx0XHRcdHByb2Nlc3NRKCk7XG5cdFx0XHR9LFxuXHRcdFx0b24gPSBmdW5jdGlvbihub2RlLCBldmVudCl7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZGV0ZWN0UmVhZHksIGZhbHNlKTtcblx0XHRcdFx0cmVhZHlRLnB1c2goZnVuY3Rpb24oKXsgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBkZXRlY3RSZWFkeSwgZmFsc2UpOyB9KTtcblx0XHRcdH07XG5cblx0XHRpZighaGFzKFwiZG9tLWFkZGV2ZW50bGlzdGVuZXJcIikpe1xuXHRcdFx0b24gPSBmdW5jdGlvbihub2RlLCBldmVudCl7XG5cdFx0XHRcdGV2ZW50ID0gXCJvblwiICsgZXZlbnQ7XG5cdFx0XHRcdG5vZGUuYXR0YWNoRXZlbnQoZXZlbnQsIGRldGVjdFJlYWR5KTtcblx0XHRcdFx0cmVhZHlRLnB1c2goZnVuY3Rpb24oKXsgbm9kZS5kZXRhY2hFdmVudChldmVudCwgZGV0ZWN0UmVhZHkpOyB9KTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdHRyeXtcblx0XHRcdFx0aWYoZGl2LmRvU2Nyb2xsICYmIGdsb2JhbC5mcmFtZUVsZW1lbnQgPT09IG51bGwpe1xuXHRcdFx0XHRcdC8vIHRoZSBkb1Njcm9sbCB0ZXN0IGlzIG9ubHkgdXNlZnVsIGlmIHdlJ3JlIGluIHRoZSB0b3AtbW9zdCBmcmFtZVxuXHRcdFx0XHRcdHRlc3RzLnB1c2goZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdC8vIERlcml2ZWQgd2l0aCBwZXJtaXNzaW9uIGZyb20gRGllZ28gUGVyaW5pJ3MgSUVDb250ZW50TG9hZGVkXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuXHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRkaXYuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0XHRcdH1jYXRjaChlKXt9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXt9XG5cdFx0fVxuXG5cdFx0b24oZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIik7XG5cdFx0b24oZ2xvYmFsLCBcImxvYWRcIik7XG5cblx0XHRpZihcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYyl7XG5cdFx0XHRvbihkb2MsIFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcblx0XHR9ZWxzZSBpZighZml4UmVhZHlTdGF0ZSl7XG5cdFx0XHQvLyBpZiB0aGUgcmVhZHkgc3RhdGUgcHJvcGVydHkgZXhpc3RzIGFuZCB0aGVyZSdzXG5cdFx0XHQvLyBubyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50LCBwb2xsIGZvciB0aGUgc3RhdGVcblx0XHRcdC8vIHRvIGNoYW5nZVxuXHRcdFx0dGVzdHMucHVzaChmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXR1cm4gcmVhZHlTdGF0ZXNbZG9jLnJlYWR5U3RhdGVdO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYodGVzdHMubGVuZ3RoKXtcblx0XHRcdHZhciBwb2xsZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZihyZWFkeSl7IHJldHVybjsgfVxuXHRcdFx0XHR2YXIgaSA9IHRlc3RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUoaS0tKXtcblx0XHRcdFx0XHRpZih0ZXN0c1tpXSgpKXtcblx0XHRcdFx0XHRcdGRldGVjdFJlYWR5KFwicG9sbGVyXCIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRUaW1lb3V0KHBvbGxlciwgMzApO1xuXHRcdFx0fTtcblx0XHRcdHBvbGxlcigpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb21SZWFkeTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vY3JlYXRlXCJdLCBmdW5jdGlvbihjcmVhdGUpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZXJyb3JzL0NhbmNlbEVycm9yXG5cblx0Lyo9PT09PVxuXHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdERlZmF1bHQgZXJyb3IgaWYgYSBwcm9taXNlIGlzIGNhbmNlbGVkIHdpdGhvdXQgYSByZWFzb24uXG5cdH07XG5cdD09PT09Ki9cblxuXHRyZXR1cm4gY3JlYXRlKFwiQ2FuY2VsRXJyb3JcIiwgbnVsbCwgbnVsbCwgeyBkb2pvVHlwZTogXCJjYW5jZWxcIiwgbG9nOiBmYWxzZSB9KTtcbn0pO1xuIiwiZGVmaW5lKFsnLi9jcmVhdGUnXSwgZnVuY3Rpb24oY3JlYXRlKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2Vycm9ycy9SZXF1ZXN0RXJyb3JcblxuXHQvKj09PT09XG5cdCByZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQgLy8gc3VtbWFyeTpcblx0XHQgLy9cdFx0VE9ET0Ncblx0IH07XG5cdCA9PT09PSovXG5cblx0cmV0dXJuIGNyZWF0ZShcIlJlcXVlc3RFcnJvclwiLCBmdW5jdGlvbihtZXNzYWdlLCByZXNwb25zZSl7XG5cdFx0dGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFsnLi9jcmVhdGUnLCAnLi9SZXF1ZXN0RXJyb3InXSwgZnVuY3Rpb24oY3JlYXRlLCBSZXF1ZXN0RXJyb3Ipe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vZXJyb3JzL1JlcXVlc3RUaW1lb3V0RXJyb3JcblxuXHQvKj09PT09XG5cdCByZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQgLy8gc3VtbWFyeTpcblx0XHQgLy9cdFx0VE9ET0Ncblx0IH07XG5cdCA9PT09PSovXG5cblx0cmV0dXJuIGNyZWF0ZShcIlJlcXVlc3RUaW1lb3V0RXJyb3JcIiwgbnVsbCwgUmVxdWVzdEVycm9yLCB7XG5cdFx0ZG9qb1R5cGU6IFwidGltZW91dFwiXG5cdH0pO1xufSk7XG4iLCJkZWZpbmUoW1wiLi4vX2Jhc2UvbGFuZ1wiXSwgZnVuY3Rpb24obGFuZyl7XG5cdHJldHVybiBmdW5jdGlvbihuYW1lLCBjdG9yLCBiYXNlLCBwcm9wcyl7XG5cdFx0YmFzZSA9IGJhc2UgfHwgRXJyb3I7XG5cblx0XHR2YXIgRXJyb3JDdG9yID0gZnVuY3Rpb24obWVzc2FnZSl7XG5cdFx0XHRpZihiYXNlID09PSBFcnJvcil7XG5cdFx0XHRcdGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKXtcblx0XHRcdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckN0b3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRXJyb3IuY2FsbCgpIG9wZXJhdGVzIG9uIHRoZSByZXR1cm5lZCBlcnJvclxuXHRcdFx0XHQvLyBvYmplY3QgcmF0aGVyIHRoYW4gb3BlcmF0aW5nIG9uIHx0aGlzfFxuXHRcdFx0XHR2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSxcblx0XHRcdFx0XHRwcm9wO1xuXG5cdFx0XHRcdC8vIENvcHkgb3duIHByb3BlcnRpZXMgZnJvbSBlcnIgdG8gfHRoaXN8XG5cdFx0XHRcdGZvcihwcm9wIGluIGVycil7XG5cdFx0XHRcdFx0aWYoZXJyLmhhc093blByb3BlcnR5KHByb3ApKXtcblx0XHRcdFx0XHRcdHRoaXNbcHJvcF0gPSBlcnJbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbWVzc3NhZ2UgaXMgbm9uLWVudW1lcmFibGUgaW4gRVM1XG5cdFx0XHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0XHRcdC8vIHN0YWNrIGlzIG5vbi1lbnVtZXJhYmxlIGluIGF0IGxlYXN0IEZpcmVmb3hcblx0XHRcdFx0dGhpcy5zdGFjayA9IGVyci5zdGFjaztcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRpZihjdG9yKXtcblx0XHRcdFx0Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRFcnJvckN0b3IucHJvdG90eXBlID0gbGFuZy5kZWxlZ2F0ZShiYXNlLnByb3RvdHlwZSwgcHJvcHMpO1xuXHRcdEVycm9yQ3Rvci5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cdFx0RXJyb3JDdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVycm9yQ3RvcjtcblxuXHRcdHJldHVybiBFcnJvckN0b3I7XG5cdH07XG59KTtcbiIsImRlZmluZShmdW5jdGlvbigpe1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGdsb2JhbCBzcGVjIGRlZmluZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgY2FsbGVkICdnbG9iYWwnXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxuICAgICAgICAvLyBgZ2xvYmFsYCBpcyBhbHNvIGRlZmluZWQgaW4gTm9kZUpTXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHdpbmRvdyBpcyBkZWZpbmVkIGluIGJyb3dzZXJzXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzZWxmIGlzIGRlZmluZWQgaW4gV2ViV29ya2Vyc1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59KTtcbiIsImRlZmluZShbXCIuL2dsb2JhbFwiLCBcInJlcXVpcmVcIiwgXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGdsb2JhbCwgcmVxdWlyZSwgbW9kdWxlKXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2hhc1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHREZWZpbmVzIHRoZSBoYXMuanMgQVBJIGFuZCBzZXZlcmFsIGZlYXR1cmUgdGVzdHMgdXNlZCBieSBkb2pvLlxuXHQvLyBkZXNjcmlwdGlvbjpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgZGVmaW5lcyB0aGUgaGFzIEFQSSBhcyBkZXNjcmliZWQgYnkgdGhlIHByb2plY3QgaGFzLmpzIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIGZlYXR1cmVzOlxuXHQvL1xuXHQvL1x0XHQtIHRoZSBoYXMgdGVzdCBjYWNoZSBpcyBleHBvc2VkIGF0IGhhcy5jYWNoZS5cblx0Ly9cdFx0LSB0aGUgbWV0aG9kIGhhcy5hZGQgaW5jbHVkZXMgYSBmb3J0aCBwYXJhbWV0ZXIgdGhhdCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCBleGlzdGluZyB0ZXN0cyBhcmUgcmVwbGFjZWRcblx0Ly9cdFx0LSB0aGUgbG9hZGVyJ3MgaGFzIGNhY2hlIG1heSBiZSBvcHRpb25hbGx5IGNvcGllZCBpbnRvIHRoaXMgbW9kdWxlJ3MgaGFzIGNhaGNlLlxuXHQvL1xuXHQvL1x0XHRUaGlzIG1vZHVsZSBhZG9wdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BoaWdnaW5zNDIvaGFzLmpzOyB0aGFua3MgaGFzLmpzIHRlYW0hXG5cblx0Ly8gdHJ5IHRvIHB1bGwgdGhlIGhhcyBpbXBsZW1lbnRhdGlvbiBmcm9tIHRoZSBsb2FkZXI7IGJvdGggdGhlIGRvam8gbG9hZGVyIGFuZCBiZExvYWQgcHJvdmlkZSBvbmVcblx0Ly8gaWYgdXNpbmcgYSBmb3JlaWduIGxvYWRlciwgdGhlbiB0aGUgaGFzIGNhY2hlIG1heSBiZSBpbml0aWFsaXplZCB2aWEgdGhlIGNvbmZpZyBvYmplY3QgZm9yIHRoaXMgbW9kdWxlXG5cdC8vIFdBUk5JTkc6IGlmIGEgZm9yZWlnbiBsb2FkZXIgZGVmaW5lcyByZXF1aXJlLmhhcyB0byBiZSBzb21ldGhpbmcgb3RoZXIgdGhhbiB0aGUgaGFzLmpzIEFQSSwgdGhlbiB0aGlzIGltcGxlbWVudGF0aW9uIGZhaWxcblx0dmFyIGhhcyA9IHJlcXVpcmUuaGFzIHx8IGZ1bmN0aW9uKCl7fTtcblx0aWYoIWhhcyhcImRvam8taGFzLWFwaVwiKSl7XG5cdFx0dmFyXG5cdFx0XHRpc0Jyb3dzZXIgPVxuXHRcdFx0XHQvLyB0aGUgbW9zdCBmdW5kYW1lbnRhbCBkZWNpc2lvbjogYXJlIHdlIGluIHRoZSBicm93c2VyP1xuXHRcdFx0XHR0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0dHlwZW9mIGxvY2F0aW9uICE9IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0dHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0d2luZG93LmxvY2F0aW9uID09IGxvY2F0aW9uICYmIHdpbmRvdy5kb2N1bWVudCA9PSBkb2N1bWVudCxcblxuXHRcdFx0Ly8gaGFzIEFQSSB2YXJpYWJsZXNcblx0XHRcdGRvYyA9IGlzQnJvd3NlciAmJiBkb2N1bWVudCxcblx0XHRcdGVsZW1lbnQgPSBkb2MgJiYgZG9jLmNyZWF0ZUVsZW1lbnQoXCJEaVZcIiksXG5cdFx0XHRjYWNoZSA9IChtb2R1bGUuY29uZmlnICYmIG1vZHVsZS5jb25maWcoKSkgfHwge307XG5cblx0XHRoYXMgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG5hbWVkIGZlYXR1cmUuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gbmFtZTogU3RyaW5nfEludGVnZXJcblx0XHRcdC8vXHRcdFRoZSBuYW1lIChpZiBhIHN0cmluZykgb3IgaWRlbnRpZmllciAoaWYgYW4gaW50ZWdlcikgb2YgdGhlIGZlYXR1cmUgdG8gdGVzdC5cblx0XHRcdC8vXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmZWF0dXJlIG5hbWVkIGJ5IG5hbWUuIFRoZSBmZWF0dXJlIG11c3QgaGF2ZSBiZWVuXG5cdFx0XHQvL1x0XHRwcmV2aW91c2x5IGFkZGVkIHRvIHRoZSBjYWNoZSBieSBoYXMuYWRkLlxuXG5cdFx0XHRyZXR1cm4gdHlwZW9mIGNhY2hlW25hbWVdID09IFwiZnVuY3Rpb25cIiA/IChjYWNoZVtuYW1lXSA9IGNhY2hlW25hbWVdKGdsb2JhbCwgZG9jLCBlbGVtZW50KSkgOiBjYWNoZVtuYW1lXTsgLy8gQm9vbGVhblxuXHRcdH07XG5cblx0XHRoYXMuY2FjaGUgPSBjYWNoZTtcblxuXHRcdGhhcy5hZGQgPSBmdW5jdGlvbihuYW1lLCB0ZXN0LCBub3csIGZvcmNlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0IFx0UmVnaXN0ZXIgYSBuZXcgZmVhdHVyZSB0ZXN0IGZvciBzb21lIG5hbWVkIGZlYXR1cmUuXG5cdFx0XHQvLyBuYW1lOiBTdHJpbmd8SW50ZWdlclxuXHRcdFx0Ly9cdCBcdFRoZSBuYW1lIChpZiBhIHN0cmluZykgb3IgaWRlbnRpZmllciAoaWYgYW4gaW50ZWdlcikgb2YgdGhlIGZlYXR1cmUgdG8gdGVzdC5cblx0XHRcdC8vIHRlc3Q6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHQgQSB0ZXN0IGZ1bmN0aW9uIHRvIHJlZ2lzdGVyLiBJZiBhIGZ1bmN0aW9uLCBxdWV1ZWQgZm9yIHRlc3RpbmcgdW50aWwgYWN0dWFsbHlcblx0XHRcdC8vXHRcdCBuZWVkZWQuIFRoZSB0ZXN0IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmdcblx0XHRcdC8vXHQgXHR0aGUgcHJlc2VuY2Ugb2YgYSBmZWF0dXJlIG9yIGJ1Zy5cblx0XHRcdC8vIG5vdzogQm9vbGVhbj9cblx0XHRcdC8vXHRcdCBPcHRpb25hbC4gT21pdCBpZiBgdGVzdGAgaXMgbm90IGEgZnVuY3Rpb24uIFByb3ZpZGVzIGEgd2F5IHRvIGltbWVkaWF0ZWx5XG5cdFx0XHQvL1x0XHQgcnVuIHRoZSB0ZXN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0LlxuXHRcdFx0Ly8gZm9yY2U6IEJvb2xlYW4/XG5cdFx0XHQvL1x0IFx0T3B0aW9uYWwuIElmIHRoZSB0ZXN0IGFscmVhZHkgZXhpc3RzIGFuZCBmb3JjZSBpcyB0cnV0aHksIHRoZW4gdGhlIGV4aXN0aW5nXG5cdFx0XHQvL1x0IFx0dGVzdCB3aWxsIGJlIHJlcGxhY2VkOyBvdGhlcndpc2UsIGFkZCBkb2VzIG5vdCByZXBsYWNlIGFuIGV4aXN0aW5nIHRlc3QgKHRoYXRcblx0XHRcdC8vXHQgXHRpcywgYnkgZGVmYXVsdCwgdGhlIGZpcnN0IHRlc3QgYWR2aWNlIHdpbnMpLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEEgcmVkdW5kYW50IHRlc3QsIHRlc3RGbiB3aXRoIGltbWVkaWF0ZSBleGVjdXRpb246XG5cdFx0XHQvL1x0fFx0aGFzLmFkZChcImphdmFzY3JpcHRcIiwgZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH0sIHRydWUpO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRBZ2FpbiB3aXRoIHRoZSByZWR1bmRhbnRuZXNzLiBZb3UgY2FuIGRvIHRoaXMgaW4geW91ciB0ZXN0cywgYnV0IHdlIHNob3VsZFxuXHRcdFx0Ly9cdFx0bm90IGJlIGRvaW5nIHRoaXMgaW4gYW55IGludGVybmFsIGhhcy5qcyB0ZXN0c1xuXHRcdFx0Ly9cdHxcdGhhcy5hZGQoXCJqYXZhc2NyaXB0XCIsIHRydWUpO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRUaHJlZSB0aGluZ3MgYXJlIHBhc3NlZCB0byB0aGUgdGVzdEZ1bmN0aW9uLiBgZ2xvYmFsYCwgYGRvY3VtZW50YCwgYW5kIGEgZ2VuZXJpYyBlbGVtZW50XG5cdFx0XHQvL1x0XHRmcm9tIHdoaWNoIHRvIHdvcmsgeW91ciB0ZXN0IHNob3VsZCB0aGUgbmVlZCBhcmlzZS5cblx0XHRcdC8vXHR8XHRoYXMuYWRkKFwiYnVnLWJ5aWRcIiwgZnVuY3Rpb24oZywgZCwgZWwpe1xuXHRcdFx0Ly9cdHxcdFx0Ly8gZ1x0PT0gZ2xvYmFsLCB0eXBpY2FsbHkgd2luZG93LCB5YWRkYSB5YWRkYVxuXHRcdFx0Ly9cdHxcdFx0Ly8gZFx0PT0gZG9jdW1lbnQgb2JqZWN0XG5cdFx0XHQvL1x0fFx0XHQvLyBlbCA9PSB0aGUgZ2VuZXJpYyBlbGVtZW50LiBhIGBoYXNgIGVsZW1lbnQuXG5cdFx0XHQvL1x0fFx0XHRyZXR1cm4gZmFsc2U7IC8vIGZha2UgdGVzdCwgYnlpZC13aGVuLWZvcm0taGFzLW5hbWUtbWF0Y2hpbmctYW4taWQgaXMgc2xpZ2h0bHkgbG9uZ2VyXG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdCh0eXBlb2YgY2FjaGVbbmFtZV09PVwidW5kZWZpbmVkXCIgfHwgZm9yY2UpICYmIChjYWNoZVtuYW1lXT0gdGVzdCk7XG5cdFx0XHRyZXR1cm4gbm93ICYmIGhhcyhuYW1lKTtcblx0XHR9O1xuXG5cdFx0Ly8gc2luY2Ugd2UncmUgb3BlcmF0aW5nIHVuZGVyIGEgbG9hZGVyIHRoYXQgZG9lc24ndCBwcm92aWRlIGEgaGFzIEFQSSwgd2UgbXVzdCBleHBsaWNpdGx5IGluaXRpYWxpemVcblx0XHQvLyBoYXMgYXMgaXQgd291bGQgaGF2ZSBvdGhlcndpc2UgYmVlbiBpbml0aWFsaXplZCBieSB0aGUgZG9qbyBsb2FkZXI7IHVzZSBoYXMuYWRkIHRvIHRoZSBidWlsZGVyXG5cdFx0Ly8gY2FuIG9wdGltaXplIHRoZXNlIGF3YXkgaWZmIGRlc2lyZWRcblx0XHRoYXMuYWRkKFwiaG9zdC1icm93c2VyXCIsIGlzQnJvd3Nlcik7XG5cdFx0aGFzLmFkZChcImhvc3Qtbm9kZVwiLCAodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJiBwcm9jZXNzLnZlcnNpb25zLnY4KSk7XG5cdFx0aGFzLmFkZChcImhvc3Qtcmhpbm9cIiwgKHR5cGVvZiBsb2FkID09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIFBhY2thZ2VzID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgUGFja2FnZXMgPT0gXCJvYmplY3RcIikpKTtcblx0XHRoYXMuYWRkKFwiZG9tXCIsIGlzQnJvd3Nlcik7XG5cdFx0aGFzLmFkZChcImRvam8tZG9tLXJlYWR5LWFwaVwiLCAxKTtcblx0XHRoYXMuYWRkKFwiZG9qby1zbmlmZlwiLCAxKTtcblx0fVxuXG5cdGlmKGhhcyhcImhvc3QtYnJvd3NlclwiKSl7XG5cdFx0Ly8gQ29tbW9uIGFwcGxpY2F0aW9uIGxldmVsIHRlc3RzXG5cdFx0aGFzLmFkZChcImRvbS1hZGRldmVudGxpc3RlbmVyXCIsICEhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcik7XG5cblx0XHQvLyBEbyB0aGUgZGV2aWNlIGFuZCBicm93c2VyIGhhdmUgdG91Y2ggY2FwYWJpbGl0eT9cblx0XHRoYXMuYWRkKFwidG91Y2hcIiwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudFxuXHRcdFx0fHwgKFwib25wb2ludGVyZG93blwiIGluIGRvY3VtZW50ICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApXG5cdFx0XHR8fCB3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMpO1xuXG5cdFx0Ly8gVG91Y2ggZXZlbnRzIHN1cHBvcnRcblx0XHRoYXMuYWRkKFwidG91Y2gtZXZlbnRzXCIsIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQpO1xuXG5cdFx0Ly8gVGVzdCBpZiBwb2ludGVyIGV2ZW50cyBhcmUgc3VwcG9ydGVkIGFuZCBlbmFibGVkLCB3aXRoIGVpdGhlciBzdGFuZGFyZCBuYW1lcyAoXCJwb2ludGVyZG93blwiIGV0Yy4pIG9yXG5cdFx0Ly8gSUUgc3BlY2lmaWMgbmFtZXMgKFwiTVNQb2ludGVyRG93blwiIGV0Yy4pLiAgVGVzdHMgYXJlIGRlc2lnbmVkIHRvIHdvcmsgb24gZW1iZWRkZWQgQyMgV2ViQnJvd3NlciBDb250cm9sc1xuXHRcdC8vIGluIGFkZGl0aW9uIHRvIElFLCBFZGdlLCBhbmQgZnV0dXJlIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIENocm9tZS5cblx0XHQvLyBOb3RlIHRoYXQgb24gSUUxMSwgaGFzKFwicG9pbnRlci1ldmVudHNcIikgYW5kIGhhcyhcIk1TUG9pbnRlclwiKSBhcmUgYm90aCB0cnVlLlxuXHRcdGhhcy5hZGQoXCJwb2ludGVyLWV2ZW50c1wiLCBcInBvaW50ZXJFbmFibGVkXCIgaW4gd2luZG93Lm5hdmlnYXRvciA/XG5cdFx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgOiBcIlBvaW50ZXJFdmVudFwiIGluIHdpbmRvdyk7XG5cdFx0aGFzLmFkZChcIk1TUG9pbnRlclwiLCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpO1xuXHRcdC8vIFRoZSBcInBvaW50ZXJtb3ZlXCJcIiBldmVudCBpcyBvbmx5IGNvbnRpbnVvdXNseSBlbWl0dGVkIGluIGEgdG91Y2ggZW52aXJvbm1lbnQgaWZcblx0XHQvLyB0aGUgdGFyZ2V0IG5vZGUncyBcInRvdWNoLWFjdGlvblwiXCIgQ1NTIHByb3BlcnR5IGlzIHNldCB0byBcIm5vbmVcIlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN0aGUtdG91Y2gtYWN0aW9uLWNzcy1wcm9wZXJ0eVxuXHRcdGhhcy5hZGQoXCJ0b3VjaC1hY3Rpb25cIiwgaGFzKFwidG91Y2hcIikgJiYgaGFzKFwicG9pbnRlci1ldmVudHNcIikpO1xuXG5cdFx0Ly8gSSBkb24ndCBrbm93IGlmIGFueSBvZiB0aGVzZSB0ZXN0cyBhcmUgcmVhbGx5IGNvcnJlY3QsIGp1c3QgYSByb3VnaCBndWVzc1xuXHRcdGhhcy5hZGQoXCJkZXZpY2Utd2lkdGhcIiwgc2NyZWVuLmF2YWlsV2lkdGggfHwgaW5uZXJXaWR0aCk7XG5cblx0XHQvLyBUZXN0cyBmb3IgRE9NTm9kZS5hdHRyaWJ1dGVzW10gYmVoYXZpb3I6XG5cdFx0Ly9cdCAtIGRvbS1hdHRyaWJ1dGVzLWV4cGxpY2l0IC0gYXR0cmlidXRlc1tdIG9ubHkgbGlzdHMgZXhwbGljaXRseSB1c2VyIHNwZWNpZmllZCBhdHRyaWJ1dGVzXG5cdFx0Ly9cdCAtIGRvbS1hdHRyaWJ1dGVzLXNwZWNpZmllZC1mbGFnIChJRTgpIC0gbmVlZCB0byBjaGVjayBhdHRyLnNwZWNpZmllZCBmbGFnIHRvIHNraXAgYXR0cmlidXRlcyB1c2VyIGRpZG4ndCBzcGVjaWZ5XG5cdFx0Ly9cdCAtIE90aGVyd2lzZSwgaW4gSUU2LTcuIGF0dHJpYnV0ZXNbXSB3aWxsIGxpc3QgaHVuZHJlZHMgb2YgdmFsdWVzLCBzbyBuZWVkIHRvIGRvIG91dGVySFRNTCB0byBnZXQgYXR0cnMgaW5zdGVhZC5cblx0XHR2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO1xuXHRcdGhhcy5hZGQoXCJkb20tYXR0cmlidXRlcy1leHBsaWNpdFwiLCBmb3JtLmF0dHJpYnV0ZXMubGVuZ3RoID09IDApOyAvLyBXM0Ncblx0XHRoYXMuYWRkKFwiZG9tLWF0dHJpYnV0ZXMtc3BlY2lmaWVkLWZsYWdcIiwgZm9ybS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDAgJiYgZm9ybS5hdHRyaWJ1dGVzLmxlbmd0aCA8IDQwKTtcdC8vIElFOFxuXHR9XG5cblx0aGFzLmNsZWFyRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdCBEZWxldGVzIHRoZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudCBwYXNzZWQgdG8gdGVzdCBmdW5jdGlvbnMuXG5cdFx0ZWxlbWVudC5pbm5lckhUTUw9IFwiXCI7XG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH07XG5cblx0aGFzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKGlkLCB0b0Fic01pZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0IFJlc29sdmVzIGlkIGludG8gYSBtb2R1bGUgaWQgYmFzZWQgb24gcG9zc2libHktbmVzdGVkIHRlbmFyeSBleHByZXNzaW9uIHRoYXQgYnJhbmNoZXMgb24gaGFzIGZlYXR1cmUgdGVzdCB2YWx1ZShzKS5cblx0XHQvL1xuXHRcdC8vIHRvQWJzTWlkOiBGdW5jdGlvblxuXHRcdC8vXHQgUmVzb2x2ZXMgYSByZWxhdGl2ZSBtb2R1bGUgaWQgaW50byBhbiBhYnNvbHV0ZSBtb2R1bGUgaWRcblx0XHR2YXJcblx0XHRcdHRva2VucyA9IGlkLm1hdGNoKC9bXFw/Ol18W146XFw/XSovZyksIGkgPSAwLFxuXHRcdFx0Z2V0ID0gZnVuY3Rpb24oc2tpcCl7XG5cdFx0XHRcdHZhciB0ZXJtID0gdG9rZW5zW2krK107XG5cdFx0XHRcdGlmKHRlcm0gPT0gXCI6XCIpe1xuXHRcdFx0XHRcdC8vIGVtcHR5IHN0cmluZyBtb2R1bGUgbmFtZSwgcmVzb2x2ZXMgdG8gMFxuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyBwb3N0Zml4ZWQgd2l0aCBhID8gbWVhbnMgaXQgaXMgYSBmZWF0dXJlIHRvIGJyYW5jaCBvbiwgdGhlIHRlcm0gaXMgdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmVcblx0XHRcdFx0XHRpZih0b2tlbnNbaSsrXSA9PSBcIj9cIil7XG5cdFx0XHRcdFx0XHRpZighc2tpcCAmJiBoYXModGVybSkpe1xuXHRcdFx0XHRcdFx0XHQvLyBtYXRjaGVkIHRoZSBmZWF0dXJlLCBnZXQgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIG9wdGlvbnNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldCgpO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIGRpZCBub3QgbWF0Y2gsIGdldCB0aGUgc2Vjb25kIHZhbHVlLCBwYXNzaW5nIG92ZXIgdGhlIGZpcnN0XG5cdFx0XHRcdFx0XHRcdGdldCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldChza2lwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gYSBtb2R1bGVcblx0XHRcdFx0XHRyZXR1cm4gdGVybSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdGlkID0gZ2V0KCk7XG5cdFx0cmV0dXJuIGlkICYmIHRvQWJzTWlkKGlkKTtcblx0fTtcblxuXHRoYXMubG9hZCA9IGZ1bmN0aW9uKGlkLCBwYXJlbnRSZXF1aXJlLCBsb2FkZWQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0Q29uZGl0aW9uYWwgbG9hZGluZyBvZiBBTUQgbW9kdWxlcyBiYXNlZCBvbiBhIGhhcyBmZWF0dXJlIHRlc3QgdmFsdWUuXG5cdFx0Ly8gaWQ6IFN0cmluZ1xuXHRcdC8vXHRcdEdpdmVzIHRoZSByZXNvbHZlZCBtb2R1bGUgaWQgdG8gbG9hZC5cblx0XHQvLyBwYXJlbnRSZXF1aXJlOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoZSBsb2FkZXIgcmVxdWlyZSBmdW5jdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG1vZHVsZSB0aGF0IGNvbnRhaW5lZCB0aGUgcGx1Z2luIHJlc291cmNlIGluIGl0J3Ncblx0XHQvL1x0XHRkZXBlbmRlbmN5IGxpc3QuXG5cdFx0Ly8gbG9hZGVkOiBGdW5jdGlvblxuXHRcdC8vXHQgQ2FsbGJhY2sgdG8gbG9hZGVyIHRoYXQgY29uc3VtZXMgcmVzdWx0IG9mIHBsdWdpbiBkZW1hbmQuXG5cblx0XHRpZihpZCl7XG5cdFx0XHRwYXJlbnRSZXF1aXJlKFtpZF0sIGxvYWRlZCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRsb2FkZWQoKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGhhcztcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2UvbGFuZ1wiXSwgZnVuY3Rpb24obGFuZyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2lvLXF1ZXJ5XG5cblx0dmFyIGJhY2tzdG9wID0ge307XG5cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgcXVlcnkgc3RyaW5nIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuXG5cdFx0b2JqZWN0VG9RdWVyeTogZnVuY3Rpb24gb2JqZWN0VG9RdWVyeSgvKk9iamVjdCovIG1hcCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0dGFrZXMgYSBuYW1lL3ZhbHVlIG1hcHBpbmcgb2JqZWN0IGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZ1xuXHRcdFx0Ly9cdFx0YSBVUkwtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoYXQgb2JqZWN0LlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdHRoaXMgb2JqZWN0OlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHR7XG5cdFx0XHQvL1x0fFx0XHRibGFoOiBcImJsYWhcIixcblx0XHRcdC8vXHR8XHRcdG11bHRpOiBbXG5cdFx0XHQvL1x0fFx0XHRcdFwidGh1ZFwiLFxuXHRcdFx0Ly9cdHxcdFx0XHRcInRob25rXCJcblx0XHRcdC8vXHR8XHRcdF1cblx0XHRcdC8vXHR8XHR9O1xuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHlpZWxkcyB0aGUgZm9sbG93aW5nIHF1ZXJ5IHN0cmluZzpcblx0XHRcdC8vXG5cdFx0XHQvL1x0fFx0XCJibGFoPWJsYWgmbXVsdGk9dGh1ZCZtdWx0aT10aG9ua1wiXG5cblx0XHRcdC8vIEZJWE1FOiBuZWVkIHRvIGltcGxlbWVudCBlbmNvZGVBc2NpaSEhXG5cdFx0XHR2YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50LCBwYWlycyA9IFtdO1xuXHRcdFx0Zm9yKHZhciBuYW1lIGluIG1hcCl7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hcFtuYW1lXTtcblx0XHRcdFx0aWYodmFsdWUgIT0gYmFja3N0b3BbbmFtZV0pe1xuXHRcdFx0XHRcdHZhciBhc3NpZ24gPSBlbmMobmFtZSkgKyBcIj1cIjtcblx0XHRcdFx0XHRpZihsYW5nLmlzQXJyYXkodmFsdWUpKXtcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRcdFx0XHRwYWlycy5wdXNoKGFzc2lnbiArIGVuYyh2YWx1ZVtpXSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cGFpcnMucHVzaChhc3NpZ24gKyBlbmModmFsdWUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwYWlycy5qb2luKFwiJlwiKTsgLy8gU3RyaW5nXG5cdFx0fSxcblxuXHRcdHF1ZXJ5VG9PYmplY3Q6IGZ1bmN0aW9uIHF1ZXJ5VG9PYmplY3QoLypTdHJpbmcqLyBzdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENyZWF0ZSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZGUtc2VyaWFsaXplZCBxdWVyeSBzZWN0aW9uIG9mIGFcblx0XHRcdC8vXHRcdFVSTC4gUXVlcnkga2V5cyB3aXRoIG11bHRpcGxlIHZhbHVlcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFRoaXMgc3RyaW5nOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHRcdFwiZm9vPWJhciZmb289YmF6JnRoaW5nZXI9JTIwc3BhY2VzJTIwPWJsYWgmem9uaz1ibGFyZyZcIlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdHJlc3VsdHMgaW4gdGhpcyBvYmplY3Qgc3RydWN0dXJlOlxuXHRcdFx0Ly9cblx0XHRcdC8vXHR8XHRcdHtcblx0XHRcdC8vXHR8XHRcdFx0Zm9vOiBbIFwiYmFyXCIsIFwiYmF6XCIgXSxcblx0XHRcdC8vXHR8XHRcdFx0dGhpbmdlcjogXCIgc3BhY2VzID1ibGFoXCIsXG5cdFx0XHQvL1x0fFx0XHRcdHpvbms6IFwiYmxhcmdcIlxuXHRcdFx0Ly9cdHxcdFx0fVxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdE5vdGUgdGhhdCBzcGFjZXMgYW5kIG90aGVyIHVybGVuY29kZWQgZW50aXRpZXMgYXJlIGNvcnJlY3RseVxuXHRcdFx0Ly9cdFx0aGFuZGxlZC5cblxuICAgICAgICBcdHZhciBkZWMgPSBkZWNvZGVVUklDb21wb25lbnQsIHFwID0gc3RyLnNwbGl0KFwiJlwiKSwgcmV0ID0ge30sIG5hbWUsIHZhbDtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBxcC5sZW5ndGgsIGl0ZW07IGkgPCBsOyArK2kpe1xuXHRcdFx0XHRpdGVtID0gcXBbaV07XG5cdFx0XHRcdGlmKGl0ZW0ubGVuZ3RoKXtcblx0XHRcdFx0XHR2YXIgcyA9IGl0ZW0uaW5kZXhPZihcIj1cIik7XG5cdFx0XHRcdFx0aWYocyA8IDApe1xuXHRcdFx0XHRcdFx0bmFtZSA9IGRlYyhpdGVtKTtcblx0XHRcdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRuYW1lID0gZGVjKGl0ZW0uc2xpY2UoMCwgcykpO1xuXHRcdFx0XHRcdFx0dmFsID0gZGVjKGl0ZW0uc2xpY2UocyArIDEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodHlwZW9mIHJldFtuYW1lXSA9PSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0XHRcdFx0cmV0W25hbWVdID0gW3JldFtuYW1lXV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYobGFuZy5pc0FycmF5KHJldFtuYW1lXSkpe1xuXHRcdFx0XHRcdFx0cmV0W25hbWVdLnB1c2godmFsKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHJldFtuYW1lXSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7IC8vIE9iamVjdFxuXHRcdH1cblx0fTtcbn0pOyIsImRlZmluZShbXCIuL2hhc1wiXSwgZnVuY3Rpb24oaGFzKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBoYXNKU09OID0gdHlwZW9mIEpTT04gIT0gXCJ1bmRlZmluZWRcIjtcblx0aGFzLmFkZChcImpzb24tcGFyc2VcIiwgaGFzSlNPTik7IC8vIGFsbCB0aGUgcGFyc2VycyB3b3JrIGZpbmVcblx0XHQvLyBGaXJlZm94IDMuNS9HZWNrbyAxLjkgZmFpbHMgdG8gdXNlIHJlcGxhY2VyIGluIHN0cmluZ2lmeSBwcm9wZXJseSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDkxODRcblx0aGFzLmFkZChcImpzb24tc3RyaW5naWZ5XCIsIGhhc0pTT04gJiYgSlNPTi5zdHJpbmdpZnkoe2E6MH0sIGZ1bmN0aW9uKGssdil7cmV0dXJuIHZ8fDE7fSkgPT0gJ3tcImFcIjoxfScpO1xuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEZ1bmN0aW9ucyB0byBwYXJzZSBhbmQgc2VyaWFsaXplIEpTT05cblxuXHRcdHBhcnNlOiBmdW5jdGlvbihzdHIsIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UGFyc2VzIGEgW0pTT05dKGh0dHA6Ly9qc29uLm9yZykgc3RyaW5nIHRvIHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0LlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGZvbGxvd3MgW25hdGl2ZSBKU09OIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSlNPTilcblx0XHRcdC8vXHRcdFRocm93cyBmb3IgaW52YWxpZCBKU09OIHN0cmluZ3MuIFRoaXMgZGVsZWdhdGVzIHRvIGV2YWwoKSBpZiBuYXRpdmUgSlNPTlxuXHRcdFx0Ly9cdFx0c3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBCeSBkZWZhdWx0IHRoaXMgd2lsbCBldmFsdWF0ZSBhbnkgdmFsaWQgSlMgZXhwcmVzc2lvbi5cblx0XHRcdC8vXHRcdFdpdGggdGhlIHN0cmljdCBwYXJhbWV0ZXIgc2V0IHRvIHRydWUsIHRoZSBwYXJzZXIgd2lsbCBlbnN1cmUgdGhhdCBvbmx5XG5cdFx0XHQvL1x0XHR2YWxpZCBKU09OIHN0cmluZ3MgYXJlIHBhcnNlZCAob3RoZXJ3aXNlIHRocm93aW5nIGFuIGVycm9yKS4gV2l0aG91dCB0aGUgc3RyaWN0XG5cdFx0XHQvL1x0XHRwYXJhbWV0ZXIsIHRoZSBjb250ZW50IHBhc3NlZCB0byB0aGlzIG1ldGhvZCBtdXN0IGNvbWVcblx0XHRcdC8vXHRcdGZyb20gYSB0cnVzdGVkIHNvdXJjZS5cblx0XHRcdC8vIHN0cjpcblx0XHRcdC8vXHRcdGEgc3RyaW5nIGxpdGVyYWwgb2YgYSBKU09OIGl0ZW0sIGZvciBpbnN0YW5jZTpcblx0XHRcdC8vXHRcdGAneyBcImZvb1wiOiBbIFwiYmFyXCIsIDEsIHsgXCJiYXpcIjogXCJ0aHVkXCIgfSBdIH0nYFxuXHRcdFx0Ly8gc3RyaWN0OlxuXHRcdFx0Ly9cdFx0V2hlbiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIGVuc3VyZSB0aGF0IG9ubHkgdmFsaWQsIHNlY3VyZSBKU09OIGlzIGV2ZXIgcGFyc2VkLlxuXHRcdFx0Ly9cdFx0TWFrZSBzdXJlIHRoaXMgaXMgc2V0IHRvIHRydWUgZm9yIHVudHJ1c3RlZCBjb250ZW50LiBOb3RlIHRoYXQgb24gYnJvd3NlcnMvZW5naW5lc1xuXHRcdFx0Ly9cdFx0d2l0aG91dCBuYXRpdmUgSlNPTiBzdXBwb3J0LCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHJ1biBzbG93ZXIuXG5cdFx0fSxcblx0XHRzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbHVlLCByZXBsYWNlciwgc3BhY2VyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgW0pTT05dKGh0dHA6Ly9qc29uLm9yZykgc2VyaWFsaXphdGlvbiBvZiBhbiBvYmplY3QuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBbSlNPTl0oaHR0cDovL2pzb24ub3JnKSBzZXJpYWxpemF0aW9uIG9mIGFuIG9iamVjdC5cblx0XHRcdC8vXHRcdFRoaXMgZnVuY3Rpb24gZm9sbG93cyBbbmF0aXZlIEpTT04gQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KU09OKVxuXHRcdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgZG9lc24ndCBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uLCBzbyBkb24ndCBkbyB0aGF0IVxuXHRcdFx0Ly8gdmFsdWU6XG5cdFx0XHQvL1x0XHRBIHZhbHVlIHRvIGJlIHNlcmlhbGl6ZWQuXG5cdFx0XHQvLyByZXBsYWNlcjpcblx0XHRcdC8vXHRcdEEgcmVwbGFjZXIgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggdmFsdWUgYW5kIGNhbiByZXR1cm4gYSByZXBsYWNlbWVudFxuXHRcdFx0Ly8gc3BhY2VyOlxuXHRcdFx0Ly9cdFx0QSBzcGFjZXIgc3RyaW5nIHRvIGJlIHVzZWQgZm9yIHByZXR0eSBwcmludGluZyBvZiBKU09OXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFx0c2ltcGxlIHNlcmlhbGl6YXRpb24gb2YgYSB0cml2aWFsIG9iamVjdFxuXHRcdFx0Ly9cdHxcdGRlZmluZShbXCJkb2pvL2pzb25cIl0sIGZ1bmN0aW9uKEpTT04pe1xuXHRcdFx0Ly8gXHR8XHRcdHZhciBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoeyBob3dkeTogXCJzdHJhbmdlciFcIiwgaXNTdHJhbmdlOiB0cnVlIH0pO1xuXHRcdFx0Ly9cdHxcdFx0ZG9oLmlzKCd7XCJob3dkeVwiOlwic3RyYW5nZXIhXCIsXCJpc1N0cmFuZ2VcIjp0cnVlfScsIGpzb25TdHIpO1xuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdGlmKGhhcyhcImpzb24tc3RyaW5naWZ5XCIpKXtcblx0XHRyZXR1cm4gSlNPTjtcblx0fWVsc2V7XG5cdFx0dmFyIGVzY2FwZVN0cmluZyA9IGZ1bmN0aW9uKC8qU3RyaW5nKi9zdHIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZHMgZXNjYXBlIHNlcXVlbmNlcyBmb3Igbm9uLXZpc3VhbCBjaGFyYWN0ZXJzLCBkb3VibGUgcXVvdGUgYW5kXG5cdFx0XHQvL1x0XHRiYWNrc2xhc2ggYW5kIHN1cnJvdW5kcyB3aXRoIGRvdWJsZSBxdW90ZXMgdG8gZm9ybSBhIHZhbGlkIHN0cmluZ1xuXHRcdFx0Ly9cdFx0bGl0ZXJhbC5cblx0XHRcdHJldHVybiAoJ1wiJyArIHN0ci5yZXBsYWNlKC8oW1wiXFxcXF0pL2csICdcXFxcJDEnKSArICdcIicpLlxuXHRcdFx0XHRyZXBsYWNlKC9bXFxmXS9nLCBcIlxcXFxmXCIpLnJlcGxhY2UoL1tcXGJdL2csIFwiXFxcXGJcIikucmVwbGFjZSgvW1xcbl0vZywgXCJcXFxcblwiKS5cblx0XHRcdFx0cmVwbGFjZSgvW1xcdF0vZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9bXFxyXS9nLCBcIlxcXFxyXCIpOyAvLyBzdHJpbmdcblx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRwYXJzZTogaGFzKFwianNvbi1wYXJzZVwiKSA/IEpTT04ucGFyc2UgOiBmdW5jdGlvbihzdHIsIHN0cmljdCl7XG5cdFx0XHRcdGlmKHN0cmljdCAmJiAhL14oW1xcc1xcW1xce10qKD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8LT9cXGRbXFxkXFwuXSooPzpbRWVdWystXT9cXGQrKT98bnVsbHx0cnVlfGZhbHNlfClbXFxzXFxdXFx9XSooPzosfDp8JCkpKyQvLnRlc3Qoc3RyKSl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXJzIGluIEpTT05cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGV2YWwoJygnICsgc3RyICsgJyknKTtcblx0XHRcdH0sXG5cdFx0XHRzdHJpbmdpZnk6IGZ1bmN0aW9uKHZhbHVlLCByZXBsYWNlciwgc3BhY2VyKXtcblx0XHRcdFx0dmFyIHVuZGVmO1xuXHRcdFx0XHRpZih0eXBlb2YgcmVwbGFjZXIgPT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdFx0c3BhY2VyID0gcmVwbGFjZXI7XG5cdFx0XHRcdFx0cmVwbGFjZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgaW5kZW50LCBrZXkpe1xuXHRcdFx0XHRcdGlmKHJlcGxhY2VyKXtcblx0XHRcdFx0XHRcdGl0ID0gcmVwbGFjZXIoa2V5LCBpdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWwsIG9ianR5cGUgPSB0eXBlb2YgaXQ7XG5cdFx0XHRcdFx0aWYob2JqdHlwZSA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0XHRcdHJldHVybiBpc0Zpbml0ZShpdCkgPyBpdCArIFwiXCIgOiBcIm51bGxcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYob2JqdHlwZSA9PSBcImJvb2xlYW5cIil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXQgKyBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdCA9PT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJudWxsXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHR5cGVvZiBpdCA9PSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdHJldHVybiBlc2NhcGVTdHJpbmcoaXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihvYmp0eXBlID09IFwiZnVuY3Rpb25cIiB8fCBvYmp0eXBlID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmOyAvLyB1bmRlZmluZWRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc2hvcnQtY2lyY3VpdCBmb3Igb2JqZWN0cyB0aGF0IHN1cHBvcnQgXCJqc29uXCIgc2VyaWFsaXphdGlvblxuXHRcdFx0XHRcdC8vIGlmIHRoZXkgcmV0dXJuIFwic2VsZlwiIHRoZW4ganVzdCBwYXNzLXRocm91Z2guLi5cblx0XHRcdFx0XHRpZih0eXBlb2YgaXQudG9KU09OID09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KGl0LnRvSlNPTihrZXkpLCBpbmRlbnQsIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0IGluc3RhbmNlb2YgRGF0ZSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ1wie0Z1bGxZZWFyfS17TW9udGgrfS17RGF0ZX1Ue0hvdXJzfTp7TWludXRlc306e1NlY29uZHN9WlwiJy5yZXBsYWNlKC9cXHsoXFx3KykoXFwrKT9cXH0vZywgZnVuY3Rpb24odCwgcHJvcCwgcGx1cyl7XG5cdFx0XHRcdFx0XHRcdHZhciBudW0gPSBpdFtcImdldFVUQ1wiICsgcHJvcF0oKSArIChwbHVzID8gMSA6IDApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVtIDwgMTAgPyBcIjBcIiArIG51bSA6IG51bTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdC52YWx1ZU9mKCkgIT09IGl0KXtcblx0XHRcdFx0XHRcdC8vIHByaW1pdGl2ZSB3cmFwcGVyLCB0cnkgYWdhaW4gdW53cmFwcGVkOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShpdC52YWx1ZU9mKCksIGluZGVudCwga2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIG5leHRJbmRlbnQ9IHNwYWNlciA/IChpbmRlbnQgKyBzcGFjZXIpIDogXCJcIjtcblx0XHRcdFx0XHQvKiB3ZSB1c2VkIHRvIHRlc3QgZm9yIERPTSBub2RlcyBhbmQgdGhyb3csIGJ1dCBGRiBzZXJpYWxpemVzIHRoZW0gYXMge30sIHNvIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3kgaXMgcHJvYmFibHkgbm90IGVmZmljaWVudGx5IGF0dGFpbmFibGUgKi8gXG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBzZXAgPSBzcGFjZXIgPyBcIiBcIiA6IFwiXCI7XG5cdFx0XHRcdFx0dmFyIG5ld0xpbmUgPSBzcGFjZXIgPyBcIlxcblwiIDogXCJcIjtcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gYXJyYXlcblx0XHRcdFx0XHRpZihpdCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRcdHZhciBpdGwgPSBpdC5sZW5ndGgsIHJlcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yKGtleSA9IDA7IGtleSA8IGl0bDsga2V5Kyspe1xuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gaXRba2V5XTtcblx0XHRcdFx0XHRcdFx0dmFsID0gc3RyaW5naWZ5KG9iaiwgbmV4dEluZGVudCwga2V5KTtcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIHZhbCAhPSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSBcIm51bGxcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXMucHVzaChuZXdMaW5lICsgbmV4dEluZGVudCArIHZhbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJbXCIgKyByZXMuam9pbihcIixcIikgKyBuZXdMaW5lICsgaW5kZW50ICsgXCJdXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGdlbmVyaWMgb2JqZWN0IGNvZGUgcGF0aFxuXHRcdFx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdFx0XHRmb3Ioa2V5IGluIGl0KXtcblx0XHRcdFx0XHRcdHZhciBrZXlTdHI7XG5cdFx0XHRcdFx0XHRpZihpdC5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGtleSA9PSBcIm51bWJlclwiKXtcblx0XHRcdFx0XHRcdFx0XHRrZXlTdHIgPSAnXCInICsga2V5ICsgJ1wiJztcblx0XHRcdFx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiKXtcblx0XHRcdFx0XHRcdFx0XHRrZXlTdHIgPSBlc2NhcGVTdHJpbmcoa2V5KTtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBub24tc3RyaW5nIG9yIG51bWJlciBrZXlzXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsID0gc3RyaW5naWZ5KGl0W2tleV0sIG5leHRJbmRlbnQsIGtleSk7XG5cdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiB2YWwgIT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBub24tc2VyaWFsaXphYmxlIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBtb3N0IG5vbi1JRSBicm93c2VycyBkb24ndCBnZXQgaW4gdGhpcyBicmFuY2ggXG5cdFx0XHRcdFx0XHRcdC8vICh0aGV5IGhhdmUgbmF0aXZlIEpTT04pLCBzbyBwdXNoIGlzIGRlZmluaXRlbHkgdGhlIHdheSB0b1xuXHRcdFx0XHRcdFx0XHRvdXRwdXQucHVzaChuZXdMaW5lICsgbmV4dEluZGVudCArIGtleVN0ciArIFwiOlwiICsgc2VwICsgdmFsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFwie1wiICsgb3V0cHV0LmpvaW4oXCIsXCIpICsgbmV3TGluZSArIGluZGVudCArIFwifVwiOyAvLyBTdHJpbmdcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbHVlLCBcIlwiLCBcIlwiKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcbiIsImRlZmluZShbXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vc25pZmZcIl0sIGZ1bmN0aW9uKGRvam8sIGhhcyl7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL2tleXNcblxuXHRyZXR1cm4gZG9qby5rZXlzID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RGVmaW5pdGlvbnMgZm9yIGNvbW1vbiBrZXkgdmFsdWVzLiAgQ2xpZW50IGNvZGUgc2hvdWxkIHRlc3Qga2V5Q29kZSBhZ2FpbnN0IHRoZXNlIG5hbWVkIGNvbnN0YW50cyxcblx0XHQvL1x0XHRhcyB0aGUgYWN0dWFsIGNvZGVzIGNhbiB2YXJ5IGJ5IGJyb3dzZXIuXG5cblx0XHRCQUNLU1BBQ0U6IDgsXG5cdFx0VEFCOiA5LFxuXHRcdENMRUFSOiAxMixcblx0XHRFTlRFUjogMTMsXG5cdFx0U0hJRlQ6IDE2LFxuXHRcdENUUkw6IDE3LFxuXHRcdEFMVDogMTgsXG5cdFx0TUVUQTogaGFzKFwid2Via2l0XCIpID8gOTEgOiAyMjQsXHRcdC8vIHRoZSBhcHBsZSBrZXkgb24gbWFjc1xuXHRcdFBBVVNFOiAxOSxcblx0XHRDQVBTX0xPQ0s6IDIwLFxuXHRcdEVTQ0FQRTogMjcsXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFBBR0VfVVA6IDMzLFxuXHRcdFBBR0VfRE9XTjogMzQsXG5cdFx0RU5EOiAzNSxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUX0FSUk9XOiAzNyxcblx0XHRVUF9BUlJPVzogMzgsXG5cdFx0UklHSFRfQVJST1c6IDM5LFxuXHRcdERPV05fQVJST1c6IDQwLFxuXHRcdElOU0VSVDogNDUsXG5cdFx0REVMRVRFOiA0Nixcblx0XHRIRUxQOiA0Nyxcblx0XHRMRUZUX1dJTkRPVzogOTEsXG5cdFx0UklHSFRfV0lORE9XOiA5Mixcblx0XHRTRUxFQ1Q6IDkzLFxuXHRcdE5VTVBBRF8wOiA5Nixcblx0XHROVU1QQURfMTogOTcsXG5cdFx0TlVNUEFEXzI6IDk4LFxuXHRcdE5VTVBBRF8zOiA5OSxcblx0XHROVU1QQURfNDogMTAwLFxuXHRcdE5VTVBBRF81OiAxMDEsXG5cdFx0TlVNUEFEXzY6IDEwMixcblx0XHROVU1QQURfNzogMTAzLFxuXHRcdE5VTVBBRF84OiAxMDQsXG5cdFx0TlVNUEFEXzk6IDEwNSxcblx0XHROVU1QQURfTVVMVElQTFk6IDEwNixcblx0XHROVU1QQURfUExVUzogMTA3LFxuXHRcdE5VTVBBRF9FTlRFUjogMTA4LFxuXHRcdE5VTVBBRF9NSU5VUzogMTA5LFxuXHRcdE5VTVBBRF9QRVJJT0Q6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0RjE6IDExMixcblx0XHRGMjogMTEzLFxuXHRcdEYzOiAxMTQsXG5cdFx0RjQ6IDExNSxcblx0XHRGNTogMTE2LFxuXHRcdEY2OiAxMTcsXG5cdFx0Rjc6IDExOCxcblx0XHRGODogMTE5LFxuXHRcdEY5OiAxMjAsXG5cdFx0RjEwOiAxMjEsXG5cdFx0RjExOiAxMjIsXG5cdFx0RjEyOiAxMjMsXG5cdFx0RjEzOiAxMjQsXG5cdFx0RjE0OiAxMjUsXG5cdFx0RjE1OiAxMjYsXG5cdFx0TlVNX0xPQ0s6IDE0NCxcblx0XHRTQ1JPTExfTE9DSzogMTQ1LFxuXHRcdFVQX0RQQUQ6IDE3NSxcblx0XHRET1dOX0RQQUQ6IDE3Nixcblx0XHRMRUZUX0RQQUQ6IDE3Nyxcblx0XHRSSUdIVF9EUEFEOiAxNzgsXG5cdFx0Ly8gdmlydHVhbCBrZXkgbWFwcGluZ1xuXHRcdGNvcHlLZXk6IGhhcyhcIm1hY1wiKSAmJiAhaGFzKFwiYWlyXCIpID8gKGhhcyhcInNhZmFyaVwiKSA/IDkxIDogMjI0ICkgOiAxN1xuXHR9O1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL29uXCIsIFwiLi9oYXNcIiwgXCIuL2RvbVwiLCBcIi4vX2Jhc2Uvd2luZG93XCJdLCBmdW5jdGlvbihkb2pvLCBvbiwgaGFzLCBkb20sIHdpbil7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL21vdXNlXG5cbiAgICBoYXMuYWRkKFwiZG9tLXF1aXJrc1wiLCB3aW4uZG9jICYmIHdpbi5kb2MuY29tcGF0TW9kZSA9PSBcIkJhY2tDb21wYXRcIik7XG5cdGhhcy5hZGQoXCJldmVudHMtbW91c2VlbnRlclwiLCB3aW4uZG9jICYmIFwib25tb3VzZWVudGVyXCIgaW4gd2luLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcblx0aGFzLmFkZChcImV2ZW50cy1tb3VzZXdoZWVsXCIsIHdpbi5kb2MgJiYgJ29ubW91c2V3aGVlbCcgaW4gd2luLmRvYyk7XG5cblx0dmFyIG1vdXNlQnV0dG9ucztcblx0aWYoKGhhcyhcImRvbS1xdWlya3NcIikgJiYgaGFzKFwiaWVcIikpIHx8ICFoYXMoXCJkb20tYWRkZXZlbnRsaXN0ZW5lclwiKSl7XG5cdFx0bW91c2VCdXR0b25zID0ge1xuXHRcdFx0TEVGVDogICAxLFxuXHRcdFx0TUlERExFOiA0LFxuXHRcdFx0UklHSFQ6ICAyLFxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXHRcdFx0aXNCdXR0b246IGZ1bmN0aW9uKGUsIGJ1dHRvbil7IHJldHVybiBlLmJ1dHRvbiAmIGJ1dHRvbjsgfSxcblx0XHRcdGlzTGVmdDogICBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgMTsgfSxcblx0XHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgNDsgfSxcblx0XHRcdGlzUmlnaHQ6ICBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uICYgMjsgfVxuXHRcdH07XG5cdH1lbHNle1xuXHRcdG1vdXNlQnV0dG9ucyA9IHtcblx0XHRcdExFRlQ6ICAgMCxcblx0XHRcdE1JRERMRTogMSxcblx0XHRcdFJJR0hUOiAgMixcblx0XHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0XHRcdGlzQnV0dG9uOiBmdW5jdGlvbihlLCBidXR0b24peyByZXR1cm4gZS5idXR0b24gPT0gYnV0dG9uOyB9LFxuXHRcdFx0aXNMZWZ0OiAgIGZ1bmN0aW9uKGUpeyByZXR1cm4gZS5idXR0b24gPT0gMDsgfSxcblx0XHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXsgcmV0dXJuIGUuYnV0dG9uID09IDE7IH0sXG5cdFx0XHRpc1JpZ2h0OiAgZnVuY3Rpb24oZSl7IHJldHVybiBlLmJ1dHRvbiA9PSAyOyB9XG5cdFx0fTtcblx0fVxuXHRkb2pvLm1vdXNlQnV0dG9ucyA9IG1vdXNlQnV0dG9ucztcblxuLyo9PT09PVxuXHRkb2pvLm1vdXNlQnV0dG9ucyA9IHtcblx0XHQvLyBMRUZUOiBOdW1iZXJcblx0XHQvL1x0XHROdW1lcmljIHZhbHVlIG9mIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBmb3IgdGhlIHBsYXRmb3JtLlxuXHRcdExFRlQ6ICAgMCxcblx0XHQvLyBNSURETEU6IE51bWJlclxuXHRcdC8vXHRcdE51bWVyaWMgdmFsdWUgb2YgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gZm9yIHRoZSBwbGF0Zm9ybS5cblx0XHRNSURETEU6IDEsXG5cdFx0Ly8gUklHSFQ6IE51bWJlclxuXHRcdC8vXHRcdE51bWVyaWMgdmFsdWUgb2YgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBmb3IgdGhlIHBsYXRmb3JtLlxuXHRcdFJJR0hUOiAgMixcblxuXHRcdGlzQnV0dG9uOiBmdW5jdGlvbihlLCBidXR0b24pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyBhbiBldmVudCBvYmplY3QgZm9yIGEgcHJlc3NlZCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0Ly8gYnV0dG9uOiBOdW1iZXJcblx0XHRcdC8vXHRcdFRoZSBidXR0b24gdmFsdWUgKGV4YW1wbGU6IGRvam8ubW91c2VCdXR0b24uTEVGVClcblx0XHRcdHJldHVybiBlLmJ1dHRvbiA9PSBidXR0b247IC8vIEJvb2xlYW5cblx0XHR9LFxuXHRcdGlzTGVmdDogZnVuY3Rpb24oZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIGFuIGV2ZW50IG9iamVjdCBmb3IgdGhlIHByZXNzZWQgbGVmdCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0cmV0dXJuIGUuYnV0dG9uID09IDA7IC8vIEJvb2xlYW5cblx0XHR9LFxuXHRcdGlzTWlkZGxlOiBmdW5jdGlvbihlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3MgYW4gZXZlbnQgb2JqZWN0IGZvciB0aGUgcHJlc3NlZCBtaWRkbGUgYnV0dG9uXG5cdFx0XHQvLyBlOiBFdmVudFxuXHRcdFx0Ly9cdFx0RXZlbnQgb2JqZWN0IHRvIGV4YW1pbmVcblx0XHRcdHJldHVybiBlLmJ1dHRvbiA9PSAxOyAvLyBCb29sZWFuXG5cdFx0fSxcblx0XHRpc1JpZ2h0OiBmdW5jdGlvbihlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3MgYW4gZXZlbnQgb2JqZWN0IGZvciB0aGUgcHJlc3NlZCByaWdodCBidXR0b25cblx0XHRcdC8vIGU6IEV2ZW50XG5cdFx0XHQvL1x0XHRFdmVudCBvYmplY3QgdG8gZXhhbWluZVxuXHRcdFx0cmV0dXJuIGUuYnV0dG9uID09IDI7IC8vIEJvb2xlYW5cblx0XHR9XG5cdH07XG49PT09PSovXG5cblx0ZnVuY3Rpb24gZXZlbnRIYW5kbGVyKHR5cGUsIHNlbGVjdEhhbmRsZXIpe1xuXHRcdC8vIGVtdWxhdGlvbiBvZiBtb3VzZWVudGVyL2xlYXZlIHdpdGggbW91c2VvdmVyL291dCB1c2luZyBkZXNjZW5kYW50IGNoZWNraW5nXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gb24obm9kZSwgdHlwZSwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0aWYoc2VsZWN0SGFuZGxlcil7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGVjdEhhbmRsZXIoZXZ0LCBsaXN0ZW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWRvbS5pc0Rlc2NlbmRhbnQoZXZ0LnJlbGF0ZWRUYXJnZXQsIG5vZGUpKXtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdGhhbmRsZXIuYnViYmxlID0gZnVuY3Rpb24oc2VsZWN0KXtcblx0XHRcdHJldHVybiBldmVudEhhbmRsZXIodHlwZSwgZnVuY3Rpb24oZXZ0LCBsaXN0ZW5lcil7XG5cdFx0XHRcdC8vIHVzaW5nIGEgc2VsZWN0b3IsIHVzZSB0aGUgc2VsZWN0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgbW91c2UgbW92ZWQgaW5zaWRlIHRoZSBzZWxlY3RvciBhbmQgd2FzIHByZXZpb3VzbHkgb3V0c2lkZSB0aGUgc2VsZWN0b3Jcblx0XHRcdFx0dmFyIHRhcmdldCA9IHNlbGVjdChldnQudGFyZ2V0KTtcblx0XHRcdFx0dmFyIHJlbGF0ZWRUYXJnZXQgPSBldnQucmVsYXRlZFRhcmdldDtcblx0XHRcdFx0aWYodGFyZ2V0ICYmICh0YXJnZXQgIT0gKHJlbGF0ZWRUYXJnZXQgJiYgcmVsYXRlZFRhcmdldC5ub2RlVHlwZSA9PSAxICYmIHNlbGVjdChyZWxhdGVkVGFyZ2V0KSkpKXtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0YXJnZXQsIGV2dCk7XG5cdFx0XHRcdH0gXG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHJldHVybiBoYW5kbGVyO1xuXHR9XG5cdHZhciB3aGVlbDtcblx0aWYoaGFzKFwiZXZlbnRzLW1vdXNld2hlZWxcIikpe1xuXHRcdHdoZWVsID0gJ21vdXNld2hlZWwnO1xuXHR9ZWxzZXsgLy9maXJlZm94XG5cdFx0d2hlZWwgPSBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gb24obm9kZSwgJ0RPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0ZXZ0LndoZWVsRGVsdGEgPSAtZXZ0LmRldGFpbDtcblx0XHRcdFx0bGlzdGVuZXIuY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgcHJvdmlkZSBtb3VzZSBldmVudCBoYW5kbGluZyB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgZXhwb3J0c1xuXHRcdC8vXHRcdG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmUgZXZlbnQgZW11bGF0aW9uLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VG8gdXNlIHRoZXNlIGV2ZW50cywgeW91IHJlZ2lzdGVyIGEgbW91c2VlbnRlciBsaWtlIHRoaXM6XG5cdFx0Ly9cdFx0fFx0ZGVmaW5lKFtcImRvam8vb25cIiwgXCJkb2pvL21vdXNlXCJdLCBmdW5jdGlvbihvbiwgbW91c2Upe1xuXHRcdC8vXHRcdHxcdFx0b24odGFyZ2V0Tm9kZSwgbW91c2UuZW50ZXIsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHQvL1x0XHR8XHRcdFx0ZG9qby5hZGRDbGFzcyh0YXJnZXROb2RlLCBcImhpZ2hsaWdodGVkXCIpO1xuXHRcdC8vXHRcdHxcdFx0fSk7XG5cdFx0Ly9cdFx0fFx0XHRvbih0YXJnZXROb2RlLCBtb3VzZS5sZWF2ZSwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vXHRcdHxcdFx0XHRkb2pvLnJlbW92ZUNsYXNzKHRhcmdldE5vZGUsIFwiaGlnaGxpZ2h0ZWRcIik7XG5cdFx0Ly9cdFx0fFx0XHR9KTtcblxuXHRcdF9ldmVudEhhbmRsZXI6IGV2ZW50SGFuZGxlcixcdFx0Ly8gZm9yIGRvam8vdG91Y2hcblxuXHRcdC8vIGVudGVyOiBTeW50aGV0aWMgRXZlbnRcblx0XHQvL1x0XHRUaGlzIGlzIGFuIGV4dGVuc2lvbiBldmVudCBmb3IgdGhlIG1vdXNlZW50ZXIgdGhhdCBJRSBwcm92aWRlcywgZW11bGF0aW5nIHRoZVxuXHRcdC8vXHRcdGJlaGF2aW9yIG9uIG90aGVyIGJyb3dzZXJzLlxuXHRcdGVudGVyOiBldmVudEhhbmRsZXIoXCJtb3VzZW92ZXJcIiksXG5cblx0XHQvLyBsZWF2ZTogU3ludGhldGljIEV2ZW50XG5cdFx0Ly9cdFx0VGhpcyBpcyBhbiBleHRlbnNpb24gZXZlbnQgZm9yIHRoZSBtb3VzZWxlYXZlIHRoYXQgSUUgcHJvdmlkZXMsIGVtdWxhdGluZyB0aGVcblx0XHQvL1x0XHRiZWhhdmlvciBvbiBvdGhlciBicm93c2Vycy5cblx0XHRsZWF2ZTogZXZlbnRIYW5kbGVyKFwibW91c2VvdXRcIiksXG5cblx0XHQvLyB3aGVlbDogTm9ybWFsaXplZCBNb3VzZSBXaGVlbCBFdmVudFxuXHRcdC8vXHRcdFRoaXMgaXMgYW4gZXh0ZW5zaW9uIGV2ZW50IGZvciB0aGUgbW91c2V3aGVlbCB0aGF0IG5vbi1Nb3ppbGxhIGJyb3dzZXJzIHByb3ZpZGUsXG5cdFx0Ly9cdFx0ZW11bGF0aW5nIHRoZSBiZWhhdmlvciBvbiBNb3ppbGxhIGJhc2VkIGJyb3dzZXJzLlxuXHRcdHdoZWVsOiB3aGVlbCxcblxuXHRcdGlzTGVmdDogbW91c2VCdXR0b25zLmlzTGVmdCxcblx0XHQvKj09PT09XG5cdFx0aXNMZWZ0OiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3QgYW4gZXZlbnQgb2JqZWN0IChmcm9tIGEgbW91c2Vkb3duIGV2ZW50KSB0byBzZWUgaWYgdGhlIGxlZnQgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0aXNNaWRkbGU6IG1vdXNlQnV0dG9ucy5pc01pZGRsZSxcblx0XHQvKj09PT09XG5cdFx0IGlzTWlkZGxlOiBmdW5jdGlvbigpe1xuXHRcdFx0IC8vIHN1bW1hcnk6XG5cdFx0XHQgLy9cdFx0VGVzdCBhbiBldmVudCBvYmplY3QgKGZyb20gYSBtb3VzZWRvd24gZXZlbnQpIHRvIHNlZSBpZiB0aGUgbWlkZGxlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cblx0XHQgfSxcblx0XHQgPT09PT0qL1xuXG5cdFx0aXNSaWdodDogbW91c2VCdXR0b25zLmlzUmlnaHRcblx0XHQvKj09PT09XG5cdFx0ICwgaXNSaWdodDogZnVuY3Rpb24oKXtcblx0XHRcdCAvLyBzdW1tYXJ5OlxuXHRcdFx0IC8vXHRcdFRlc3QgYW4gZXZlbnQgb2JqZWN0IChmcm9tIGEgbW91c2Vkb3duIGV2ZW50KSB0byBzZWUgaWYgdGhlIHJpZ2h0IGJ1dHRvbiB3YXMgcHJlc3NlZC5cblx0XHQgfVxuXHRcdCA9PT09PSovXG5cdH07XG59KTtcbiIsImRlZmluZShbXCIuL2hhcyFkb20tYWRkZXZlbnRsaXN0ZW5lcj86Li9hc3BlY3RcIiwgXCIuL19iYXNlL2tlcm5lbFwiLCBcIi4vc25pZmZcIl0sIGZ1bmN0aW9uKGFzcGVjdCwgZG9qbywgaGFzKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0aWYoaGFzKFwiZG9tXCIpKXsgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFyZSBpbiBhIGJyb3dzZXIsIHRoaXMgbW9kdWxlIHNob3VsZCB3b3JrIGFueXdoZXJlXG5cdFx0dmFyIG1ham9yID0gd2luZG93LlNjcmlwdEVuZ2luZU1ham9yVmVyc2lvbjtcblx0XHRoYXMuYWRkKFwianNjcmlwdFwiLCBtYWpvciAmJiAobWFqb3IoKSArIFNjcmlwdEVuZ2luZU1pbm9yVmVyc2lvbigpIC8gMTApKTtcblx0XHRoYXMuYWRkKFwiZXZlbnQtb3JpZW50YXRpb25jaGFuZ2VcIiwgaGFzKFwidG91Y2hcIikgJiYgIWhhcyhcImFuZHJvaWRcIikpOyAvLyBUT0RPOiBob3cgZG8gd2UgZGV0ZWN0IHRoaXM/XG5cdFx0aGFzLmFkZChcImV2ZW50LXN0b3BpbW1lZGlhdGVwcm9wYWdhdGlvblwiLCB3aW5kb3cuRXZlbnQgJiYgISF3aW5kb3cuRXZlbnQucHJvdG90eXBlICYmICEhd2luZG93LkV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pO1xuXHRcdGhhcy5hZGQoXCJldmVudC1mb2N1c2luXCIsIGZ1bmN0aW9uKGdsb2JhbCwgZG9jLCBlbGVtZW50KXtcblx0XHRcdHJldHVybiAnb25mb2N1c2luJyBpbiBlbGVtZW50O1xuXHRcdH0pO1xuXG5cdFx0aWYoaGFzKFwidG91Y2hcIikpe1xuXHRcdFx0aGFzLmFkZChcInRvdWNoLWNhbi1tb2RpZnktZXZlbnQtZGVsZWdhdGVcIiwgZnVuY3Rpb24oKXtcblx0XHRcdFx0Ly8gVGhpcyBmZWF0dXJlIHRlc3QgY2hlY2tzIHdoZXRoZXIgZGVsZXRpbmcgYSBwcm9wZXJ0eSBvZiBhbiBldmVudCBkZWxlZ2F0ZSB3b3Jrc1xuXHRcdFx0XHQvLyBmb3IgYSB0b3VjaC1lbmFibGVkIGRldmljZS4gSWYgaXQgd29ya3MsIGV2ZW50IGRlbGVnYXRpb24gY2FuIGJlIHVzZWQgYXMgZmFsbGJhY2tcblx0XHRcdFx0Ly8gZm9yIGJyb3dzZXJzIHN1Y2ggYXMgU2FmYXJpIGluIG9sZGVyIGlPUyB3aGVyZSBkZWxldGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbFxuXHRcdFx0XHQvLyBldmVudCBkb2VzIG5vdCB3b3JrLlxuXHRcdFx0XHR2YXIgRXZlbnREZWxlZ2F0ZSA9IGZ1bmN0aW9uKCl7fTtcblx0XHRcdFx0RXZlbnREZWxlZ2F0ZS5wcm90b3R5cGUgPVxuXHRcdFx0XHRcdGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7IC8vIG9yaWdpbmFsIGV2ZW50XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gbW9kaWZ5IGEgcHJvcGVydHkgb2YgYW4gZXZlbnQgZGVsZWdhdGUgYW5kIGNoZWNrIGlmXG5cdFx0XHRcdC8vIGl0IHN1Y2NlZWRzLiBEZXBlbmRpbmcgb24gYnJvd3NlcnMgYW5kIG9uIHdoZXRoZXIgZG9qby9vbidzXG5cdFx0XHRcdC8vIHN0cmljdCBtb2RlIGlzIHN0cmlwcGVkIGluIGEgRG9qbyBidWlsZCwgdGhlcmUgYXJlIDMga25vd24gYmVoYXZpb3JzOlxuXHRcdFx0XHQvLyBpdCBtYXkgZWl0aGVyIHN1Y2NlZWQsIG9yIHJhaXNlIGFuIGVycm9yLCBvciBmYWlsIHRvIHNldCB0aGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gd2l0aG91dCByYWlzaW5nIGFuIGVycm9yLlxuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0dmFyIGV2ZW50RGVsZWdhdGUgPSBuZXcgRXZlbnREZWxlZ2F0ZTtcblx0XHRcdFx0XHRldmVudERlbGVnYXRlLnRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIGV2ZW50RGVsZWdhdGUudGFyZ2V0ID09PSBudWxsO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBjYW5ub3QgdXNlIGV2ZW50IGRlbGVnYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHZhciBvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0QSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGNvcmUgZXZlbnQgbGlzdGVuaW5nIGZ1bmN0aW9uYWxpdHkuIFdpdGggdGhpcyBmdW5jdGlvblxuXHRcdC8vXHRcdHlvdSBjYW4gcHJvdmlkZSBhIHRhcmdldCwgZXZlbnQgdHlwZSwgYW5kIGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mXG5cdFx0Ly9cdFx0ZnV0dXJlIG1hdGNoaW5nIGV2ZW50cyB0aGF0IGFyZSBmaXJlZC5cblx0XHQvLyB0YXJnZXQ6IEVsZW1lbnR8T2JqZWN0XG5cdFx0Ly9cdFx0VGhpcyBpcyB0aGUgdGFyZ2V0IG9iamVjdCBvciBET00gZWxlbWVudCB0aGF0IHRvIHJlY2VpdmUgZXZlbnRzIGZyb21cblx0XHQvLyB0eXBlOiBTdHJpbmd8RnVuY3Rpb25cblx0XHQvL1x0XHRUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yIG9yIGFuIGV4dGVuc2lvbiBldmVudCB0eXBlLlxuXHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdC8vXHRcdFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBmaXJlcy5cblx0XHQvLyByZXR1cm5zOiBPYmplY3Rcblx0XHQvL1x0XHRBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSgpIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3AgbGlzdGVuaW5nIGZvciB0aGlzXG5cdFx0Ly9cdFx0ZXZlbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VG8gbGlzdGVuIGZvciBcImNsaWNrXCIgZXZlbnRzIG9uIGEgYnV0dG9uIG5vZGUsIHdlIGNhbiBkbzpcblx0XHQvL1x0XHR8XHRkZWZpbmUoW1wiZG9qby9vblwiXSwgZnVuY3Rpb24ob24pe1xuXHRcdC8vXHRcdHxcdFx0b24oYnV0dG9uLCBcImNsaWNrXCIsIGNsaWNrSGFuZGxlcik7XG5cdFx0Ly9cdFx0fFx0XHQuLi5cblx0XHQvL1x0XHRFdmVudGVkIEphdmFTY3JpcHQgb2JqZWN0cyBjYW4gYWxzbyBoYXZlIHRoZWlyIG93biBldmVudHMuXG5cdFx0Ly9cdFx0fFx0dmFyIG9iaiA9IG5ldyBFdmVudGVkO1xuXHRcdC8vXHRcdHxcdG9uKG9iaiwgXCJmb29cIiwgZm9vSGFuZGxlcik7XG5cdFx0Ly9cdFx0QW5kIHRoZW4gd2UgY291bGQgcHVibGlzaCBhIFwiZm9vXCIgZXZlbnQ6XG5cdFx0Ly9cdFx0fFx0b24uZW1pdChvYmosIFwiZm9vXCIsIHtrZXk6IFwidmFsdWVcIn0pO1xuXHRcdC8vXHRcdFdlIGNhbiB1c2UgZXh0ZW5zaW9uIGV2ZW50cyBhcyB3ZWxsLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGxpc3RlbiBmb3IgYSB0YXAgZ2VzdHVyZTpcblx0XHQvL1x0XHR8XHRkZWZpbmUoW1wiZG9qby9vblwiLCBcImRvam8vZ2VzdHVyZS90YXBcIiwgZnVuY3Rpb24ob24sIHRhcCl7XG5cdFx0Ly9cdFx0fFx0XHRvbihidXR0b24sIHRhcCwgdGFwSGFuZGxlcik7XG5cdFx0Ly9cdFx0fFx0XHQuLi5cblx0XHQvL1x0XHR3aGljaCB3b3VsZCB0cmlnZ2VyIGZvb0hhbmRsZXIuIE5vdGUgdGhhdCBmb3IgYSBzaW1wbGUgb2JqZWN0IHRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuXHRcdC8vXHRcdHxcdG9iai5vbmZvbyh7a2V5OlwidmFsdWVcIn0pO1xuXHRcdC8vXHRcdElmIHlvdSB1c2Ugb24uZW1pdCBvbiBhIERPTSBub2RlLCBpdCB3aWxsIHVzZSBuYXRpdmUgZXZlbnQgZGlzcGF0Y2hpbmcgd2hlbiBwb3NzaWJsZS5cblxuXHRcdGlmKHR5cGVvZiB0YXJnZXQub24gPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0eXBlICE9IFwiZnVuY3Rpb25cIiAmJiAhdGFyZ2V0Lm5vZGVUeXBlKXtcblx0XHRcdC8vIGRlbGVnYXRlIHRvIHRoZSB0YXJnZXQncyBvbigpIG1ldGhvZCwgc28gaXQgY2FuIGhhbmRsZSBpdCdzIG93biBsaXN0ZW5pbmcgaWYgaXQgd2FudHMgKHVubGVzcyBpdFxuXHRcdFx0Ly8gaXMgRE9NIG5vZGUgYW5kIHdlIG1heSBiZSBkZWFsaW5nIHdpdGggalF1ZXJ5IG9yIFByb3RvdHlwZSdzIGluY29tcGF0aWJsZSBhZGRpdGlvbiB0byB0aGVcblx0XHRcdC8vIEVsZW1lbnQgcHJvdG90eXBlXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0Ly8gZGVsZWdhdGUgdG8gbWFpbiBsaXN0ZW5lciBjb2RlXG5cdFx0cmV0dXJuIG9uLnBhcnNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCB0aGlzKTtcblx0fTtcblx0b24ucGF1c2FibGUgPSAgZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgZG9udEZpeCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIGZ1bmN0aW9uIGFjdHMgdGhlIHNhbWUgYXMgb24oKSwgYnV0IHdpdGggcGF1c2FibGUgZnVuY3Rpb25hbGl0eS4gVGhlXG5cdFx0Ly9cdFx0cmV0dXJuZWQgc2lnbmFsIG9iamVjdCBoYXMgcGF1c2UoKSBhbmQgcmVzdW1lKCkgZnVuY3Rpb25zLiBDYWxsaW5nIHRoZVxuXHRcdC8vXHRcdHBhdXNlKCkgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIG5vdCBiZSBjYWxsZWQgZm9yIGZ1dHVyZSBldmVudHMuIENhbGxpbmcgdGhlXG5cdFx0Ly9cdFx0cmVzdW1lKCkgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGFnYWluIGJlIGNhbGxlZCBmb3IgZnV0dXJlIGV2ZW50cy5cblx0XHR2YXIgcGF1c2VkO1xuXHRcdHZhciBzaWduYWwgPSBvbih0YXJnZXQsIHR5cGUsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpZighcGF1c2VkKXtcblx0XHRcdFx0cmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSwgZG9udEZpeCk7XG5cdFx0c2lnbmFsLnBhdXNlID0gZnVuY3Rpb24oKXtcblx0XHRcdHBhdXNlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRzaWduYWwucmVzdW1lID0gZnVuY3Rpb24oKXtcblx0XHRcdHBhdXNlZCA9IGZhbHNlO1xuXHRcdH07XG5cdFx0cmV0dXJuIHNpZ25hbDtcblx0fTtcblx0b24ub25jZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBmdW5jdGlvbiBhY3RzIHRoZSBzYW1lIGFzIG9uKCksIGJ1dCB3aWxsIG9ubHkgY2FsbCB0aGUgbGlzdGVuZXIgb25jZS4gVGhlXG5cdFx0Ly9cdFx0bGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgZm9yIHRoZSBmaXJzdFxuXHRcdC8vXHRcdGV2ZW50IHRoYXQgdGFrZXMgcGxhY2UgYW5kIHRoZW4gbGlzdGVuZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQuXG5cdFx0dmFyIHNpZ25hbCA9IG9uKHRhcmdldCwgdHlwZSwgZnVuY3Rpb24oKXtcblx0XHRcdC8vIHJlbW92ZSB0aGlzIGxpc3RlbmVyXG5cdFx0XHRzaWduYWwucmVtb3ZlKCk7XG5cdFx0XHQvLyBwcm9jZWVkIHRvIGNhbGwgdGhlIGxpc3RlbmVyXG5cdFx0XHRyZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gc2lnbmFsO1xuXHR9O1xuXHRvbi5wYXJzZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KXtcblx0XHR2YXIgZXZlbnRzO1xuXHRcdGlmKHR5cGUuY2FsbCl7XG5cdFx0XHQvLyBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBvbihub2RlLCB0b3VjaC5wcmVzcywgdG91Y2hMaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm4gdHlwZS5jYWxsKG1hdGNoZXNUYXJnZXQsIHRhcmdldCwgbGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHQvLyBhbGxvdyBhbiBhcnJheSBvZiBldmVudCBuYW1lcyAob3IgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMpXG5cdFx0XHRldmVudHMgPSB0eXBlO1xuXHRcdH1lbHNlIGlmKHR5cGUuaW5kZXhPZihcIixcIikgPiAtMSl7XG5cdFx0XHQvLyB3ZSBhbGxvdyBjb21tYSBkZWxpbWl0ZWQgZXZlbnQgbmFtZXMsIHNvIHlvdSBjYW4gcmVnaXN0ZXIgZm9yIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG5cdFx0XHRldmVudHMgPSB0eXBlLnNwbGl0KC9cXHMqLFxccyovKTtcblx0XHR9XG5cdFx0aWYoZXZlbnRzKXtcblx0XHRcdHZhciBoYW5kbGVzID0gW107XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0d2hpbGUoZXZlbnROYW1lID0gZXZlbnRzW2krK10peyAvLyBpbnRlbnRpb25hbCBhc3NpZ25tZW50XG5cdFx0XHRcdGhhbmRsZXMucHVzaChvbi5wYXJzZSh0YXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGFkZExpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KSk7XG5cdFx0XHR9XG5cdFx0XHRoYW5kbGVzLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBoYW5kbGVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRoYW5kbGVzW2ldLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhhbmRsZXM7XG5cdFx0fVxuXHRcdHJldHVybiBhZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBkb250Rml4LCBtYXRjaGVzVGFyZ2V0KTtcblx0fTtcblx0dmFyIHRvdWNoRXZlbnRzID0gL150b3VjaC87XG5cdGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvbnRGaXgsIG1hdGNoZXNUYXJnZXQpe1xuXHRcdC8vIGV2ZW50IGRlbGVnYXRpb246XG5cdFx0dmFyIHNlbGVjdG9yID0gdHlwZS5tYXRjaCgvKC4qKTooLiopLyk7XG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHNlbGVjdG9yOmV2ZW50LCB0aGUgbGFzdCBvbmUgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gZXZlbnQsIGFuZCB3ZSB1c2UgZXZlbnQgZGVsZWdhdGlvblxuXHRcdGlmKHNlbGVjdG9yKXtcblx0XHRcdHR5cGUgPSBzZWxlY3RvclsyXTtcblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3JbMV07XG5cdFx0XHQvLyBjcmVhdGUgdGhlIGV4dGVuc2lvbiBldmVudCBmb3Igc2VsZWN0b3JzIGFuZCBkaXJlY3RseSBjYWxsIGl0XG5cdFx0XHRyZXR1cm4gb24uc2VsZWN0b3Ioc2VsZWN0b3IsIHR5cGUpLmNhbGwobWF0Y2hlc1RhcmdldCwgdGFyZ2V0LCBsaXN0ZW5lcik7XG5cdFx0fVxuXHRcdC8vIHRlc3QgdG8gc2VlIGlmIGl0IGEgdG91Y2ggZXZlbnQgcmlnaHQgbm93LCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIGl0IGV2ZXJ5IHRpbWUgaXQgZmlyZXNcblx0XHRpZihoYXMoXCJ0b3VjaFwiKSl7XG5cdFx0XHRpZih0b3VjaEV2ZW50cy50ZXN0KHR5cGUpKXtcblx0XHRcdFx0Ly8gdG91Y2ggZXZlbnQsIGZpeCBpdFxuXHRcdFx0XHRsaXN0ZW5lciA9IGZpeFRvdWNoTGlzdGVuZXIobGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWhhcyhcImV2ZW50LW9yaWVudGF0aW9uY2hhbmdlXCIpICYmICh0eXBlID09IFwib3JpZW50YXRpb25jaGFuZ2VcIikpe1xuXHRcdFx0XHQvL1wib3JpZW50YXRpb25jaGFuZ2VcIiBub3Qgc3VwcG9ydGVkIDw9IEFuZHJvaWQgMi4xLFxuXHRcdFx0XHQvL2J1dCB3b3JrcyB0aHJvdWdoIFwicmVzaXplXCIgb24gd2luZG93XG5cdFx0XHRcdHR5cGUgPSBcInJlc2l6ZVwiO1xuXHRcdFx0XHR0YXJnZXQgPSB3aW5kb3c7XG5cdFx0XHRcdGxpc3RlbmVyID0gZml4VG91Y2hMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGFkZFN0b3BJbW1lZGlhdGUpe1xuXHRcdFx0Ly8gYWRkIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRsaXN0ZW5lciA9IGFkZFN0b3BJbW1lZGlhdGUobGlzdGVuZXIpO1xuXHRcdH1cblx0XHQvLyBub3JtYWwgcGF0aCwgdGhlIHRhcmdldCBpcyB8dGhpc3xcblx0XHRpZih0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcil7XG5cdFx0XHQvLyB0aGUgdGFyZ2V0IGhhcyBhZGRFdmVudExpc3RlbmVyLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpZiBhdmFpbGFibGUgKG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhIG5vZGUsIG5vbi1ub2RlcyBjYW4gaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFzIHdlbGwpXG5cdFx0XHQvLyBjaGVjayBmb3IgY2FwdHVyZSBjb252ZXJzaW9uc1xuXHRcdFx0dmFyIGNhcHR1cmUgPSB0eXBlIGluIGNhcHR1cmVzLFxuXHRcdFx0XHRhZGp1c3RlZFR5cGUgPSBjYXB0dXJlID8gY2FwdHVyZXNbdHlwZV0gOiB0eXBlO1xuXHRcdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoYWRqdXN0ZWRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0XHQvLyBjcmVhdGUgYW5kIHJldHVybiB0aGUgc2lnbmFsXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWRqdXN0ZWRUeXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHR5cGUgPSBcIm9uXCIgKyB0eXBlO1xuXHRcdGlmKGZpeEF0dGFjaCAmJiB0YXJnZXQuYXR0YWNoRXZlbnQpe1xuXHRcdFx0cmV0dXJuIGZpeEF0dGFjaCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG11c3QgYmUgYW4gZXZlbnQgZW1pdHRlclwiKTtcblx0fVxuXHRvbi5tYXRjaGVzID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IsIGNvbnRleHQsIGNoaWxkcmVuLCBtYXRjaGVzVGFyZ2V0KSB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRDaGVjayBpZiBhIG5vZGUgbWF0Y2ggdGhlIGN1cnJlbnQgc2VsZWN0b3Igd2l0aGluIHRoZSBjb25zdHJhaW50IG9mIGEgY29udGV4dFxuXHRcdC8vIG5vZGU6IERPTU5vZGVcblx0XHQvL1x0XHRUaGUgbm9kZSB0aGF0IG9yaWdpbmF0ZSB0aGUgZXZlbnRcblx0XHQvLyBzZWxlY3RvcjogU3RyaW5nXG5cdFx0Ly9cdFx0VGhlIHNlbGVjdG9yIHRvIGNoZWNrIGFnYWluc3Rcblx0XHQvLyBjb250ZXh0OiBET01Ob2RlXG5cdFx0Ly9cdFx0VGhlIGNvbnRleHQgdG8gc2VhcmNoIGluLlxuXHRcdC8vIGNoaWxkcmVuOiBCb29sZWFuXG5cdFx0Ly9cdFx0SW5kaWNhdGVzIGlmIGNoaWxkcmVuIGVsZW1lbnRzIG9mIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgYWxsb3dlZC4gVGhpcyBkZWZhdWx0cyB0b1xuXHRcdC8vXHRcdHRydWVcblx0XHQvLyBtYXRjaGVzVGFyZ2V0OiBPYmplY3R8ZG9qby9xdWVyeT9cblx0XHQvL1x0XHRBbiBvYmplY3Qgd2l0aCBhIHByb3BlcnR5IFwibWF0Y2hlc1wiIGFzIGEgZnVuY3Rpb24uIERlZmF1bHQgaXMgZG9qby9xdWVyeS5cblx0XHQvL1x0XHRNYXRjaGluZyBET01Ob2RlcyB3aWxsIGJlIGRvbmUgYWdhaW5zdCB0aGlzIGZ1bmN0aW9uXG5cdFx0Ly9cdFx0VGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgQm9vbGVhbi5cblx0XHQvL1x0XHRJdCB3aWxsIGhhdmUgMyBhcmd1bWVudHM6IFwibm9kZVwiLCBcInNlbGVjdG9yXCIgYW5kIFwiY29udGV4dFwiXG5cdFx0Ly9cdFx0VHJ1ZSBpcyBleHBlY3RlZCBpZiBcIm5vZGVcIiBpcyBtYXRjaGluZyB0aGUgY3VycmVudCBcInNlbGVjdG9yXCIgaW4gdGhlIHBhc3NlZCBcImNvbnRleHRcIlxuXHRcdC8vIHJldHVybnM6IERPTU5vZGU/XG5cdFx0Ly9cdFx0VGhlIG1hdGNoaW5nIG5vZGUsIGlmIGFueS4gRWxzZSB5b3UgZ2V0IGZhbHNlXG5cblx0XHQvLyBzZWUgaWYgd2UgaGF2ZSBhIHZhbGlkIG1hdGNoZXNUYXJnZXQgb3IgZGVmYXVsdCB0byBkb2pvL3F1ZXJ5XG5cdFx0bWF0Y2hlc1RhcmdldCA9IG1hdGNoZXNUYXJnZXQgJiYgKHR5cGVvZiBtYXRjaGVzVGFyZ2V0Lm1hdGNoZXMgPT0gXCJmdW5jdGlvblwiKSA/IG1hdGNoZXNUYXJnZXQgOiBkb2pvLnF1ZXJ5O1xuXHRcdGNoaWxkcmVuID0gY2hpbGRyZW4gIT09IGZhbHNlO1xuXHRcdC8vIHRoZXJlIGlzIGEgc2VsZWN0b3IsIHNvIG1ha2Ugc3VyZSBpdCBtYXRjaGVzXG5cdFx0aWYobm9kZS5ub2RlVHlwZSAhPSAxKXtcblx0XHRcdC8vIHRleHQgbm9kZSB3aWxsIGZhaWwgaW4gbmF0aXZlIG1hdGNoIHNlbGVjdG9yXG5cdFx0XHRub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdH1cblx0XHR3aGlsZSghbWF0Y2hlc1RhcmdldC5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yLCBjb250ZXh0KSl7XG5cdFx0XHRpZihub2RlID09IGNvbnRleHQgfHwgY2hpbGRyZW4gPT09IGZhbHNlIHx8ICEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5ub2RlVHlwZSAhPSAxKXsgLy8gaW50ZW50aW9uYWwgYXNzaWdubWVudFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXHRvbi5zZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudFR5cGUsIGNoaWxkcmVuKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENyZWF0ZXMgYSBuZXcgZXh0ZW5zaW9uIGV2ZW50IHdpdGggZXZlbnQgZGVsZWdhdGlvbi4gVGhpcyBpcyBiYXNlZCBvblxuXHRcdC8vXHRcdHRoZSBwcm92aWRlZCBldmVudCB0eXBlIChjYW4gYmUgZXh0ZW5zaW9uIGV2ZW50KSB0aGF0XG5cdFx0Ly9cdFx0b25seSBjYWxscyB0aGUgbGlzdGVuZXIgd2hlbiB0aGUgQ1NTIHNlbGVjdG9yIG1hdGNoZXMgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQuXG5cdFx0Ly9cblx0XHQvL1x0XHRUaGUgYXBwbGljYXRpb24gbXVzdCByZXF1aXJlKCkgYW4gYXBwcm9wcmlhdGUgbGV2ZWwgb2YgZG9qby9xdWVyeSB0byBoYW5kbGUgdGhlIHNlbGVjdG9yLlxuXHRcdC8vIHNlbGVjdG9yOlxuXHRcdC8vXHRcdFRoZSBDU1Mgc2VsZWN0b3IgdG8gdXNlIGZvciBmaWx0ZXIgZXZlbnRzIGFuZCBkZXRlcm1pbmUgdGhlIHx0aGlzfCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0Ly8gZXZlbnRUeXBlOlxuXHRcdC8vXHRcdFRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG5cdFx0Ly8gY2hpbGRyZW46XG5cdFx0Ly9cdFx0SW5kaWNhdGVzIGlmIGNoaWxkcmVuIGVsZW1lbnRzIG9mIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgYWxsb3dlZC4gVGhpcyBkZWZhdWx0cyB0b1xuXHRcdC8vXHRcdHRydWVcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vIHxcdHJlcXVpcmUoW1wiZG9qby9vblwiLCBcImRvam8vbW91c2VcIiwgXCJkb2pvL3F1ZXJ5IWNzczJcIl0sIGZ1bmN0aW9uKG9uLCBtb3VzZSl7XG5cdFx0Ly8gfFx0XHRvbihub2RlLCBvbi5zZWxlY3RvcihcIi5teS1jbGFzc1wiLCBtb3VzZS5lbnRlciksIGhhbmRsZXJGb3JNeUhvdmVyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBpZiB0aGUgc2VsZWN0b3IgaXMgZnVuY3Rpb24sIHVzZSBpdCB0byBzZWxlY3QgdGhlIG5vZGUsIG90aGVyd2lzZSB1c2UgdGhlIG1hdGNoZXMgbWV0aG9kXG5cdFx0XHR2YXIgbWF0Y2hlc1RhcmdldCA9IHR5cGVvZiBzZWxlY3RvciA9PSBcImZ1bmN0aW9uXCIgPyB7bWF0Y2hlczogc2VsZWN0b3J9IDogdGhpcyxcblx0XHRcdFx0YnViYmxlID0gZXZlbnRUeXBlLmJ1YmJsZTtcblx0XHRcdGZ1bmN0aW9uIHNlbGVjdChldmVudFRhcmdldCl7XG5cdFx0XHRcdHJldHVybiBvbi5tYXRjaGVzKGV2ZW50VGFyZ2V0LCBzZWxlY3RvciwgdGFyZ2V0LCBjaGlsZHJlbiwgbWF0Y2hlc1RhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRpZihidWJibGUpe1xuXHRcdFx0XHQvLyB0aGUgZXZlbnQgdHlwZSBkb2Vzbid0IG5hdHVyYWxseSBidWJibGUsIGJ1dCBoYXMgYSBidWJibGluZyBmb3JtLCB1c2UgdGhhdCwgYW5kIGdpdmUgaXQgdGhlIHNlbGVjdG9yIHNvIGl0IGNhbiBwZXJmb3JtIHRoZSBzZWxlY3QgaXRzZWxmXG5cdFx0XHRcdHJldHVybiBvbih0YXJnZXQsIGJ1YmJsZShzZWxlY3QpLCBsaXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdGFuZGFyZCBldmVudCBkZWxlZ2F0aW9uXG5cdFx0XHRyZXR1cm4gb24odGFyZ2V0LCBldmVudFR5cGUsIGZ1bmN0aW9uKGV2ZW50KXtcblx0XHRcdFx0Ly8gY2FsbCBzZWxlY3QgdG8gc2VlIGlmIHdlIG1hdGNoXG5cdFx0XHRcdHZhciBldmVudFRhcmdldCA9IHNlbGVjdChldmVudC50YXJnZXQpO1xuXHRcdFx0XHQvLyBpZiBpdCBtYXRjaGVzIHdlIGNhbGwgdGhlIGxpc3RlbmVyXG5cdFx0XHRcdGlmIChldmVudFRhcmdldCkge1xuXHRcdFx0XHRcdC8vIFdlIHNhdmUgdGhlIG1hdGNoaW5nIHRhcmdldCBpbnRvIHRoZSBldmVudCwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGV2ZW4gd2hlbiBoaXRjaGluZyAoc2VlICMxODM1NSlcblx0XHRcdFx0XHRldmVudC5zZWxlY3RvclRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuXHRcdFx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKGV2ZW50VGFyZ2V0LCBldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH07XG5cblx0ZnVuY3Rpb24gc3ludGhldGljUHJldmVudERlZmF1bHQoKXtcblx0XHR0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHR9XG5cdGZ1bmN0aW9uIHN5bnRoZXRpY1N0b3BQcm9wYWdhdGlvbigpe1xuXHRcdHRoaXMuYnViYmxlcyA9IGZhbHNlO1xuXHR9XG5cdHZhciBzbGljZSA9IFtdLnNsaWNlLFxuXHRcdHN5bnRoZXRpY0Rpc3BhdGNoID0gb24uZW1pdCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgZXZlbnQpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0RmlyZXMgYW4gZXZlbnQgb24gdGhlIHRhcmdldCBvYmplY3QuXG5cdFx0Ly8gdGFyZ2V0OlxuXHRcdC8vXHRcdFRoZSB0YXJnZXQgb2JqZWN0IHRvIGZpcmUgdGhlIGV2ZW50IG9uLiBUaGlzIGNhbiBiZSBhIERPTSBlbGVtZW50IG9yIGEgcGxhaW5cblx0XHQvL1x0XHRKUyBvYmplY3QuIElmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgbmF0aXZlIGV2ZW50IGVtaXR0aW5nIG1lY2hhbmlzbXNcblx0XHQvL1x0XHRhcmUgdXNlZCB3aGVuIHBvc3NpYmxlLlxuXHRcdC8vIHR5cGU6XG5cdFx0Ly9cdFx0VGhlIGV2ZW50IHR5cGUgbmFtZS4gWW91IGNhbiBlbXVsYXRlIHN0YW5kYXJkIG5hdGl2ZSBldmVudHMgbGlrZSBcImNsaWNrXCIgYW5kXG5cdFx0Ly9cdFx0XCJtb3VzZW92ZXJcIiBvciBjcmVhdGUgY3VzdG9tIGV2ZW50cyBsaWtlIFwib3BlblwiIG9yIFwiZmluaXNoXCIuXG5cdFx0Ly8gZXZlbnQ6XG5cdFx0Ly9cdFx0QW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgdGhlIHByb3BlcnRpZXMgZm9yIHRoZSBldmVudC4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9ldmVudC5pbml0RXZlbnRcblx0XHQvL1x0XHRmb3Igc29tZSBvZiB0aGUgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuXG5cdFx0Ly9cdFx0T2YgcGFydGljdWxhciBpbXBvcnRhbmNlIGFyZSB0aGUgY2FuY2VsYWJsZSBhbmQgYnViYmxlcyBwcm9wZXJ0aWVzLiBUaGVcblx0XHQvL1x0XHRjYW5jZWxhYmxlIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgZXZlbnQgaGFzIGEgZGVmYXVsdCBhY3Rpb25cblx0XHQvL1x0XHR0aGF0IGNhbiBiZSBjYW5jZWxsZWQuIFRoZSBldmVudCBpcyBjYW5jZWxsZWQgYnkgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCgpIG9uXG5cdFx0Ly9cdFx0dGhlIGV2ZW50IG9iamVjdC4gVGhlIGJ1YmJsZXMgcHJvcGVydHkgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuXHRcdC8vXHRcdGV2ZW50IHdpbGwgYnViYmxlIHVwIHRoZSBET00gdHJlZS4gSWYgYnViYmxlcyBpcyB0cnVlLCB0aGUgZXZlbnQgd2lsbCBiZSBjYWxsZWRcblx0XHQvL1x0XHRvbiB0aGUgdGFyZ2V0IGFuZCB0aGVuIGVhY2ggcGFyZW50IHN1Y2Nlc3NpdmVseSB1bnRpbCB0aGUgdG9wIG9mIHRoZSB0cmVlXG5cdFx0Ly9cdFx0aXMgcmVhY2hlZCBvciBzdG9wUHJvcGFnYXRpb24oKSBpcyBjYWxsZWQuIEJvdGggYnViYmxlcyBhbmQgY2FuY2VsYWJsZVxuXHRcdC8vXHRcdGRlZmF1bHQgdG8gZmFsc2UuXG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHRJZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZSBhbmQgdGhlIGV2ZW50IGlzIG5vdCBjYW5jZWxsZWQsXG5cdFx0Ly9cdFx0ZW1pdCB3aWxsIHJldHVybiB0cnVlLiBJZiB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZSBhbmQgdGhlIGV2ZW50IGlzIGNhbmNlbGxlZCxcblx0XHQvL1x0XHRlbWl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHRcdC8vIGRldGFpbHM6XG5cdFx0Ly9cdFx0Tm90ZSB0aGF0IHRoaXMgaXMgZGVzaWduZWQgdG8gZW1pdCBldmVudHMgZm9yIGxpc3RlbmVycyByZWdpc3RlcmVkIHRocm91Z2hcblx0XHQvL1x0XHRkb2pvL29uLiBJdCBzaG91bGQgYWN0dWFsbHkgd29yayB3aXRoIGFueSBldmVudCBsaXN0ZW5lciBleGNlcHQgdGhvc2Vcblx0XHQvL1x0XHRhZGRlZCB0aHJvdWdoIElFJ3MgYXR0YWNoRXZlbnQgKElFOCBhbmQgYmVsb3cncyBub24tVzNDIGV2ZW50IGVtaXR0aW5nXG5cdFx0Ly9cdFx0ZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBldmVudCB0eXBlcykuIEl0IHNob3VsZCB3b3JrIHdpdGggYWxsIGV2ZW50cyByZWdpc3RlcmVkXG5cdFx0Ly9cdFx0dGhyb3VnaCBkb2pvL29uLiBBbHNvIG5vdGUgdGhhdCB0aGUgZW1pdCBtZXRob2QgZG9lcyBkbyBhbnkgZGVmYXVsdFxuXHRcdC8vXHRcdGFjdGlvbiwgaXQgb25seSByZXR1cm5zIGEgdmFsdWUgdG8gaW5kaWNhdGUgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHNob3VsZCB0YWtlXG5cdFx0Ly9cdFx0cGxhY2UuIEZvciBleGFtcGxlLCBlbWl0dGluZyBhIGtleXByZXNzIGV2ZW50IHdvdWxkIG5vdCBjYXVzZSBhIGNoYXJhY3RlclxuXHRcdC8vXHRcdHRvIGFwcGVhciBpbiBhIHRleHRib3guXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRUbyBmaXJlIG91ciBvd24gY2xpY2sgZXZlbnRcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL29uXCIsIFwiZG9qby9kb21cIlxuXHRcdC8vXHR8XHRdLCBmdW5jdGlvbihvbiwgZG9tKXtcblx0XHQvL1x0fFx0XHRvbi5lbWl0KGRvbS5ieUlkKFwiYnV0dG9uXCIpLCBcImNsaWNrXCIsIHtcblx0XHQvL1x0fFx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0Ly9cdHxcdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdC8vXHR8XHRcdFx0c2NyZWVuWDogMzMsXG5cdFx0Ly9cdHxcdFx0XHRzY3JlZW5ZOiA0NFxuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHRcdFdlIGNhbiBhbHNvIGZpcmUgb3VyIG93biBjdXN0b20gZXZlbnRzOlxuXHRcdC8vXHR8XHRcdG9uLmVtaXQoZG9tLmJ5SWQoXCJzbGlkZXJcIiksIFwic2xpZGVcIiwge1xuXHRcdC8vXHR8XHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHQvL1x0fFx0XHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0Ly9cdHxcdFx0XHRkaXJlY3Rpb246IFwibGVmdC10by1yaWdodFwiXG5cdFx0Ly9cdHxcdFx0fSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHRcdHZhciBtZXRob2QgPSBcIm9uXCIgKyB0eXBlO1xuXHRcdGlmKFwicGFyZW50Tm9kZVwiIGluIHRhcmdldCl7XG5cdFx0XHQvLyBub2RlIChvciBub2RlLWxpa2UpLCBjcmVhdGUgZXZlbnQgY29udHJvbGxlciBtZXRob2RzXG5cdFx0XHR2YXIgbmV3RXZlbnQgPSBhcmdzWzBdID0ge307XG5cdFx0XHRmb3IodmFyIGkgaW4gZXZlbnQpe1xuXHRcdFx0XHRuZXdFdmVudFtpXSA9IGV2ZW50W2ldO1xuXHRcdFx0fVxuXHRcdFx0bmV3RXZlbnQucHJldmVudERlZmF1bHQgPSBzeW50aGV0aWNQcmV2ZW50RGVmYXVsdDtcblx0XHRcdG5ld0V2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHN5bnRoZXRpY1N0b3BQcm9wYWdhdGlvbjtcblx0XHRcdG5ld0V2ZW50LnRhcmdldCA9IHRhcmdldDtcblx0XHRcdG5ld0V2ZW50LnR5cGUgPSB0eXBlO1xuXHRcdFx0ZXZlbnQgPSBuZXdFdmVudDtcblx0XHR9XG5cdFx0ZG97XG5cdFx0XHQvLyBjYWxsIGFueSBub2RlIHdoaWNoIGhhcyBhIGhhbmRsZXIgKG5vdGUgdGhhdCBpZGVhbGx5IHdlIHdvdWxkIHRyeS9jYXRjaCB0byBzaW11bGF0ZSBub3JtYWwgZXZlbnQgcHJvcGFnYXRpb24gYnV0IHRoYXQgY2F1c2VzIHRvbyBtdWNoIHBhaW4gZm9yIGRlYnVnZ2luZylcblx0XHRcdHRhcmdldFttZXRob2RdICYmIHRhcmdldFttZXRob2RdLmFwcGx5KHRhcmdldCwgYXJncyk7XG5cdFx0XHQvLyBhbmQgdGhlbiBjb250aW51ZSB1cCB0aGUgcGFyZW50IG5vZGUgY2hhaW4gaWYgaXQgaXMgc3RpbGwgYnViYmxpbmcgKGlmIHN0YXJ0ZWQgYXMgYnViYmxlcyBhbmQgc3RvcFByb3BhZ2F0aW9uIGhhc24ndCBiZWVuIGNhbGxlZClcblx0XHR9d2hpbGUoZXZlbnQgJiYgZXZlbnQuYnViYmxlcyAmJiAodGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpKTtcblx0XHRyZXR1cm4gZXZlbnQgJiYgZXZlbnQuY2FuY2VsYWJsZSAmJiBldmVudDsgLy8gaWYgaXQgaXMgc3RpbGwgdHJ1ZSAod2FzIGNhbmNlbGFibGUgYW5kIHdhcyBjYW5jZWxsZWQpLCByZXR1cm4gdGhlIGV2ZW50IHRvIGluZGljYXRlIGRlZmF1bHQgYWN0aW9uIHNob3VsZCBoYXBwZW5cblx0fTtcblx0dmFyIGNhcHR1cmVzID0gaGFzKFwiZXZlbnQtZm9jdXNpblwiKSA/IHt9IDoge2ZvY3VzaW46IFwiZm9jdXNcIiwgZm9jdXNvdXQ6IFwiYmx1clwifTtcblx0aWYoIWhhcyhcImV2ZW50LXN0b3BpbW1lZGlhdGVwcm9wYWdhdGlvblwiKSl7XG5cdFx0dmFyIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuaW1tZWRpYXRlbHlTdG9wcGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMubW9kaWZpZWQgPSB0cnVlOyAvLyBtYXJrIGl0IGFzIG1vZGlmaWVkIHNvIHRoZSBldmVudCB3aWxsIGJlIGNhY2hlZCBpbiBJRVxuXHRcdH07XG5cdFx0dmFyIGFkZFN0b3BJbW1lZGlhdGUgPSBmdW5jdGlvbihsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0XHRpZighZXZlbnQuaW1tZWRpYXRlbHlTdG9wcGVkKXsvLyBjaGVjayB0byBtYWtlIHN1cmUgaXQgaGFzbid0IGJlZW4gc3RvcHBlZCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmKGhhcyhcImRvbS1hZGRldmVudGxpc3RlbmVyXCIpKXtcblx0XHQvLyBlbWl0dGVyIHRoYXQgd29ya3Mgd2l0aCBuYXRpdmUgZXZlbnQgaGFuZGxpbmdcblx0XHRvbi5lbWl0ID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBldmVudCl7XG5cdFx0XHRpZih0YXJnZXQuZGlzcGF0Y2hFdmVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCl7XG5cdFx0XHRcdC8vIHVzZSB0aGUgbmF0aXZlIGV2ZW50IGVtaXR0aW5nIG1lY2hhbmlzbSBpZiBpdCBpcyBhdmFpbGFibGUgb24gdGhlIHRhcmdldCBvYmplY3Rcblx0XHRcdFx0Ly8gY3JlYXRlIGEgZ2VuZXJpYyBldmVudFxuXHRcdFx0XHQvLyB3ZSBjb3VsZCBjcmVhdGUgYnJhbmNoIGludG8gdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudCBjb25zdHJ1Y3RvcnMsIGJ1dFxuXHRcdFx0XHQvLyB0aGF0IHdvdWxkIGJlIGEgbG90IG9mIGV4dHJhIGNvZGUsIHdpdGggbGl0dGxlIGJlbmVmaXQgdGhhdCBJIGNhbiBzZWUsIHNlZW1zXG5cdFx0XHRcdC8vIGJlc3QgdG8gdXNlIHRoZSBnZW5lcmljIGNvbnN0cnVjdG9yIGFuZCBjb3B5IHByb3BlcnRpZXMgb3ZlciwgbWFraW5nIGl0XG5cdFx0XHRcdC8vIGVhc3kgdG8gaGF2ZSBldmVudHMgbG9vayBsaWtlIHRoZSBvbmVzIGNyZWF0ZWQgd2l0aCBzcGVjaWZpYyBpbml0aWFsaXplcnNcblx0XHRcdFx0dmFyIG93bmVyRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0dmFyIG5hdGl2ZUV2ZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIik7XG5cdFx0XHRcdG5hdGl2ZUV2ZW50LmluaXRFdmVudCh0eXBlLCAhIWV2ZW50LmJ1YmJsZXMsICEhZXZlbnQuY2FuY2VsYWJsZSk7XG5cdFx0XHRcdC8vIGFuZCBjb3B5IGFsbCBvdXIgcHJvcGVydGllcyBvdmVyXG5cdFx0XHRcdGZvcih2YXIgaSBpbiBldmVudCl7XG5cdFx0XHRcdFx0aWYoIShpIGluIG5hdGl2ZUV2ZW50KSl7XG5cdFx0XHRcdFx0XHRuYXRpdmVFdmVudFtpXSA9IGV2ZW50W2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnQpICYmIG5hdGl2ZUV2ZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN5bnRoZXRpY0Rpc3BhdGNoLmFwcGx5KG9uLCBhcmd1bWVudHMpOyAvLyBlbWl0IGZvciBhIG5vbi1ub2RlXG5cdFx0fTtcblx0fWVsc2V7XG5cdFx0Ly8gbm8gYWRkRXZlbnRMaXN0ZW5lciwgYmFzaWNhbGx5IG9sZCBJRSBldmVudCBub3JtYWxpemF0aW9uXG5cdFx0b24uX2ZpeEV2ZW50ID0gZnVuY3Rpb24oZXZ0LCBzZW5kZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdG5vcm1hbGl6ZXMgcHJvcGVydGllcyBvbiB0aGUgZXZlbnQgb2JqZWN0IGluY2x1ZGluZyBldmVudFxuXHRcdFx0Ly9cdFx0YnViYmxpbmcgbWV0aG9kcywga2V5c3Ryb2tlIG5vcm1hbGl6YXRpb24sIGFuZCB4L3kgcG9zaXRpb25zXG5cdFx0XHQvLyBldnQ6XG5cdFx0XHQvL1x0XHRuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHQvLyBzZW5kZXI6XG5cdFx0XHQvL1x0XHRub2RlIHRvIHRyZWF0IGFzIFwiY3VycmVudFRhcmdldFwiXG5cdFx0XHRpZighZXZ0KXtcblx0XHRcdFx0dmFyIHcgPSBzZW5kZXIgJiYgKHNlbmRlci5vd25lckRvY3VtZW50IHx8IHNlbmRlci5kb2N1bWVudCB8fCBzZW5kZXIpLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG5cdFx0XHRcdGV2dCA9IHcuZXZlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZighZXZ0KXtyZXR1cm4gZXZ0O31cblx0XHRcdHRyeXtcblx0XHRcdFx0aWYobGFzdEV2ZW50ICYmIGV2dC50eXBlID09IGxhc3RFdmVudC50eXBlICAmJiBldnQuc3JjRWxlbWVudCA9PSBsYXN0RXZlbnQudGFyZ2V0KXtcblx0XHRcdFx0XHQvLyBzaG91bGQgYmUgc2FtZSBldmVudCwgcmV1c2UgZXZlbnQgb2JqZWN0IChzbyBpdCBjYW4gYmUgYXVnbWVudGVkKTtcblx0XHRcdFx0XHQvLyBhY2Nlc3NpbmcgZXZ0LnNyY0VsZW1lbnQgcmF0aGVyIHRoYW4gZXZ0LnRhcmdldCBzaW5jZSBldnQudGFyZ2V0IG5vdCBzZXQgb24gSUUgdW50aWwgZml4dXAgYmVsb3dcblx0XHRcdFx0XHRldnQgPSBsYXN0RXZlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0Ly8gd2lsbCBvY2N1ciBvbiBJRSBvbiBsYXN0RXZlbnQudHlwZSByZWZlcmVuY2UgaWYgbGFzdEV2ZW50IHBvaW50cyB0byBhIHByZXZpb3VzIGV2ZW50IHRoYXQgYWxyZWFkeVxuXHRcdFx0XHQvLyBmaW5pc2hlZCBidWJibGluZywgYnV0IHRoZSBzZXRUaW1lb3V0KCkgdG8gY2xlYXIgbGFzdEV2ZW50IGhhc24ndCBmaXJlZCB5ZXRcblx0XHRcdH1cblx0XHRcdGlmKCFldnQudGFyZ2V0KXsgLy8gY2hlY2sgdG8gc2VlIGlmIGl0IGhhcyBiZWVuIGZpeGVkIHlldFxuXHRcdFx0XHRldnQudGFyZ2V0ID0gZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0XHRcdGV2dC5jdXJyZW50VGFyZ2V0ID0gKHNlbmRlciB8fCBldnQuc3JjRWxlbWVudCk7XG5cdFx0XHRcdGlmKGV2dC50eXBlID09IFwibW91c2VvdmVyXCIpe1xuXHRcdFx0XHRcdGV2dC5yZWxhdGVkVGFyZ2V0ID0gZXZ0LmZyb21FbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV2dC50eXBlID09IFwibW91c2VvdXRcIil7XG5cdFx0XHRcdFx0ZXZ0LnJlbGF0ZWRUYXJnZXQgPSBldnQudG9FbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFldnQuc3RvcFByb3BhZ2F0aW9uKXtcblx0XHRcdFx0XHRldnQuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uO1xuXHRcdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaChldnQudHlwZSl7XG5cdFx0XHRcdFx0Y2FzZSBcImtleXByZXNzXCI6XG5cdFx0XHRcdFx0XHR2YXIgYyA9IChcImNoYXJDb2RlXCIgaW4gZXZ0ID8gZXZ0LmNoYXJDb2RlIDogZXZ0LmtleUNvZGUpO1xuXHRcdFx0XHRcdFx0aWYgKGM9PTEwKXtcblx0XHRcdFx0XHRcdFx0Ly8gQ1RSTC1FTlRFUiBpcyBDVFJMLUFTQ0lJKDEwKSBvbiBJRSwgYnV0IENUUkwtRU5URVIgb24gTW96aWxsYVxuXHRcdFx0XHRcdFx0XHRjPTA7XG5cdFx0XHRcdFx0XHRcdGV2dC5rZXlDb2RlID0gMTM7XG5cdFx0XHRcdFx0XHR9ZWxzZSBpZihjPT0xM3x8Yz09Mjcpe1xuXHRcdFx0XHRcdFx0XHRjPTA7IC8vIE1vemlsbGEgY29uc2lkZXJzIEVOVEVSIGFuZCBFU0Mgbm9uLXByaW50YWJsZVxuXHRcdFx0XHRcdFx0fWVsc2UgaWYoYz09Myl7XG5cdFx0XHRcdFx0XHRcdGM9OTk7IC8vIE1vemlsbGEgbWFwcyBDVFJMLUJSRUFLIHRvIENUUkwtY1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gTW96aWxsYSBzZXRzIGtleUNvZGUgdG8gMCB3aGVuIHRoZXJlIGlzIGEgY2hhckNvZGVcblx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHN0b3BzIHRoZSBldmVudCBvbiBJRS5cblx0XHRcdFx0XHRcdGV2dC5jaGFyQ29kZSA9IGM7XG5cdFx0XHRcdFx0XHRfc2V0S2V5Q2hhcihldnQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBldnQ7XG5cdFx0fTtcblx0XHR2YXIgbGFzdEV2ZW50LCBJRVNpZ25hbCA9IGZ1bmN0aW9uKGhhbmRsZSl7XG5cdFx0XHR0aGlzLmhhbmRsZSA9IGhhbmRsZTtcblx0XHR9O1xuXHRcdElFU2lnbmFsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpe1xuXHRcdFx0ZGVsZXRlIF9kb2pvSUVMaXN0ZW5lcnNfW3RoaXMuaGFuZGxlXTtcblx0XHR9O1xuXHRcdHZhciBmaXhMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcblx0XHRcdC8vIHRoaXMgaXMgYSBtaW5pbWFsIGZ1bmN0aW9uIGZvciBjbG9zaW5nIG9uIHRoZSBwcmV2aW91cyBsaXN0ZW5lciB3aXRoIGFzIGZldyBhcyB2YXJpYWJsZXMgYXMgcG9zc2libGVcblx0XHRcdHJldHVybiBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRldnQgPSBvbi5fZml4RXZlbnQoZXZ0LCB0aGlzKTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGxpc3RlbmVyLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0aWYoZXZ0Lm1vZGlmaWVkKXtcblx0XHRcdFx0XHQvLyBjYWNoZSB0aGUgbGFzdCBldmVudCBhbmQgcmV1c2UgaXQgaWYgd2UgY2FuXG5cdFx0XHRcdFx0aWYoIWxhc3RFdmVudCl7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGxhc3RFdmVudCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdEV2ZW50ID0gZXZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0dmFyIGZpeEF0dGFjaCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpe1xuXHRcdFx0bGlzdGVuZXIgPSBmaXhMaXN0ZW5lcihsaXN0ZW5lcik7XG5cdFx0XHRpZigoKHRhcmdldC5vd25lckRvY3VtZW50ID8gdGFyZ2V0Lm93bmVyRG9jdW1lbnQucGFyZW50V2luZG93IDogdGFyZ2V0LnBhcmVudFdpbmRvdyB8fCB0YXJnZXQud2luZG93IHx8IHdpbmRvdykgIT0gdG9wIHx8XG5cdFx0XHRcdFx0XHRoYXMoXCJqc2NyaXB0XCIpIDwgNS44KSAmJlxuXHRcdFx0XHRcdCFoYXMoXCJjb25maWctX2FsbG93X2xlYWtzXCIpKXtcblx0XHRcdFx0Ly8gSUUgd2lsbCBsZWFrIG1lbW9yeSBvbiBjZXJ0YWluIGhhbmRsZXJzIGluIGZyYW1lcyAoSUU4IGFuZCBlYXJsaWVyKSBhbmQgaW4gdW5hdHRhY2hlZCBET00gbm9kZXMgZm9yIEpTY3JpcHQgNS43IGFuZCBiZWxvdy5cblx0XHRcdFx0Ly8gSGVyZSB3ZSB1c2UgZ2xvYmFsIHJlZGlyZWN0aW9uIHRvIHNvbHZlIHRoZSBtZW1vcnkgbGVha3Ncblx0XHRcdFx0aWYodHlwZW9mIF9kb2pvSUVMaXN0ZW5lcnNfID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdF9kb2pvSUVMaXN0ZW5lcnNfID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGVtaXR0ZXIgPSB0YXJnZXRbdHlwZV07XG5cdFx0XHRcdGlmKCFlbWl0dGVyIHx8ICFlbWl0dGVyLmxpc3RlbmVycyl7XG5cdFx0XHRcdFx0dmFyIG9sZExpc3RlbmVyID0gZW1pdHRlcjtcblx0XHRcdFx0XHRlbWl0dGVyID0gRnVuY3Rpb24oJ2V2ZW50JywgJ3ZhciBjYWxsZWUgPSBhcmd1bWVudHMuY2FsbGVlOyBmb3IodmFyIGkgPSAwOyBpPGNhbGxlZS5saXN0ZW5lcnMubGVuZ3RoOyBpKyspe3ZhciBsaXN0ZW5lciA9IF9kb2pvSUVMaXN0ZW5lcnNfW2NhbGxlZS5saXN0ZW5lcnNbaV1dOyBpZihsaXN0ZW5lcil7bGlzdGVuZXIuY2FsbCh0aGlzLGV2ZW50KTt9fScpO1xuXHRcdFx0XHRcdGVtaXR0ZXIubGlzdGVuZXJzID0gW107XG5cdFx0XHRcdFx0dGFyZ2V0W3R5cGVdID0gZW1pdHRlcjtcblx0XHRcdFx0XHRlbWl0dGVyLmdsb2JhbCA9IHRoaXM7XG5cdFx0XHRcdFx0aWYob2xkTGlzdGVuZXIpe1xuXHRcdFx0XHRcdFx0ZW1pdHRlci5saXN0ZW5lcnMucHVzaChfZG9qb0lFTGlzdGVuZXJzXy5wdXNoKG9sZExpc3RlbmVyKSAtIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgaGFuZGxlO1xuXHRcdFx0XHRlbWl0dGVyLmxpc3RlbmVycy5wdXNoKGhhbmRsZSA9IChlbWl0dGVyLmdsb2JhbC5fZG9qb0lFTGlzdGVuZXJzXy5wdXNoKGxpc3RlbmVyKSAtIDEpKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBJRVNpZ25hbChoYW5kbGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFzcGVjdC5hZnRlcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9zZXRLZXlDaGFyID0gZnVuY3Rpb24oZXZ0KXtcblx0XHRcdGV2dC5rZXlDaGFyID0gZXZ0LmNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShldnQuY2hhckNvZGUpIDogJyc7XG5cdFx0XHRldnQuY2hhck9yQ29kZSA9IGV2dC5rZXlDaGFyIHx8IGV2dC5rZXlDb2RlO1x0Ly8gVE9ETzogcmVtb3ZlIGZvciAyLjBcblx0XHR9O1xuXHRcdC8vIENhbGxlZCBpbiBFdmVudCBzY29wZVxuXHRcdHZhciBzdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHRcdH07XG5cdFx0dmFyIHByZXZlbnREZWZhdWx0ID0gb24uX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFNldHRpbmcga2V5Q29kZSB0byAwIGlzIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50IGNlcnRhaW4ga2V5cHJlc3NlcyAobmFtZWx5XG5cdFx0XHQvLyBjdHJsLWNvbWJpbmF0aW9ucyB0aGF0IGNvcnJlc3BvbmQgdG8gbWVudSBhY2NlbGVyYXRvciBrZXlzKS5cblx0XHRcdC8vIE90b2gsIGl0IHByZXZlbnRzIHVwc3RyZWFtIGxpc3RlbmVycyBmcm9tIGdldHRpbmcgdGhpcyBpbmZvcm1hdGlvblxuXHRcdFx0Ly8gVHJ5IHRvIHNwbGl0IHRoZSBkaWZmZXJlbmNlIGhlcmUgYnkgY2xvYmJlcmluZyBrZXlDb2RlIG9ubHkgZm9yIGN0cmxcblx0XHRcdC8vIGNvbWJpbmF0aW9ucy4gSWYgeW91IHN0aWxsIG5lZWQgdG8gYWNjZXNzIHRoZSBrZXkgdXBzdHJlYW0sIGJ1YmJsZWRLZXlDb2RlIGlzXG5cdFx0XHQvLyBwcm92aWRlZCBhcyBhIHdvcmthcm91bmQuXG5cdFx0XHR0aGlzLmJ1YmJsZWRLZXlDb2RlID0gdGhpcy5rZXlDb2RlO1xuXHRcdFx0aWYodGhpcy5jdHJsS2V5KXtcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdC8vIHNxdWVsY2ggZXJyb3JzIHdoZW4ga2V5Q29kZSBpcyByZWFkLW9ubHlcblx0XHRcdFx0XHQvLyAoZS5nLiBpZiBrZXlDb2RlIGlzIGN0cmwgb3Igc2hpZnQpXG5cdFx0XHRcdFx0dGhpcy5rZXlDb2RlID0gMDtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5tb2RpZmllZCA9IHRydWU7IC8vIG1hcmsgaXQgYXMgbW9kaWZpZWQgIChmb3IgZGVmYXVsdFByZXZlbnRlZCBmbGFnKSBzbyB0aGUgZXZlbnQgd2lsbCBiZSBjYWNoZWQgaW4gSUVcblx0XHR9O1xuXHR9XG5cdGlmKGhhcyhcInRvdWNoXCIpKXtcblx0XHR2YXIgRXZlbnREZWxlZ2F0ZSA9IGZ1bmN0aW9uKCl7fTtcblx0XHR2YXIgd2luZG93T3JpZW50YXRpb24gPSB3aW5kb3cub3JpZW50YXRpb247XG5cdFx0dmFyIGZpeFRvdWNoTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCl7XG5cdFx0XHRcdC8vRXZlbnQgbm9ybWFsaXphdGlvbihmb3Igb250b3VjaHh4eCBhbmQgcmVzaXplKTpcblx0XHRcdFx0Ly8xLmluY29ycmVjdCBlLnBhZ2VYfHBhZ2VZIGluIGlPU1xuXHRcdFx0XHQvLzIudGhlcmUgYXJlIG5vIFwiZS5yb3RhdGlvblwiLCBcImUuc2NhbGVcIiBhbmQgXCJvbm9yaWVudGF0aW9uY2hhbmdlXCIgaW4gQW5kcm9pZFxuXHRcdFx0XHQvLzMuTW9yZSBUQkQgZS5nLiBmb3JjZSB8IHNjcmVlblggfCBzY3JlZW5YIHwgY2xpZW50WCB8IGNsaWVudFkgfCByYWRpdXNYIHwgcmFkaXVzWVxuXG5cdFx0XHRcdC8vIHNlZSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNvcnJlY3RlZFxuXHRcdFx0XHR2YXIgZXZlbnQgPSBvcmlnaW5hbEV2ZW50LmNvcnJlY3RlZDtcblx0XHRcdFx0aWYoIWV2ZW50KXtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IG9yaWdpbmFsRXZlbnQudHlwZTtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRkZWxldGUgb3JpZ2luYWxFdmVudC50eXBlOyAvLyBvbiBzb21lIEpTIGVuZ2luZXMgKGFuZHJvaWQpLCBkZWxldGluZyBwcm9wZXJ0aWVzIG1ha2VzIHRoZW0gbXV0YWJsZVxuXHRcdFx0XHRcdH1jYXRjaChlKXt9XG5cdFx0XHRcdFx0aWYob3JpZ2luYWxFdmVudC50eXBlKXtcblx0XHRcdFx0XHRcdC8vIERlbGV0aW5nIHRoZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgZGlkIG5vdCB3b3JrICh0aGlzIGlzIHRoZSBjYXNlIG9mXG5cdFx0XHRcdFx0XHQvLyBicm93c2VycyBzdWNoIGFzIG9sZGVyIFNhZmFyaSBpT1MpLCBoZW5jZSBmYWxsYmFjazpcblx0XHRcdFx0XHRcdGlmKGhhcyhcInRvdWNoLWNhbi1tb2RpZnktZXZlbnQtZGVsZWdhdGVcIikpe1xuXHRcdFx0XHRcdFx0XHQvLyBJZiBkZWxldGluZyBwcm9wZXJ0aWVzIG9mIGRlbGVnYXRlZCBldmVudCB3b3JrcywgdXNlIGV2ZW50IGRlbGVnYXRpb246XG5cdFx0XHRcdFx0XHRcdEV2ZW50RGVsZWdhdGUucHJvdG90eXBlID0gb3JpZ2luYWxFdmVudDtcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSBuZXcgRXZlbnREZWxlZ2F0ZTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UgbGFzdCBmYWxsYmFjazogb3RoZXIgYnJvd3NlcnMsIHN1Y2ggYXMgbW9iaWxlIEZpcmVmb3gsIGRvIG5vdCBsaWtlXG5cdFx0XHRcdFx0XHRcdC8vIGRlbGVnYXRlZCBwcm9wZXJ0aWVzLCBzbyB3ZSBoYXZlIHRvIGNvcHlcblx0XHRcdFx0XHRcdFx0ZXZlbnQgPSB7fTtcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBuYW1lIGluIG9yaWdpbmFsRXZlbnQpe1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50W25hbWVdID0gb3JpZ2luYWxFdmVudFtuYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gaGF2ZSB0byBkZWxlZ2F0ZSBtZXRob2RzIHRvIG1ha2UgdGhlbSB3b3JrXG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIGRlbGV0aW9uIHdvcmtlZCwgdXNlIHByb3BlcnR5IGFzIGlzXG5cdFx0XHRcdFx0XHRldmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cdFx0XHRcdFx0XHRldmVudC50eXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b3JpZ2luYWxFdmVudC5jb3JyZWN0ZWQgPSBldmVudDtcblx0XHRcdFx0XHRpZih0eXBlID09ICdyZXNpemUnKXtcblx0XHRcdFx0XHRcdGlmKHdpbmRvd09yaWVudGF0aW9uID09IHdpbmRvdy5vcmllbnRhdGlvbil7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsOy8vZG91YmxlIHRhcCBjYXVzZXMgYW4gdW5leHBlY3RlZCAncmVzaXplJyBpbiBBbmRyb2lkXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aW5kb3dPcmllbnRhdGlvbiA9IHdpbmRvdy5vcmllbnRhdGlvbjtcblx0XHRcdFx0XHRcdGV2ZW50LnR5cGUgPSBcIm9yaWVudGF0aW9uY2hhbmdlXCI7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFdlIHVzZSB0aGUgb3JpZ2luYWwgZXZlbnQgYW5kIGF1Z21lbnQsIHJhdGhlciB0aGFuIGRvaW5nIGFuIGV4cGVuc2l2ZSBtaXhpbiBvcGVyYXRpb25cblx0XHRcdFx0XHRpZighKFwicm90YXRpb25cIiBpbiBldmVudCkpeyAvLyB0ZXN0IHRvIHNlZSBpZiBpdCBoYXMgcm90YXRpb25cblx0XHRcdFx0XHRcdGV2ZW50LnJvdGF0aW9uID0gMDtcblx0XHRcdFx0XHRcdGV2ZW50LnNjYWxlID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHdpbmRvdy5Ub3VjaEV2ZW50ICYmIG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG5cdFx0XHRcdFx0XHQvLyB1c2UgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVh8cGFnZVl8c2NyZWVuWHxzY3JlZW5ZfGNsaWVudFh8Y2xpZW50WXx0YXJnZXRcblx0XHRcdFx0XHRcdHZhciBmaXJzdENoYW5nZVRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgaW4gZmlyc3RDaGFuZ2VUb3VjaCl7IC8vIHVzZSBmb3ItaW4sIHdlIGRvbid0IG5lZWQgdG8gaGF2ZSBkZXBlbmRlbmN5IG9uIGRvam8vX2Jhc2UvbGFuZyBoZXJlXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBldmVudFtpXTsgLy8gZGVsZXRlIGl0IGZpcnN0IHRvIG1ha2UgaXQgbXV0YWJsZVxuXHRcdFx0XHRcdFx0XHRldmVudFtpXSA9IGZpcnN0Q2hhbmdlVG91Y2hbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gb247XG59KTtcbiIsImRlZmluZShbXG5cdFwicmVxdWlyZVwiLCBcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9fYmFzZS9hcnJheVwiLCBcIi4vX2Jhc2UvY29uZmlnXCIsIFwiLi9kb21cIiwgXCIuL19iYXNlL3dpbmRvd1wiLFxuXHRcdFwiLi9fYmFzZS91cmxcIiwgXCIuL2FzcGVjdFwiLCBcIi4vcHJvbWlzZS9hbGxcIiwgXCIuL2RhdGUvc3RhbXBcIiwgXCIuL0RlZmVycmVkXCIsIFwiLi9oYXNcIiwgXCIuL3F1ZXJ5XCIsIFwiLi9vblwiLCBcIi4vcmVhZHlcIlxuXSwgZnVuY3Rpb24ocmVxdWlyZSwgZG9qbywgZGxhbmcsIGRhcnJheSwgY29uZmlnLCBkb20sIGR3aW5kb3csIF9VcmwsIGFzcGVjdCwgYWxsLCBkYXRlcywgRGVmZXJyZWQsIGhhcywgcXVlcnksIGRvbiwgcmVhZHkpe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9wYXJzZXJcblxuXHRuZXcgRGF0ZShcIlhcIik7IC8vIHdvcmthcm91bmQgZm9yICMxMTI3OSwgbmV3IERhdGUoXCJcIikgPT0gTmFOXG5cblx0Ly8gZGF0YS1kb2pvLXByb3BzIGV0Yy4gaXMgbm90IHJlc3RyaWN0ZWQgdG8gSlNPTiwgaXQgY2FuIGJlIGFueSBqYXZhc2NyaXB0XG5cdGZ1bmN0aW9uIG15RXZhbCh0ZXh0KXtcblx0XHRyZXR1cm4gZXZhbChcIihcIiArIHRleHQgKyBcIilcIik7XG5cdH1cblxuXHQvLyBXaWRnZXRzIGxpa2UgQm9yZGVyQ29udGFpbmVyIGFkZCBwcm9wZXJ0aWVzIHRvIF9XaWRnZXQgdmlhIGRvam8uZXh0ZW5kKCkuXG5cdC8vIElmIEJvcmRlckNvbnRhaW5lciBpcyBsb2FkZWQgYWZ0ZXIgX1dpZGdldCdzIHBhcmFtZXRlciBsaXN0IGhhcyBiZWVuIGNhY2hlZCxcblx0Ly8gd2UgbmVlZCB0byByZWZyZXNoIHRoYXQgcGFyYW1ldGVyIGxpc3QgKGZvciBfV2lkZ2V0IGFuZCBhbGwgd2lkZ2V0cyB0aGF0IGV4dGVuZCBfV2lkZ2V0KS5cblx0dmFyIGV4dGVuZENudCA9IDA7XG5cdGFzcGVjdC5hZnRlcihkbGFuZywgXCJleHRlbmRcIiwgZnVuY3Rpb24oKXtcblx0XHRleHRlbmRDbnQrKztcblx0fSwgdHJ1ZSk7XG5cblx0ZnVuY3Rpb24gZ2V0TmFtZU1hcChjdG9yKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHVybnMgbWFwIGZyb20gbG93ZXJjYXNlIG5hbWUgdG8gYXR0cmlidXRlIG5hbWUgaW4gY2xhc3MsIGV4OiB7b25jbGljazogXCJvbkNsaWNrXCJ9XG5cdFx0dmFyIG1hcCA9IGN0b3IuX25hbWVDYXNlTWFwLCBwcm90byA9IGN0b3IucHJvdG90eXBlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBtYXAgaWYgaXQncyB1bmRlZmluZWQuXG5cdFx0Ly8gUmVmcmVzaCB0aGUgbWFwIGlmIGEgc3VwZXJjbGFzcyB3YXMgcG9zc2libHkgZXh0ZW5kZWQgd2l0aCBuZXcgbWV0aG9kcyBzaW5jZSB0aGUgbWFwIHdhcyBjcmVhdGVkLlxuXHRcdGlmKCFtYXAgfHwgbWFwLl9leHRlbmRDbnQgPCBleHRlbmRDbnQpe1xuXHRcdFx0bWFwID0gY3Rvci5fbmFtZUNhc2VNYXAgPSB7fTtcblx0XHRcdGZvcih2YXIgbmFtZSBpbiBwcm90byl7XG5cdFx0XHRcdGlmKG5hbWUuY2hhckF0KDApID09PSBcIl9cIil7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cdC8vIHNraXAgaW50ZXJuYWwgcHJvcGVydGllc1xuXHRcdFx0XHRtYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0XHR9XG5cdFx0XHRtYXAuX2V4dGVuZENudCA9IGV4dGVuZENudDtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEN0b3IoLypTdHJpbmdbXSovIHR5cGVzLCAvKkZ1bmN0aW9uPyovIGNvbnRleHRSZXF1aXJlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFJldHJpZXZlcyBhIGNvbnN0cnVjdG9yLiAgSWYgdGhlIHR5cGVzIGFycmF5IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgY2xhc3MvTUlEIHRoZW4gdGhlXG5cdFx0Ly9cdFx0c3Vic2VxdWVudCBjbGFzc2VzIHdpbGwgYmUgbWl4ZWQgaW50byB0aGUgZmlyc3QgY2xhc3MgYW5kIGEgdW5pcXVlIGNvbnN0cnVjdG9yIHdpbGwgYmVcblx0XHQvL1x0XHRyZXR1cm5lZCBmb3IgdGhhdCBhcnJheS5cblxuXHRcdGlmKCFjb250ZXh0UmVxdWlyZSl7XG5cdFx0XHRjb250ZXh0UmVxdWlyZSA9IHJlcXVpcmU7XG5cdFx0fVxuXG5cdFx0Ly8gTWFwIGZyb20gd2lkZ2V0IG5hbWUgb3IgbGlzdCBvZiB3aWRnZXQgbmFtZXMoZXg6IFwiZGlqaXQvZm9ybS9CdXR0b24sYWNtZS9NeU1peGluXCIpIHRvIGEgY29uc3RydWN0b3IuXG5cdFx0Ly8gS2VlcCBzZXBhcmF0ZSBtYXAgZm9yIGVhY2ggcmVxdWlyZUNvbnRleHQgdG8gYXZvaWQgZmFsc2UgbWF0Y2hlcyAoZXg6IFwiLi9Gb29cIiBjYW4gbWVhbiBkaWZmZXJlbnQgdGhpbmdzXG5cdFx0Ly8gZGVwZW5kaW5nIG9uIGNvbnRleHQuKVxuXHRcdHZhciBjdG9yTWFwID0gY29udGV4dFJlcXVpcmUuX2Rvam9QYXJzZXJDdG9yTWFwIHx8IChjb250ZXh0UmVxdWlyZS5fZG9qb1BhcnNlckN0b3JNYXAgPSB7fSk7XG5cblx0XHR2YXIgdHMgPSB0eXBlcy5qb2luKCk7XG5cdFx0aWYoIWN0b3JNYXBbdHNdKXtcblx0XHRcdHZhciBtaXhpbnMgPSBbXTtcblx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSB0eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHR2YXIgdCA9IHR5cGVzW2ldO1xuXHRcdFx0XHQvLyBUT0RPOiBDb25zaWRlciBzd2FwcGluZyBnZXRPYmplY3QgYW5kIHJlcXVpcmUgaW4gdGhlIGZ1dHVyZVxuXHRcdFx0XHRtaXhpbnNbbWl4aW5zLmxlbmd0aF0gPSAoY3Rvck1hcFt0XSA9IGN0b3JNYXBbdF0gfHwgKGRsYW5nLmdldE9iamVjdCh0KSB8fCAofnQuaW5kZXhPZignLycpICYmXG5cdFx0XHRcdFx0Y29udGV4dFJlcXVpcmUodCkpKSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3RvciA9IG1peGlucy5zaGlmdCgpO1xuXHRcdFx0Y3Rvck1hcFt0c10gPSBtaXhpbnMubGVuZ3RoID8gKGN0b3IuY3JlYXRlU3ViY2xhc3MgPyBjdG9yLmNyZWF0ZVN1YmNsYXNzKG1peGlucykgOiBjdG9yLmV4dGVuZC5hcHBseShjdG9yLCBtaXhpbnMpKSA6IGN0b3I7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN0b3JNYXBbdHNdO1xuXHR9XG5cblx0dmFyIHBhcnNlciA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoZSBEb20vV2lkZ2V0IHBhcnNpbmcgcGFja2FnZVxuXG5cdFx0X2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2xlYXIgY2FjaGVkIGRhdGEuICAgVXNlZCBtYWlubHkgZm9yIGJlbmNobWFya2luZy5cblx0XHRcdGV4dGVuZENudCsrO1xuXHRcdFx0X2N0b3JNYXAgPSB7fTtcblx0XHR9LFxuXG5cdFx0X2Z1bmN0aW9uRnJvbVNjcmlwdDogZnVuY3Rpb24oc2NyaXB0LCBhdHRyRGF0YSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q29udmVydCBhIGA8c2NyaXB0IHR5cGU9XCJkb2pvL21ldGhvZFwiIGFyZ3M9XCJhLCBiLCBjXCI+IC4uLiA8L3NjcmlwdD5gXG5cdFx0XHQvL1x0XHRpbnRvIGEgZnVuY3Rpb25cblx0XHRcdC8vIHNjcmlwdDogRE9NTm9kZVxuXHRcdFx0Ly9cdFx0VGhlIGA8c2NyaXB0PmAgRE9NTm9kZVxuXHRcdFx0Ly8gYXR0ckRhdGE6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0Rm9yIEhUTUw1IGNvbXBsaWFuY2UsIHNlYXJjaGVzIGZvciBhdHRyRGF0YSArIFwiYXJnc1wiICh0eXBpY2FsbHlcblx0XHRcdC8vXHRcdFwiZGF0YS1kb2pvLWFyZ3NcIikgaW5zdGVhZCBvZiBcImFyZ3NcIlxuXHRcdFx0dmFyIHByZWFtYmxlID0gXCJcIixcblx0XHRcdFx0c3VmZml4ID0gXCJcIixcblx0XHRcdFx0YXJnc1N0ciA9IChzY3JpcHQuZ2V0QXR0cmlidXRlKGF0dHJEYXRhICsgXCJhcmdzXCIpIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJhcmdzXCIpKSxcblx0XHRcdFx0d2l0aFN0ciA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJ3aXRoXCIpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueSBhcmd1bWVudHMgc3VwcGxpZWQgaW4gc2NyaXB0IHRhZyBpbnRvIGFuIGFycmF5IHRvIGJlIHBhc3NlZCB0byB0aGVcblx0XHRcdHZhciBmbkFyZ3MgPSAoYXJnc1N0ciB8fCBcIlwiKS5zcGxpdCgvXFxzKixcXHMqLyk7XG5cblx0XHRcdGlmKHdpdGhTdHIgJiYgd2l0aFN0ci5sZW5ndGgpe1xuXHRcdFx0XHRkYXJyYXkuZm9yRWFjaCh3aXRoU3RyLnNwbGl0KC9cXHMqLFxccyovKSwgZnVuY3Rpb24ocGFydCl7XG5cdFx0XHRcdFx0cHJlYW1ibGUgKz0gXCJ3aXRoKFwiICsgcGFydCArIFwiKXtcIjtcblx0XHRcdFx0XHRzdWZmaXggKz0gXCJ9XCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uKGZuQXJncywgcHJlYW1ibGUgKyBzY3JpcHQuaW5uZXJIVE1MICsgc3VmZml4KTtcblx0XHR9LFxuXG5cdFx0aW5zdGFudGlhdGU6IGZ1bmN0aW9uKG5vZGVzLCBtaXhpbiwgb3B0aW9ucyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGFrZXMgYXJyYXkgb2Ygbm9kZXMsIGFuZCB0dXJucyB0aGVtIGludG8gY2xhc3MgaW5zdGFuY2VzIGFuZFxuXHRcdFx0Ly9cdFx0cG90ZW50aWFsbHkgY2FsbHMgYSBzdGFydHVwIG1ldGhvZCB0byBhbGxvdyB0aGVtIHRvIGNvbm5lY3Qgd2l0aFxuXHRcdFx0Ly9cdFx0YW55IGNoaWxkcmVuLlxuXHRcdFx0Ly8gbm9kZXM6IEFycmF5XG5cdFx0XHQvL1x0XHRBcnJheSBvZiBET00gbm9kZXNcblx0XHRcdC8vIG1peGluOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRBbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1peGVkIGluIHdpdGggZWFjaCBub2RlIGluIHRoZSBhcnJheS5cblx0XHRcdC8vXHRcdFZhbHVlcyBpbiB0aGUgbWl4aW4gd2lsbCBvdmVycmlkZSB2YWx1ZXMgaW4gdGhlIG5vZGUsIGlmIHRoZXlcblx0XHRcdC8vXHRcdGV4aXN0LlxuXHRcdFx0Ly8gb3B0aW9uczogT2JqZWN0P1xuXHRcdFx0Ly9cdFx0QW4gb2JqZWN0IHVzZWQgdG8gaG9sZCBrd0FyZ3MgZm9yIGluc3RhbnRpYXRpb24uXG5cdFx0XHQvL1x0XHRTZWUgcGFyc2Uub3B0aW9ucyBhcmd1bWVudCBmb3IgZGV0YWlscy5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBcnJheSBvZiBpbnN0YW5jZXMuXG5cblx0XHRcdG1peGluID0gbWl4aW4gfHwge307XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0dmFyIGRvam9UeXBlID0gKG9wdGlvbnMuc2NvcGUgfHwgZG9qby5fc2NvcGVOYW1lKSArIFwiVHlwZVwiLCAvLyB0eXBpY2FsbHkgXCJkb2pvVHlwZVwiXG5cdFx0XHRcdGF0dHJEYXRhID0gXCJkYXRhLVwiICsgKG9wdGlvbnMuc2NvcGUgfHwgZG9qby5fc2NvcGVOYW1lKSArIFwiLVwiLCAvLyB0eXBpY2FsbHkgXCJkYXRhLWRvam8tXCJcblx0XHRcdFx0ZGF0YURvam9UeXBlID0gYXR0ckRhdGEgKyBcInR5cGVcIiwgLy8gdHlwaWNhbGx5IFwiZGF0YS1kb2pvLXR5cGVcIlxuXHRcdFx0XHRkYXRhRG9qb01peGlucyA9IGF0dHJEYXRhICsgXCJtaXhpbnNcIjtcdFx0XHRcdFx0Ly8gdHlwaWNhbGx5IFwiZGF0YS1kb2pvLW1peGluc1wiXG5cblx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRkYXJyYXkuZm9yRWFjaChub2RlcywgZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHZhciB0eXBlID0gZG9qb1R5cGUgaW4gbWl4aW4gPyBtaXhpbltkb2pvVHlwZV0gOiBub2RlLmdldEF0dHJpYnV0ZShkYXRhRG9qb1R5cGUpIHx8IG5vZGUuZ2V0QXR0cmlidXRlKGRvam9UeXBlKTtcblx0XHRcdFx0aWYodHlwZSl7XG5cdFx0XHRcdFx0dmFyIG1peGluc1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoZGF0YURvam9NaXhpbnMpLFxuXHRcdFx0XHRcdFx0dHlwZXMgPSBtaXhpbnNWYWx1ZSA/IFt0eXBlXS5jb25jYXQobWl4aW5zVmFsdWUuc3BsaXQoL1xccyosXFxzKi8pKSA6IFt0eXBlXTtcblxuXHRcdFx0XHRcdGxpc3QucHVzaCh7XG5cdFx0XHRcdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0XHRcdFx0dHlwZXM6IHR5cGVzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbm9kZXMgYW5kIHJldHVybiB0aGUgbGlzdCBvZiBpbnN0YW5jZXMuXG5cdFx0XHRyZXR1cm4gdGhpcy5faW5zdGFudGlhdGUobGlzdCwgbWl4aW4sIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRfaW5zdGFudGlhdGU6IGZ1bmN0aW9uKG5vZGVzLCBtaXhpbiwgb3B0aW9ucywgcmV0dXJuUHJvbWlzZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0VGFrZXMgYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgbm9kZXMsIGFuZCB0dXJucyB0aGVtIGludG8gY2xhc3MgaW5zdGFuY2VzIGFuZFxuXHRcdFx0Ly9cdFx0cG90ZW50aWFsbHkgY2FsbHMgYSBzdGFydHVwIG1ldGhvZCB0byBhbGxvdyB0aGVtIHRvIGNvbm5lY3Qgd2l0aFxuXHRcdFx0Ly9cdFx0YW55IGNoaWxkcmVuLlxuXHRcdFx0Ly8gbm9kZXM6IEFycmF5XG5cdFx0XHQvL1x0XHRBcnJheSBvZiBvYmplY3RzIGxpa2Vcblx0XHRcdC8vXHR8XHRcdHtcblx0XHRcdC8vXHR8XHRcdFx0Y3RvcjogRnVuY3Rpb24gKG1heSBiZSBudWxsKVxuXHRcdFx0Ly9cdHxcdFx0XHR0eXBlczogW1wiZGlqaXQvZm9ybS9CdXR0b25cIiwgXCJhY21lL015TWl4aW5cIl0gKHVzZWQgaWYgY3RvciBub3Qgc3BlY2lmaWVkKVxuXHRcdFx0Ly9cdHxcdFx0XHRub2RlOiBET01Ob2RlLFxuXHRcdFx0Ly9cdHxcdFx0XHRzY3JpcHRzOiBbIC4uLiBdLFx0Ly8gYXJyYXkgb2YgPHNjcmlwdCB0eXBlPVwiZG9qby8uLi5cIj4gY2hpbGRyZW4gb2Ygbm9kZVxuXHRcdFx0Ly9cdHxcdFx0XHRpbmhlcml0ZWQ6IHsgLi4uIH1cdC8vIHNldHRpbmdzIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBsaWtlIGRpciwgdGhlbWUsIGV0Yy5cblx0XHRcdC8vXHR8XHRcdH1cblx0XHRcdC8vIG1peGluOiBPYmplY3Rcblx0XHRcdC8vXHRcdEFuIG9iamVjdCB0aGF0IHdpbGwgYmUgbWl4ZWQgaW4gd2l0aCBlYWNoIG5vZGUgaW4gdGhlIGFycmF5LlxuXHRcdFx0Ly9cdFx0VmFsdWVzIGluIHRoZSBtaXhpbiB3aWxsIG92ZXJyaWRlIHZhbHVlcyBpbiB0aGUgbm9kZSwgaWYgdGhleVxuXHRcdFx0Ly9cdFx0ZXhpc3QuXG5cdFx0XHQvLyBvcHRpb25zOiBPYmplY3Rcblx0XHRcdC8vXHRcdEFuIG9wdGlvbnMgb2JqZWN0IHVzZWQgdG8gaG9sZCBrd0FyZ3MgZm9yIGluc3RhbnRpYXRpb24uXG5cdFx0XHQvL1x0XHRTZWUgcGFyc2Uub3B0aW9ucyBhcmd1bWVudCBmb3IgZGV0YWlscy5cblx0XHRcdC8vIHJldHVyblByb21pc2U6IEJvb2xlYW5cblx0XHRcdC8vXHRcdFJldHVybiBhIFByb21pc2UgcmF0aGVyIHRoYW4gdGhlIGluc3RhbmNlOyBzdXBwb3J0cyBhc3luY2hyb25vdXMgd2lkZ2V0IGNyZWF0aW9uLlxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEFycmF5IG9mIGluc3RhbmNlcywgb3IgaWYgcmV0dXJuUHJvbWlzZSBpcyB0cnVlLCBhIHByb21pc2UgZm9yIGFycmF5IG9mIGluc3RhbmNlc1xuXHRcdFx0Ly9cdFx0dGhhdCByZXNvbHZlcyB3aGVuIGluc3RhbmNlcyBoYXZlIGZpbmlzaGVkIGluaXRpYWxpemluZy5cblxuXHRcdFx0Ly8gQ2FsbCB3aWRnZXQgY29uc3RydWN0b3JzLiAgIFNvbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJuIHByb21pc2VzLlxuXHRcdFx0dmFyIHRoZWxpc3QgPSBkYXJyYXkubWFwKG5vZGVzLCBmdW5jdGlvbihvYmope1xuXHRcdFx0XHR2YXIgY3RvciA9IG9iai5jdG9yIHx8IGdldEN0b3Iob2JqLnR5cGVzLCBvcHRpb25zLmNvbnRleHRSZXF1aXJlKTtcblx0XHRcdFx0Ly8gSWYgd2Ugc3RpbGwgaGF2ZW4ndCByZXNvbHZlZCBhIGN0b3IsIGl0IGlzIGZhdGFsIG5vd1xuXHRcdFx0XHRpZighY3Rvcil7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgY29uc3RydWN0b3IgZm9yOiAnXCIgKyBvYmoudHlwZXMuam9pbigpICsgXCInXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdChjdG9yLCBvYmoubm9kZSwgbWl4aW4sIG9wdGlvbnMsIG9iai5zY3JpcHRzLCBvYmouaW5oZXJpdGVkKTtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHQvLyBBZnRlciBhbGwgd2lkZ2V0IGNvbnN0cnVjdGlvbiBmaW5pc2hlcywgY2FsbCBzdGFydHVwIG9uIGVhY2ggdG9wIGxldmVsIGluc3RhbmNlIGlmIGl0IG1ha2VzIHNlbnNlIChhcyBmb3Jcblx0XHRcdC8vIHdpZGdldHMpLiAgUGFyZW50IHdpZGdldHMgd2lsbCByZWN1cnNpdmVseSBjYWxsIHN0YXJ0dXAgb24gdGhlaXIgKG5vbi10b3AgbGV2ZWwpIGNoaWxkcmVuXG5cdFx0XHRmdW5jdGlvbiBvbkNvbnN0cnVjdCh0aGVsaXN0KXtcblx0XHRcdFx0aWYoIW1peGluLl9zdGFydGVkICYmICFvcHRpb25zLm5vU3RhcnQpe1xuXHRcdFx0XHRcdGRhcnJheS5mb3JFYWNoKHRoZWxpc3QsIGZ1bmN0aW9uKGluc3RhbmNlKXtcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBpbnN0YW5jZS5zdGFydHVwID09PSBcImZ1bmN0aW9uXCIgJiYgIWluc3RhbmNlLl9zdGFydGVkKXtcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uuc3RhcnR1cCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoZWxpc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHJldHVyblByb21pc2Upe1xuXHRcdFx0XHRyZXR1cm4gYWxsKHRoZWxpc3QpLnRoZW4ob25Db25zdHJ1Y3QpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIEJhY2stY29tcGF0IHBhdGgsIHJlbW92ZSBmb3IgMi4wXG5cdFx0XHRcdHJldHVybiBvbkNvbnN0cnVjdCh0aGVsaXN0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y29uc3RydWN0OiBmdW5jdGlvbihjdG9yLCBub2RlLCBtaXhpbiwgb3B0aW9ucywgc2NyaXB0cywgaW5oZXJpdGVkKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDYWxscyBuZXcgY3RvcihwYXJhbXMsIG5vZGUpLCB3aGVyZSBwYXJhbXMgaXMgdGhlIGhhc2ggb2YgcGFyYW1ldGVycyBzcGVjaWZpZWQgb24gdGhlIG5vZGUsXG5cdFx0XHQvL1x0XHRleGNsdWRpbmcgZGF0YS1kb2pvLXR5cGUgYW5kIGRhdGEtZG9qby1taXhpbnMuICAgRG9lcyBub3QgY2FsbCBzdGFydHVwKCkuXG5cdFx0XHQvLyBjdG9yOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0V2lkZ2V0IGNvbnN0cnVjdG9yLlxuXHRcdFx0Ly8gbm9kZTogRE9NTm9kZVxuXHRcdFx0Ly9cdFx0VGhpcyBub2RlIHdpbGwgYmUgcmVwbGFjZWQvYXR0YWNoZWQgdG8gYnkgdGhlIHdpZGdldC4gIEl0IGFsc28gc3BlY2lmaWVzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byBjdG9yLlxuXHRcdFx0Ly8gbWl4aW46IE9iamVjdD9cblx0XHRcdC8vXHRcdEF0dHJpYnV0ZXMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBjdG9yLFxuXHRcdFx0Ly9cdFx0b3ZlcnJpZGluZyBhdHRyaWJ1dGVzIHNwZWNpZmllZCBvbiB0aGUgbm9kZS5cblx0XHRcdC8vIG9wdGlvbnM6IE9iamVjdD9cblx0XHRcdC8vXHRcdEFuIG9wdGlvbnMgb2JqZWN0IHVzZWQgdG8gaG9sZCBrd0FyZ3MgZm9yIGluc3RhbnRpYXRpb24uICAgU2VlIHBhcnNlLm9wdGlvbnMgYXJndW1lbnQgZm9yIGRldGFpbHMuXG5cdFx0XHQvLyBzY3JpcHRzOiBEb21Ob2RlW10/XG5cdFx0XHQvL1x0XHRBcnJheSBvZiBgPHNjcmlwdCB0eXBlPVwiZG9qby8qXCI+YCBET01Ob2Rlcy4gIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgc2VhcmNoIGZvciBgPHNjcmlwdD5gIHRhZ3MgaW5zaWRlIG5vZGUuXG5cdFx0XHQvLyBpbmhlcml0ZWQ6IE9iamVjdD9cblx0XHRcdC8vXHRcdFNldHRpbmdzIGZyb20gZGlyPXJ0bCBvciBsYW5nPS4uLiBvbiBhIG5vZGUgYWJvdmUgdGhpcyBub2RlLiAgIE92ZXJyaWRlcyBvcHRpb25zLmluaGVyaXRlZC5cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRJbnN0YW5jZSBvciBQcm9taXNlIGZvciB0aGUgaW5zdGFuY2UsIGlmIG1hcmt1cEZhY3RvcnkoKSBpdHNlbGYgcmV0dXJuZWQgYSBwcm9taXNlXG5cblx0XHRcdHZhciBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0Ly8gU2V0dXAgaGFzaCB0byBob2xkIHBhcmFtZXRlciBzZXR0aW5ncyBmb3IgdGhpcyB3aWRnZXQuXHRTdGFydCB3aXRoIHRoZSBwYXJhbWV0ZXJcblx0XHRcdC8vIHNldHRpbmdzIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyAoXCJkaXJcIiBhbmQgXCJsYW5nXCIpLlxuXHRcdFx0Ly8gSW5oZXJpdGVkIHNldHRpbmcgbWF5IGxhdGVyIGJlIG92ZXJyaWRkZW4gYnkgZXhwbGljaXQgc2V0dGluZ3Mgb24gbm9kZSBpdHNlbGYuXG5cdFx0XHR2YXIgcGFyYW1zID0ge307XG5cblx0XHRcdGlmKG9wdGlvbnMuZGVmYXVsdHMpe1xuXHRcdFx0XHQvLyBzZXR0aW5ncyBmb3IgdGhlIGRvY3VtZW50IGl0c2VsZiAob3Igd2hhdGV2ZXIgc3VidHJlZSBpcyBiZWluZyBwYXJzZWQpXG5cdFx0XHRcdGRsYW5nLm1peGluKHBhcmFtcywgb3B0aW9ucy5kZWZhdWx0cyk7XG5cdFx0XHR9XG5cdFx0XHRpZihpbmhlcml0ZWQpe1xuXHRcdFx0XHQvLyBzZXR0aW5ncyBmcm9tIGRpcj1ydGwgb3IgbGFuZz0uLi4gb24gYSBub2RlIGFib3ZlIHRoaXMgbm9kZVxuXHRcdFx0XHRkbGFuZy5taXhpbihwYXJhbXMsIGluaGVyaXRlZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCBsaXN0IG9mIGF0dHJpYnV0ZXMgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIG1hcmt1cFxuXHRcdFx0dmFyIGF0dHJpYnV0ZXM7XG5cdFx0XHRpZihoYXMoXCJkb20tYXR0cmlidXRlcy1leHBsaWNpdFwiKSl7XG5cdFx0XHRcdC8vIFN0YW5kYXJkIHBhdGggdG8gZ2V0IGxpc3Qgb2YgdXNlciBzcGVjaWZpZWQgYXR0cmlidXRlc1xuXHRcdFx0XHRhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXHRcdFx0fWVsc2UgaWYoaGFzKFwiZG9tLWF0dHJpYnV0ZXMtc3BlY2lmaWVkLWZsYWdcIikpe1xuXHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NpbmcgbmVlZGVkIGZvciBJRTgsIHRvIHNraXAgYSBmZXcgZmF1eCB2YWx1ZXMgaW4gYXR0cmlidXRlc1tdXG5cdFx0XHRcdGF0dHJpYnV0ZXMgPSBkYXJyYXkuZmlsdGVyKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24oYSl7XG5cdFx0XHRcdFx0cmV0dXJuIGEuc3BlY2lmaWVkO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBTcGVjaWFsIHBhdGggZm9yIElFNi03LCBhdm9pZCAoc29tZXRpbWVzID4xMDApIGJvZ3VzIGVudHJpZXMgaW4gbm9kZS5hdHRyaWJ1dGVzXG5cdFx0XHRcdHZhciBjbG9uZSA9IC9eaW5wdXQkfF5pbWckL2kudGVzdChub2RlLm5vZGVOYW1lKSA/IG5vZGUgOiBub2RlLmNsb25lTm9kZShmYWxzZSksXG5cdFx0XHRcdFx0YXR0cnMgPSBjbG9uZS5vdXRlckhUTUwucmVwbGFjZSgvPVteXFxzXCInXSt8PVwiW15cIl0qXCJ8PSdbXiddKicvZywgXCJcIikucmVwbGFjZSgvXlxccyo8W2EtekEtWjAtOV0qXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xccyo+LiokLywgXCJcIik7XG5cblx0XHRcdFx0YXR0cmlidXRlcyA9IGRhcnJheS5tYXAoYXR0cnMuc3BsaXQoL1xccysvKSwgZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdFx0dmFyIGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdC8vIGdldEF0dHJpYnV0ZSgpIGRvZXNuJ3Qgd29yayBmb3IgYnV0dG9uLnZhbHVlLCByZXR1cm5zIGlubmVySFRNTCBvZiBidXR0b24uXG5cdFx0XHRcdFx0XHQvLyBidXQgZ2V0QXR0cmlidXRlTm9kZSgpLnZhbHVlIGRvZXNuJ3Qgd29yayBmb3IgdGhlIGZvcm0uZW5jVHlwZSBvciBsaS52YWx1ZVxuXHRcdFx0XHRcdFx0dmFsdWU6IChub2RlLm5vZGVOYW1lID09IFwiTElcIiAmJiBuYW1lID09IFwidmFsdWVcIikgfHwgbGNOYW1lID09IFwiZW5jdHlwZVwiID9cblx0XHRcdFx0XHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUobGNOYW1lKSA6IG5vZGUuZ2V0QXR0cmlidXRlTm9kZShsY05hbWUpLnZhbHVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhc2ggdG8gY29udmVydCBzY29wZWQgYXR0cmlidXRlIG5hbWUgKGV4OiBkYXRhLWRvam8xNy1wYXJhbXMpIHRvIHNvbWV0aGluZyBmcmllbmRseSAoZXg6IGRhdGEtZG9qby1wYXJhbXMpXG5cdFx0XHQvLyBUT0RPOiByZW1vdmUgc2NvcGUgZm9yIDIuMFxuXHRcdFx0dmFyIHNjb3BlID0gb3B0aW9ucy5zY29wZSB8fCBkb2pvLl9zY29wZU5hbWUsXG5cdFx0XHRcdGF0dHJEYXRhID0gXCJkYXRhLVwiICsgc2NvcGUgKyBcIi1cIiwgLy8gdHlwaWNhbGx5IFwiZGF0YS1kb2pvLVwiXG5cdFx0XHRcdGhhc2ggPSB7fTtcblx0XHRcdGlmKHNjb3BlICE9PSBcImRvam9cIil7XG5cdFx0XHRcdGhhc2hbYXR0ckRhdGEgKyBcInByb3BzXCJdID0gXCJkYXRhLWRvam8tcHJvcHNcIjtcblx0XHRcdFx0aGFzaFthdHRyRGF0YSArIFwidHlwZVwiXSA9IFwiZGF0YS1kb2pvLXR5cGVcIjtcblx0XHRcdFx0aGFzaFthdHRyRGF0YSArIFwibWl4aW5zXCJdID0gXCJkYXRhLWRvam8tbWl4aW5zXCI7XG5cdFx0XHRcdGhhc2hbc2NvcGUgKyBcInR5cGVcIl0gPSBcImRvam90eXBlXCI7XG5cdFx0XHRcdGhhc2hbYXR0ckRhdGEgKyBcImlkXCJdID0gXCJkYXRhLWRvam8taWRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVhZCBpbiBhdHRyaWJ1dGVzIGFuZCBwcm9jZXNzIHRoZW0sIGluY2x1ZGluZyBkYXRhLWRvam8tcHJvcHMsIGRhdGEtZG9qby10eXBlLFxuXHRcdFx0Ly8gZG9qb0F0dGFjaFBvaW50LCBldGMuLCBhcyB3ZWxsIGFzIG5vcm1hbCBmb289YmFyIGF0dHJpYnV0ZXMuXG5cdFx0XHR2YXIgaSA9IDAsIGl0ZW0sIGZ1bmNBdHRycyA9IFtdLCBqc25hbWUsIGV4dHJhO1xuXHRcdFx0d2hpbGUoaXRlbSA9IGF0dHJpYnV0ZXNbaSsrXSl7XG5cdFx0XHRcdHZhciBuYW1lID0gaXRlbS5uYW1lLFxuXHRcdFx0XHRcdGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHR2YWx1ZSA9IGl0ZW0udmFsdWU7XG5cblx0XHRcdFx0c3dpdGNoKGhhc2hbbGNOYW1lXSB8fCBsY05hbWUpe1xuXHRcdFx0XHQvLyBBbHJlYWR5IHByb2Nlc3NlZCwganVzdCBpZ25vcmVcblx0XHRcdFx0Y2FzZSBcImRhdGEtZG9qby10eXBlXCI6XG5cdFx0XHRcdGNhc2UgXCJkb2pvdHlwZVwiOlxuXHRcdFx0XHRjYXNlIFwiZGF0YS1kb2pvLW1peGluc1wiOlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIERhdGEtZG9qby1wcm9wcy4gICBTYXZlIGZvciBsYXRlciB0byBtYWtlIHN1cmUgaXQgb3ZlcnJpZGVzIGRpcmVjdCBmb289YmFyIHNldHRpbmdzXG5cdFx0XHRcdGNhc2UgXCJkYXRhLWRvam8tcHJvcHNcIjpcblx0XHRcdFx0XHRleHRyYSA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIGRhdGEtZG9qby1pZCBvciBqc0lkLiBUT0RPOiBkcm9wIGpzSWQgaW4gMi4wXG5cdFx0XHRcdGNhc2UgXCJkYXRhLWRvam8taWRcIjpcblx0XHRcdFx0Y2FzZSBcImpzaWRcIjpcblx0XHRcdFx0XHRqc25hbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBGb3IgdGhlIGJlbmVmaXQgb2YgX1RlbXBsYXRlZFxuXHRcdFx0XHRjYXNlIFwiZGF0YS1kb2pvLWF0dGFjaC1wb2ludFwiOlxuXHRcdFx0XHRjYXNlIFwiZG9qb2F0dGFjaHBvaW50XCI6XG5cdFx0XHRcdFx0cGFyYW1zLmRvam9BdHRhY2hQb2ludCA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGF0YS1kb2pvLWF0dGFjaC1ldmVudFwiOlxuXHRcdFx0XHRjYXNlIFwiZG9qb2F0dGFjaGV2ZW50XCI6XG5cdFx0XHRcdFx0cGFyYW1zLmRvam9BdHRhY2hFdmVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdC8vIFNwZWNpYWwgcGFyYW1ldGVyIGhhbmRsaW5nIG5lZWRlZCBmb3IgSUVcblx0XHRcdFx0Y2FzZSBcImNsYXNzXCI6XG5cdFx0XHRcdFx0cGFyYW1zW1wiY2xhc3NcIl0gPSBub2RlLmNsYXNzTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInN0eWxlXCI6XG5cdFx0XHRcdFx0cGFyYW1zW1wic3R5bGVcIl0gPSBub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUuY3NzVGV4dDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBOb3JtYWwgYXR0cmlidXRlLCBleDogdmFsdWU9XCIxMjNcIlxuXG5cdFx0XHRcdFx0Ly8gRmluZCBhdHRyaWJ1dGUgaW4gd2lkZ2V0IGNvcnJlc3BvbmRpbmcgdG8gc3BlY2lmaWVkIG5hbWUuXG5cdFx0XHRcdFx0Ly8gTWF5IGludm9sdmUgY2FzZSBjb252ZXJzaW9uLCBleDogb25jbGljayAtLT4gb25DbGlja1xuXHRcdFx0XHRcdGlmKCEobmFtZSBpbiBwcm90bykpe1xuXHRcdFx0XHRcdFx0dmFyIG1hcCA9IGdldE5hbWVNYXAoY3Rvcik7XG5cdFx0XHRcdFx0XHRuYW1lID0gbWFwW2xjTmFtZV0gfHwgbmFtZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgcGFyYW1zW25hbWVdIHRvIHZhbHVlLCBkb2luZyB0eXBlIGNvbnZlcnNpb25cblx0XHRcdFx0XHRpZihuYW1lIGluIHByb3RvKXtcblx0XHRcdFx0XHRcdHN3aXRjaCh0eXBlb2YgcHJvdG9bbmFtZV0pe1xuXHRcdFx0XHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0XHRcdFx0XHRwYXJhbXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1tuYW1lXSA9IHZhbHVlLmxlbmd0aCA/IE51bWJlcih2YWx1ZSkgOiBOYU47XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcImJvb2xlYW5cIjpcblx0XHRcdFx0XHRcdFx0Ly8gZm9yIGNoZWNrZWQvZGlzYWJsZWQgdmFsdWUgbWlnaHQgYmUgXCJcIiBvciBcImNoZWNrZWRcIi5cdCBpbnRlcnByZXQgYXMgdHJ1ZS5cblx0XHRcdFx0XHRcdFx0cGFyYW1zW25hbWVdID0gdmFsdWUudG9Mb3dlckNhc2UoKSAhPSBcImZhbHNlXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRcdFx0XHRcdGlmKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlLnNlYXJjaCgvW15cXHdcXC5dKy9pKSAhPSAtMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIHVzZXIgaGFzIHNwZWNpZmllZCBzb21lIHRleHQgZm9yIGEgZnVuY3Rpb24gbGlrZSBcInJldHVybiB4KzVcIlxuXHRcdFx0XHRcdFx0XHRcdHBhcmFtc1tuYW1lXSA9IG5ldyBGdW5jdGlvbih2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgdGhlIG5hbWUgb2YgYSBnbG9iYWwgZnVuY3Rpb24gbGlrZSBcIm15T25DbGlja1wiXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3IgYSBzaW5nbGUgd29yZCBmdW5jdGlvbiBcInJldHVyblwiXG5cdFx0XHRcdFx0XHRcdFx0cGFyYW1zW25hbWVdID0gZGxhbmcuZ2V0T2JqZWN0KHZhbHVlLCBmYWxzZSkgfHwgbmV3IEZ1bmN0aW9uKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmdW5jQXR0cnMucHVzaChuYW1lKTtcdC8vIHByZXZlbnQgXCJkb3VibGUgY29ubmVjdFwiLCBzZWUgIzE1MDI2XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0dmFyIHBWYWwgPSBwcm90b1tuYW1lXTtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW25hbWVdID1cblx0XHRcdFx0XHRcdFx0XHQocFZhbCAmJiBcImxlbmd0aFwiIGluIHBWYWwpID8gKHZhbHVlID8gdmFsdWUuc3BsaXQoL1xccyosXFxzKi8pIDogW10pIDpcdC8vIGFycmF5XG5cdFx0XHRcdFx0XHRcdFx0XHQocFZhbCBpbnN0YW5jZW9mIERhdGUpID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0KHZhbHVlID09IFwiXCIgPyBuZXcgRGF0ZShcIlwiKSA6XHQvLyB0aGUgTmFOIG9mIGRhdGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlID09IFwibm93XCIgPyBuZXcgRGF0ZSgpIDpcdC8vIGN1cnJlbnQgZGF0ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRlcy5mcm9tSVNPU3RyaW5nKHZhbHVlKSkgOlxuXHRcdFx0XHRcdFx0XHRcdChwVmFsIGluc3RhbmNlb2YgX1VybCkgPyAoZG9qby5iYXNlVXJsICsgdmFsdWUpIDpcblx0XHRcdFx0XHRcdFx0XHRteUV2YWwodmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cGFyYW1zW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBmdW5jdGlvbiBhdHRyaWJ1dGVzIGZyb20gRE9NTm9kZSB0byBwcmV2ZW50IFwiZG91YmxlIGNvbm5lY3RcIiBwcm9ibGVtLCBzZWUgIzE1MDI2LlxuXHRcdFx0Ly8gRG8gdGhpcyBhcyBhIHNlcGFyYXRlIGxvb3Agc2luY2UgYXR0cmlidXRlc1tdIGlzIG9mdGVuIGEgbGl2ZSBjb2xsZWN0aW9uIChkZXBlbmRzIG9uIHRoZSBicm93c2VyIHRob3VnaCkuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZnVuY0F0dHJzLmxlbmd0aDsgaisrKXtcblx0XHRcdFx0dmFyIGxjZm5hbWUgPSBmdW5jQXR0cnNbal0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobGNmbmFtZSk7XG5cdFx0XHRcdG5vZGVbbGNmbmFtZV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNaXggdGhpbmdzIGZvdW5kIGluIGRhdGEtZG9qby1wcm9wcyBpbnRvIHRoZSBwYXJhbXMsIG92ZXJyaWRpbmcgYW55IGRpcmVjdCBzZXR0aW5nc1xuXHRcdFx0aWYoZXh0cmEpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0ZXh0cmEgPSBteUV2YWwuY2FsbChvcHRpb25zLnByb3BzVGhpcywgXCJ7XCIgKyBleHRyYSArIFwifVwiKTtcblx0XHRcdFx0XHRkbGFuZy5taXhpbihwYXJhbXMsIGV4dHJhKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdC8vIGdpdmUgdGhlIHVzZXIgYSBwb2ludGVyIHRvIHRoZWlyIGludmFsaWQgcGFyYW1ldGVycy4gRklYTUU6IGNhbiB3ZSBraWxsIHRoaXMgaW4gcHJvZHVjdGlvbj9cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZS50b1N0cmluZygpICsgXCIgaW4gZGF0YS1kb2pvLXByb3BzPSdcIiArIGV4dHJhICsgXCInXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFueSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiBcIm1peGluXCIgb3ZlcnJpZGUgZXZlcnl0aGluZyBlbHNlLlxuXHRcdFx0ZGxhbmcubWl4aW4ocGFyYW1zLCBtaXhpbik7XG5cblx0XHRcdC8vIEdldCA8c2NyaXB0PiBub2RlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB3aWRnZXQsIGlmIHRoZXkgd2VyZW4ndCBzcGVjaWZpZWQgZXhwbGljaXRseVxuXHRcdFx0aWYoIXNjcmlwdHMpe1xuXHRcdFx0XHRzY3JpcHRzID0gKGN0b3IgJiYgKGN0b3IuX25vU2NyaXB0IHx8IHByb3RvLl9ub1NjcmlwdCkgPyBbXSA6IHF1ZXJ5KFwiPiBzY3JpcHRbdHlwZV49J2Rvam8vJ11cIiwgbm9kZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcm9jZXNzIDxzY3JpcHQgdHlwZT1cImRvam8vKlwiPiBzY3JpcHQgdGFnc1xuXHRcdFx0Ly8gPHNjcmlwdCB0eXBlPVwiZG9qby9tZXRob2RcIiBkYXRhLWRvam8tZXZlbnQ9XCJmb29cIj4gdGFncyBhcmUgYWRkZWQgdG8gcGFyYW1zLCBhbmQgcGFzc2VkIHRvXG5cdFx0XHQvLyB0aGUgd2lkZ2V0IG9uIGluc3RhbnRpYXRpb24uXG5cdFx0XHQvLyA8c2NyaXB0IHR5cGU9XCJkb2pvL21ldGhvZFwiPiB0YWdzICh3aXRoIG5vIGV2ZW50KSBhcmUgZXhlY3V0ZWQgYWZ0ZXIgaW5zdGFudGlhdGlvblxuXHRcdFx0Ly8gPHNjcmlwdCB0eXBlPVwiZG9qby9jb25uZWN0XCIgZGF0YS1kb2pvLWV2ZW50PVwiZm9vXCI+IHRhZ3MgYXJlIGRvam8uY29ubmVjdGVkIGFmdGVyIGluc3RhbnRpYXRpb24sXG5cdFx0XHQvLyBhbmQgbGlrZXdpc2Ugd2l0aCA8c2NyaXB0IHR5cGU9XCJkb2pvL2FzcGVjdFwiIGRhdGEtZG9qby1tZXRob2Q9XCJmb29cIj5cblx0XHRcdC8vIDxzY3JpcHQgdHlwZT1cImRvam8vd2F0Y2hcIiBkYXRhLWRvam8tcHJvcD1cImZvb1wiPiB0YWdzIGFyZSBkb2pvLndhdGNoIGFmdGVyIGluc3RhbnRpYXRpb25cblx0XHRcdC8vIDxzY3JpcHQgdHlwZT1cImRvam8vb25cIiBkYXRhLWRvam8tZXZlbnQ9XCJmb29cIj4gdGFncyBhcmUgZG9qby5vbiBhZnRlciBpbnN0YW50aWF0aW9uXG5cdFx0XHQvLyBub3RlOiBkb2pvLyogc2NyaXB0IHRhZ3MgY2Fubm90IGV4aXN0IGluIHNlbGYgY2xvc2luZyB3aWRnZXRzLCBsaWtlIDxpbnB1dCAvPlxuXHRcdFx0dmFyIGFzcGVjdHMgPSBbXSxcdC8vIGFzcGVjdHMgdG8gY29ubmVjdCBhZnRlciBpbnN0YW50aWF0aW9uXG5cdFx0XHRcdGNhbGxzID0gW10sXHRcdC8vIGZ1bmN0aW9ucyB0byBjYWxsIGFmdGVyIGluc3RhbnRpYXRpb25cblx0XHRcdFx0d2F0Y2hlcyA9IFtdLCAgLy8gZnVuY3Rpb25zIHRvIHdhdGNoIGFmdGVyIGluc3RhbnRpYXRpb25cblx0XHRcdFx0b25zID0gW107IC8vIGZ1bmN0aW9ucyB0byBvbiBhZnRlciBpbnN0YW50aWF0aW9uXG5cblx0XHRcdGlmKHNjcmlwdHMpe1xuXHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHR2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdFx0Ly8gRklYTUU6IGRyb3AgZXZlbnQ9XCJcIiBzdXBwb3J0IGluIDIuMC4gdXNlIGRhdGEtZG9qby1ldmVudD1cIlwiIGluc3RlYWRcblx0XHRcdFx0XHR2YXIgZXZlbnQgPSAoc2NyaXB0LmdldEF0dHJpYnV0ZShhdHRyRGF0YSArIFwiZXZlbnRcIikgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZShcImV2ZW50XCIpKSxcblx0XHRcdFx0XHRcdHByb3AgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKGF0dHJEYXRhICsgXCJwcm9wXCIpLFxuXHRcdFx0XHRcdFx0bWV0aG9kID0gc2NyaXB0LmdldEF0dHJpYnV0ZShhdHRyRGF0YSArIFwibWV0aG9kXCIpLFxuXHRcdFx0XHRcdFx0YWR2aWNlID0gc2NyaXB0LmdldEF0dHJpYnV0ZShhdHRyRGF0YSArIFwiYWR2aWNlXCIpLFxuXHRcdFx0XHRcdFx0c2NyaXB0VHlwZSA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpLFxuXHRcdFx0XHRcdFx0bmYgPSB0aGlzLl9mdW5jdGlvbkZyb21TY3JpcHQoc2NyaXB0LCBhdHRyRGF0YSk7XG5cdFx0XHRcdFx0aWYoZXZlbnQpe1xuXHRcdFx0XHRcdFx0aWYoc2NyaXB0VHlwZSA9PSBcImRvam8vY29ubmVjdFwiKXtcblx0XHRcdFx0XHRcdFx0YXNwZWN0cy5wdXNoKHsgbWV0aG9kOiBldmVudCwgZnVuYzogbmYgfSk7XG5cdFx0XHRcdFx0XHR9ZWxzZSBpZihzY3JpcHRUeXBlID09IFwiZG9qby9vblwiKXtcblx0XHRcdFx0XHRcdFx0b25zLnB1c2goeyBldmVudDogZXZlbnQsIGZ1bmM6IG5mIH0pO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIDxzY3JpcHQgdHlwZT1cImRvam8vbWV0aG9kXCIgZGF0YS1kb2pvLWV2ZW50PVwiZm9vXCI+XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE8gZm9yIDIuMDogdXNlIGRhdGEtZG9qby1tZXRob2Q9XCJmb29cIiBpbnN0ZWFkIChhbHNvIGFmZmVjdHMgZGlqaXQvRGVjbGFyYXRpb24pXG5cdFx0XHRcdFx0XHRcdHBhcmFtc1tldmVudF0gPSBuZjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ZWxzZSBpZihzY3JpcHRUeXBlID09IFwiZG9qby9hc3BlY3RcIil7XG5cdFx0XHRcdFx0XHRhc3BlY3RzLnB1c2goeyBtZXRob2Q6IG1ldGhvZCwgYWR2aWNlOiBhZHZpY2UsIGZ1bmM6IG5mIH0pO1xuXHRcdFx0XHRcdH1lbHNlIGlmKHNjcmlwdFR5cGUgPT0gXCJkb2pvL3dhdGNoXCIpe1xuXHRcdFx0XHRcdFx0d2F0Y2hlcy5wdXNoKHsgcHJvcDogcHJvcCwgZnVuYzogbmYgfSk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRjYWxscy5wdXNoKG5mKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBpbnN0YW5jZVxuXHRcdFx0dmFyIG1hcmt1cEZhY3RvcnkgPSBjdG9yLm1hcmt1cEZhY3RvcnkgfHwgcHJvdG8ubWFya3VwRmFjdG9yeTtcblx0XHRcdHZhciBpbnN0YW5jZSA9IG1hcmt1cEZhY3RvcnkgPyBtYXJrdXBGYWN0b3J5KHBhcmFtcywgbm9kZSwgY3RvcikgOiBuZXcgY3RvcihwYXJhbXMsIG5vZGUpO1xuXG5cdFx0XHRmdW5jdGlvbiBvbkluc3RhbnRpYXRlKGluc3RhbmNlKXtcblx0XHRcdFx0Ly8gbWFwIGl0IHRvIHRoZSBKUyBuYW1lc3BhY2UgaWYgdGhhdCBtYWtlcyBzZW5zZVxuXHRcdFx0XHRpZihqc25hbWUpe1xuXHRcdFx0XHRcdGRsYW5nLnNldE9iamVjdChqc25hbWUsIGluc3RhbmNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByb2Nlc3MgY29ubmVjdGlvbnMgYW5kIHN0YXJ0dXAgZnVuY3Rpb25zXG5cdFx0XHRcdGZvcihpID0gMDsgaSA8IGFzcGVjdHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGFzcGVjdFthc3BlY3RzW2ldLmFkdmljZSB8fCBcImFmdGVyXCJdKGluc3RhbmNlLCBhc3BlY3RzW2ldLm1ldGhvZCwgZGxhbmcuaGl0Y2goaW5zdGFuY2UsIGFzcGVjdHNbaV0uZnVuYyksIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcihpID0gMDsgaSA8IGNhbGxzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRjYWxsc1tpXS5jYWxsKGluc3RhbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IoaSA9IDA7IGkgPCB3YXRjaGVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRpbnN0YW5jZS53YXRjaCh3YXRjaGVzW2ldLnByb3AsIHdhdGNoZXNbaV0uZnVuYyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgb25zLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRkb24oaW5zdGFuY2UsIG9uc1tpXS5ldmVudCwgb25zW2ldLmZ1bmMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGluc3RhbmNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihpbnN0YW5jZS50aGVuKXtcblx0XHRcdFx0cmV0dXJuIGluc3RhbmNlLnRoZW4ob25JbnN0YW50aWF0ZSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIG9uSW5zdGFudGlhdGUoaW5zdGFuY2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzY2FuOiBmdW5jdGlvbihyb290LCBvcHRpb25zKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRTY2FuIGEgRE9NIHRyZWUgYW5kIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgRE9NTm9kZXNcblx0XHRcdC8vXHRcdHRoYXQgbmVlZCB0byBiZSB0dXJuZWQgaW50byB3aWRnZXRzLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRTZWFyY2ggc3BlY2lmaWVkIG5vZGUgKG9yIGRvY3VtZW50IHJvb3Qgbm9kZSkgcmVjdXJzaXZlbHkgZm9yIGNsYXNzIGluc3RhbmNlc1xuXHRcdFx0Ly9cdFx0YW5kIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHBvdGVudGlhbCB3aWRnZXRzIHRvIGJlXG5cdFx0XHQvL1x0XHRpbnN0YW50aWF0ZWQuIFNlYXJjaGVzIGZvciBlaXRoZXIgZGF0YS1kb2pvLXR5cGU9XCJNSURcIiBvciBkb2pvVHlwZT1cIk1JRFwiIHdoZXJlXG5cdFx0XHQvL1x0XHRcIk1JRFwiIGlzIGEgbW9kdWxlIElEIGxpa2UgXCJkaWppdC9mb3JtL0J1dHRvblwiIG9yIGEgZnVsbHkgcXVhbGlmaWVkIENsYXNzIG5hbWVcblx0XHRcdC8vXHRcdGxpa2UgXCJkaWppdC9mb3JtL0J1dHRvblwiLiAgSWYgdGhlIE1JRCBpcyBub3QgY3VycmVudGx5IGF2YWlsYWJsZSwgc2NhbiB3aWxsXG5cdFx0XHQvL1x0XHRhdHRlbXB0IHRvIHJlcXVpcmUoKSBpbiB0aGUgbW9kdWxlLlxuXHRcdFx0Ly9cblx0XHRcdC8vXHRcdFNlZSBwYXJzZXIucGFyc2UoKSBmb3IgZGV0YWlscyBvZiBtYXJrdXAuXG5cdFx0XHQvLyByb290OiBEb21Ob2RlP1xuXHRcdFx0Ly9cdFx0QSBkZWZhdWx0IHN0YXJ0aW5nIHJvb3Qgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBwYXJzaW5nLiBDYW4gYmVcblx0XHRcdC8vXHRcdG9taXR0ZWQsIGRlZmF1bHRpbmcgdG8gdGhlIGVudGlyZSBkb2N1bWVudC4gSWYgb21pdHRlZCwgdGhlIGBvcHRpb25zYFxuXHRcdFx0Ly9cdFx0b2JqZWN0IGNhbiBiZSBwYXNzZWQgaW4gdGhpcyBwbGFjZS4gSWYgdGhlIGBvcHRpb25zYCBvYmplY3QgaGFzIGFcblx0XHRcdC8vXHRcdGByb290Tm9kZWAgbWVtYmVyLCB0aGF0IGlzIHVzZWQuXG5cdFx0XHQvLyBvcHRpb25zOiBPYmplY3Rcblx0XHRcdC8vXHRcdGEga3dBcmdzIG9wdGlvbnMgb2JqZWN0LCBzZWUgcGFyc2UoKSBmb3IgZGV0YWlsc1xuXHRcdFx0Ly9cblx0XHRcdC8vIHJldHVybnM6IFByb21pc2Vcblx0XHRcdC8vXHRcdEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIHBhcnNlZC5cblxuXHRcdFx0dmFyIGxpc3QgPSBbXSwgLy8gT3V0cHV0IExpc3Rcblx0XHRcdFx0bWlkcyA9IFtdLCAvLyBBbiBhcnJheSBvZiBtb2R1bGVzIHRoYXQgYXJlIG5vdCB5ZXQgbG9hZGVkXG5cdFx0XHRcdG1pZHNIYXNoID0ge307IC8vIFVzZWQgdG8ga2VlcCB0aGUgbWlkcyBhcnJheSB1bmlxdWVcblxuXHRcdFx0dmFyIGRvam9UeXBlID0gKG9wdGlvbnMuc2NvcGUgfHwgZG9qby5fc2NvcGVOYW1lKSArIFwiVHlwZVwiLCAvLyB0eXBpY2FsbHkgXCJkb2pvVHlwZVwiXG5cdFx0XHRcdGF0dHJEYXRhID0gXCJkYXRhLVwiICsgKG9wdGlvbnMuc2NvcGUgfHwgZG9qby5fc2NvcGVOYW1lKSArIFwiLVwiLCAvLyB0eXBpY2FsbHkgXCJkYXRhLWRvam8tXCJcblx0XHRcdFx0ZGF0YURvam9UeXBlID0gYXR0ckRhdGEgKyBcInR5cGVcIiwgLy8gdHlwaWNhbGx5IFwiZGF0YS1kb2pvLXR5cGVcIlxuXHRcdFx0XHRkYXRhRG9qb1RleHREaXIgPSBhdHRyRGF0YSArIFwidGV4dGRpclwiLCAvLyB0eXBpY2FsbHkgXCJkYXRhLWRvam8tdGV4dGRpclwiXG5cdFx0XHRcdGRhdGFEb2pvTWl4aW5zID0gYXR0ckRhdGEgKyBcIm1peGluc1wiO1x0XHRcdFx0XHQvLyB0eXBpY2FsbHkgXCJkYXRhLWRvam8tbWl4aW5zXCJcblxuXHRcdFx0Ly8gSW5mbyBvbiBET01Ob2RlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWRcblx0XHRcdHZhciBub2RlID0gcm9vdC5maXJzdENoaWxkO1xuXG5cdFx0XHQvLyBJbmZvIG9uIHBhcmVudCBvZiBET01Ob2RlIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWRcblx0XHRcdC8vXHQtIGluaGVyaXRlZDogZGlyLCBsYW5nLCBhbmQgdGV4dERpciBzZXR0aW5nIG9mIHBhcmVudCwgb3IgaW5oZXJpdGVkIGJ5IHBhcmVudFxuXHRcdFx0Ly9cdC0gcGFyZW50OiBwb2ludGVyIHRvIGlkZW50aWNhbCBzdHJ1Y3R1cmUgZm9yIG15IHBhcmVudCAob3IgbnVsbCBpZiBubyBwYXJlbnQpXG5cdFx0XHQvL1x0LSBzY3JpcHRzOiBpZiBzcGVjaWZpZWQsIGNvbGxlY3RzIDxzY3JpcHQgdHlwZT1cImRvam8vLi4uXCI+IHR5cGUgbm9kZXMgZnJvbSBjaGlsZHJlblxuXHRcdFx0dmFyIGluaGVyaXRlZCA9IG9wdGlvbnMuaW5oZXJpdGVkO1xuXHRcdFx0aWYoIWluaGVyaXRlZCl7XG5cdFx0XHRcdGZ1bmN0aW9uIGZpbmRBbmNlc3RvckF0dHIobm9kZSwgYXR0cil7XG5cdFx0XHRcdFx0cmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShhdHRyKSkgfHxcblx0XHRcdFx0XHRcdChub2RlLnBhcmVudE5vZGUgJiYgZmluZEFuY2VzdG9yQXR0cihub2RlLnBhcmVudE5vZGUsIGF0dHIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluaGVyaXRlZCA9IHtcblx0XHRcdFx0XHRkaXI6IGZpbmRBbmNlc3RvckF0dHIocm9vdCwgXCJkaXJcIiksXG5cdFx0XHRcdFx0bGFuZzogZmluZEFuY2VzdG9yQXR0cihyb290LCBcImxhbmdcIiksXG5cdFx0XHRcdFx0dGV4dERpcjogZmluZEFuY2VzdG9yQXR0cihyb290LCBkYXRhRG9qb1RleHREaXIpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvcih2YXIga2V5IGluIGluaGVyaXRlZCl7XG5cdFx0XHRcdFx0aWYoIWluaGVyaXRlZFtrZXldKXtcblx0XHRcdFx0XHRcdGRlbGV0ZSBpbmhlcml0ZWRba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0YWRhdGEgYWJvdXQgcGFyZW50IG5vZGVcblx0XHRcdHZhciBwYXJlbnQgPSB7XG5cdFx0XHRcdGluaGVyaXRlZDogaW5oZXJpdGVkXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBGb3IgY29sbGVjdGluZyA8c2NyaXB0IHR5cGU9XCJkb2pvLy4uLlwiPiB0eXBlIG5vZGVzICh3aGVuIG51bGwsIHdlIGRvbid0IG5lZWQgdG8gY29sbGVjdClcblx0XHRcdHZhciBzY3JpcHRzO1xuXG5cdFx0XHQvLyB3aGVuIHRydWUsIG9ubHkgbG9vayBmb3IgPHNjcmlwdCB0eXBlPVwiZG9qby8uLi5cIj4gdGFncywgYW5kIGRvbid0IHJlY3Vyc2UgdG8gY2hpbGRyZW5cblx0XHRcdHZhciBzY3JpcHRzT25seTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0RWZmZWN0aXZlKHBhcmVudCl7XG5cdFx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHRcdC8vXHRcdEdldCBlZmZlY3RpdmUgZGlyLCBsYW5nLCB0ZXh0RGlyIHNldHRpbmdzIGZvciBzcGVjaWZpZWQgb2JqXG5cdFx0XHRcdC8vXHRcdChtYXRjaGluZyBcInBhcmVudFwiIG9iamVjdCBzdHJ1Y3R1cmUgYWJvdmUpLCBhbmQgZG8gY2FjaGluZy5cblx0XHRcdFx0Ly9cdFx0VGFrZSBjYXJlIG5vdCB0byByZXR1cm4gbnVsbCBlbnRyaWVzLlxuXHRcdFx0XHRpZighcGFyZW50LmluaGVyaXRlZCl7XG5cdFx0XHRcdFx0cGFyZW50LmluaGVyaXRlZCA9IHt9O1xuXHRcdFx0XHRcdHZhciBub2RlID0gcGFyZW50Lm5vZGUsXG5cdFx0XHRcdFx0XHRncmFuZHBhcmVudCA9IGdldEVmZmVjdGl2ZShwYXJlbnQucGFyZW50KTtcblx0XHRcdFx0XHR2YXIgaW5oZXJpdGVkID0ge1xuXHRcdFx0XHRcdFx0ZGlyOiBub2RlLmdldEF0dHJpYnV0ZShcImRpclwiKSB8fCBncmFuZHBhcmVudC5kaXIsXG5cdFx0XHRcdFx0XHRsYW5nOiBub2RlLmdldEF0dHJpYnV0ZShcImxhbmdcIikgfHwgZ3JhbmRwYXJlbnQubGFuZyxcblx0XHRcdFx0XHRcdHRleHREaXI6IG5vZGUuZ2V0QXR0cmlidXRlKGRhdGFEb2pvVGV4dERpcikgfHwgZ3JhbmRwYXJlbnQudGV4dERpclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgaW4gaW5oZXJpdGVkKXtcblx0XHRcdFx0XHRcdGlmKGluaGVyaXRlZFtrZXldKXtcblx0XHRcdFx0XHRcdFx0cGFyZW50LmluaGVyaXRlZFtrZXldID0gaW5oZXJpdGVkW2tleV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJlbnQuaW5oZXJpdGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBERlMgb24gRE9NIHRyZWUsIGNvbGxlY3Rpbmcgbm9kZXMgd2l0aCBkYXRhLWRvam8tdHlwZSBzcGVjaWZpZWQuXG5cdFx0XHR3aGlsZSh0cnVlKXtcblx0XHRcdFx0aWYoIW5vZGUpe1xuXHRcdFx0XHRcdC8vIEZpbmlzaGVkIHRoaXMgbGV2ZWwsIGNvbnRpbnVlIHRvIHBhcmVudCdzIG5leHQgc2libGluZ1xuXHRcdFx0XHRcdGlmKCFwYXJlbnQgfHwgIXBhcmVudC5ub2RlKXtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gcGFyZW50Lm5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0c2NyaXB0c09ubHkgPSBmYWxzZTtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0XHRcdHNjcmlwdHMgPSBwYXJlbnQuc2NyaXB0cztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKG5vZGUubm9kZVR5cGUgIT0gMSl7XG5cdFx0XHRcdFx0Ly8gVGV4dCBvciBjb21tZW50IG5vZGUsIHNraXAgdG8gbmV4dCBzaWJsaW5nXG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihzY3JpcHRzICYmIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBcInNjcmlwdFwiKXtcblx0XHRcdFx0XHQvLyBTYXZlIDxzY3JpcHQgdHlwZT1cImRvam8vLi4uXCI+IGZvciBwYXJlbnQsIHRoZW4gY29udGludWUgdG8gbmV4dCBzaWJsaW5nXG5cdFx0XHRcdFx0dHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblx0XHRcdFx0XHRpZih0eXBlICYmIC9eZG9qb1xcL1xcdy9pLnRlc3QodHlwZSkpe1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzY3JpcHRzT25seSl7XG5cdFx0XHRcdFx0Ly8gc2NyaXB0c09ubHkgZmxhZyBpcyBzZXQsIHdlIGhhdmUgYWxyZWFkeSBjb2xsZWN0ZWQgc2NyaXB0cyBpZiB0aGUgcGFyZW50IHdhbnRzIHRoZW0sIHNvIG5vdyB3ZSBzaG91bGRuJ3Rcblx0XHRcdFx0XHQvLyBjb250aW51ZSBmdXJ0aGVyIGFuYWx5c2lzIG9mIHRoZSBub2RlIGFuZCB3aWxsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHNpYmxpbmdcblx0XHRcdFx0XHRub2RlID0gbm9kZS5uZXh0U2libGluZztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBkYXRhLWRvam8tdHlwZSBhdHRyaWJ1dGUsIGZhbGxiYWNrIHRvIGJhY2t3YXJkIGNvbXBhdGlibGUgZG9qb1R5cGVcblx0XHRcdFx0Ly8gVE9ETzogUmVtb3ZlIGRvam9UeXBlIGluIDIuMFxuXHRcdFx0XHR2YXIgdHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGRhdGFEb2pvVHlwZSkgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoZG9qb1R5cGUpO1xuXG5cdFx0XHRcdC8vIFNob3J0IGNpcmN1aXQgZm9yIGxlYWYgbm9kZXMgY29udGFpbmluZyBub3RoaW5nIFtidXQgdGV4dF1cblx0XHRcdFx0dmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdGlmKCF0eXBlICYmICghZmlyc3RDaGlsZCB8fCAoZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzICYmICFmaXJzdENoaWxkLm5leHRTaWJsaW5nKSkpe1xuXHRcdFx0XHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWV0YSBkYXRhIGFib3V0IGN1cnJlbnQgbm9kZVxuXHRcdFx0XHR2YXIgY3VycmVudDtcblxuXHRcdFx0XHR2YXIgY3RvciA9IG51bGw7XG5cdFx0XHRcdGlmKHR5cGUpe1xuXHRcdFx0XHRcdC8vIElmIGRvam9UeXBlL2RhdGEtZG9qby10eXBlIHNwZWNpZmllZCwgYWRkIHRvIG91dHB1dCBhcnJheSBvZiBub2RlcyB0byBpbnN0YW50aWF0ZS5cblx0XHRcdFx0XHR2YXIgbWl4aW5zVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShkYXRhRG9qb01peGlucyksXG5cdFx0XHRcdFx0XHR0eXBlcyA9IG1peGluc1ZhbHVlID8gW3R5cGVdLmNvbmNhdChtaXhpbnNWYWx1ZS5zcGxpdCgvXFxzKixcXHMqLykpIDogW3R5cGVdO1xuXG5cdFx0XHRcdFx0Ly8gTm90ZTogd29uJ3QgZmluZCBjbGFzc2VzIGRlY2xhcmVkIHZpYSBkb2pvL0RlY2xhcmF0aW9uIG9yIGFueSBtb2R1bGVzIHRoYXQgaGF2ZW4ndCBiZWVuXG5cdFx0XHRcdFx0Ly8gbG9hZGVkIHlldCBzbyB1c2UgdHJ5L2NhdGNoIHRvIGF2b2lkIHRocm93IGZyb20gcmVxdWlyZSgpXG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0Y3RvciA9IGdldEN0b3IodHlwZXMsIG9wdGlvbnMuY29udGV4dFJlcXVpcmUpO1xuXHRcdFx0XHRcdH1jYXRjaChlKXt9XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdCBmb3VuZCwgY2hlY2sgdG8gc2VlIGlmIGl0IGhhcyBtb2R1bGVzIHRoYXQgY2FuIGJlIGxvYWRlZFxuXHRcdFx0XHRcdGlmKCFjdG9yKXtcblx0XHRcdFx0XHRcdGRhcnJheS5mb3JFYWNoKHR5cGVzLCBmdW5jdGlvbih0KXtcblx0XHRcdFx0XHRcdFx0aWYofnQuaW5kZXhPZignLycpICYmICFtaWRzSGFzaFt0XSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHR5cGUgbG9va3MgbGlrZSBhIE1JRCBhbmQgaXQgY3VycmVudGx5IGlzbid0IGluIHRoZSBhcnJheSBvZiBNSURzIHRvIGxvYWQsIGFkZCBpdC5cblx0XHRcdFx0XHRcdFx0XHRtaWRzSGFzaFt0XSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0bWlkc1ttaWRzLmxlbmd0aF0gPSB0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY2hpbGRTY3JpcHRzID0gY3RvciAmJiAhY3Rvci5wcm90b3R5cGUuX25vU2NyaXB0ID8gW10gOiBudWxsOyAvLyA8c2NyaXB0PiBub2RlcyB0aGF0IGFyZSBwYXJlbnQncyBjaGlsZHJlblxuXG5cdFx0XHRcdFx0Ly8gU2V0dXAgbWV0YSBkYXRhIGFib3V0IHRoaXMgd2lkZ2V0IG5vZGUsIGFuZCBzYXZlIGl0IHRvIGxpc3Qgb2Ygbm9kZXMgdG8gaW5zdGFudGlhdGVcblx0XHRcdFx0XHRjdXJyZW50ID0ge1xuXHRcdFx0XHRcdFx0dHlwZXM6IHR5cGVzLFxuXHRcdFx0XHRcdFx0Y3RvcjogY3Rvcixcblx0XHRcdFx0XHRcdHBhcmVudDogcGFyZW50LFxuXHRcdFx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0XHRcdHNjcmlwdHM6IGNoaWxkU2NyaXB0c1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Y3VycmVudC5pbmhlcml0ZWQgPSBnZXRFZmZlY3RpdmUoY3VycmVudCk7IC8vIGRpciAmIGxhbmcgc2V0dGluZ3MgZm9yIGN1cnJlbnQgbm9kZSwgZXhwbGljaXQgb3IgaW5oZXJpdGVkXG5cdFx0XHRcdFx0bGlzdC5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyBNZXRhIGRhdGEgYWJvdXQgdGhpcyBub24td2lkZ2V0IG5vZGVcblx0XHRcdFx0XHRjdXJyZW50ID0ge1xuXHRcdFx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0XHRcdHNjcmlwdHM6IHNjcmlwdHMsXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IHBhcmVudFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlLCBjb2xsZWN0aW5nIDxzY3JpcHQgdHlwZT1cImRvam8vLi4uXCI+IGNoaWxkcmVuLCBhbmQgYWxzbyBsb29raW5nIGZvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IG5vZGVzIHdpdGggZG9qb1R5cGUgc3BlY2lmaWVkICh1bmxlc3MgdGhlIHdpZGdldCBoYXMgdGhlIHN0b3BQYXJzZXIgZmxhZykuXG5cdFx0XHRcdC8vIFdoZW4gZmluaXNoZWQgd2l0aCBjaGlsZHJlbiwgZ28gdG8gbXkgbmV4dCBzaWJsaW5nLlxuXHRcdFx0XHRzY3JpcHRzID0gY2hpbGRTY3JpcHRzO1xuXHRcdFx0XHRzY3JpcHRzT25seSA9IG5vZGUuc3RvcFBhcnNlciB8fCAoY3RvciAmJiBjdG9yLnByb3RvdHlwZS5zdG9wUGFyc2VyICYmICEob3B0aW9ucy50ZW1wbGF0ZSkpO1xuXHRcdFx0XHRwYXJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRub2RlID0gZmlyc3RDaGlsZDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGQgPSBuZXcgRGVmZXJyZWQoKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG1vZHVsZXMgdG8gbG9hZCB0aGVuIHJlcXVpcmUgdGhlbSBpblxuXHRcdFx0aWYobWlkcy5sZW5ndGgpe1xuXHRcdFx0XHQvLyBXYXJuIHRoYXQgdGhlcmUgYXJlIG1vZHVsZXMgYmVpbmcgYXV0by1yZXF1aXJlZFxuXHRcdFx0XHRpZihoYXMoXCJkb2pvLWRlYnVnLW1lc3NhZ2VzXCIpKXtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBNb2R1bGVzIGJlaW5nIEF1dG8tUmVxdWlyZWQ6IFwiICsgbWlkcy5qb2luKFwiLCBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByID0gb3B0aW9ucy5jb250ZXh0UmVxdWlyZSB8fCByZXF1aXJlO1xuXHRcdFx0XHRyKG1pZHMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Ly8gR28gdGhyb3VnaCBsaXN0IG9mIHdpZGdldCBub2RlcywgZmlsbGluZyBpbiBtaXNzaW5nIGNvbnN0cnVjdG9ycywgYW5kIGZpbHRlcmluZyBvdXQgbm9kZXMgdGhhdCBzaG91bGRuJ3Rcblx0XHRcdFx0XHQvLyBiZSBpbnN0YW50aWF0ZWQgZHVlIHRvIGEgc3RvcFBhcnNlciBmbGFnIG9uIGFuIGFuY2VzdG9yIHRoYXQgd2UgYmVsYXRlZGx5IGxlYXJuZWQgYWJvdXQgZHVlIHRvXG5cdFx0XHRcdFx0Ly8gYXV0by1yZXF1aXJlIG9mIGEgbW9kdWxlIGxpa2UgQ29udGVudFBhbmUuICAgQXNzdW1lcyBsaXN0IGlzIGluIERGUyBvcmRlci5cblx0XHRcdFx0XHRkLnJlc29sdmUoZGFycmF5LmZpbHRlcihsaXN0LCBmdW5jdGlvbih3aWRnZXQpe1xuXHRcdFx0XHRcdFx0aWYoIXdpZGdldC5jdG9yKXtcblx0XHRcdFx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBmaW5kIHRoZSBjb25zdHJ1Y3RvciBhZ2Fpbi4gICBTdGlsbCB3b24ndCBmaW5kIGNsYXNzZXMgZGVmaW5lZCB2aWFcblx0XHRcdFx0XHRcdFx0Ly8gZGlqaXQvRGVjbGFyYXRpb24gc28gbmVlZCB0byB0cnkvY2F0Y2guXG5cdFx0XHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdFx0XHR3aWRnZXQuY3RvciA9IGdldEN0b3Iod2lkZ2V0LnR5cGVzLCBvcHRpb25zLmNvbnRleHRSZXF1aXJlKTtcblx0XHRcdFx0XHRcdFx0fWNhdGNoKGUpe31cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBwYXJlbnQgd2lkZ2V0XG5cdFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gd2lkZ2V0LnBhcmVudDtcblx0XHRcdFx0XHRcdHdoaWxlKHBhcmVudCAmJiAhcGFyZW50LnR5cGVzKXtcblx0XHRcdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIGlmIHRoaXMgbm9kZSBzaG91bGQgYmUgc2tpcHBlZCBkdWUgdG8gc3RvcFBhcnNlciBvbiBhbiBhbmNlc3Rvci5cblx0XHRcdFx0XHRcdC8vIFNpbmNlIGxpc3RbXSBpcyBpbiBERlMgb3JkZXIsIHRoaXMgbG9vcCB3aWxsIGFsd2F5cyBzZXQgcGFyZW50Lmluc3RhbnRpYXRlQ2hpbGRyZW4gYmVmb3JlXG5cdFx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gY29tcHV0ZSB3aWRnZXQuaW5zdGFudGlhdGUuXG5cdFx0XHRcdFx0XHR2YXIgcHJvdG8gPSB3aWRnZXQuY3RvciAmJiB3aWRnZXQuY3Rvci5wcm90b3R5cGU7XG5cdFx0XHRcdFx0XHR3aWRnZXQuaW5zdGFudGlhdGVDaGlsZHJlbiA9ICEocHJvdG8gJiYgcHJvdG8uc3RvcFBhcnNlciAmJiAhKG9wdGlvbnMudGVtcGxhdGUpKTtcblx0XHRcdFx0XHRcdHdpZGdldC5pbnN0YW50aWF0ZSA9ICFwYXJlbnQgfHwgKHBhcmVudC5pbnN0YW50aWF0ZSAmJiBwYXJlbnQuaW5zdGFudGlhdGVDaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gd2lkZ2V0Lmluc3RhbnRpYXRlO1xuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gVGhlcmUgd2VyZSBubyBtb2R1bGVzIHRvIGxvYWQsIHNvIGp1c3QgcmVzb2x2ZSB3aXRoIHRoZSBwYXJzZWQgbm9kZXMuICAgVGhpcyBzZXBhcmF0ZSBjb2RlIHBhdGggaXMgZm9yXG5cdFx0XHRcdC8vIGVmZmljaWVuY3ksIHRvIGF2b2lkIHJ1bm5pbmcgdGhlIHJlcXVpcmUoKSBhbmQgdGhlIGNhbGxiYWNrIGNvZGUgYWJvdmUuXG5cdFx0XHRcdGQucmVzb2x2ZShsaXN0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBwcm9taXNlXG5cdFx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHRcdH0sXG5cblx0XHRfcmVxdWlyZTogZnVuY3Rpb24oLypET01Ob2RlKi8gc2NyaXB0LCAvKk9iamVjdD8qLyBvcHRpb25zKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRIZWxwZXIgZm9yIF9zY2FuQU1EKCkuICBUYWtlcyBhIGA8c2NyaXB0IHR5cGU9ZG9qby9yZXF1aXJlPmJhcjogXCJhY21lL2JhclwiLCAuLi48L3NjcmlwdD5gIG5vZGUsXG5cdFx0XHQvL1x0XHRjYWxscyByZXF1aXJlKCkgdG8gbG9hZCB0aGUgc3BlY2lmaWVkIG1vZHVsZXMgYW5kIChhc3luY2hyb25vdXNseSkgYXNzaWduIHRoZW0gdG8gdGhlIHNwZWNpZmllZCBnbG9iYWxcblx0XHRcdC8vXHRcdHZhcmlhYmxlcywgYW5kIHJldHVybnMgYSBQcm9taXNlIGZvciB3aGVuIHRoYXQgb3BlcmF0aW9uIGNvbXBsZXRlcy5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRJbiB0aGUgZXhhbXBsZSBhYm92ZSwgaXQgaXMgZWZmZWN0aXZlbHkgZG9pbmcgYSByZXF1aXJlKFtcImFjbWUvYmFyXCIsIC4uLl0sIGZ1bmN0aW9uKGEpeyBiYXIgPSBhOyB9KS5cblxuXHRcdFx0dmFyIGhhc2ggPSBteUV2YWwoXCJ7XCIgKyBzY3JpcHQuaW5uZXJIVE1MICsgXCJ9XCIpLCAvLyBjYW4ndCB1c2UgZG9qby9qc29uOjpwYXJzZSgpIGJlY2F1c2UgbWF5YmUgbm8gcXVvdGVzXG5cdFx0XHRcdHZhcnMgPSBbXSxcblx0XHRcdFx0bWlkcyA9IFtdLFxuXHRcdFx0XHRkID0gbmV3IERlZmVycmVkKCk7XG5cblx0XHRcdHZhciBjb250ZXh0UmVxdWlyZSA9IChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dFJlcXVpcmUpIHx8IHJlcXVpcmU7XG5cblx0XHRcdGZvcih2YXIgbmFtZSBpbiBoYXNoKXtcblx0XHRcdFx0dmFycy5wdXNoKG5hbWUpO1xuXHRcdFx0XHRtaWRzLnB1c2goaGFzaFtuYW1lXSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHRSZXF1aXJlKG1pZHMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRkbGFuZy5zZXRPYmplY3QodmFyc1tpXSwgYXJndW1lbnRzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkLnJlc29sdmUoYXJndW1lbnRzKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHRcdH0sXG5cblx0XHRfc2NhbkFtZDogZnVuY3Rpb24ocm9vdCwgb3B0aW9ucyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0U2NhbnMgdGhlIERPTSBmb3IgYW55IGRlY2xhcmF0aXZlIHJlcXVpcmVzIGFuZCByZXR1cm5zIHRoZWlyIHZhbHVlcy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0TG9va3MgZm9yIGA8c2NyaXB0IHR5cGU9ZG9qby9yZXF1aXJlPmJhcjogXCJhY21lL2JhclwiLCAuLi48L3NjcmlwdD5gIG5vZGUsIGNhbGxzIHJlcXVpcmUoKSB0byBsb2FkIHRoZVxuXHRcdFx0Ly9cdFx0c3BlY2lmaWVkIG1vZHVsZXMgYW5kIChhc3luY2hyb25vdXNseSkgYXNzaWduIHRoZW0gdG8gdGhlIHNwZWNpZmllZCBnbG9iYWwgdmFyaWFibGVzLFxuXHRcdFx0Ly9cdFx0YW5kIHJldHVybnMgYSBQcm9taXNlIGZvciB3aGVuIHRob3NlIG9wZXJhdGlvbnMgY29tcGxldGUuXG5cdFx0XHQvLyByb290OiBEb21Ob2RlXG5cdFx0XHQvL1x0XHRUaGUgbm9kZSB0byBiYXNlIHRoZSBzY2FuIGZyb20uXG5cdFx0XHQvLyBvcHRpb25zOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRhIGt3QXJncyBvcHRpb25zIG9iamVjdCwgc2VlIHBhcnNlKCkgZm9yIGRldGFpbHNcblxuXHRcdFx0Ly8gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHRoZSA8c2NyaXB0IHR5cGU9ZG9qby9yZXF1aXJlPiBub2RlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG5cdFx0XHR2YXIgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKSxcblx0XHRcdFx0cHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRxdWVyeShcInNjcmlwdFt0eXBlPSdkb2pvL3JlcXVpcmUnXVwiLCByb290KS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHQvLyBGaXJlIG9mZiByZXF1aXJlKCkgY2FsbCBmb3Igc3BlY2lmaWVkIG1vZHVsZXMuICBDaGFpbiB0aGlzIHJlcXVpcmUgdG8gZmlyZSBhZnRlclxuXHRcdFx0XHQvLyBhbnkgcHJldmlvdXMgcmVxdWlyZXMgY29tcGxldGUsIHNvIHRoYXQgbGF5ZXJzIGNhbiBiZSBsb2FkZWQgYmVmb3JlIGluZGl2aWR1YWwgbW9kdWxlIHJlcXVpcmUoKSdzIGZpcmUuXG5cdFx0XHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fcmVxdWlyZShub2RlLCBvcHRpb25zKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gRE9NIHNvIGl0IGlzbid0IHNlZW4gYWdhaW5cblx0XHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24ocm9vdE5vZGUsIG9wdGlvbnMpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNjYW4gdGhlIERPTSBmb3IgY2xhc3MgaW5zdGFuY2VzLCBhbmQgaW5zdGFudGlhdGUgdGhlbS5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0U2VhcmNoIHNwZWNpZmllZCBub2RlIChvciByb290IG5vZGUpIHJlY3Vyc2l2ZWx5IGZvciBjbGFzcyBpbnN0YW5jZXMsXG5cdFx0XHQvL1x0XHRhbmQgaW5zdGFudGlhdGUgdGhlbS4gU2VhcmNoZXMgZm9yIGVpdGhlciBkYXRhLWRvam8tdHlwZT1cIkNsYXNzXCIgb3Jcblx0XHRcdC8vXHRcdGRvam9UeXBlPVwiQ2xhc3NcIiB3aGVyZSBcIkNsYXNzXCIgaXMgYSBhIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lLFxuXHRcdFx0Ly9cdFx0bGlrZSBgZGlqaXQvZm9ybS9CdXR0b25gXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdFx0VXNpbmcgYGRhdGEtZG9qby10eXBlYDpcblx0XHRcdC8vXHRcdEF0dHJpYnV0ZXMgdXNpbmcgY2FuIGJlIG1peGVkIGludG8gdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGVcblx0XHRcdC8vXHRcdENsYXNzIGJ5IHVzaW5nIGEgYGRhdGEtZG9qby1wcm9wc2AgYXR0cmlidXRlIG9uIHRoZSBub2RlIGJlaW5nIGNvbnZlcnRlZC5cblx0XHRcdC8vXHRcdGBkYXRhLWRvam8tcHJvcHNgIHNob3VsZCBiZSBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gYmUgY29udmVydGVkIGZyb20gSlNPTi5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHRVc2luZyBgZG9qb1R5cGVgOlxuXHRcdFx0Ly9cdFx0QXR0cmlidXRlcyBhcmUgcmVhZCBmcm9tIHRoZSBvcmlnaW5hbCBkb21Ob2RlIGFuZCBjb252ZXJ0ZWQgdG8gYXBwcm9wcmlhdGVcblx0XHRcdC8vXHRcdHR5cGVzIGJ5IGxvb2tpbmcgdXAgdGhlIENsYXNzIHByb3RvdHlwZSB2YWx1ZXMuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Jcblx0XHRcdC8vXHRcdGZyb20gRG9qbyAxLjAgdG8gRG9qbyAxLjUuIGBkb2pvVHlwZWAgc3VwcG9ydCBpcyBkZXByZWNhdGVkLCBhbmQgd2lsbFxuXHRcdFx0Ly9cdFx0Z28gYXdheSBpbiBEb2pvIDIuMC5cblx0XHRcdC8vIHJvb3ROb2RlOiBEb21Ob2RlP1xuXHRcdFx0Ly9cdFx0QSBkZWZhdWx0IHN0YXJ0aW5nIHJvb3Qgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBwYXJzaW5nLiBDYW4gYmVcblx0XHRcdC8vXHRcdG9taXR0ZWQsIGRlZmF1bHRpbmcgdG8gdGhlIGVudGlyZSBkb2N1bWVudC4gSWYgb21pdHRlZCwgdGhlIGBvcHRpb25zYFxuXHRcdFx0Ly9cdFx0b2JqZWN0IGNhbiBiZSBwYXNzZWQgaW4gdGhpcyBwbGFjZS4gSWYgdGhlIGBvcHRpb25zYCBvYmplY3QgaGFzIGFcblx0XHRcdC8vXHRcdGByb290Tm9kZWAgbWVtYmVyLCB0aGF0IGlzIHVzZWQuXG5cdFx0XHQvLyBvcHRpb25zOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRBIGhhc2ggb2Ygb3B0aW9ucy5cblx0XHRcdC8vXG5cdFx0XHQvL1x0XHQtIG5vU3RhcnQ6IEJvb2xlYW4/OlxuXHRcdFx0Ly9cdFx0XHR3aGVuIHNldCB3aWxsIHByZXZlbnQgdGhlIHBhcnNlciBmcm9tIGNhbGxpbmcgLnN0YXJ0dXAoKVxuXHRcdFx0Ly9cdFx0XHR3aGVuIGxvY2F0aW5nIHRoZSBub2Rlcy5cblx0XHRcdC8vXHRcdC0gcm9vdE5vZGU6IERvbU5vZGU/OlxuXHRcdFx0Ly9cdFx0XHRpZGVudGljYWwgdG8gdGhlIGZ1bmN0aW9uJ3MgYHJvb3ROb2RlYCBhcmd1bWVudCwgdGhvdWdoXG5cdFx0XHQvL1x0XHRcdGFsbG93ZWQgdG8gYmUgcGFzc2VkIGluIHZpYSB0aGlzIGBvcHRpb25zIG9iamVjdC5cblx0XHRcdC8vXHRcdC0gdGVtcGxhdGU6IEJvb2xlYW46XG5cdFx0XHQvL1x0XHRcdElmIHRydWUsIGlnbm9yZXMgQ29udGVudFBhbmUncyBzdG9wUGFyc2VyIGZsYWcgYW5kIHBhcnNlcyBjb250ZW50cyBpbnNpZGUgb2Zcblx0XHRcdC8vXHRcdFx0YSBDb250ZW50UGFuZSBpbnNpZGUgb2YgYSB0ZW1wbGF0ZS4gICBUaGlzIGFsbG93cyBkb2pvQXR0YWNoUG9pbnQgb24gd2lkZ2V0cy9ub2Rlc1xuXHRcdFx0Ly9cdFx0XHRuZXN0ZWQgaW5zaWRlIHRoZSBDb250ZW50UGFuZSB0byB3b3JrLlxuXHRcdFx0Ly9cdFx0LSBpbmhlcml0ZWQ6IE9iamVjdDpcblx0XHRcdC8vXHRcdFx0SGFzaCBwb3NzaWJseSBjb250YWluaW5nIGRpciBhbmQgbGFuZyBzZXR0aW5ncyB0byBiZSBhcHBsaWVkIHRvXG5cdFx0XHQvL1x0XHRcdHBhcnNlZCB3aWRnZXRzLCB1bmxlc3MgdGhlcmUncyBhbm90aGVyIHNldHRpbmcgb24gYSBzdWItbm9kZSB0aGF0IG92ZXJyaWRlc1xuXHRcdFx0Ly9cdFx0LSBzY29wZTogU3RyaW5nOlxuXHRcdFx0Ly9cdFx0XHRSb290IGZvciBhdHRyaWJ1dGUgbmFtZXMgdG8gc2VhcmNoIGZvci4gICBJZiBzY29wZU5hbWUgaXMgZG9qbyxcblx0XHRcdC8vXHRcdFx0d2lsbCBzZWFyY2ggZm9yIGRhdGEtZG9qby10eXBlIChvciBkb2pvVHlwZSkuICAgRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHQvL1x0XHRcdHJlYXNvbnMgZGVmYXVsdHMgdG8gZG9qby5fc2NvcGVOYW1lICh3aGljaCBpcyBcImRvam9cIiBleGNlcHQgd2hlblxuXHRcdFx0Ly9cdFx0XHRtdWx0aS12ZXJzaW9uIHN1cHBvcnQgaXMgdXNlZCwgd2hlbiBpdCB3aWxsIGJlIHNvbWV0aGluZyBsaWtlIGRvam8xNiwgZG9qbzIwLCBldGMuKVxuXHRcdFx0Ly9cdFx0LSBwcm9wc1RoaXM6IE9iamVjdDpcblx0XHRcdC8vXHRcdFx0SWYgc3BlY2lmaWVkLCBcInRoaXNcIiByZWZlcmVuY2VkIGZyb20gZGF0YS1kb2pvLXByb3BzIHdpbGwgcmVmZXIgdG8gcHJvcHNUaGlzLlxuXHRcdFx0Ly9cdFx0XHRJbnRlbmRlZCBmb3IgdXNlIGZyb20gdGhlIHdpZGdldHMtaW4tdGVtcGxhdGUgZmVhdHVyZSBvZiBgZGlqaXQuX1dpZGdldHNJblRlbXBsYXRlTWl4aW5gXG5cdFx0XHQvL1x0XHQtIGNvbnRleHRSZXF1aXJlOiBGdW5jdGlvbjpcblx0XHRcdC8vXHRcdFx0SWYgc3BlY2lmaWVkLCB0aGlzIHJlcXVpcmUgaXMgdXRpbGlzZWQgZm9yIGxvb2tpbmcgcmVzb2x2aW5nIG1vZHVsZXMgaW5zdGVhZCBvZiB0aGVcblx0XHRcdC8vXHRcdFx0YGRvam8vcGFyc2VyYCBjb250ZXh0IGByZXF1aXJlKClgLiAgSW50ZW5kZWQgZm9yIHVzZSBmcm9tIHRoZSB3aWRnZXRzLWluLXRlbXBsYXRlIGZlYXR1cmUgb2Zcblx0XHRcdC8vXHRcdFx0YGRpaml0Ll9XaWRnZXRzSW5UZW1wbGF0ZU1peGluYC5cblx0XHRcdC8vIHJldHVybnM6IE1peGVkXG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgYmxlbmRlZCBvYmplY3QgdGhhdCBpcyBhbiBhcnJheSBvZiB0aGUgaW5zdGFudGlhdGVkIG9iamVjdHMsIGJ1dCBhbHNvIGNhbiBpbmNsdWRlXG5cdFx0XHQvL1x0XHRhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSBpbnN0YW50aWF0ZWQgb2JqZWN0cy4gIFRoaXMgaXMgZG9uZSBmb3IgYmFja3dhcmRzXG5cdFx0XHQvL1x0XHRjb21wYXRpYmlsaXR5LiAgSWYgdGhlIHBhcnNlciBhdXRvLXJlcXVpcmVzIG1vZHVsZXMsIGl0IHdpbGwgYWx3YXlzIGJlaGF2ZSBpbiBhIHByb21pc2Vcblx0XHRcdC8vXHRcdGZhc2hpb24gYW5kIGBwYXJzZXIucGFyc2UoKS50aGVuKGZ1bmN0aW9uKGluc3RhbmNlcyl7Li4ufSlgIHNob3VsZCBiZSB1c2VkLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFBhcnNlIGFsbCB3aWRnZXRzIG9uIGEgcGFnZTpcblx0XHRcdC8vXHR8XHRcdHBhcnNlci5wYXJzZSgpO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFBhcnNlIGFsbCBjbGFzc2VzIHdpdGhpbiB0aGUgbm9kZSB3aXRoIGlkPVwiZm9vXCJcblx0XHRcdC8vXHR8XHRcdHBhcnNlci5wYXJzZShkb2pvLmJ5SWQoJ2ZvbycpKTtcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRQYXJzZSBhbGwgY2xhc3NlcyBpbiBhIHBhZ2UsIGJ1dCBkbyBub3QgY2FsbCAuc3RhcnR1cCgpIG9uIGFueVxuXHRcdFx0Ly9cdFx0Y2hpbGRcblx0XHRcdC8vXHR8XHRcdHBhcnNlci5wYXJzZSh7IG5vU3RhcnQ6IHRydWUgfSlcblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRQYXJzZSBhbGwgY2xhc3NlcyBpbiBhIG5vZGUsIGJ1dCBkbyBub3QgY2FsbCAuc3RhcnR1cCgpXG5cdFx0XHQvL1x0fFx0XHRwYXJzZXIucGFyc2Uoc29tZU5vZGUsIHsgbm9TdGFydDp0cnVlIH0pO1xuXHRcdFx0Ly9cdHxcdFx0Ly8gb3Jcblx0XHRcdC8vXHR8XHRcdHBhcnNlci5wYXJzZSh7IG5vU3RhcnQ6dHJ1ZSwgcm9vdE5vZGU6IHNvbWVOb2RlIH0pO1xuXG5cdFx0XHQvLyBkZXRlcm1pbmUgdGhlIHJvb3Qgbm9kZSBhbmQgb3B0aW9ucyBiYXNlZCBvbiB0aGUgcGFzc2VkIGFyZ3VtZW50cy5cblx0XHRcdGlmKHJvb3ROb2RlICYmIHR5cGVvZiByb290Tm9kZSAhPSBcInN0cmluZ1wiICYmICEoXCJub2RlVHlwZVwiIGluIHJvb3ROb2RlKSl7XG5cdFx0XHRcdC8vIElmIGNhbGxlZCBhcyBwYXJzZShvcHRpb25zKSByYXRoZXIgdGhhbiBwYXJzZSgpLCBwYXJzZShyb290Tm9kZSksIG9yIHBhcnNlKHJvb3ROb2RlLCBvcHRpb25zKS4uLlxuXHRcdFx0XHRvcHRpb25zID0gcm9vdE5vZGU7XG5cdFx0XHRcdHJvb3ROb2RlID0gb3B0aW9ucy5yb290Tm9kZTtcblx0XHRcdH1cblx0XHRcdHZhciByb290ID0gcm9vdE5vZGUgPyBkb20uYnlJZChyb290Tm9kZSkgOiBkd2luZG93LmJvZHkoKTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHR2YXIgbWl4aW4gPSBvcHRpb25zLnRlbXBsYXRlID8geyB0ZW1wbGF0ZTogdHJ1ZSB9IDoge30sXG5cdFx0XHRcdGluc3RhbmNlcyA9IFtdLFxuXHRcdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdFx0Ly8gRmlyc3Qgc2NhbiBmb3IgYW55IDxzY3JpcHQgdHlwZT1kb2pvL3JlcXVpcmU+IG5vZGVzLCBhbmQgZXhlY3V0ZS5cblx0XHRcdC8vIFRoZW4gc2NhbiBmb3IgYWxsIG5vZGVzIHdpdGggZGF0YS1kb2pvLXR5cGUsIGFuZCBsb2FkIGFueSB1bmxvYWRlZCBtb2R1bGVzLlxuXHRcdFx0Ly8gVGhlbiBidWlsZCB0aGUgb2JqZWN0IGluc3RhbmNlcy4gIEFkZCBpbnN0YW5jZXMgdG8gYWxyZWFkeSBleGlzdGluZyAoYnV0IGVtcHR5KSBpbnN0YW5jZXNbXSBhcnJheSxcblx0XHRcdC8vIHdoaWNoIG1heSBhbHJlYWR5IGhhdmUgYmVlbiByZXR1cm5lZCB0byBjYWxsZXIuICBBbHNvLCB1c2Ugb3RoZXJ3aXNlIHRvIGNvbGxlY3QgYW5kIHRocm93IGFueSBlcnJvcnNcblx0XHRcdC8vIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBwYXJzZSgpLlxuXHRcdFx0dmFyIHAgPVxuXHRcdFx0XHR0aGlzLl9zY2FuQW1kKHJvb3QsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5zY2FuKHJvb3QsIG9wdGlvbnMpO1xuXHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uKHBhcnNlZE5vZGVzKXtcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5faW5zdGFudGlhdGUocGFyc2VkTm9kZXMsIG1peGluLCBvcHRpb25zLCB0cnVlKTtcblx0XHRcdFx0fSkudGhlbihmdW5jdGlvbihfaW5zdGFuY2VzKXtcblx0XHRcdFx0XHQvLyBDb3B5IHRoZSBpbnN0YW5jZXMgaW50byB0aGUgaW5zdGFuY2VzW10gYXJyYXkgd2UgZGVjbGFyZWQgYWJvdmUsIGFuZCBhcmUgYWNjZXNzaW5nIGFzXG5cdFx0XHRcdFx0Ly8gb3VyIHJldHVybiB2YWx1ZS5cblx0XHRcdFx0XHRyZXR1cm4gaW5zdGFuY2VzID0gaW5zdGFuY2VzLmNvbmNhdChfaW5zdGFuY2VzKTtcblx0XHRcdFx0fSkub3RoZXJ3aXNlKGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdC8vIFRPRE8gTW9kaWZ5IHRvIGZvbGxvdyBiZXR0ZXIgcGF0dGVybiBmb3IgcHJvbWlzZSBlcnJvciBtYW5hZ2VtZW50IHdoZW4gYXZhaWxhYmxlXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcImRvam8vcGFyc2VyOjpwYXJzZSgpIGVycm9yXCIsIGUpO1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBCbGVuZCB0aGUgYXJyYXkgd2l0aCB0aGUgcHJvbWlzZVxuXHRcdFx0ZGxhbmcubWl4aW4oaW5zdGFuY2VzLCBwKTtcblx0XHRcdHJldHVybiBpbnN0YW5jZXM7XG5cdFx0fVxuXHR9O1xuXG5cdGlmKGhhcyhcImV4dGVuZC1kb2pvXCIpKXtcblx0XHRkb2pvLnBhcnNlciA9IHBhcnNlcjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBwYXJzZXIgY2FsbGJhY2suIEl0IHNob3VsZCBiZSB0aGUgZmlyc3QgY2FsbGJhY2tcblx0Ly8gYWZ0ZXIgdGhlIGExMXkgdGVzdC5cblx0aWYoY29uZmlnLnBhcnNlT25Mb2FkKXtcblx0XHRyZWFkeSgxMDAsIHBhcnNlciwgXCJwYXJzZVwiKTtcblx0fVxuXG5cdHJldHVybiBwYXJzZXI7XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi4vX2Jhc2UvbGFuZ1wiXG5dLCBmdW5jdGlvbihsYW5nKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3Byb21pc2UvUHJvbWlzZVxuXG5cdGZ1bmN0aW9uIHRocm93QWJzdHJhY3QoKXtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiYWJzdHJhY3RcIik7XG5cdH1cblxuXHRyZXR1cm4gbGFuZy5leHRlbmQoZnVuY3Rpb24gUHJvbWlzZSgpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhlIHB1YmxpYyBpbnRlcmZhY2UgdG8gYSBkZWZlcnJlZC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUaGUgcHVibGljIGludGVyZmFjZSB0byBhIGRlZmVycmVkLiBBbGwgcHJvbWlzZXMgaW4gRG9qbyBhcmVcblx0XHQvL1x0XHRpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcy5cblx0fSwge1xuXHRcdHRoZW46IGZ1bmN0aW9uKGNhbGxiYWNrLCBlcnJiYWNrLCBwcm9nYmFjayl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkIG5ldyBjYWxsYmFja3MgdG8gdGhlIHByb21pc2UuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEFkZCBuZXcgY2FsbGJhY2tzIHRvIHRoZSBkZWZlcnJlZC4gQ2FsbGJhY2tzIGNhbiBiZSBhZGRlZFxuXHRcdFx0Ly9cdFx0YmVmb3JlIG9yIGFmdGVyIHRoZSBkZWZlcnJlZCBpcyBmdWxmaWxsZWQuXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuXG5cdFx0XHQvL1x0XHRSZWNlaXZlcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0XHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuXHRcdFx0Ly9cdFx0UmVjZWl2ZXMgdGhlIHJlamVjdGlvbiBlcnJvci5cblx0XHRcdC8vIHByb2diYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBlbWl0cyBhIHByb2dyZXNzXG5cdFx0XHQvL1x0XHR1cGRhdGUuIFJlY2VpdmVzIHRoZSBwcm9ncmVzcyB1cGRhdGUuXG5cdFx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayhzKS5cblx0XHRcdC8vXHRcdFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNoYWluaW5nIG1hbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0Y2FuY2VsOiBmdW5jdGlvbihyZWFzb24sIHN0cmljdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0SW5mb3JtIHRoZSBkZWZlcnJlZCBpdCBtYXkgY2FuY2VsIGl0cyBhc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuXHRcdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0XHQvL1x0XHRJbmZvcm0gdGhlIGRlZmVycmVkIGl0IG1heSBjYW5jZWwgaXRzIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG5cdFx0XHQvL1x0XHRUaGUgZGVmZXJyZWQncyAob3B0aW9uYWwpIGNhbmNlbGVyIGlzIGludm9rZWQgYW5kIHRoZVxuXHRcdFx0Ly9cdFx0ZGVmZXJyZWQgd2lsbCBiZSBsZWZ0IGluIGEgcmVqZWN0ZWQgc3RhdGUuIENhbiBhZmZlY3Qgb3RoZXJcblx0XHRcdC8vXHRcdHByb21pc2VzIHRoYXQgb3JpZ2luYXRlIHdpdGggdGhlIHNhbWUgZGVmZXJyZWQuXG5cdFx0XHQvLyByZWFzb246IGFueVxuXHRcdFx0Ly9cdFx0QSBtZXNzYWdlIHRoYXQgbWF5IGJlIHNlbnQgdG8gdGhlIGRlZmVycmVkJ3MgY2FuY2VsZXIsXG5cdFx0XHQvL1x0XHRleHBsYWluaW5nIHdoeSBpdCdzIGJlaW5nIGNhbmNlbGVkLlxuXHRcdFx0Ly8gc3RyaWN0OiBCb29sZWFuP1xuXHRcdFx0Ly9cdFx0SWYgc3RyaWN0LCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBkZWZlcnJlZCBoYXMgYWxyZWFkeVxuXHRcdFx0Ly9cdFx0YmVlbiBmdWxmaWxsZWQgYW5kIGNvbnNlcXVlbnRseSBjYW5ub3QgYmUgY2FuY2VsZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBhbnlcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIGRlZmVycmVkIHdhcyBjYW5jZWxlZFxuXHRcdFx0Ly9cdFx0bm9ybWFsbHkuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0aXNSZXNvbHZlZDogZnVuY3Rpb24oKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDaGVja3Mgd2hldGhlciB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZC5cblx0XHRcdC8vIHJldHVybnM6IEJvb2xlYW5cblxuXHRcdFx0dGhyb3dBYnN0cmFjdCgpO1xuXHRcdH0sXG5cblx0XHRpc1JlamVjdGVkOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyB3aGV0aGVyIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHR0aHJvd0Fic3RyYWN0KCk7XG5cdFx0fSxcblxuXHRcdGlzRnVsZmlsbGVkOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENoZWNrcyB3aGV0aGVyIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gcmV0dXJuczogQm9vbGVhblxuXG5cdFx0XHR0aHJvd0Fic3RyYWN0KCk7XG5cdFx0fSxcblxuXHRcdGlzQ2FuY2VsZWQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2tzIHdoZXRoZXIgdGhlIHByb21pc2UgaGFzIGJlZW4gY2FuY2VsZWQuXG5cdFx0XHQvLyByZXR1cm5zOiBCb29sZWFuXG5cblx0XHRcdHRocm93QWJzdHJhY3QoKTtcblx0XHR9LFxuXG5cdFx0XCJmaW5hbGx5XCI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkIGEgY2FsbGJhY2sgdG8gdGhlIHByb21pc2UgdGhhdCB3aWxsIGZpcmUgd2hldGhlciBpdFxuXHRcdFx0Ly9cdFx0cmVzb2x2ZXMgb3IgcmVqZWN0cy5cblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Q29uZm9ybXMgdG8gRVMyMDE4J3MgYFByb21pc2UucHJvdG90eXBlLmZpbmFsbHlgLlxuXHRcdFx0Ly9cdFx0QWRkIGEgY2FsbGJhY2sgdG8gdGhlIHByb21pc2UgdGhhdCB3aWxsIGZpcmUgd2hldGhlciBpdFxuXHRcdFx0Ly9cdFx0cmVzb2x2ZXMgb3IgcmVqZWN0cy4gTm8gdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cblx0XHRcdC8vXHRcdFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVmbGVjdHMgdGhlIHN0YXRlIG9mIHRoZSBvcmlnaW5hbCBwcm9taXNlLFxuXHRcdFx0Ly9cdFx0d2l0aCB0d28gZXhjZXB0aW9uczpcblx0XHRcdC8vXHRcdC0gSWYgdGhlIGNhbGxiYWNrIHJldHVybiBhIHByb21pc2UsIHRoZSBvdXRlciBwcm9taXNlIHdpbGwgd2FpdFxuXHRcdFx0Ly9cdFx0dW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgcmVzb2x2ZWQsIHRoZW4gaXQgd2lsbCByZXNvbHZlXG5cdFx0XHQvL1x0XHR3aXRoIHRoZSBvcmlnaW5hbCB2YWx1ZS5cblx0XHRcdC8vXHRcdC0gSWYgdGhlIGNhbGxiYWNrIHRocm93cyBhbiBleGNlcHRpb24gb3IgcmV0dXJucyBhIHByb21pc2UgdGhhdFxuXHRcdFx0Ly9cdFx0aXMgcmVqZWN0ZWQgKG9yIHJlamVjdHMgbGF0ZXIpLCB0aGUgb3V0ZXIgcHJvbWlzZSB3aWxsIHJlamVjdFxuXHRcdFx0Ly9cdFx0d2l0aCB0aGUgaW5uZXIgcHJvbWlzZSdzIHJlamVjdGlvbiByZWFzb24uXG5cdFx0XHQvLyBjYWxsYmFjazogRnVuY3Rpb24/XG5cdFx0XHQvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcblx0XHRcdC8vXHRcdG9yIHJlamVjdGVkLiBEb2Vzbid0IHJlY2VpdmUgYW55IHZhbHVlLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgcHJvbWlzZSB0aGF0IHJlZmxlY3RzIHRoZSBzdGF0ZSBvZiB0aGUgb3JpZ2luYWwgcHJvbWlzZSxcblx0XHRcdC8vXHRcdHdpdGggdHdvIHNtYWxsIGV4Y2VwdGlvbnMgKHNlZSBkZXNjcmlwdGlvbikuXG5cdFx0XHQvL1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSl7XG5cdFx0XHRcdHZhciB2YWx1ZU9yUHJvbWlzZSA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGlmICh2YWx1ZU9yUHJvbWlzZSAmJiB0eXBlb2YgdmFsdWVPclByb21pc2UudGhlbiA9PT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWVPclByb21pc2UudGhlbihmdW5jdGlvbiAoKXtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9LCBmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdFx0dmFyIHZhbHVlT3JQcm9taXNlID0gY2FsbGJhY2soKTtcblx0XHRcdFx0aWYgKHZhbHVlT3JQcm9taXNlICYmIHR5cGVvZiB2YWx1ZU9yUHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZU9yUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpe1xuXHRcdFx0XHRcdFx0dGhyb3cgcmVhc29uO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IHJlYXNvbjtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRhbHdheXM6IGZ1bmN0aW9uKGNhbGxiYWNrT3JFcnJiYWNrKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRBZGQgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcblx0XHRcdC8vXHRcdG9yIHJlamVjdGVkLlxuXHRcdFx0Ly8gY2FsbGJhY2tPckVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdFx0Ly9cdFx0QSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgYm90aCBhcyBhIGNhbGxiYWNrIGFuZCBlcnJiYWNrLlxuXHRcdFx0Ly8gcmV0dXJuczogZG9qby9wcm9taXNlL1Byb21pc2Vcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2svZXJyYmFjay5cblxuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihjYWxsYmFja09yRXJyYmFjaywgY2FsbGJhY2tPckVycmJhY2spO1xuXHRcdH0sXG5cblx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKGVycmJhY2spe1xuXHRcdCAgICAvLyBzdW1tYXJ5OlxuXHRcdCAgICAvL1x0XHRBZGQgbmV3IGVycmJhY2tzIHRvIHRoZSBwcm9taXNlLiBGb2xsb3dzIEVDTUEgc3BlY2lmaWNhdGlvbiBuYW1pbmcuXG5cdFx0ICAgIC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdCAgICAvL1x0XHRDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG5cdFx0ICAgIC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0ICAgIC8vXHRcdFJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgZXJyYmFjay5cblxuXHRcdCAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIGVycmJhY2spO1xuXHRcdH0sXG5cblx0XHRvdGhlcndpc2U6IGZ1bmN0aW9uKGVycmJhY2spe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEFkZCBuZXcgZXJyYmFja3MgdG8gdGhlIHByb21pc2UuXG5cdFx0XHQvLyBlcnJiYWNrOiBGdW5jdGlvbj9cblx0XHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cblx0XHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIGVycmJhY2suXG5cblx0XHRcdHJldHVybiB0aGlzLnRoZW4obnVsbCwgZXJyYmFjayk7XG5cdFx0fSxcblxuXHRcdHRyYWNlOiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHRyYWNlUmVqZWN0ZWQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvLyByZXR1cm5zOiBzdHJpbmdcblx0XHRcdC8vXHRcdFJldHVybnMgYFtvYmplY3QgUHJvbWlzZV1gLlxuXG5cdFx0XHRyZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCIuLi9fYmFzZS9hcnJheVwiLFxuXHRcIi4uL19iYXNlL2xhbmdcIixcblx0XCIuLi9EZWZlcnJlZFwiLFxuXHRcIi4uL3doZW5cIlxuXSwgZnVuY3Rpb24oYXJyYXksIGxhbmcsIERlZmVycmVkLCB3aGVuKXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3Byb21pc2UvYWxsXG5cblx0dmFyIHNvbWUgPSBhcnJheS5zb21lO1xuXG5cdHJldHVybiBmdW5jdGlvbiBhbGwob2JqZWN0T3JBcnJheSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUYWtlcyBtdWx0aXBsZSBwcm9taXNlcyBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkXG5cdFx0Ly9cdFx0d2hlbiBhbGwgcHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIG9yIG9uZSBoYXMgYmVlbiByZWplY3RlZC5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHRUYWtlcyBtdWx0aXBsZSBwcm9taXNlcyBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkXG5cdFx0Ly9cdFx0d2hlbiBhbGwgcHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIG9yIG9uZSBoYXMgYmVlbiByZWplY3RlZC4gSWYgb25lIG9mXG5cdFx0Ly9cdFx0dGhlIHByb21pc2VzIGlzIHJlamVjdGVkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBhbHNvIHJlamVjdGVkLiBDYW5jZWxpbmdcblx0XHQvL1x0XHR0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsICpub3QqIGNhbmNlbCBhbnkgcGFzc2VkIHByb21pc2VzLlxuXHRcdC8vIG9iamVjdE9yQXJyYXk6IE9iamVjdHxBcnJheT9cblx0XHQvL1x0XHRUaGUgcHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGEgbGlzdCBvZiByZXN1bHRzIGlmIGludm9rZWQgd2l0aCBhblxuXHRcdC8vXHRcdGFycmF5LCBvciBhbiBvYmplY3Qgb2YgcmVzdWx0cyB3aGVuIHBhc3NlZCBhbiBvYmplY3QgKHVzaW5nIHRoZSBzYW1lXG5cdFx0Ly9cdFx0a2V5cykuIElmIHBhc3NlZCBuZWl0aGVyIGFuIG9iamVjdCBvciBhcnJheSBpdCBpcyByZXNvbHZlZCB3aXRoIGFuXG5cdFx0Ly9cdFx0dW5kZWZpbmVkIHZhbHVlLlxuXHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cblx0XHR2YXIgb2JqZWN0LCBhcnJheTtcblx0XHRpZihsYW5nLmlzQXJyYXkob2JqZWN0T3JBcnJheSkpe1xuXHRcdFx0YXJyYXkgPSBvYmplY3RPckFycmF5O1xuXHRcdH1lbHNlIGlmKG9iamVjdE9yQXJyYXkgJiYgdHlwZW9mIG9iamVjdE9yQXJyYXkgPT09IFwib2JqZWN0XCIpe1xuXHRcdFx0b2JqZWN0ID0gb2JqZWN0T3JBcnJheTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0cztcblx0XHR2YXIga2V5TG9va3VwID0gW107XG5cdFx0aWYob2JqZWN0KXtcblx0XHRcdGFycmF5ID0gW107XG5cdFx0XHRmb3IodmFyIGtleSBpbiBvYmplY3Qpe1xuXHRcdFx0XHRpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpe1xuXHRcdFx0XHRcdGtleUxvb2t1cC5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaChvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlc3VsdHMgPSB7fTtcblx0XHR9ZWxzZSBpZihhcnJheSl7XG5cdFx0XHRyZXN1bHRzID0gW107XG5cdFx0fVxuXG5cdFx0aWYoIWFycmF5IHx8ICFhcnJheS5sZW5ndGgpe1xuXHRcdFx0cmV0dXJuIG5ldyBEZWZlcnJlZCgpLnJlc29sdmUocmVzdWx0cyk7XG5cdFx0fVxuXG5cdFx0dmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cdFx0ZGVmZXJyZWQucHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKXtcblx0XHRcdHJlc3VsdHMgPSBrZXlMb29rdXAgPSBudWxsO1xuXHRcdH0pO1xuXHRcdHZhciB3YWl0aW5nID0gYXJyYXkubGVuZ3RoO1xuXHRcdHNvbWUoYXJyYXksIGZ1bmN0aW9uKHZhbHVlT3JQcm9taXNlLCBpbmRleCl7XG5cdFx0XHRpZighb2JqZWN0KXtcblx0XHRcdFx0a2V5TG9va3VwLnB1c2goaW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0d2hlbih2YWx1ZU9yUHJvbWlzZSwgZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRpZighZGVmZXJyZWQuaXNGdWxmaWxsZWQoKSl7XG5cdFx0XHRcdFx0cmVzdWx0c1trZXlMb29rdXBbaW5kZXhdXSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmKC0td2FpdGluZyA9PT0gMCl7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgZGVmZXJyZWQucmVqZWN0KTtcblx0XHRcdHJldHVybiBkZWZlcnJlZC5pc0Z1bGZpbGxlZCgpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1x0Ly8gZG9qby9wcm9taXNlL1Byb21pc2Vcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCIuLi9fYmFzZS9hcnJheVwiLFxuXHRcIi4uL0RlZmVycmVkXCIsXG5cdFwiLi4vd2hlblwiXG5dLCBmdW5jdGlvbihhcnJheSwgRGVmZXJyZWQsIHdoZW4pe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vcHJvbWlzZS9maXJzdFxuXG5cdHZhciBmb3JFYWNoID0gYXJyYXkuZm9yRWFjaDtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZmlyc3Qob2JqZWN0T3JBcnJheSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUYWtlcyBtdWx0aXBsZSBwcm9taXNlcyBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkXG5cdFx0Ly9cdFx0d2hlbiB0aGUgZmlyc3Qgb2YgdGhlc2UgcHJvbWlzZXMgaXMgZnVsZmlsbGVkLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFRha2VzIG11bHRpcGxlIHByb21pc2VzIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWRcblx0XHQvL1x0XHR3aGVuIHRoZSBmaXJzdCBvZiB0aGVzZSBwcm9taXNlcyBpcyBmdWxmaWxsZWQuIENhbmNlbGluZyB0aGUgcmV0dXJuZWRcblx0XHQvL1x0XHRwcm9taXNlIHdpbGwgKm5vdCogY2FuY2VsIGFueSBwYXNzZWQgcHJvbWlzZXMuIFRoZSBwcm9taXNlIHdpbGwgYmVcblx0XHQvL1x0XHRmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGZ1bGZpbGxlZCBwcm9taXNlLlxuXHRcdC8vIG9iamVjdE9yQXJyYXk6IE9iamVjdHxBcnJheT9cblx0XHQvL1x0XHRUaGUgcHJvbWlzZXMgYXJlIHRha2VuIGZyb20gdGhlIGFycmF5IG9yIG9iamVjdCB2YWx1ZXMuIElmIG5vIHZhbHVlXG5cdFx0Ly9cdFx0aXMgcGFzc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGFuIHVuZGVmaW5lZCB2YWx1ZS5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXG5cdFx0dmFyIGFycmF5O1xuXHRcdGlmKG9iamVjdE9yQXJyYXkgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRhcnJheSA9IG9iamVjdE9yQXJyYXk7XG5cdFx0fWVsc2UgaWYob2JqZWN0T3JBcnJheSAmJiB0eXBlb2Ygb2JqZWN0T3JBcnJheSA9PT0gXCJvYmplY3RcIil7XG5cdFx0XHRhcnJheSA9IFtdO1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gb2JqZWN0T3JBcnJheSl7XG5cdFx0XHRcdGlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdE9yQXJyYXksIGtleSkpe1xuXHRcdFx0XHRcdGFycmF5LnB1c2gob2JqZWN0T3JBcnJheVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKCFhcnJheSB8fCAhYXJyYXkubGVuZ3RoKXtcblx0XHRcdHJldHVybiBuZXcgRGVmZXJyZWQoKS5yZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG5cdFx0Zm9yRWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWVPclByb21pc2Upe1xuXHRcdFx0d2hlbih2YWx1ZU9yUHJvbWlzZSwgZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcdC8vIGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdH07XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi90cmFjZXJcIixcblx0XCIuLi9oYXNcIixcblx0XCIuLi9fYmFzZS9sYW5nXCIsXG5cdFwiLi4vX2Jhc2UvYXJyYXlcIlxuXSwgZnVuY3Rpb24odHJhY2VyLCBoYXMsIGxhbmcsIGFycmF5VXRpbCl7XG5cdGhhcy5hZGQoXCJjb25maWctdXNlRGVmZXJyZWRJbnN0cnVtZW50YXRpb25cIiwgXCJyZXBvcnQtdW5oYW5kbGVkLXJlamVjdGlvbnNcIik7XG5cblx0ZnVuY3Rpb24gbG9nRXJyb3IoZXJyb3IsIHJlamVjdGlvbiwgZGVmZXJyZWQpe1xuXHRcdGlmKGVycm9yICYmIGVycm9yLmxvZyA9PT0gZmFsc2Upe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgc3RhY2sgPSBcIlwiO1xuXHRcdGlmKGVycm9yICYmIGVycm9yLnN0YWNrKXtcblx0XHRcdHN0YWNrICs9IGVycm9yLnN0YWNrO1xuXHRcdH1cblx0XHRpZihyZWplY3Rpb24gJiYgcmVqZWN0aW9uLnN0YWNrKXtcblx0XHRcdHN0YWNrICs9IFwiXFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgcmVqZWN0ZWRcIiArIHJlamVjdGlvbi5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKS5qb2luKFwiXFxuXCIpLnJlcGxhY2UoL15cXHMrLywgXCIgXCIpO1xuXHRcdH1cblx0XHRpZihkZWZlcnJlZCAmJiBkZWZlcnJlZC5zdGFjayl7XG5cdFx0XHRzdGFjayArPSBcIlxcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgKyBkZWZlcnJlZC5zdGFjaztcblx0XHR9XG5cdFx0Y29uc29sZS5lcnJvcihlcnJvciwgc3RhY2spO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVwb3J0UmVqZWN0aW9ucyhlcnJvciwgaGFuZGxlZCwgcmVqZWN0aW9uLCBkZWZlcnJlZCl7XG5cdFx0aWYoIWhhbmRsZWQpe1xuXHRcdFx0bG9nRXJyb3IoZXJyb3IsIHJlamVjdGlvbiwgZGVmZXJyZWQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIGFjdGl2ZVRpbWVvdXQgPSBmYWxzZTtcblx0dmFyIHVuaGFuZGxlZFdhaXQgPSAxMDAwO1xuXHRmdW5jdGlvbiB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMoZXJyb3IsIGhhbmRsZWQsIHJlamVjdGlvbiwgZGVmZXJyZWQpe1xuXHRcdC8vIHRyeSB0byBmaW5kIHRoZSBleGlzdGluZyB0cmFja2luZyBvYmplY3Rcblx0XHRpZighYXJyYXlVdGlsLnNvbWUoZXJyb3JzLCBmdW5jdGlvbihvYmope1xuXHRcdFx0aWYob2JqLmVycm9yID09PSBlcnJvcil7XG5cdFx0XHRcdC8vIGZvdW5kIHRoZSB0cmFja2luZyBvYmplY3QgZm9yIHRoaXMgZXJyb3Jcblx0XHRcdFx0aWYoaGFuZGxlZCl7XG5cdFx0XHRcdFx0Ly8gaWYgaGFuZGxlZCwgdXBkYXRlIHRoZSBzdGF0ZVxuXHRcdFx0XHRcdG9iai5oYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KSl7XG5cdFx0XHQvLyBubyB0cmFja2luZyBvYmplY3QgaGFzIGJlZW4gc2V0dXAsIGNyZWF0ZSBvbmVcblx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRyZWplY3Rpb246IHJlamVjdGlvbixcblx0XHRcdFx0aGFuZGxlZDogaGFuZGxlZCxcblx0XHRcdFx0ZGVmZXJyZWQ6IGRlZmVycmVkLFxuXHRcdFx0XHR0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZighYWN0aXZlVGltZW91dCl7XG5cdFx0XHRhY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dChsb2dSZWplY3RlZCwgdW5oYW5kbGVkV2FpdCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9nUmVqZWN0ZWQoKXtcblx0XHR2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dmFyIHJlcG9ydEJlZm9yZSA9IG5vdyAtIHVuaGFuZGxlZFdhaXQ7XG5cdFx0ZXJyb3JzID0gYXJyYXlVdGlsLmZpbHRlcihlcnJvcnMsIGZ1bmN0aW9uKG9iail7XG5cdFx0XHQvLyBvbmx5IHJlcG9ydCB0aGUgZXJyb3IgaWYgd2UgaGF2ZSB3YWl0ZWQgbG9uZyBlbm91Z2ggYW5kXG5cdFx0XHQvLyBpdCBoYXNuJ3QgYmVlbiBoYW5kbGVkXG5cdFx0XHRpZihvYmoudGltZXN0YW1wIDwgcmVwb3J0QmVmb3JlKXtcblx0XHRcdFx0aWYoIW9iai5oYW5kbGVkKXtcblx0XHRcdFx0XHRsb2dFcnJvcihvYmouZXJyb3IsIG9iai5yZWplY3Rpb24sIG9iai5kZWZlcnJlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0XHRpZihlcnJvcnMubGVuZ3RoKXtcblx0XHRcdGFjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGxvZ1JlamVjdGVkLCBlcnJvcnNbMF0udGltZXN0YW1wICsgdW5oYW5kbGVkV2FpdCAtIG5vdyk7XG5cdFx0fWVsc2V7XG5cdFx0XHRhY3RpdmVUaW1lb3V0ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKERlZmVycmVkKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEluaXRpYWxpemUgaW5zdHJ1bWVudGF0aW9uIGZvciB0aGUgRGVmZXJyZWQgY2xhc3MuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SW5pdGlhbGl6ZSBpbnN0cnVtZW50YXRpb24gZm9yIHRoZSBEZWZlcnJlZCBjbGFzcy5cblx0XHQvL1x0XHREb25lIGF1dG9tYXRpY2FsbHkgYnkgYGRvam8vRGVmZXJyZWRgIGlmIHRoZVxuXHRcdC8vXHRcdGBkZWZlcnJlZEluc3RydW1lbnRhdGlvbmAgYW5kIGB1c2VEZWZlcnJlZEluc3RydW1lbnRhdGlvbmBcblx0XHQvL1x0XHRjb25maWcgb3B0aW9ucyBhcmUgc2V0LlxuXHRcdC8vXG5cdFx0Ly9cdFx0U2V0cyB1cCBgZG9qby9wcm9taXNlL3RyYWNlcmAgdG8gbG9nIHRvIHRoZSBjb25zb2xlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0U2V0cyB1cCBpbnN0cnVtZW50YXRpb24gb2YgcmVqZWN0ZWQgZGVmZXJyZWRzIHNvIHVuaGFuZGxlZFxuXHRcdC8vXHRcdGVycm9ycyBhcmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuXG5cdFx0dmFyIHVzYWdlID0gaGFzKFwiY29uZmlnLXVzZURlZmVycmVkSW5zdHJ1bWVudGF0aW9uXCIpO1xuXHRcdGlmKHVzYWdlKXtcblx0XHRcdHRyYWNlci5vbihcInJlc29sdmVkXCIsIGxhbmcuaGl0Y2goY29uc29sZSwgXCJsb2dcIiwgXCJyZXNvbHZlZFwiKSk7XG5cdFx0XHR0cmFjZXIub24oXCJyZWplY3RlZFwiLCBsYW5nLmhpdGNoKGNvbnNvbGUsIFwibG9nXCIsIFwicmVqZWN0ZWRcIikpO1xuXHRcdFx0dHJhY2VyLm9uKFwicHJvZ3Jlc3NcIiwgbGFuZy5oaXRjaChjb25zb2xlLCBcImxvZ1wiLCBcInByb2dyZXNzXCIpKTtcblxuXHRcdFx0dmFyIGFyZ3MgPSBbXTtcblx0XHRcdGlmKHR5cGVvZiB1c2FnZSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdGFyZ3MgPSB1c2FnZS5zcGxpdChcIixcIik7XG5cdFx0XHRcdHVzYWdlID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYodXNhZ2UgPT09IFwicmVwb3J0LXJlamVjdGlvbnNcIil7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCA9IHJlcG9ydFJlamVjdGlvbnM7XG5cdFx0XHR9ZWxzZSBpZih1c2FnZSA9PT0gXCJyZXBvcnQtdW5oYW5kbGVkLXJlamVjdGlvbnNcIiB8fCB1c2FnZSA9PT0gdHJ1ZSB8fCB1c2FnZSA9PT0gMSl7XG5cdFx0XHRcdERlZmVycmVkLmluc3RydW1lbnRSZWplY3RlZCA9IHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucztcblx0XHRcdFx0dW5oYW5kbGVkV2FpdCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKSB8fCB1bmhhbmRsZWRXYWl0O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGluc3RydW1lbnRhdGlvbiB1c2FnZSA8XCIgKyB1c2FnZSArIFwiPlwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi4vX2Jhc2UvbGFuZ1wiLFxuXHRcIi4vUHJvbWlzZVwiLFxuXHRcIi4uL0V2ZW50ZWRcIlxuXSwgZnVuY3Rpb24obGFuZywgUHJvbWlzZSwgRXZlbnRlZCl7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby9wcm9taXNlL3RyYWNlclxuXG5cdC8qPT09PT1cblx0cmV0dXJuIHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRyYWNlIHByb21pc2UgZnVsZmlsbG1lbnQuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VHJhY2UgcHJvbWlzZSBmdWxmaWxsbWVudC4gQ2FsbGluZyBgLnRyYWNlKClgIG9yIGAudHJhY2VFcnJvcigpYCBvbiBhXG5cdFx0Ly9cdFx0cHJvbWlzZSBlbmFibGVzIHRyYWNpbmcuIFdpbGwgZW1pdCBgcmVzb2x2ZWRgLCBgcmVqZWN0ZWRgIG9yIGBwcm9ncmVzc2Bcblx0XHQvL1x0XHRldmVudHMuXG5cblx0XHRvbjogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN1YnNjcmliZSB0byB0cmFjZXMuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFNlZSBgZG9qby9FdmVudGVkI29uKClgLlxuXHRcdFx0Ly8gdHlwZTogU3RyaW5nXG5cdFx0XHQvL1x0XHRgcmVzb2x2ZWRgLCBgcmVqZWN0ZWRgLCBvciBgcHJvZ3Jlc3NgXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdFRoZSBsaXN0ZW5lciBpcyBwYXNzZWQgdGhlIHRyYWNlZCB2YWx1ZSBhbmQgYW55IGFyZ3VtZW50c1xuXHRcdFx0Ly9cdFx0dGhhdCB3ZXJlIHVzZWQgd2l0aCB0aGUgYC50cmFjZSgpYCBjYWxsLlxuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdHZhciBldmVudGVkID0gbmV3IEV2ZW50ZWQ7XG5cdHZhciBlbWl0ID0gZXZlbnRlZC5lbWl0O1xuXHRldmVudGVkLmVtaXQgPSBudWxsO1xuXHQvLyBFbWl0IGV2ZW50cyBhc3luY2hyb25vdXNseSBzaW5jZSB0aGV5IHNob3VsZCBub3QgY2hhbmdlIHRoZSBwcm9taXNlIHN0YXRlLlxuXHRmdW5jdGlvbiBlbWl0QXN5bmMoYXJncyl7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0ZW1pdC5hcHBseShldmVudGVkLCBhcmdzKTtcblx0XHR9LCAwKTtcblx0fVxuXG5cdFByb21pc2UucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24oKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRyYWNlIHRoZSBwcm9taXNlLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFRyYWNpbmcgYWxsb3dzIHlvdSB0byB0cmFuc3BhcmVudGx5IGxvZyBwcm9ncmVzcyxcblx0XHQvL1x0XHRyZXNvbHV0aW9uIGFuZCByZWplY3Rpb24gb2YgcHJvbWlzZXMsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZVxuXHRcdC8vXHRcdHByb21pc2UgaXRzZWxmLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byBgdHJhY2UoKWAgYXJlXG5cdFx0Ly9cdFx0ZW1pdHRlZCBpbiB0cmFjZSBldmVudHMuIFNlZSBgZG9qby9wcm9taXNlL3RyYWNlcmAgb24gaG93XG5cdFx0Ly9cdFx0dG8gaGFuZGxlIHRyYWNlcy5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3Byb21pc2UvUHJvbWlzZVxuXHRcdC8vXHRcdFRoZSBwcm9taXNlIGluc3RhbmNlIGB0cmFjZSgpYCBpcyBjYWxsZWQgb24uXG5cblx0XHR2YXIgYXJncyA9IGxhbmcuX3RvQXJyYXkoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRoZW4oXG5cdFx0XHRmdW5jdGlvbih2YWx1ZSl7IGVtaXRBc3luYyhbXCJyZXNvbHZlZFwiLCB2YWx1ZV0uY29uY2F0KGFyZ3MpKTsgfSxcblx0XHRcdGZ1bmN0aW9uKGVycm9yKXsgZW1pdEFzeW5jKFtcInJlamVjdGVkXCIsIGVycm9yXS5jb25jYXQoYXJncykpOyB9LFxuXHRcdFx0ZnVuY3Rpb24odXBkYXRlKXsgZW1pdEFzeW5jKFtcInByb2dyZXNzXCIsIHVwZGF0ZV0uY29uY2F0KGFyZ3MpKTsgfVxuXHRcdCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0UHJvbWlzZS5wcm90b3R5cGUudHJhY2VSZWplY3RlZCA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUcmFjZSByZWplY3Rpb24gb2YgdGhlIHByb21pc2UuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0VHJhY2luZyBhbGxvd3MgeW91IHRvIHRyYW5zcGFyZW50bHkgbG9nIHByb2dyZXNzLFxuXHRcdC8vXHRcdHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBvZiBwcm9taXNlcywgd2l0aG91dCBhZmZlY3RpbmcgdGhlXG5cdFx0Ly9cdFx0cHJvbWlzZSBpdHNlbGYuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIGB0cmFjZSgpYCBhcmVcblx0XHQvL1x0XHRlbWl0dGVkIGluIHRyYWNlIGV2ZW50cy4gU2VlIGBkb2pvL3Byb21pc2UvdHJhY2VyYCBvbiBob3dcblx0XHQvL1x0XHR0byBoYW5kbGUgdHJhY2VzLlxuXHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0VGhlIHByb21pc2UgaW5zdGFuY2UgYHRyYWNlUmVqZWN0ZWQoKWAgaXMgY2FsbGVkIG9uLlxuXG5cdFx0dmFyIGFyZ3MgPSBsYW5nLl90b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5vdGhlcndpc2UoZnVuY3Rpb24oZXJyb3Ipe1xuXHRcdFx0ZW1pdEFzeW5jKFtcInJlamVjdGVkXCIsIGVycm9yXS5jb25jYXQoYXJncykpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJldHVybiBldmVudGVkO1xufSk7XG4iLCJkZWZpbmUoW1wiLi9fYmFzZS9rZXJuZWxcIiwgXCIuL2hhc1wiLCBcIi4vZG9tXCIsIFwiLi9vblwiLCBcIi4vX2Jhc2UvYXJyYXlcIiwgXCIuL19iYXNlL2xhbmdcIiwgXCIuL3NlbGVjdG9yL19sb2FkZXJcIiwgXCIuL3NlbGVjdG9yL19sb2FkZXIhZGVmYXVsdFwiXSxcblx0ZnVuY3Rpb24oZG9qbywgaGFzLCBkb20sIG9uLCBhcnJheSwgbGFuZywgbG9hZGVyLCBkZWZhdWx0RW5naW5lKXtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRoYXMuYWRkKFwiYXJyYXktZXh0ZW5zaWJsZVwiLCBmdW5jdGlvbigpe1xuXHRcdC8vIHRlc3QgdG8gc2VlIGlmIHdlIGNhbiBleHRlbmQgYW4gYXJyYXkgKG5vdCBzdXBwb3J0ZWQgaW4gb2xkIElFKVxuXHRcdHJldHVybiBsYW5nLmRlbGVnYXRlKFtdLCB7bGVuZ3RoOiAxfSkubGVuZ3RoID09IDEgJiYgIWhhcyhcImJ1Zy1mb3ItaW4tc2tpcHMtc2hhZG93ZWRcIik7XG5cdH0pO1xuXHRcblx0dmFyIGFwID0gQXJyYXkucHJvdG90eXBlLCBhcHMgPSBhcC5zbGljZSwgYXBjID0gYXAuY29uY2F0LCBmb3JFYWNoID0gYXJyYXkuZm9yRWFjaDtcblxuXHR2YXIgdG5sID0gZnVuY3Rpb24oLypBcnJheSovIGEsIC8qZG9qby9Ob2RlTGlzdD8qLyBwYXJlbnQsIC8qRnVuY3Rpb24/Ki8gTm9kZUxpc3RDdG9yKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGRlY29yYXRlIGFuIGFycmF5IHRvIG1ha2UgaXQgbG9vayBsaWtlIGEgYGRvam8vTm9kZUxpc3RgLlxuXHRcdC8vIGE6XG5cdFx0Ly9cdFx0QXJyYXkgb2Ygbm9kZXMgdG8gZGVjb3JhdGUuXG5cdFx0Ly8gcGFyZW50OlxuXHRcdC8vXHRcdEFuIG9wdGlvbmFsIHBhcmVudCBOb2RlTGlzdCB0aGF0IGdlbmVyYXRlZCB0aGUgY3VycmVudFxuXHRcdC8vXHRcdGxpc3Qgb2Ygbm9kZXMuIFVzZWQgdG8gY2FsbCBfc3Rhc2goKSBzbyB0aGUgcGFyZW50IE5vZGVMaXN0XG5cdFx0Ly9cdFx0Y2FuIGJlIGFjY2Vzc2VkIHZpYSBlbmQoKSBsYXRlci5cblx0XHQvLyBOb2RlTGlzdEN0b3I6XG5cdFx0Ly9cdFx0QW4gb3B0aW9uYWwgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gdXNlIGZvciBhbnlcblx0XHQvL1x0XHRuZXcgTm9kZUxpc3QgY2FsbHMuIFRoaXMgYWxsb3dzIGEgY2VydGFpbiBjaGFpbiBvZlxuXHRcdC8vXHRcdE5vZGVMaXN0IGNhbGxzIHRvIHVzZSBhIGRpZmZlcmVudCBvYmplY3QgdGhhbiBkb2pvL05vZGVMaXN0LlxuXHRcdHZhciBub2RlTGlzdCA9IG5ldyAoTm9kZUxpc3RDdG9yIHx8IHRoaXMuX05vZGVMaXN0Q3RvciB8fCBubCkoYSk7XG5cdFx0cmV0dXJuIHBhcmVudCA/IG5vZGVMaXN0Ll9zdGFzaChwYXJlbnQpIDogbm9kZUxpc3Q7XG5cdH07XG5cblx0dmFyIGxvb3BCb2R5ID0gZnVuY3Rpb24oZiwgYSwgbyl7XG5cdFx0YSA9IFswXS5jb25jYXQoYXBzLmNhbGwoYSwgMCkpO1xuXHRcdG8gPSBvIHx8IGRvam8uZ2xvYmFsO1xuXHRcdHJldHVybiBmdW5jdGlvbihub2RlKXtcblx0XHRcdGFbMF0gPSBub2RlO1xuXHRcdFx0cmV0dXJuIGYuYXBwbHkobywgYSk7XG5cdFx0fTtcblx0fTtcblxuXHQvLyBhZGFwdGVyc1xuXG5cdHZhciBhZGFwdEFzRm9yRWFjaCA9IGZ1bmN0aW9uKGYsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgZm9yRWFjaC10eXBlXG5cdFx0Ly9cdFx0YWN0aW9ucy4gVGhlIGluaXRpYWwgb2JqZWN0IGlzIHJldHVybmVkIGZyb20gdGhlIHNwZWNpYWxpemVkXG5cdFx0Ly9cdFx0ZnVuY3Rpb24uXG5cdFx0Ly8gZjogRnVuY3Rpb25cblx0XHQvL1x0XHRhIGZ1bmN0aW9uIHRvIGFkYXB0XG5cdFx0Ly8gbzogT2JqZWN0P1xuXHRcdC8vXHRcdGFuIG9wdGlvbmFsIGNvbnRleHQgZm9yIGZcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuZm9yRWFjaChsb29wQm9keShmLCBhcmd1bWVudHMsIG8pKTtcblx0XHRcdHJldHVybiB0aGlzO1x0Ly8gT2JqZWN0XG5cdFx0fTtcblx0fTtcblxuXHR2YXIgYWRhcHRBc01hcCA9IGZ1bmN0aW9uKGYsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgbWFwLXR5cGVcblx0XHQvL1x0XHRhY3Rpb25zLiBUaGUgcmV0dXJuIGlzIGEgbmV3IGFycmF5IG9mIHZhbHVlcywgYXMgdmlhIGBkb2pvL19iYXNlL2FycmF5Lm1hcGBcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBvOiBPYmplY3Q/XG5cdFx0Ly9cdFx0YW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZlxuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKGxvb3BCb2R5KGYsIGFyZ3VtZW50cywgbykpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIGFkYXB0QXNGaWx0ZXIgPSBmdW5jdGlvbihmLCBvKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGFkYXB0cyBhIHNpbmdsZSBub2RlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgaW4gdGhlIGZpbHRlci10eXBlIGFjdGlvbnNcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBvOiBPYmplY3Q/XG5cdFx0Ly9cdFx0YW4gb3B0aW9uYWwgY29udGV4dCBmb3IgZlxuXHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGxvb3BCb2R5KGYsIGFyZ3VtZW50cywgbykpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIGFkYXB0V2l0aENvbmRpdGlvbiA9IGZ1bmN0aW9uKGYsIGcsIG8pe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0YWRhcHRzIGEgc2luZ2xlIG5vZGUgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiB0aGUgbWFwLXR5cGVcblx0XHQvL1x0XHRhY3Rpb25zLCBiZWhhdmVzIGxpa2UgZm9yRWFjaCgpIG9yIG1hcCgpIGRlcGVuZGluZyBvbiBhcmd1bWVudHNcblx0XHQvLyBmOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgZnVuY3Rpb24gdG8gYWRhcHRcblx0XHQvLyBnOiBGdW5jdGlvblxuXHRcdC8vXHRcdGEgY29uZGl0aW9uIGZ1bmN0aW9uLCBpZiB0cnVlIHJ1bnMgYXMgbWFwKCksIG90aGVyd2lzZSBydW5zIGFzIGZvckVhY2goKVxuXHRcdC8vIG86IE9iamVjdD9cblx0XHQvL1x0XHRhbiBvcHRpb25hbCBjb250ZXh0IGZvciBmIGFuZCBnXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgYSA9IGFyZ3VtZW50cywgYm9keSA9IGxvb3BCb2R5KGYsIGEsIG8pO1xuXHRcdFx0aWYoZy5jYWxsKG8gfHwgZG9qby5nbG9iYWwsIGEpKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGJvZHkpO1x0Ly8gc2VsZlxuXHRcdFx0fVxuXHRcdFx0dGhpcy5mb3JFYWNoKGJvZHkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XHQvLyBzZWxmXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgTm9kZUxpc3QgPSBmdW5jdGlvbihhcnJheSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRBcnJheS1saWtlIG9iamVjdCB3aGljaCBhZGRzIHN5bnRhY3RpY1xuXHRcdC8vXHRcdHN1Z2FyIGZvciBjaGFpbmluZywgY29tbW9uIGl0ZXJhdGlvbiBvcGVyYXRpb25zLCBhbmltYXRpb24sIGFuZFxuXHRcdC8vXHRcdG5vZGUgbWFuaXB1bGF0aW9uLiBOb2RlTGlzdHMgYXJlIG1vc3Qgb2Z0ZW4gcmV0dXJuZWQgYXMgdGhlXG5cdFx0Ly9cdFx0cmVzdWx0IG9mIGRvam8vcXVlcnkoKSBjYWxscy5cblx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHQvL1x0XHROb2RlTGlzdCBpbnN0YW5jZXMgcHJvdmlkZSBtYW55IHV0aWxpdGllcyB0aGF0IHJlZmxlY3Rcblx0XHQvL1x0XHRjb3JlIERvam8gQVBJcyBmb3IgQXJyYXkgaXRlcmF0aW9uIGFuZCBtYW5pcHVsYXRpb24sIERPTVxuXHRcdC8vXHRcdG1hbmlwdWxhdGlvbiwgYW5kIGV2ZW50IGhhbmRsaW5nLiBJbnN0ZWFkIG9mIG5lZWRpbmcgdG8gZGlnIHVwXG5cdFx0Ly9cdFx0ZnVuY3Rpb25zIGluIHRoZSBkb2pvIHBhY2thZ2UsIE5vZGVMaXN0cyBnZW5lcmFsbHkgbWFrZSB0aGVcblx0XHQvL1x0XHRmdWxsIHBvd2VyIG9mIERvam8gYXZhaWxhYmxlIGZvciBET00gbWFuaXB1bGF0aW9uIHRhc2tzIGluIGFcblx0XHQvL1x0XHRzaW1wbGUsIGNoYWluYWJsZSB3YXkuXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRjcmVhdGUgYSBub2RlIGxpc3QgZnJvbSBhIG5vZGVcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL2RvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGRvbSl7XG5cdFx0Ly9cdFx0fFx0XHRxdWVyeS5Ob2RlTGlzdChkb20uYnlJZChcImZvb1wiKSk7XG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRnZXQgYSBOb2RlTGlzdCBmcm9tIGEgQ1NTIHF1ZXJ5IGFuZCBpdGVyYXRlIG9uIGl0XG5cdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL29uXCIsIFwiZG9qby9kb21cIlxuXHRcdC8vXHRcdHxcdF0sIGZ1bmN0aW9uKG9uLCBkb20pe1xuXHRcdC8vXHRcdHxcdFx0dmFyIGwgPSBxdWVyeShcIi50aGluZ2VyXCIpO1xuXHRcdC8vXHRcdHxcdFx0bC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUsIGluZGV4LCBub2RlTGlzdCl7XG5cdFx0Ly9cdFx0fFx0XHRcdGNvbnNvbGUubG9nKGluZGV4LCBub2RlLmlubmVySFRNTCk7XG5cdFx0Ly9cdFx0fFx0XHR9KTtcblx0XHQvL1x0XHR8XHR9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdHVzZSBuYXRpdmUgYW5kIERvam8tcHJvdmlkZWQgYXJyYXkgbWV0aG9kcyB0byBtYW5pcHVsYXRlIGFcblx0XHQvL1x0XHROb2RlTGlzdCB3aXRob3V0IG5lZWRpbmcgdG8gdXNlIGRvam8uKiBmdW5jdGlvbnMgZXhwbGljaXRseTpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL2RvbS1jb25zdHJ1Y3RcIiwgXCJkb2pvL2RvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGRvbUNvbnN0cnVjdCwgZG9tKXtcblx0XHQvL1x0XHR8XHRcdHZhciBsID0gcXVlcnkoXCIudGhpbmdlclwiKTtcblx0XHQvL1x0XHR8XHRcdC8vIHNpbmNlIE5vZGVMaXN0cyBhcmUgcmVhbCBhcnJheXMsIHRoZXkgaGF2ZSBhIGxlbmd0aFxuXHRcdC8vXHRcdHxcdFx0Ly8gcHJvcGVydHkgdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSBhbmRcblx0XHQvL1x0XHR8XHRcdC8vIHB1c2gvcG9wL3NoaWZ0L3Vuc2hpZnQgbWV0aG9kc1xuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2cobC5sZW5ndGgpO1xuXHRcdC8vXHRcdHxcdFx0bC5wdXNoKGRvbUNvbnN0cnVjdC5jcmVhdGUoXCJzcGFuXCIpKTtcblx0XHQvL1x0XHR8XG5cdFx0Ly9cdFx0fFx0XHQvLyBkb2pvJ3Mgbm9ybWFsaXplZCBhcnJheSBtZXRob2RzIHdvcmsgdG9vOlxuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2coIGwuaW5kZXhPZihkb20uYnlJZChcImZvb1wiKSkgKTtcblx0XHQvL1x0XHR8XHRcdC8vIC4uLmluY2x1ZGluZyB0aGUgc3BlY2lhbCBcImZ1bmN0aW9uIGFzIHN0cmluZ1wiIHNob3J0aGFuZFxuXHRcdC8vXHRcdHxcdFx0Y29uc29sZS5sb2coIGwuZXZlcnkoXCJpdGVtLm5vZGVUeXBlID09IDFcIikgKTtcblx0XHQvL1x0XHR8XG5cdFx0Ly9cdFx0fFx0XHQvLyBOb2RlTGlzdHMgY2FuIGJlIFsuLl0gaW5kZXhlZCwgb3IgeW91IGNhbiB1c2UgdGhlIGF0KClcblx0XHQvL1x0XHR8XHRcdC8vIGZ1bmN0aW9uIHRvIGdldCBzcGVjaWZpYyBpdGVtcyB3cmFwcGVkIGluIGEgbmV3IE5vZGVMaXN0OlxuXHRcdC8vXHRcdHxcdFx0dmFyIG5vZGUgPSBsWzNdOyAvLyB0aGUgNHRoIGVsZW1lbnRcblx0XHQvL1x0XHR8XHRcdHZhciBuZXdMaXN0ID0gbC5hdCgxLCAzKTsgLy8gdGhlIDJuZCBhbmQgNHRoIGVsZW1lbnRzXG5cdFx0Ly9cdFx0fFx0fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRjaGFpbmFiaWxpdHkgaXMgYSBrZXkgYWR2YW50YWdlIG9mIE5vZGVMaXN0czpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL05vZGVMaXN0LWRvbVwiXG5cdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdC8vXHRcdHxcdFx0cXVlcnkoXCIudGhpbmdlclwiKVxuXHRcdC8vXHRcdHxcdFx0XHQub25jbGljayhmdW5jdGlvbihlKXsgLyogLi4uICovIH0pXG5cdFx0Ly9cdFx0fFx0XHRcdC5hdCgxLCAzLCA4KSAvLyBnZXQgYSBzdWJzZXRcblx0XHQvL1x0XHR8XHRcdFx0XHQuc3R5bGUoXCJwYWRkaW5nXCIsIFwiNXB4XCIpXG5cdFx0Ly9cdFx0fFx0XHRcdFx0LmZvckVhY2goY29uc29sZS5sb2cpO1xuXHRcdC8vXHRcdHxcdH0pO1xuXG5cdFx0dmFyIGlzTmV3ID0gdGhpcyBpbnN0YW5jZW9mIG5sICYmIGhhcyhcImFycmF5LWV4dGVuc2libGVcIik7XG5cdFx0aWYodHlwZW9mIGFycmF5ID09IFwibnVtYmVyXCIpe1xuXHRcdFx0YXJyYXkgPSBBcnJheShhcnJheSk7XG5cdFx0fVxuXHRcdHZhciBub2RlQXJyYXkgPSAoYXJyYXkgJiYgXCJsZW5ndGhcIiBpbiBhcnJheSkgPyBhcnJheSA6IGFyZ3VtZW50cztcblx0XHRpZihpc05ldyB8fCAhbm9kZUFycmF5LnNvcnQpe1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGl0J3MgYSByZWFsIGFycmF5IGJlZm9yZSB3ZSBwYXNzIGl0IG9uIHRvIGJlIHdyYXBwZWQgXG5cdFx0XHR2YXIgdGFyZ2V0ID0gaXNOZXcgPyB0aGlzIDogW10sXG5cdFx0XHRcdGwgPSB0YXJnZXQubGVuZ3RoID0gbm9kZUFycmF5Lmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHR0YXJnZXRbaV0gPSBub2RlQXJyYXlbaV07XG5cdFx0XHR9XG5cdFx0XHRpZihpc05ldyl7XG5cdFx0XHRcdC8vIGNhbGxlZCB3aXRoIG5ldyBvcGVyYXRvciwgdGhpcyBtZWFucyB3ZSBhcmUgZ29pbmcgdG8gdXNlIHRoaXMgaW5zdGFuY2UgYW5kIHB1c2hcblx0XHRcdFx0Ly8gdGhlIG5vZGVzIG9uIHRvIGl0LiBUaGlzIGlzIHVzdWFsbHkgbXVjaCBmYXN0ZXIgc2luY2UgdGhlIE5vZGVMaXN0IHByb3BlcnRpZXNcblx0XHRcdFx0Ly9cdGRvbid0IG5lZWQgdG8gYmUgY29waWVkICh1bmxlc3MgdGhlIGxpc3Qgb2Ygbm9kZXMgaXMgZXh0cmVtZWx5IGxhcmdlKS5cblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblx0XHRcdG5vZGVBcnJheSA9IHRhcmdldDtcblx0XHR9XG5cdFx0Ly8gY2FsbGVkIHdpdGhvdXQgbmV3IG9wZXJhdG9yLCB1c2UgYSByZWFsIGFycmF5IGFuZCBjb3B5IHByb3RvdHlwZSBwcm9wZXJ0aWVzLFxuXHRcdC8vIHRoaXMgaXMgc2xvd2VyIGFuZCBleGlzdHMgZm9yIGJhY2stY29tcGF0LiBTaG91bGQgYmUgcmVtb3ZlZCBpbiAyLjAuXG5cdFx0bGFuZy5fbWl4aW4obm9kZUFycmF5LCBubHApO1xuXHRcdG5vZGVBcnJheS5fTm9kZUxpc3RDdG9yID0gZnVuY3Rpb24oYXJyYXkpe1xuXHRcdFx0Ly8gY2FsbCB3aXRob3V0IG5ldyBvcGVyYXRvciB0byBwcmVzZXJ2ZSBiYWNrLWNvbXBhdCBiZWhhdmlvclxuXHRcdFx0cmV0dXJuIG5sKGFycmF5KTtcblx0XHR9O1xuXHRcdHJldHVybiBub2RlQXJyYXk7XG5cdH07XG5cdFxuXHR2YXIgbmwgPSBOb2RlTGlzdCwgbmxwID0gbmwucHJvdG90eXBlID0gXG5cdFx0aGFzKFwiYXJyYXktZXh0ZW5zaWJsZVwiKSA/IFtdIDoge307Ly8gZXh0ZW5kIGFuIGFycmF5IGlmIGl0IGlzIGV4dGVuc2libGVcblxuXHQvLyBleHBvc2UgYWRhcHRlcnMgYW5kIHRoZSB3cmFwcGVyIGFzIHByaXZhdGUgZnVuY3Rpb25zXG5cblx0bmwuX3dyYXAgPSBubHAuX3dyYXAgPSB0bmw7XG5cdG5sLl9hZGFwdEFzTWFwID0gYWRhcHRBc01hcDtcblx0bmwuX2FkYXB0QXNGb3JFYWNoID0gYWRhcHRBc0ZvckVhY2g7XG5cdG5sLl9hZGFwdEFzRmlsdGVyICA9IGFkYXB0QXNGaWx0ZXI7XG5cdG5sLl9hZGFwdFdpdGhDb25kaXRpb24gPSBhZGFwdFdpdGhDb25kaXRpb247XG5cblx0Ly8gbWFzcyBhc3NpZ25tZW50XG5cblx0Ly8gYWRkIGFycmF5IHJlZGlyZWN0b3JzXG5cdGZvckVhY2goW1wic2xpY2VcIiwgXCJzcGxpY2VcIl0sIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBmID0gYXBbbmFtZV07XG5cdFx0Ly9Vc2UgYSBjb3B5IG9mIHRoZSB0aGlzIGFycmF5IHZpYSB0aGlzLnNsaWNlKCkgdG8gYWxsb3cgLmVuZCgpIHRvIHdvcmsgcmlnaHQgaW4gdGhlIHNwbGljZSBjYXNlLlxuXHRcdC8vIENBTk5PVCBhcHBseSAuX3N0YXNoKCkvZW5kKCkgdG8gc3BsaWNlIHNpbmNlIGl0IGN1cnJlbnRseSBtb2RpZmllc1xuXHRcdC8vIHRoZSBleGlzdGluZyB0aGlzIGFycmF5IC0tIGl0IHdvdWxkIGJyZWFrIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaWYgd2UgY29weSB0aGUgYXJyYXkgYmVmb3JlXG5cdFx0Ly8gdGhlIHNwbGljZSBzbyB0aGF0IHdlIGNhbiB1c2UgLmVuZCgpLiBTbyBvbmx5IGRvaW5nIHRoZSBzdGFzaCBvcHRpb24gdG8gdGhpcy5fd3JhcCBmb3Igc2xpY2UuXG5cdFx0bmxwW25hbWVdID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3dyYXAoZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBuYW1lID09IFwic2xpY2VcIiA/IHRoaXMgOiBudWxsKTsgfTtcblx0fSk7XG5cdC8vIGNvbmNhdCBzaG91bGQgYmUgaGVyZSBidXQgc29tZSBicm93c2VycyB3aXRoIG5hdGl2ZSBOb2RlTGlzdCBoYXZlIHByb2JsZW1zIHdpdGggaXRcblxuXHQvLyBhZGQgYXJyYXkuanMgcmVkaXJlY3RvcnNcblx0Zm9yRWFjaChbXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIiwgXCJldmVyeVwiLCBcInNvbWVcIl0sIGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBmID0gYXJyYXlbbmFtZV07XG5cdFx0bmxwW25hbWVdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGYuYXBwbHkoZG9qbywgW3RoaXNdLmNvbmNhdChhcHMuY2FsbChhcmd1bWVudHMsIDApKSk7IH07XG5cdH0pO1xuXG5cdGxhbmcuZXh0ZW5kKE5vZGVMaXN0LCB7XG5cdFx0Ly8gY29weSB0aGUgY29uc3RydWN0b3JzXG5cdFx0Y29uc3RydWN0b3I6IG5sLFxuXHRcdF9Ob2RlTGlzdEN0b3I6IG5sLFxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nIGNhbid0IGJlIGFwcGxpZWQgdG8gb2JqZWN0cywgc28gd2UgdXNlIGpvaW5cblx0XHRcdHJldHVybiB0aGlzLmpvaW4oXCIsXCIpO1xuXHRcdH0sXG5cdFx0X3N0YXNoOiBmdW5jdGlvbihwYXJlbnQpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHByaXZhdGUgZnVuY3Rpb24gdG8gaG9sZCB0byBhIHBhcmVudCBOb2RlTGlzdC4gZW5kKCkgdG8gcmV0dXJuIHRoZSBwYXJlbnQgTm9kZUxpc3QuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdEhvdyB0byBtYWtlIGEgYGRvam8vTm9kZUxpc3RgIG1ldGhvZCB0aGF0IG9ubHkgcmV0dXJucyB0aGUgdGhpcmQgbm9kZSBpblxuXHRcdFx0Ly9cdFx0dGhlIGRvam8vTm9kZUxpc3QgYnV0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsIE5vZGVMaXN0IGJ5IHVzaW5nIHRoaXMuX3N0YXNoOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiLCBcImRvam8vX2Jhc2UvbGFuZ1wiLCBcImRvam8vTm9kZUxpc3RcIiwgXCJkb2pvL05vZGVMaXN0LWRvbVwiXG5cdFx0XHQvL1x0fFx0XSwgZnVuY3Rpb24ocXVlcnksIGxhbmcpe1xuXHRcdFx0Ly9cdHxcdFx0bGFuZy5leHRlbmQoTm9kZUxpc3QsIHtcblx0XHRcdC8vXHR8XHRcdFx0dGhpcmQ6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvL1x0fFx0XHRcdFx0dmFyIG5ld05vZGVMaXN0ID0gTm9kZUxpc3QodGhpc1syXSk7XG5cdFx0XHQvL1x0fFx0XHRcdFx0cmV0dXJuIG5ld05vZGVMaXN0Ll9zdGFzaCh0aGlzKTtcblx0XHRcdC8vXHR8XHRcdFx0fVxuXHRcdFx0Ly9cdHxcdFx0fSk7XG5cdFx0XHQvL1x0fFx0XHQvLyB0aGVuIHNlZSBob3cgX3N0YXNoIGFwcGxpZXMgYSBzdWItbGlzdCwgdG8gYmUgLmVuZCgpJ2VkIG91dCBvZlxuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCIuZm9vXCIpXG5cdFx0XHQvL1x0fFx0XHRcdC50aGlyZCgpXG5cdFx0XHQvL1x0fFx0XHRcdFx0LmFkZENsYXNzKFwidGhpcmRGb29cIilcblx0XHRcdC8vXHR8XHRcdFx0LmVuZCgpXG5cdFx0XHQvL1x0fFx0XHRcdC8vIGFjY2VzcyB0byB0aGUgb3JpZyAuZm9vIGxpc3Rcblx0XHRcdC8vXHR8XHRcdFx0LnJlbW92ZUNsYXNzKFwiZm9vXCIpXG5cdFx0XHQvL1x0fFx0fSk7XG5cdFx0XHQvL1xuXHRcdFx0dGhpcy5fcGFyZW50ID0gcGFyZW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7IC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXG5cdFx0b246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdExpc3RlbiBmb3IgZXZlbnRzIG9uIHRoZSBub2RlcyBpbiB0aGUgTm9kZUxpc3QuIEJhc2ljIHVzYWdlIGlzOlxuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIi5teS1jbGFzc1wiKS5vbihcImNsaWNrXCIsIGxpc3RlbmVyKTtcblx0XHRcdC8vXHRcdFx0VGhpcyBzdXBwb3J0cyBldmVudCBkZWxlZ2F0aW9uIGJ5IHVzaW5nIHNlbGVjdG9ycyBhcyB0aGUgZmlyc3QgYXJndW1lbnQgd2l0aCB0aGUgZXZlbnQgbmFtZXMgYXNcblx0XHRcdC8vXHRcdFx0cHNldWRvIHNlbGVjdG9ycy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHR8IFx0XHRxdWVyeShcIiNteS1saXN0XCIpLm9uKFwibGk6Y2xpY2tcIiwgbGlzdGVuZXIpO1xuXHRcdFx0Ly9cdFx0XHRUaGlzIHdpbGwgbGlzdGVuIGZvciBjbGljayBldmVudHMgd2l0aGluIGA8bGk+YCBlbGVtZW50cyB0aGF0IGFyZSBpbnNpZGUgdGhlIGAjbXktbGlzdGAgZWxlbWVudC5cblx0XHRcdC8vXHRcdFx0QmVjYXVzZSBvbiBzdXBwb3J0cyBDU1Mgc2VsZWN0b3Igc3ludGF4LCB3ZSBjYW4gdXNlIGNvbW1hLWRlbGltaXRlZCBldmVudHMgYXMgd2VsbDpcblx0XHRcdC8vXHRcdHwgXHRcdHF1ZXJ5KFwiI215LWxpc3RcIikub24oXCJsaSBidXR0b246bW91c2VvdmVyLCBsaTpjbGlja1wiLCBsaXN0ZW5lcik7XG5cdFx0XHQvL1x0XHR8XHR9KTtcblx0XHRcdHZhciBoYW5kbGVzID0gdGhpcy5tYXAoZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHJldHVybiBvbihub2RlLCBldmVudE5hbWUsIGxpc3RlbmVyKTsgLy8gVE9ETzogYXBwbHkgdG8gdGhlIE5vZGVMaXN0IHNvIHRoZSBzYW1lIHNlbGVjdG9yIGVuZ2luZSBpcyB1c2VkIGZvciBtYXRjaGVzXG5cdFx0XHR9KTtcblx0XHRcdGhhbmRsZXMucmVtb3ZlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhhbmRsZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdGhhbmRsZXNbaV0ucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGFuZGxlcztcblx0XHR9LFxuXG5cdFx0ZW5kOiBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEVuZHMgdXNlIG9mIHRoZSBjdXJyZW50IGBOb2RlTGlzdGAgYnkgcmV0dXJuaW5nIHRoZSBwcmV2aW91cyBOb2RlTGlzdFxuXHRcdFx0Ly9cdFx0dGhhdCBnZW5lcmF0ZWQgdGhlIGN1cnJlbnQgTm9kZUxpc3QuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIGBOb2RlTGlzdGAgdGhhdCBnZW5lcmF0ZWQgdGhlIGN1cnJlbnQgYE5vZGVMaXN0YC4gSWYgdGhlcmVcblx0XHRcdC8vXHRcdGlzIG5vIHBhcmVudCBOb2RlTGlzdCwgYW4gZW1wdHkgTm9kZUxpc3QgaXMgcmV0dXJuZWQuXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiLCBcImRvam8vTm9kZUxpc3QtZG9tXCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcImFcIilcblx0XHRcdC8vXHR8XHRcdFx0LmZpbHRlcihcIi5kaXNhYmxlZFwiKVxuXHRcdFx0Ly9cdHxcdFx0XHRcdC8vIG9wZXJhdGUgb24gdGhlIGFuY2hvcnMgdGhhdCBvbmx5IGhhdmUgYSBkaXNhYmxlZCBjbGFzc1xuXHRcdFx0Ly9cdHxcdFx0XHRcdC5zdHlsZShcImNvbG9yXCIsIFwiZ3JleVwiKVxuXHRcdFx0Ly9cdHxcdFx0XHQuZW5kKClcblx0XHRcdC8vXHR8XHRcdFx0Ly8ganVtcCBiYWNrIHRvIHRoZSBsaXN0IG9mIGFuY2hvcnNcblx0XHRcdC8vXHR8XHRcdFx0LnN0eWxlKC4uLilcblx0XHRcdC8vXHR8XHR9KTtcblx0XHRcdC8vXG5cdFx0XHRpZih0aGlzLl9wYXJlbnQpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vSnVzdCByZXR1cm4gZW1wdHkgbGlzdC5cblx0XHRcdFx0cmV0dXJuIG5ldyB0aGlzLl9Ob2RlTGlzdEN0b3IoMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZTpHbG9iYWxfT2JqZWN0czpBcnJheSNNZXRob2RzXG5cblx0XHQvLyBGSVhNRTogaGFuZGxlIHJldHVybiB2YWx1ZXMgZm9yICMzMjQ0XG5cdFx0Ly9cdFx0aHR0cDovL3RyYWMuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8zMjQ0XG5cblx0XHQvLyBGSVhNRTpcblx0XHQvL1x0XHRuZWVkIHRvIHdyYXAgb3IgaW1wbGVtZW50OlxuXHRcdC8vXHRcdFx0am9pbiAocGVyaGFwcyB3LyBpbm5lckhUTUwvb3V0ZXJIVE1MIG92ZXJsb2FkIGZvciB0b1N0cmluZygpIG9mIGl0ZW1zPylcblx0XHQvL1x0XHRcdHJlZHVjZVxuXHRcdC8vXHRcdFx0cmVkdWNlUmlnaHRcblxuXHRcdC8qPT09PT1cblx0XHRzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmV0dXJucyBhIG5ldyBOb2RlTGlzdCwgbWFpbnRhaW5pbmcgdGhpcyBvbmUgaW4gcGxhY2Vcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgYmVoYXZlcyBleGFjdGx5IGxpa2UgdGhlIEFycmF5LnNsaWNlIG1ldGhvZFxuXHRcdFx0Ly9cdFx0d2l0aCB0aGUgY2F2ZWF0IHRoYXQgaXQgcmV0dXJucyBhIGBkb2pvL05vZGVMaXN0YCBhbmQgbm90IGFcblx0XHRcdC8vXHRcdHJhdyBBcnJheS4gRm9yIG1vcmUgZGV0YWlscywgc2VlIE1vemlsbGEncyBbc2xpY2Vcblx0XHRcdC8vXHRcdGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlKVxuXHRcdFx0Ly8gYmVnaW46IEludGVnZXJcblx0XHRcdC8vXHRcdENhbiBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIsIHdpdGggcG9zaXRpdmVcblx0XHRcdC8vXHRcdGludGVnZXJzIG5vdGluZyB0aGUgb2Zmc2V0IHRvIGJlZ2luIGF0LCBhbmQgbmVnYXRpdmVcblx0XHRcdC8vXHRcdGludGVnZXJzIGRlbm90aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgKGkuZS4sIHRvIHRoZSBsZWZ0XG5cdFx0XHQvL1x0XHRvZiB0aGUgZW5kKVxuXHRcdFx0Ly8gZW5kOiBJbnRlZ2VyP1xuXHRcdFx0Ly9cdFx0T3B0aW9uYWwgcGFyYW1ldGVyIHRvIGRlc2NyaWJlIHdoYXQgcG9zaXRpb24gcmVsYXRpdmUgdG9cblx0XHRcdC8vXHRcdHRoZSBOb2RlTGlzdCdzIHplcm8gaW5kZXggdG8gZW5kIHRoZSBzbGljZSBhdC4gTGlrZSBiZWdpbixcblx0XHRcdC8vXHRcdGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS5cblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGEuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIGhvd21hbnksIGl0ZW0pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgTm9kZUxpc3QsIG1hbmlwdWxhdGluZyB0aGlzIE5vZGVMaXN0IGJhc2VkIG9uXG5cdFx0XHQvL1x0XHR0aGUgYXJndW1lbnRzIHBhc3NlZCwgcG90ZW50aWFsbHkgc3BsaWNpbmcgaW4gbmV3IGVsZW1lbnRzXG5cdFx0XHQvL1x0XHRhdCBhbiBvZmZzZXQsIG9wdGlvbmFsbHkgZGVsZXRpbmcgZWxlbWVudHNcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0VGhpcyBtZXRob2QgYmVoYXZlcyBleGFjdGx5IGxpa2UgdGhlIEFycmF5LnNwbGljZSBtZXRob2Rcblx0XHRcdC8vXHRcdHdpdGggdGhlIGNhdmVhdCB0aGF0IGl0IHJldHVybnMgYSBgZG9qby9Ob2RlTGlzdGAgYW5kIG5vdCBhXG5cdFx0XHQvL1x0XHRyYXcgQXJyYXkuIEZvciBtb3JlIGRldGFpbHMsIHNlZSBNb3ppbGxhJ3MgW3NwbGljZVxuXHRcdFx0Ly9cdFx0ZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKVxuXHRcdFx0Ly9cdFx0Rm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBjYWxsaW5nIC5lbmQoKSBvbiB0aGUgc3BsaWNlZCBOb2RlTGlzdFxuXHRcdFx0Ly9cdFx0ZG9lcyBub3QgcmV0dXJuIHRoZSBvcmlnaW5hbCBOb2RlTGlzdCAtLSBzcGxpY2UgYWx0ZXJzIHRoZSBOb2RlTGlzdCBpbiBwbGFjZS5cblx0XHRcdC8vIGluZGV4OiBJbnRlZ2VyXG5cdFx0XHQvL1x0XHRiZWdpbiBjYW4gYmUgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyLCB3aXRoIHBvc2l0aXZlXG5cdFx0XHQvL1x0XHRpbnRlZ2VycyBub3RpbmcgdGhlIG9mZnNldCB0byBiZWdpbiBhdCwgYW5kIG5lZ2F0aXZlXG5cdFx0XHQvL1x0XHRpbnRlZ2VycyBkZW5vdGluZyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIChpLmUuLCB0byB0aGUgbGVmdFxuXHRcdFx0Ly9cdFx0b2YgdGhlIGVuZClcblx0XHRcdC8vIGhvd21hbnk6IEludGVnZXI/XG5cdFx0XHQvL1x0XHRPcHRpb25hbCBwYXJhbWV0ZXIgdG8gZGVzY3JpYmUgd2hhdCBwb3NpdGlvbiByZWxhdGl2ZSB0b1xuXHRcdFx0Ly9cdFx0dGhlIE5vZGVMaXN0J3MgemVybyBpbmRleCB0byBlbmQgdGhlIHNsaWNlIGF0LiBMaWtlIGJlZ2luLFxuXHRcdFx0Ly9cdFx0Y2FuIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuXHRcdFx0Ly8gaXRlbTogT2JqZWN0Li4uP1xuXHRcdFx0Ly9cdFx0QW55IG51bWJlciBvZiBvcHRpb25hbCBwYXJhbWV0ZXJzIG1heSBiZSBwYXNzZWQgaW4gdG8gYmVcblx0XHRcdC8vXHRcdHNwbGljZWQgaW50byB0aGUgTm9kZUxpc3Rcblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGEuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1x0Ly8gZG9qby9Ob2RlTGlzdFxuXHRcdH0sXG5cblx0XHRpbmRleE9mOiBmdW5jdGlvbih2YWx1ZSwgZnJvbUluZGV4KXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRzZWUgYGRvam8vX2Jhc2UvYXJyYXkuaW5kZXhPZigpYC4gVGhlIHByaW1hcnkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBhY3RlZC1vblxuXHRcdFx0Ly9cdFx0YXJyYXkgaXMgaW1wbGljaXRseSB0aGlzIE5vZGVMaXN0XG5cdFx0XHQvLyB2YWx1ZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vXHRcdFRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gT3B0aW9uYWwuIERlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdEZvciBtb3JlIGRldGFpbHMgb24gdGhlIGJlaGF2aW9yIG9mIGluZGV4T2YsIHNlZSBNb3ppbGxhJ3Ncblx0XHRcdC8vXHRcdFtpbmRleE9mXG5cdFx0XHQvL1x0XHRkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdFBvc2l0aXZlIEludGVnZXIgb3IgMCBmb3IgYSBtYXRjaCwgLTEgb2Ygbm90IGZvdW5kLlxuXHRcdFx0cmV0dXJuIGQuaW5kZXhPZih0aGlzLCB2YWx1ZSwgZnJvbUluZGV4KTsgLy8gSW50ZWdlclxuXHRcdH0sXG5cblx0XHRsYXN0SW5kZXhPZjogZnVuY3Rpb24odmFsdWUsIGZyb21JbmRleCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0c2VlIGBkb2pvL19iYXNlL2FycmF5Lmxhc3RJbmRleE9mKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlXG5cdFx0XHQvL1x0XHRhY3RlZC1vbiBhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3Rcblx0XHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdFx0Ly9cdFx0Rm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgYmVoYXZpb3Igb2YgbGFzdEluZGV4T2YsIHNlZVxuXHRcdFx0Ly9cdFx0TW96aWxsYSdzIFtsYXN0SW5kZXhPZlxuXHRcdFx0Ly9cdFx0ZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2YpXG5cdFx0XHQvLyB2YWx1ZTogT2JqZWN0XG5cdFx0XHQvL1x0XHRUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0XHRcdC8vIGZyb21JbmRleDogSW50ZWdlcj9cblx0XHRcdC8vXHRcdFRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gT3B0aW9uYWwuIERlZmF1bHRzIHRvIDAuXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0UG9zaXRpdmUgSW50ZWdlciBvciAwIGZvciBhIG1hdGNoLCAtMSBvZiBub3QgZm91bmQuXG5cdFx0XHRyZXR1cm4gZC5sYXN0SW5kZXhPZih0aGlzLCB2YWx1ZSwgZnJvbUluZGV4KTsgLy8gSW50ZWdlclxuXHRcdH0sXG5cblx0XHRldmVyeTogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmplY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHNlZSBgZG9qby9fYmFzZS9hcnJheS5ldmVyeSgpYCBhbmQgdGhlIFtBcnJheS5ldmVyeVxuXHRcdFx0Ly9cdFx0ZG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnkpLlxuXHRcdFx0Ly9cdFx0VGFrZXMgdGhlIHNhbWUgc3RydWN0dXJlIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhc1xuXHRcdFx0Ly9cdFx0ZG9qby9fYmFzZS9hcnJheS5ldmVyeSgpIHdpdGggdGhlIGNhdmVhdCB0aGF0IHRoZSBwYXNzZWQgYXJyYXkgaXNcblx0XHRcdC8vXHRcdGltcGxpY2l0bHkgdGhpcyBOb2RlTGlzdFxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2tcblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdHRoZSBjb250ZXh0XG5cdFx0XHRyZXR1cm4gZC5ldmVyeSh0aGlzLCBjYWxsYmFjaywgdGhpc09iamVjdCk7IC8vIEJvb2xlYW5cblx0XHR9LFxuXG5cdFx0c29tZTogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmplY3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRha2VzIHRoZSBzYW1lIHN0cnVjdHVyZSBvZiBhcmd1bWVudHMgYW5kIHJldHVybnMgYXNcblx0XHRcdC8vXHRcdGBkb2pvL19iYXNlL2FycmF5LnNvbWUoKWAgd2l0aCB0aGUgY2F2ZWF0IHRoYXQgdGhlIHBhc3NlZCBhcnJheSBpc1xuXHRcdFx0Ly9cdFx0aW1wbGljaXRseSB0aGlzIE5vZGVMaXN0LiAgU2VlIGBkb2pvL19iYXNlL2FycmF5LnNvbWUoKWAgYW5kIE1vemlsbGEnc1xuXHRcdFx0Ly9cdFx0W0FycmF5LnNvbWVcblx0XHRcdC8vXHRcdGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWUpLlxuXHRcdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHR0aGUgY2FsbGJhY2tcblx0XHRcdC8vIHRoaXNPYmplY3Q6IE9iamVjdD9cblx0XHRcdC8vXHRcdHRoZSBjb250ZXh0XG5cdFx0XHRyZXR1cm4gZC5zb21lKHRoaXMsIGNhbGxiYWNrLCB0aGlzT2JqZWN0KTsgLy8gQm9vbGVhblxuXHRcdH0sXG5cdFx0PT09PT0qL1xuXG5cdFx0Y29uY2F0OiBmdW5jdGlvbihpdGVtKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZXR1cm5zIGEgbmV3IE5vZGVMaXN0IGNvbXByaXNlZCBvZiBpdGVtcyBpbiB0aGlzIE5vZGVMaXN0XG5cdFx0XHQvL1x0XHRhcyB3ZWxsIGFzIGl0ZW1zIHBhc3NlZCBpbiBhcyBwYXJhbWV0ZXJzXG5cdFx0XHQvLyBkZXNjcmlwdGlvbjpcblx0XHRcdC8vXHRcdFRoaXMgbWV0aG9kIGJlaGF2ZXMgZXhhY3RseSBsaWtlIHRoZSBBcnJheS5jb25jYXQgbWV0aG9kXG5cdFx0XHQvL1x0XHR3aXRoIHRoZSBjYXZlYXQgdGhhdCBpdCByZXR1cm5zIGEgYE5vZGVMaXN0YCBhbmQgbm90IGFcblx0XHRcdC8vXHRcdHJhdyBBcnJheS4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBbQXJyYXkuY29uY2F0XG5cdFx0XHQvL1x0XHRkb2NzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9jb25jYXQpXG5cdFx0XHQvLyBpdGVtOiBPYmplY3Q/XG5cdFx0XHQvL1x0XHRBbnkgbnVtYmVyIG9mIG9wdGlvbmFsIHBhcmFtZXRlcnMgbWF5IGJlIHBhc3NlZCBpbiB0byBiZVxuXHRcdFx0Ly9cdFx0c3BsaWNlZCBpbnRvIHRoZSBOb2RlTGlzdFxuXG5cdFx0XHQvL3JldHVybiB0aGlzLl93cmFwKGFwYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0XHRcdC8vIHRoZSBsaW5lIGFib3ZlIHdvbid0IHdvcmsgZm9yIHRoZSBuYXRpdmUgTm9kZUxpc3QsIG9yIGZvciBEb2pvIE5vZGVMaXN0cyBlaXRoZXIgOi0oXG5cblx0XHRcdC8vIGltcGxlbWVudGF0aW9uIG5vdGVzOlxuXHRcdFx0Ly8gQXJyYXkuY29uY2F0KCkgZG9lc24ndCByZWNvZ25pemUgbmF0aXZlIE5vZGVMaXN0cyBvciBEb2pvIE5vZGVMaXN0c1xuXHRcdFx0Ly8gYXMgYXJyYXlzLCBhbmQgc28gZG9lcyBub3QgaW5saW5lIHRoZW0gaW50byBhIHVuaW9uZWQgYXJyYXksIGJ1dFxuXHRcdFx0Ly8gYXBwZW5kcyB0aGVtIGFzIHNpbmdsZSBlbnRpdGllcy4gQm90aCB0aGUgb3JpZ2luYWwgTm9kZUxpc3QgYW5kIHRoZVxuXHRcdFx0Ly8gaXRlbXMgcGFzc2VkIGluIGFzIHBhcmFtZXRlcnMgbXVzdCBiZSBjb252ZXJ0ZWQgdG8gcmF3IEFycmF5c1xuXHRcdFx0Ly8gYW5kIHRoZW4gdGhlIGNvbmNhdGVuYXRpb24gcmVzdWx0IG1heSBiZSByZS1fd3JhcCgpZWQgYXMgYSBEb2pvIE5vZGVMaXN0LlxuXG5cdFx0XHR2YXIgdCA9IGFwcy5jYWxsKHRoaXMsIDApLFxuXHRcdFx0XHRtID0gYXJyYXkubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYSl7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcy5jYWxsKGEsIDApO1xuXHRcdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzLl93cmFwKGFwYy5hcHBseSh0LCBtKSwgdGhpcyk7XHQvLyBkb2pvL05vZGVMaXN0XG5cdFx0fSxcblxuXHRcdG1hcDogZnVuY3Rpb24oLypGdW5jdGlvbiovIGZ1bmMsIC8qRnVuY3Rpb24/Ki8gb2JqKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRzZWUgYGRvam8vX2Jhc2UvYXJyYXkubWFwKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFjdGVkLW9uXG5cdFx0XHQvL1x0XHRhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3QgYW5kIHRoZSByZXR1cm4gaXMgYVxuXHRcdFx0Ly9cdFx0Tm9kZUxpc3QgKGEgc3ViY2xhc3Mgb2YgQXJyYXkpXG5cdFx0XHRyZXR1cm4gdGhpcy5fd3JhcChhcnJheS5tYXAodGhpcywgZnVuYywgb2JqKSwgdGhpcyk7IC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXG5cdFx0Zm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNPYmope1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdHNlZSBgZG9qby9fYmFzZS9hcnJheS5mb3JFYWNoKClgLiBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhlIGFjdGVkLW9uXG5cdFx0XHQvL1x0XHRhcnJheSBpcyBpbXBsaWNpdGx5IHRoaXMgTm9kZUxpc3QuIElmIHlvdSB3YW50IHRoZSBvcHRpb24gdG8gYnJlYWsgb3V0XG5cdFx0XHQvL1x0XHRvZiB0aGUgZm9yRWFjaCBsb29wLCB1c2UgZXZlcnkoKSBvciBzb21lKCkgaW5zdGVhZC5cblx0XHRcdGZvckVhY2godGhpcywgY2FsbGJhY2ssIHRoaXNPYmopO1xuXHRcdFx0Ly8gbm9uLXN0YW5kYXJkIHJldHVybiB0byBhbGxvdyBlYXNpZXIgY2hhaW5pbmdcblx0XHRcdHJldHVybiB0aGlzOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0fSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKC8qU3RyaW5nfEZ1bmN0aW9uKi8gZmlsdGVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRcIm1hc2tzXCIgdGhlIGJ1aWx0LWluIGphdmFzY3JpcHQgZmlsdGVyKCkgbWV0aG9kIChzdXBwb3J0ZWRcblx0XHRcdC8vXHRcdGluIERvam8gdmlhIGBkb2pvL19iYXNlL2FycmF5LmZpbHRlcmApIHRvIHN1cHBvcnQgcGFzc2luZyBhIHNpbXBsZVxuXHRcdFx0Ly9cdFx0c3RyaW5nIGZpbHRlciBpbiBhZGRpdGlvbiB0byBzdXBwb3J0aW5nIGZpbHRlcmluZyBmdW5jdGlvblxuXHRcdFx0Ly9cdFx0b2JqZWN0cy5cblx0XHRcdC8vIGZpbHRlcjpcblx0XHRcdC8vXHRcdElmIGEgc3RyaW5nLCBhIENTUyBydWxlIGxpa2UgXCIudGhpbmdlclwiIG9yIFwiZGl2ID4gc3BhblwiLlxuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdFwicmVndWxhclwiIEpTIGZpbHRlciBzeW50YXggYXMgZXhwb3NlZCBpbiBgZG9qby9fYmFzZS9hcnJheS5maWx0ZXJgOlxuXHRcdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCIsIFwiZG9qby9Ob2RlTGlzdC1kb21cIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIipcIikuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0Ly9cdFx0fFx0XHRcdC8vIGhpZ2hsaWdodCBldmVyeSBwYXJhZ3JhcGhcblx0XHRcdC8vXHRcdHxcdFx0XHRyZXR1cm4gKGl0ZW0ubm9kZU5hbWUgPT0gXCJwXCIpO1xuXHRcdFx0Ly9cdFx0fFx0XHR9KS5zdHlsZShcImJhY2tncm91bmRDb2xvclwiLCBcInllbGxvd1wiKTtcblx0XHRcdC8vXHRcdHxcdH0pO1xuXHRcdFx0Ly8gZXhhbXBsZTpcblx0XHRcdC8vXHRcdHRoZSBzYW1lIGZpbHRlcmluZyB1c2luZyBhIENTUyBzZWxlY3RvclxuXHRcdFx0Ly9cdFx0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCIsIFwiZG9qby9Ob2RlTGlzdC1kb21cIlxuXHRcdFx0Ly9cdFx0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdFx0fFx0XHRxdWVyeShcIipcIikuZmlsdGVyKFwicFwiKS5zdHlsZXMoXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJ5ZWxsb3dcIik7XG5cdFx0XHQvL1x0XHR8XHR9KTtcblxuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHMsIGl0ZW1zID0gdGhpcywgc3RhcnQgPSAwO1xuXHRcdFx0aWYodHlwZW9mIGZpbHRlciA9PSBcInN0cmluZ1wiKXsgLy8gaW5saW5lJ2QgdHlwZSBjaGVja1xuXHRcdFx0XHRpdGVtcyA9IHF1ZXJ5Ll9maWx0ZXJSZXN1bHQodGhpcywgYVswXSk7XG5cdFx0XHRcdGlmKGEubGVuZ3RoID09IDEpe1xuXHRcdFx0XHRcdC8vIGlmIHdlIG9ubHkgZ290IGEgc3RyaW5nIHF1ZXJ5LCBwYXNzIGJhY2sgdGhlIGZpbHRlcmVkIHJlc3VsdHNcblx0XHRcdFx0XHRyZXR1cm4gaXRlbXMuX3N0YXNoKHRoaXMpOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgd2UgZ290IGEgY2FsbGJhY2ssIHJ1biBpdCBvdmVyIHRoZSBmaWx0ZXJlZCBpdGVtc1xuXHRcdFx0XHRzdGFydCA9IDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fd3JhcChhcnJheS5maWx0ZXIoaXRlbXMsIGFbc3RhcnRdLCBhW3N0YXJ0ICsgMV0pLCB0aGlzKTtcdC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXHRcdGluc3RhbnRpYXRlOiBmdW5jdGlvbigvKlN0cmluZ3xPYmplY3QqLyBkZWNsYXJlZENsYXNzLCAvKk9iamVjdD8qLyBwcm9wZXJ0aWVzKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzcGVjaWZpZWQgY2xhc3MsIHVzaW5nIHRoZVxuXHRcdFx0Ly9cdFx0c3BlY2lmaWVkIHByb3BlcnRpZXMgYW5kIGVhY2ggbm9kZSBpbiB0aGUgTm9kZUxpc3QgYXMgYVxuXHRcdFx0Ly9cdFx0c3JjTm9kZVJlZi5cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0XHRHcmFicyBhbGwgYnV0dG9ucyBpbiB0aGUgcGFnZSBhbmQgY29udmVydHMgdGhlbSB0byBkaWppdC9mb3JtL0J1dHRvbidzLlxuXHRcdFx0Ly9cdHxcdHZhciBidXR0b25zID0gcXVlcnkoXCJidXR0b25cIikuaW5zdGFudGlhdGUoQnV0dG9uLCB7c2hvd0xhYmVsOiB0cnVlfSk7XG5cdFx0XHR2YXIgYyA9IGxhbmcuaXNGdW5jdGlvbihkZWNsYXJlZENsYXNzKSA/IGRlY2xhcmVkQ2xhc3MgOiBsYW5nLmdldE9iamVjdChkZWNsYXJlZENsYXNzKTtcblx0XHRcdHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0bmV3IGMocHJvcGVydGllcywgbm9kZSk7XG5cdFx0XHR9KTtcdC8vIGRvam8vTm9kZUxpc3Rcblx0XHR9LFxuXHRcdGF0OiBmdW5jdGlvbigvKj09PT09IGluZGV4ID09PT09Ki8pe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgYSBuZXcgTm9kZUxpc3QgY29tcHJpc2VkIG9mIGl0ZW1zIGluIHRoaXMgTm9kZUxpc3Rcblx0XHRcdC8vXHRcdGF0IHRoZSBnaXZlbiBpbmRleCBvciBpbmRpY2VzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGluZGV4OiBJbnRlZ2VyLi4uXG5cdFx0XHQvL1x0XHRPbmUgb3IgbW9yZSAwLWJhc2VkIGluZGljZXMgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnRcblx0XHRcdC8vXHRcdE5vZGVMaXN0LiBBIG5lZ2F0aXZlIGluZGV4IHdpbGwgc3RhcnQgYXQgdGhlIGVuZCBvZiB0aGVcblx0XHRcdC8vXHRcdGxpc3QgYW5kIGdvIGJhY2t3YXJkcy5cblx0XHRcdC8vXG5cdFx0XHQvLyBleGFtcGxlOlxuXHRcdFx0Ly9cdFNob3J0ZW4gdGhlIGxpc3QgdG8gdGhlIGZpcnN0LCBzZWNvbmQsIGFuZCB0aGlyZCBlbGVtZW50c1xuXHRcdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9xdWVyeVwiXG5cdFx0XHQvL1x0fFx0XSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdFx0Ly9cdHxcdFx0cXVlcnkoXCJhXCIpLmF0KDAsIDEsIDIpLmZvckVhY2goZm4pO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0UmV0cmlldmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnRzIG9mIGEgdW5vcmRlcmVkIGxpc3Q6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcInVsID4gbGlcIikuYXQoMCwgLTEpLmZvckVhY2goY2IpO1xuXHRcdFx0Ly9cdHxcdH0pO1xuXHRcdFx0Ly9cblx0XHRcdC8vIGV4YW1wbGU6XG5cdFx0XHQvL1x0RG8gc29tZXRoaW5nIGZvciB0aGUgZmlyc3QgZWxlbWVudCBvbmx5LCBidXQgZW5kKCkgb3V0IGJhY2sgdG9cblx0XHRcdC8vXHR0aGUgb3JpZ2luYWwgbGlzdCBhbmQgY29udGludWUgY2hhaW5pbmc6XG5cdFx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5XCJcblx0XHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0XHQvL1x0fFx0XHRxdWVyeShcImFcIikuYXQoMCkub25jbGljayhmbikuZW5kKCkuZm9yRWFjaChmdW5jdGlvbihuKXtcblx0XHRcdC8vXHR8XHRcdFx0Y29uc29sZS5sb2cobik7IC8vIGFsbCBhbmNob3JzIG9uIHRoZSBwYWdlLlxuXHRcdFx0Ly9cdHxcdH0pXG5cdFx0XHQvL1x0fFx0fSk7XG5cblx0XHRcdHZhciB0ID0gbmV3IHRoaXMuX05vZGVMaXN0Q3RvcigwKTtcblx0XHRcdGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihpKXtcblx0XHRcdFx0aWYoaSA8IDApeyBpID0gdGhpcy5sZW5ndGggKyBpOyB9XG5cdFx0XHRcdGlmKHRoaXNbaV0peyB0LnB1c2godGhpc1tpXSk7IH1cblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHQuX3N0YXNoKHRoaXMpOyAvLyBkb2pvL05vZGVMaXN0XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBxdWVyeUZvckVuZ2luZShlbmdpbmUsIE5vZGVMaXN0KXtcblx0XHR2YXIgcXVlcnkgPSBmdW5jdGlvbigvKlN0cmluZyovIHF1ZXJ5LCAvKlN0cmluZ3xET01Ob2RlPyovIHJvb3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgbm9kZXMgd2hpY2ggbWF0Y2ggdGhlIGdpdmVuIENTUyBzZWxlY3Rvciwgc2VhcmNoaW5nIHRoZVxuXHRcdFx0Ly9cdFx0ZW50aXJlIGRvY3VtZW50IGJ5IGRlZmF1bHQgYnV0IG9wdGlvbmFsbHkgdGFraW5nIGEgbm9kZSB0byBzY29wZVxuXHRcdFx0Ly9cdFx0dGhlIHNlYXJjaCBieS4gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBOb2RlTGlzdC5cblx0XHRcdGlmKHR5cGVvZiByb290ID09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRyb290ID0gZG9tLmJ5SWQocm9vdCk7XG5cdFx0XHRcdGlmKCFyb290KXtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdHMgPSB0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIiA/IGVuZ2luZShxdWVyeSwgcm9vdCkgOiBxdWVyeSA/IChxdWVyeS5lbmQgJiYgcXVlcnkub24pID8gcXVlcnkgOiBbcXVlcnldIDogW107XG5cdFx0XHRpZihyZXN1bHRzLmVuZCAmJiByZXN1bHRzLm9uKXtcblx0XHRcdFx0Ly8gYWxyZWFkeSB3cmFwcGVkXG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBOb2RlTGlzdChyZXN1bHRzKTtcblx0XHR9O1xuXHRcdHF1ZXJ5Lm1hdGNoZXMgPSBlbmdpbmUubWF0Y2ggfHwgZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IsIHJvb3Qpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFRlc3QgdG8gc2VlIGlmIGEgbm9kZSBtYXRjaGVzIGEgc2VsZWN0b3Jcblx0XHRcdHJldHVybiBxdWVyeS5maWx0ZXIoW25vZGVdLCBzZWxlY3Rvciwgcm9vdCkubGVuZ3RoID4gMDtcblx0XHR9O1xuXHRcdC8vIHRoZSBlbmdpbmUgcHJvdmlkZXMgYSBmaWx0ZXJpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBmb3IgbWF0Y2hpbmdcblx0XHRxdWVyeS5maWx0ZXIgPSBlbmdpbmUuZmlsdGVyIHx8IGZ1bmN0aW9uKG5vZGVzLCBzZWxlY3Rvciwgcm9vdCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0RmlsdGVycyBhbiBhcnJheSBvZiBub2Rlcy4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIHRvIHJldHVybiBhIE5vZGVMaXN0LCBqdXN0IGFuIGFycmF5LlxuXHRcdFx0cmV0dXJuIHF1ZXJ5KHNlbGVjdG9yLCByb290KS5maWx0ZXIoZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHJldHVybiBhcnJheS5pbmRleE9mKG5vZGVzLCBub2RlKSA+IC0xO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRpZih0eXBlb2YgZW5naW5lICE9IFwiZnVuY3Rpb25cIil7XG5cdFx0XHR2YXIgc2VhcmNoID0gZW5naW5lLnNlYXJjaDtcblx0XHRcdGVuZ2luZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KXtcblx0XHRcdFx0Ly8gU2xpY2sgZG9lcyBpdCBiYWNrd2FyZHMgKG9yIGV2ZXJ5b25lIGVsc2UgZG9lcyBpdCBiYWNrd2FyZHMsIHByb2JhYmx5IHRoZSBsYXR0ZXIpXG5cdFx0XHRcdHJldHVybiBzZWFyY2gocm9vdCB8fCBkb2N1bWVudCwgc2VsZWN0b3IpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9XG5cdHZhciBxdWVyeSA9IHF1ZXJ5Rm9yRW5naW5lKGRlZmF1bHRFbmdpbmUsIE5vZGVMaXN0KTtcblx0Lyo9PT09PVxuXHRxdWVyeSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlcyBwcm92aWRlcyBET00gcXVlcnlpbmcgZnVuY3Rpb25hbGl0eS4gVGhlIG1vZHVsZSBleHBvcnQgaXMgYSBmdW5jdGlvblxuXHRcdC8vXHRcdHRoYXQgY2FuIGJlIHVzZWQgdG8gcXVlcnkgZm9yIERPTSBub2RlcyBieSBDU1Mgc2VsZWN0b3IgYW5kIHJldHVybnMgYSBOb2RlTGlzdFxuXHRcdC8vXHRcdHJlcHJlc2VudGluZyB0aGUgbWF0Y2hpbmcgbm9kZXMuXG5cdFx0Ly8gc2VsZWN0b3I6IFN0cmluZ1xuXHRcdC8vXHRcdEEgQ1NTIHNlbGVjdG9yIHRvIHNlYXJjaCBmb3IuXG5cdFx0Ly8gY29udGV4dDogU3RyaW5nfERvbU5vZGU/XG5cdFx0Ly9cdFx0QW4gb3B0aW9uYWwgY29udGV4dCB0byBsaW1pdCB0aGUgc2VhcmNoaW5nIHNjb3BlLiBPbmx5IG5vZGVzIHVuZGVyIGBjb250ZXh0YCB3aWxsIGJlXG5cdFx0Ly9cdFx0c2Nhbm5lZC5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdGFkZCBhbiBvbmNsaWNrIGhhbmRsZXIgdG8gZXZlcnkgc3VibWl0IGJ1dHRvbiBpbiB0aGUgZG9jdW1lbnRcblx0XHQvL1x0XHR3aGljaCBjYXVzZXMgdGhlIGZvcm0gdG8gYmUgc2VudCB2aWEgQWpheCBpbnN0ZWFkOlxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnlcIiwgXCJkb2pvL3JlcXVlc3RcIiwgXCJkb2pvL2RvbS1mb3JtXCIsIFwiZG9qby9kb20tY29uc3RydWN0XCIsIFwiZG9qby9kb20tc3R5bGVcIlxuXHRcdC8vXHR8XHRdLCBmdW5jdGlvbihxdWVyeSwgcmVxdWVzdCwgZG9tRm9ybSwgZG9tQ29uc3RydWN0LCBkb21TdHlsZSl7XG5cdFx0Ly9cdHxcdFx0cXVlcnkoXCJpbnB1dFt0eXBlPSdzdWJtaXQnXVwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdC8vXHR8XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IHNlbmRpbmcgdGhlIGZvcm1cblx0XHQvL1x0fFx0XHRcdHZhciBidG4gPSBlLnRhcmdldDtcblx0XHQvL1x0fFx0XHRcdHJlcXVlc3QucG9zdChcImh0dHA6Ly9leGFtcGxlLmNvbS9cIiwge1xuXHRcdC8vXHR8XHRcdFx0XHRkYXRhOiBkb21Gb3JtLnRvT2JqZWN0KGJ0bi5mb3JtKVxuXHRcdC8vXHR8XHRcdFx0fSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0Ly9cdHxcdFx0XHRcdC8vIHJlcGxhY2UgdGhlIGZvcm0gd2l0aCB0aGUgcmVzcG9uc2Vcblx0XHQvL1x0fFx0XHRcdFx0ZG9tQ29uc3RydWN0LmNyZWF0ZShkaXYsIHtpbm5lckhUTUw6IHJlc3BvbnNlfSwgYnRuLmZvcm0sIFwiYWZ0ZXJcIik7XG5cdFx0Ly9cdHxcdFx0XHRcdGRvbVN0eWxlLnNldChidG4uZm9ybSwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHQvL1x0fFx0XHRcdH0pO1xuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdGRvam8vcXVlcnkgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IGVuZ2luZSBhbmQgd3JhcHBpbmdcblx0XHQvL1x0XHRpdHMgcmVzdWx0cyB3aXRoIGEgYE5vZGVMaXN0YC4gWW91IGNhbiB1c2UgZG9qby9xdWVyeSB3aXRoIGEgc3BlY2lmaWMgc2VsZWN0b3IgZW5naW5lXG5cdFx0Ly9cdFx0YnkgdXNpbmcgaXQgYXMgYSBwbHVnaW4uIEZvciBleGFtcGxlLCBpZiB5b3UgaW5zdGFsbGVkIHRoZSBzaXp6bGUgcGFja2FnZSwgeW91IGNvdWxkXG5cdFx0Ly9cdFx0dXNlIGl0IGFzIHRoZSBzZWxlY3RvciBlbmdpbmUgd2l0aDpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnkhc2l6emxlXCJdLCBmdW5jdGlvbihxdWVyeSl7XG5cdFx0Ly9cdFx0fFx0XHRxdWVyeShcImRpdlwiKS4uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0VGhlIGlkIGFmdGVyIHRoZSAhIGNhbiBiZSBhIG1vZHVsZSBpZCBvZiB0aGUgc2VsZWN0b3IgZW5naW5lIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcblx0XHQvL1xuXHRcdC8vXHRcdC0gYWNtZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBlbmdpbmUgdXNlZCBieSBEb2pvIGJhc2UsIGFuZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBmdWxsXG5cdFx0Ly9cdFx0QWNtZSBlbmdpbmUgaXMgYWx3YXlzIGxvYWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdC0gY3NzMjogSWYgdGhlIGJyb3dzZXIgaGFzIGEgbmF0aXZlIHNlbGVjdG9yIGVuZ2luZSwgdGhpcyB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSBhXG5cdFx0Ly9cdFx0dmVyeSBtaW5pbWFsIGxpZ2h0d2VpZ2h0IHNlbGVjdG9yIGVuZ2luZSB3aWxsIGJlIGxvYWRlZCB0aGF0IGNhbiBkbyBzaW1wbGUgQ1NTMiBzZWxlY3RvcnNcblx0XHQvL1x0XHQoYnkgI2lkLCAuY2xhc3MsIHRhZywgYW5kIFtuYW1lPXZhbHVlXSBhdHRyaWJ1dGVzLCB3aXRoIHN0YW5kYXJkIGNoaWxkIG9yIGRlc2NlbmRhbnQgKD4pXG5cdFx0Ly9cdFx0b3BlcmF0b3JzKSBhbmQgbm90aGluZyBtb3JlLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBjc3MyLjE6IElmIHRoZSBicm93c2VyIGhhcyBhIG5hdGl2ZSBzZWxlY3RvciBlbmdpbmUsIHRoaXMgd2lsbCBiZSB1c2VkLCBvdGhlcndpc2UgdGhlXG5cdFx0Ly9cdFx0ZnVsbCBBY21lIGVuZ2luZSB3aWxsIGJlIGxvYWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdC0gY3NzMzogSWYgdGhlIGJyb3dzZXIgaGFzIGEgbmF0aXZlIHNlbGVjdG9yIGVuZ2luZSB3aXRoIHN1cHBvcnQgZm9yIENTUzMgcHNldWRvXG5cdFx0Ly9cdFx0c2VsZWN0b3JzIChtb3N0IG1vZGVybiBicm93c2VycyBleGNlcHQgSUU4KSwgdGhpcyB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSB0aGVcblx0XHQvL1x0XHRmdWxsIEFjbWUgZW5naW5lIHdpbGwgYmUgbG9hZGVkLlxuXHRcdC8vXG5cdFx0Ly9cdFx0LSBPciB0aGUgbW9kdWxlIGlkIG9mIGEgc2VsZWN0b3IgZW5naW5lIGNhbiBiZSB1c2VkIHRvIGV4cGxpY2l0bHkgY2hvb3NlIHRoZSBzZWxlY3RvciBlbmdpbmVcblx0XHQvL1xuXHRcdC8vXHRcdEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIHVzaW5nIENTUzMgcHNldWRvIHNlbGVjdG9ycyBpbiBtb2R1bGUsIHlvdSBjYW4gc3BlY2lmeSB0aGF0XG5cdFx0Ly9cdFx0eW91IHdpbGwgbmVlZCBzdXBwb3J0IHRoZW0gd2l0aDpcblx0XHQvL1x0XHR8XHRyZXF1aXJlKFtcImRvam8vcXVlcnkhY3NzM1wiXSwgZnVuY3Rpb24ocXVlcnkpe1xuXHRcdC8vXHRcdHxcdFx0cXVlcnkoJyN0ID4gaDM6bnRoLWNoaWxkKG9kZCknKS4uLlxuXHRcdC8vXG5cdFx0Ly9cdFx0WW91IGNhbiBhbHNvIGNob29zZSB0aGUgc2VsZWN0b3IgZW5naW5lL2xvYWQgY29uZmlndXJhdGlvbiBieSBzZXR0aW5nIHRoZSBxdWVyeS1zZWxlY3Rvcjpcblx0XHQvL1x0XHRGb3IgZXhhbXBsZTpcblx0XHQvL1x0XHR8XHQ8c2NyaXB0IGRhdGEtZG9qby1jb25maWc9XCJxdWVyeS1zZWxlY3RvcjonY3NzMydcIiBzcmM9XCJkb2pvLmpzXCI+PC9zY3JpcHQ+XG5cdFx0Ly9cblx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KCk7IC8vIGRvam8vTm9kZUxpc3Rcblx0IH07XG5cdCA9PT09PSovXG5cblx0Ly8gdGhlIHF1ZXJ5IHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB0aGlzIG1vZHVsZSBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBkb2pvLnF1ZXJ5LFxuXHQvLyBiZWNhdXNlIGRvam8ucXVlcnkgaGFzIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcmV0dXJuaW5nIGFcblx0Ly8gdHJ1ZSBhcnJheSB3aGljaCBoYXMgcGVyZm9ybWFuY2UgcHJvYmxlbXMuIFRoZSBxdWVyeSByZXR1cm5lZCBmcm9tIHRoZSBtb2R1bGVcblx0Ly8gZG9lcyBub3QgdXNlIHRydWUgYXJyYXlzLCBidXQgcmF0aGVyIGluaGVyaXRzIGZyb20gQXJyYXksIG1ha2luZyBpdCBtdWNoIGZhc3RlciB0b1xuXHQvLyBpbnN0YW50aWF0ZS5cblx0ZG9qby5xdWVyeSA9IHF1ZXJ5Rm9yRW5naW5lKGRlZmF1bHRFbmdpbmUsIGZ1bmN0aW9uKGFycmF5KXtcblx0XHQvLyBjYWxsIGl0IHdpdGhvdXQgdGhlIG5ldyBvcGVyYXRvciB0byBpbnZva2UgdGhlIGJhY2stY29tcGF0IGJlaGF2aW9yIHRoYXQgcmV0dXJucyBhIHRydWUgYXJyYXlcblx0XHRyZXR1cm4gTm9kZUxpc3QoYXJyYXkpO1x0Ly8gZG9qby9Ob2RlTGlzdFxuXHR9KTtcblxuXHRxdWVyeS5sb2FkID0gZnVuY3Rpb24oaWQsIHBhcmVudFJlcXVpcmUsIGxvYWRlZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRjYW4gYmUgdXNlZCBhcyBBTUQgcGx1Z2luIHRvIGNvbmRpdGlvbmFsbHkgbG9hZCBuZXcgcXVlcnkgZW5naW5lXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3F1ZXJ5IWN1c3RvbVwiXSwgZnVuY3Rpb24ocXNhKXtcblx0XHQvL1x0fFx0XHQvLyBsb2FkZWQgc2VsZWN0b3IvY3VzdG9tLmpzIGFzIGVuZ2luZVxuXHRcdC8vXHR8XHRcdHFzYShcIiNmb29iYXJcIikuZm9yRWFjaCguLi4pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHRsb2FkZXIubG9hZChpZCwgcGFyZW50UmVxdWlyZSwgZnVuY3Rpb24oZW5naW5lKXtcblx0XHRcdGxvYWRlZChxdWVyeUZvckVuZ2luZShlbmdpbmUsIE5vZGVMaXN0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZG9qby5fZmlsdGVyUXVlcnlSZXN1bHQgPSBxdWVyeS5fZmlsdGVyUmVzdWx0ID0gZnVuY3Rpb24obm9kZXMsIHNlbGVjdG9yLCByb290KXtcblx0XHRyZXR1cm4gbmV3IE5vZGVMaXN0KHF1ZXJ5LmZpbHRlcihub2Rlcywgc2VsZWN0b3IsIHJvb3QpKTtcblx0fTtcblx0ZG9qby5Ob2RlTGlzdCA9IHF1ZXJ5Lk5vZGVMaXN0ID0gTm9kZUxpc3Q7XG5cdHJldHVybiBxdWVyeTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi9oYXNcIiwgXCJyZXF1aXJlXCIsIFwiLi9oYXMhaG9zdC1icm93c2VyPy4vZG9tUmVhZHlcIiwgXCIuL19iYXNlL2xhbmdcIl0sIGZ1bmN0aW9uKGRvam8sIGhhcywgcmVxdWlyZSwgZG9tUmVhZHksIGxhbmcpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vcmVhZHlcblx0Ly8gbm90ZTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IGluIGRvam8gMi4wXG5cblx0dmFyXG5cdFx0Ly8gdHJ1dGh5IGlmIERPTUNvbnRlbnRMb2FkZWQgb3IgYmV0dGVyIChlLmcuLCB3aW5kb3cub25sb2FkIGZpcmVkKSBoYXMgYmVlbiBhY2hpZXZlZFxuXHRcdGlzRG9tUmVhZHkgPSAwLFxuXG5cdFx0Ly8gVGhlIHF1ZXVlIG9mIGZ1bmN0aW9ucyB3YWl0aW5nIHRvIGV4ZWN1dGUgYXMgc29vbiBhcyBkb2pvLnJlYWR5IGNvbmRpdGlvbnMgc2F0aXNmaWVkXG5cdFx0bG9hZFEgPSBbXSxcblxuXHRcdC8vIHByZXZlbnQgcmVjdXJzaW9uIGluIG9uTG9hZFxuXHRcdG9uTG9hZFJlY3Vyc2l2ZUd1YXJkID0gMCxcblxuXHRcdGhhbmRsZURvbVJlYWR5ID0gZnVuY3Rpb24oKXtcblx0XHRcdGlzRG9tUmVhZHkgPSAxO1xuXHRcdFx0ZG9qby5fcG9zdExvYWQgPSBkb2pvLmNvbmZpZy5hZnRlck9uTG9hZCA9IHRydWU7XG5cdFx0XHRvbkV2ZW50KCk7XG5cdFx0fSxcblxuXHRcdG9uRXZlbnQgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2FsbGVkIHdoZW4gc29tZSBzdGF0ZSBjaGFuZ2VzOlxuXHRcdFx0Ly9cdFx0LSBkb20gcmVhZHlcblx0XHRcdC8vXHRcdC0gZG9qby9kb21SZWFkeSBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyBldmVyeXRoaW5nIGluIGl0cyBxdWV1ZVxuXHRcdFx0Ly9cdFx0LSB0YXNrIGFkZGVkIHRvIGxvYWRRXG5cdFx0XHQvL1x0XHQtIHJlcXVpcmUoKSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbGwgY3VycmVudGx5IHJlcXVlc3RlZCBtb2R1bGVzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gUnVuIHRoZSBmdW5jdGlvbnMgcXVldWVkIHdpdGggZG9qby5yZWFkeSBpZiBhcHByb3ByaWF0ZS5cblxuXG5cdFx0XHQvL2d1YXJkIGFnYWluc3QgcmVjdXJzaW9ucyBpbnRvIHRoaXMgZnVuY3Rpb25cblx0XHRcdGlmKG9uTG9hZFJlY3Vyc2l2ZUd1YXJkKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b25Mb2FkUmVjdXJzaXZlR3VhcmQgPSAxO1xuXG5cdFx0XHQvLyBSdW4gdGFza3MgaW4gcXVldWUgaWYgcmVxdWlyZSgpIGlzIGZpbmlzaGVkIGxvYWRpbmcgbW9kdWxlcywgdGhlIGRvbSBpcyByZWFkeSwgYW5kIHRoZXJlIGFyZSBub1xuXHRcdFx0Ly8gcGVuZGluZyB0YXNrcyByZWdpc3RlcmVkIHZpYSBkb21SZWFkeSgpLlxuXHRcdFx0Ly8gVGhlIGxhc3Qgc3RlcCBpcyBuZWNlc3Nhcnkgc28gdGhhdCBhIHVzZXIgZGVmaW5lZCBkb2pvLnJlYWR5KCkgY2FsbGJhY2sgaXMgZGVsYXllZCB1bnRpbCBhZnRlciB0aGVcblx0XHRcdC8vIGRvbVJlYWR5KCkgY2FsbHMgaW5zaWRlIG9mIGRvam8uXHQgIEZhaWx1cmUgY2FuIGJlIHNlZW4gb24gZGlqaXQvdGVzdHMvcm9ib3QvRGlhbG9nX2FsbHkuaHRtbCBvbiBJRThcblx0XHRcdC8vIGJlY2F1c2UgdGhlIGRpaml0L2ZvY3VzLmpzIGRvbVJlYWR5KCkgY2FsbGJhY2sgZG9lc24ndCBleGVjdXRlIHVudGlsIGFmdGVyIHRoZSB0ZXN0IHN0YXJ0cyBydW5uaW5nLlxuXHRcdFx0d2hpbGUoaXNEb21SZWFkeSAmJiAoIWRvbVJlYWR5IHx8IGRvbVJlYWR5Ll9RLmxlbmd0aCA9PSAwKSAmJiAocmVxdWlyZS5pZGxlID8gcmVxdWlyZS5pZGxlKCkgOiB0cnVlKSAmJiBsb2FkUS5sZW5ndGgpe1xuXHRcdFx0XHR2YXIgZiA9IGxvYWRRLnNoaWZ0KCk7XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRmKCk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHQvLyBmb3JjZSB0aGUgZG9qby5qcyBvbihcImVycm9yXCIpIGhhbmRsZXIgZG8gZGlzcGxheSB0aGUgbWVzc2FnZVxuXHRcdFx0XHRcdGUuaW5mbyA9IGUubWVzc2FnZTtcblx0XHRcdFx0XHRpZihyZXF1aXJlLnNpZ25hbCl7XG5cdFx0XHRcdFx0XHRyZXF1aXJlLnNpZ25hbChcImVycm9yXCIsIGUpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b25Mb2FkUmVjdXJzaXZlR3VhcmQgPSAwO1xuXHRcdH07XG5cblx0Ly8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJ1biB0aGUgbmV4dCBxdWV1ZSBvcGVyYXRpb24gd2hlbmV2ZXIgcmVxdWlyZSgpIGZpbmlzaGVzIGxvYWRpbmcgbW9kdWxlcyBvciBkb21SZWFkeVxuXHQvLyBmaW5pc2hlcyBwcm9jZXNzaW5nIGl0J3MgcXVldWUuXG5cdHJlcXVpcmUub24gJiYgcmVxdWlyZS5vbihcImlkbGVcIiwgb25FdmVudCk7XG5cdGlmKGRvbVJlYWR5KXtcblx0XHRkb21SZWFkeS5fb25RRW1wdHkgPSBvbkV2ZW50O1xuXHR9XG5cblx0dmFyIHJlYWR5ID0gZG9qby5yZWFkeSA9IGRvam8uYWRkT25Mb2FkID0gZnVuY3Rpb24ocHJpb3JpdHksIGNvbnRleHQsIGNhbGxiYWNrKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEFkZCBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gRE9NIGNvbnRlbnQgbG9hZGVkIGFuZCBhbGwgcmVxdWVzdGVkIG1vZHVsZXMgaGF2ZSBhcnJpdmVkIGFuZCBiZWVuIGV2YWx1YXRlZC5cblx0XHQvL1x0XHRJbiBtb3N0IGNhc2VzLCB0aGUgYGRvbVJlYWR5YCBwbHVnLWluIHNob3VsZCBzdWZmaWNlIGFuZCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIG5lZWRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdFdoZW4gY2FsbGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGp1c3QgY2hlY2tzIHRoYXQgYWxsIHJlcXVlc3RlZCBtb2R1bGVzIGhhdmUgYXJyaXZlZCBhbmQgYmVlblxuXHRcdC8vXHRcdGV2YWx1YXRlZC5cblx0XHQvLyBwcmlvcml0eTogSW50ZWdlcj9cblx0XHQvL1x0XHRUaGUgb3JkZXIgaW4gd2hpY2ggdG8gZXhlYyB0aGlzIGNhbGxiYWNrIHJlbGF0aXZlIHRvIG90aGVyIGNhbGxiYWNrcywgZGVmYXVsdHMgdG8gMTAwMFxuXHRcdC8vIGNvbnRleHQ6IE9iamVjdD98RnVuY3Rpb25cblx0XHQvL1x0XHRUaGUgY29udGV4dCBpbiB3aGljaCB0byBydW4gZXhlY3V0ZSBjYWxsYmFjaywgb3IgYSBjYWxsYmFjayBpZiBub3QgdXNpbmcgY29udGV4dFxuXHRcdC8vIGNhbGxiYWNrOiBGdW5jdGlvbj9cblx0XHQvL1x0XHRUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFNpbXBsZSBET00gYW5kIE1vZHVsZXMgcmVhZHkgc3ludGF4XG5cdFx0Ly9cdHxcdHJlcXVpcmUoW1wiZG9qby9yZWFkeVwiXSwgZnVuY3Rpb24ocmVhZHkpe1xuXHRcdC8vXHR8XHRcdHJlYWR5KGZ1bmN0aW9uKCl7IGFsZXJ0KFwiRG9tIHJlYWR5IVwiKTsgfSk7XG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0VXNpbmcgYSBwcmlvcml0eVxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcmVhZHlcIl0sIGZ1bmN0aW9uKHJlYWR5KXtcblx0XHQvL1x0fFx0XHRyZWFkeSgyLCBmdW5jdGlvbigpeyBhbGVydChcImxvdyBwcmlvcml0eSByZWFkeSFcIik7IH0pXG5cdFx0Ly9cdHxcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0VXNpbmcgY29udGV4dFxuXHRcdC8vXHR8XHRyZXF1aXJlKFtcImRvam8vcmVhZHlcIl0sIGZ1bmN0aW9uKHJlYWR5KXtcblx0XHQvL1x0fFx0XHRyZWFkeShmb28sIGZ1bmN0aW9uKCl7XG5cdFx0Ly9cdHxcdFx0XHQvLyBpbiBoZXJlLCB0aGlzID09IGZvb1xuXHRcdC8vXHR8XHRcdH0pO1xuXHRcdC8vXHR8XHR9KTtcblx0XHQvL1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFVzaW5nIGRvam8vaGl0Y2ggc3R5bGUgYXJnczpcblx0XHQvL1x0fFx0cmVxdWlyZShbXCJkb2pvL3JlYWR5XCJdLCBmdW5jdGlvbihyZWFkeSl7XG5cdFx0Ly9cdHxcdFx0dmFyIGZvbyA9IHsgZG9qb1JlYWR5OiBmdW5jdGlvbigpeyBjb25zb2xlLndhcm4odGhpcywgXCJkb2pvIGRvbSBhbmQgbW9kdWxlcyByZWFkeS5cIik7IH0gfTtcblx0XHQvL1x0fFx0XHRyZWFkeShmb28sIFwiZG9qb1JlYWR5XCIpO1xuXHRcdC8vXHR8XHR9KTtcblxuXHRcdHZhciBoaXRjaEFyZ3MgPSBsYW5nLl90b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0aWYodHlwZW9mIHByaW9yaXR5ICE9IFwibnVtYmVyXCIpe1xuXHRcdFx0Y2FsbGJhY2sgPSBjb250ZXh0O1xuXHRcdFx0Y29udGV4dCA9IHByaW9yaXR5O1xuXHRcdFx0cHJpb3JpdHkgPSAxMDAwO1xuXHRcdH1lbHNle1xuXHRcdFx0aGl0Y2hBcmdzLnNoaWZ0KCk7XG5cdFx0fVxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgP1xuXHRcdFx0bGFuZy5oaXRjaC5hcHBseShkb2pvLCBoaXRjaEFyZ3MpIDpcblx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGNvbnRleHQoKTtcblx0XHRcdH07XG5cdFx0Y2FsbGJhY2sucHJpb3JpdHkgPSBwcmlvcml0eTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbG9hZFEubGVuZ3RoICYmIHByaW9yaXR5ID49IGxvYWRRW2ldLnByaW9yaXR5OyBpKyspe31cblx0XHRsb2FkUS5zcGxpY2UoaSwgMCwgY2FsbGJhY2spO1xuXHRcdG9uRXZlbnQoKTtcblx0fTtcblxuXHRoYXMuYWRkKFwiZG9qby1jb25maWctYWRkT25Mb2FkXCIsIDEpO1xuXHRpZihoYXMoXCJkb2pvLWNvbmZpZy1hZGRPbkxvYWRcIikpe1xuXHRcdHZhciBkY2EgPSBkb2pvLmNvbmZpZy5hZGRPbkxvYWQ7XG5cdFx0aWYoZGNhKXtcblx0XHRcdHJlYWR5WyhsYW5nLmlzQXJyYXkoZGNhKSA/IFwiYXBwbHlcIiA6IFwiY2FsbFwiKV0oZG9qbywgZGNhKTtcblx0XHR9XG5cdH1cblxuXHRpZihoYXMoXCJkb2pvLXN5bmMtbG9hZGVyXCIpICYmIGRvam8uY29uZmlnLnBhcnNlT25Mb2FkICYmICFkb2pvLmlzQXN5bmMpe1xuXHRcdHJlYWR5KDk5LCBmdW5jdGlvbigpe1xuXHRcdFx0aWYoIWRvam8ucGFyc2VyKXtcblx0XHRcdFx0ZG9qby5kZXByZWNhdGVkKFwiQWRkIGV4cGxpY2l0IHJlcXVpcmUoWydkb2pvL3BhcnNlciddKTtcIiwgXCJcIiwgXCIyLjBcIik7XG5cdFx0XHRcdHJlcXVpcmUoW1wiZG9qby9wYXJzZXJcIl0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0aWYoZG9tUmVhZHkpe1xuXHRcdGRvbVJlYWR5KGhhbmRsZURvbVJlYWR5KTtcblx0fWVsc2V7XG5cdFx0aGFuZGxlRG9tUmVhZHkoKTtcblx0fVxuXG5cdHJldHVybiByZWFkeTtcbn0pO1xuIiwiZGVmaW5lKFtcblx0Jy4vcmVxdWVzdC9kZWZhdWx0IScvKj09PT09LFxuXHQnLi9fYmFzZS9kZWNsYXJlJyxcblx0Jy4vcHJvbWlzZS9Qcm9taXNlJyA9PT09PSovXG5dLCBmdW5jdGlvbihyZXF1ZXN0Lyo9PT09PSwgZGVjbGFyZSwgUHJvbWlzZSA9PT09PSovKXtcblx0Lyo9PT09PVxuXHRyZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYSByZXF1ZXN0IHVzaW5nIHRoZSBkZWZhdWx0IHRyYW5zcG9ydCBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRUaGUgVVJMIHRvIHJlcXVlc3QuXG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHJlcXVlc3QuX19Qcm9taXNlID0gZGVjbGFyZShQcm9taXNlLCB7XG5cdFx0Ly8gcmVzcG9uc2U6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0QSBwcm9taXNlIHJlc29sdmluZyB0byBhbiBvYmplY3QgcmVwcmVzZW50aW5nXG5cdFx0Ly9cdFx0dGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cblx0fSk7XG5cdHJlcXVlc3QuX19CYXNlT3B0aW9ucyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIHF1ZXJ5OiBTdHJpbmd8T2JqZWN0P1xuXHRcdC8vXHRcdFF1ZXJ5IHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHRoZSBVUkwuXG5cdFx0Ly8gZGF0YTogU3RyaW5nfE9iamVjdD9cblx0XHQvL1x0XHREYXRhIHRvIHRyYW5zZmVyLiAgVGhpcyBpcyBpZ25vcmVkIGZvciBHRVQgYW5kIERFTEVURVxuXHRcdC8vXHRcdHJlcXVlc3RzLlxuXHRcdC8vIHByZXZlbnRDYWNoZTogQm9vbGVhbj9cblx0XHQvL1x0XHRXaGV0aGVyIHRvIGFwcGVuZCBhIGNhY2hlLWJ1c3RpbmcgcGFyYW1ldGVyIHRvIHRoZSBVUkwuXG5cdFx0Ly8gdGltZW91dDogSW50ZWdlcj9cblx0XHQvL1x0XHRNaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIHJlc3BvbnNlLiAgSWYgdGhpcyB0aW1lXG5cdFx0Ly9cdFx0cGFzc2VzLCB0aGUgdGhlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cblx0XHQvLyBoYW5kbGVBczogU3RyaW5nP1xuXHRcdC8vXHRcdEhvdyB0byBoYW5kbGUgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gIERlZmF1bHQgaXNcblx0XHQvL1x0XHQndGV4dCcuICBPdGhlciB2YWx1ZXMgYXJlICdqc29uJywgJ2phdmFzY3JpcHQnLCBhbmQgJ3htbCcuXG5cdH0pO1xuXHRyZXF1ZXN0Ll9fTWV0aG9kT3B0aW9ucyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIG1ldGhvZDogU3RyaW5nP1xuXHRcdC8vXHRcdFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgdG8gbWFrZSB0aGUgcmVxdWVzdC4gIE11c3QgYmVcblx0XHQvL1x0XHR1cHBlcmNhc2UuXG5cdH0pO1xuXHRyZXF1ZXN0Ll9fT3B0aW9ucyA9IGRlY2xhcmUoW3JlcXVlc3QuX19CYXNlT3B0aW9ucywgcmVxdWVzdC5fX01ldGhvZE9wdGlvbnNdKTtcblxuXHRyZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgR0VUIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHRyZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZCBhbiBIVFRQIFBPU1QgcmVxdWVzdCB1c2luZyB0aGUgZGVmYXVsdCB0cmFuc3BvcnQgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QuX19CYXNlT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBQT1NUIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHRyZXF1ZXN0LmRlbCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kIGFuIEhUVFAgREVMRVRFIHJlcXVlc3QgdXNpbmcgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0Ll9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHQ9PT09PSovXG5cdHJldHVybiByZXF1ZXN0O1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnLi4vanNvbicsXG5cdCcuLi9fYmFzZS9rZXJuZWwnLFxuXHQnLi4vX2Jhc2UvYXJyYXknLFxuXHQnLi4vaGFzJyxcblx0Jy4uL2hhcyFkb20/Li4vc2VsZWN0b3IvX2xvYWRlcicgLy8gb25seSBpbmNsdWRlZCBmb3IgaGFzKCkgcXNhIHRlc3RzXG5dLCBmdW5jdGlvbihKU09OLCBrZXJuZWwsIGFycmF5LCBoYXMpe1xuXHRoYXMuYWRkKCdhY3RpdmV4JywgdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKTtcblx0aGFzLmFkZCgnZG9tLXBhcnNlcicsIGZ1bmN0aW9uKGdsb2JhbCl7XG5cdFx0cmV0dXJuICdET01QYXJzZXInIGluIGdsb2JhbDtcblx0fSk7XG5cblx0dmFyIGhhbmRsZVhNTDtcblx0aWYoaGFzKCdhY3RpdmV4Jykpe1xuXHRcdC8vIEdVSURzIG9idGFpbmVkIGZyb20gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNzU3ODM3KFZTLjg1KS5hc3B4XG5cdFx0dmFyIGRwID0gW1xuXHRcdFx0J01zeG1sMi5ET01Eb2N1bWVudC42LjAnLFxuXHRcdFx0J01zeG1sMi5ET01Eb2N1bWVudC40LjAnLFxuXHRcdFx0J01TWE1MMi5ET01Eb2N1bWVudC4zLjAnLFxuXHRcdFx0J01TWE1MLkRPTURvY3VtZW50JyAvLyAyLjBcblx0XHRdO1xuXHRcdHZhciBsYXN0UGFyc2VyO1xuXG5cdFx0aGFuZGxlWE1MID0gZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0dmFyIHJlc3VsdCA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHR2YXIgdGV4dCA9IHJlc3BvbnNlLnRleHQ7XG5cblx0XHRcdGlmKHJlc3VsdCAmJiBoYXMoJ2RvbS1xc2EyLjEnKSAmJiAhcmVzdWx0LnF1ZXJ5U2VsZWN0b3JBbGwgJiYgaGFzKCdkb20tcGFyc2VyJykpe1xuXHRcdFx0XHQvLyBodHRwOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE1NjMxXG5cdFx0XHRcdC8vIElFOSBzdXBwb3J0cyBhIENTUzMgcXVlcnlTZWxlY3RvckFsbCBpbXBsZW1lbnRhdGlvbiwgYnV0IHRoZSBET00gaW1wbGVtZW50YXRpb25cblx0XHRcdFx0Ly8gcmV0dXJuZWQgYnkgSUU5IHhoci5yZXNwb25zZVhNTCBkb2VzIG5vdC4gTWFudWFsbHkgY3JlYXRlIHRoZSBYTUwgRE9NIHRvIGdhaW5cblx0XHRcdFx0Ly8gdGhlIGZ1bGxlci1mZWF0dXJlZCBpbXBsZW1lbnRhdGlvbiBhbmQgYXZvaWQgYnVncyBjYXVzZWQgYnkgdGhlIGluY29uc2lzdGVuY3lcblx0XHRcdFx0cmVzdWx0ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAnYXBwbGljYXRpb24veG1sJyk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KHApIHtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QocCk7XG5cdFx0XHRcdFx0XHRkb20uYXN5bmMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGRvbS5sb2FkWE1MKHRleHQpO1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gZG9tO1xuXHRcdFx0XHRcdFx0bGFzdFBhcnNlciA9IHA7XG5cdFx0XHRcdFx0fWNhdGNoKGUpeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXJlc3VsdCB8fCAhcmVzdWx0LmRvY3VtZW50RWxlbWVudCl7XG5cdFx0XHRcdC8vIFRoZSBjcmVhdGlvbiBvZiBhbiBBY3RpdmVYIG9iamVjdCBpcyBleHBlbnNpdmUsIHNvIHdlIGNhY2hlIHRoZVxuXHRcdFx0XHQvLyBwYXJzZXIgdHlwZSB0byBhdm9pZCB0cnlpbmcgYWxsIHBhcnNlciB0eXBlcyBlYWNoIHRpbWUgd2UgaGFuZGxlIGFcblx0XHRcdFx0Ly8gZG9jdW1lbnQuIFRoZXJlIGlzIHNvbWUgY29uY2VybiB0aGF0IHNvbWUgcGFyc2VyIHR5cGVzIG1pZ2h0IGZhaWxcblx0XHRcdFx0Ly8gZGVwZW5kaW5nIG9uIHRoZSBkb2N1bWVudCBiZWluZyBwYXJzZWQuIElmIHBhcnNpbmcgdXNpbmcgdGhlIGNhY2hlZFxuXHRcdFx0XHQvLyBwYXJzZXIgdHlwZSBmYWlscywgd2UgZG8gdGhlIG1vcmUgZXhwZW5zaXZlIG9wZXJhdGlvbiBvZiBmaW5kaW5nIG9uZVxuXHRcdFx0XHQvLyB0aGF0IHdvcmtzIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE1MjQ2XG5cdFx0XHRcdGlmKCFsYXN0UGFyc2VyIHx8ICFjcmVhdGVEb2N1bWVudChsYXN0UGFyc2VyKSkge1xuXHRcdFx0XHRcdGFycmF5LnNvbWUoZHAsIGNyZWF0ZURvY3VtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH1cblxuXHR2YXIgaGFuZGxlTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuXHRcdGlmKCFoYXMoJ25hdGl2ZS14aHIyLWJsb2InKSAmJiByZXNwb25zZS5vcHRpb25zLmhhbmRsZUFzID09PSAnYmxvYicgJiYgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKXtcblx0XHRcdHJldHVybiBuZXcgQmxvYihbIHJlc3BvbnNlLnhoci5yZXNwb25zZSBdLCB7IHR5cGU6IHJlc3BvbnNlLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3BvbnNlLnhoci5yZXNwb25zZTtcblx0fVxuXG5cdHZhciBoYW5kbGVycyA9IHtcblx0XHQnamF2YXNjcmlwdCc6IGZ1bmN0aW9uKHJlc3BvbnNlKXtcblx0XHRcdHJldHVybiBrZXJuZWwuZXZhbChyZXNwb25zZS50ZXh0IHx8ICcnKTtcblx0XHR9LFxuXHRcdCdqc29uJzogZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCB8fCBudWxsKTtcblx0XHR9LFxuXHRcdCd4bWwnOiBoYW5kbGVYTUwsXG5cdFx0J2Jsb2InOiBoYW5kbGVOYXRpdmVSZXNwb25zZSxcblx0XHQnYXJyYXlidWZmZXInOiBoYW5kbGVOYXRpdmVSZXNwb25zZSxcblx0XHQnZG9jdW1lbnQnOiBoYW5kbGVOYXRpdmVSZXNwb25zZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGhhbmRsZShyZXNwb25zZSl7XG5cdFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tyZXNwb25zZS5vcHRpb25zLmhhbmRsZUFzXTtcblxuXHRcdHJlc3BvbnNlLmRhdGEgPSBoYW5kbGVyID8gaGFuZGxlcihyZXNwb25zZSkgOiAocmVzcG9uc2UuZGF0YSB8fCByZXNwb25zZS50ZXh0KTtcblxuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGhhbmRsZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpe1xuXHRcdGhhbmRsZXJzW25hbWVdID0gaGFuZGxlcjtcblx0fTtcblxuXHRyZXR1cm4gaGFuZGxlO1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnZXhwb3J0cycsXG5cdCcuLi9lcnJvcnMvUmVxdWVzdEVycm9yJyxcblx0Jy4uL2Vycm9ycy9DYW5jZWxFcnJvcicsXG5cdCcuLi9EZWZlcnJlZCcsXG5cdCcuLi9pby1xdWVyeScsXG5cdCcuLi9fYmFzZS9hcnJheScsXG5cdCcuLi9fYmFzZS9sYW5nJyxcblx0Jy4uL3Byb21pc2UvUHJvbWlzZScsXG5cdCcuLi9oYXMnXG5dLCBmdW5jdGlvbihleHBvcnRzLCBSZXF1ZXN0RXJyb3IsIENhbmNlbEVycm9yLCBEZWZlcnJlZCwgaW9RdWVyeSwgYXJyYXksIGxhbmcsIFByb21pc2UsIGhhcyl7XG5cblx0ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1hcnJheWJ1ZmZlcicpICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1ibG9iJykgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iXG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuXHRcdGlmKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJykgeyAvL2FsbCBvdGhlclxuXHRcdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcblx0XHR9XG5cblx0XHQvL0lFPD03XG5cdFx0cmV0dXJuIHZhbHVlLm5vZGVUeXBlID09PSAxO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWx1ZSkge1xuXHRcdHJldHVybiBoYXMoJ25hdGl2ZS1mb3JtZGF0YScpICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGREZWVwQ29weSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0IWlzRm9ybURhdGEodmFsdWUpICYmXG5cdFx0XHQhaXNFbGVtZW50KHZhbHVlKSAmJlxuXHRcdFx0IWlzQmxvYih2YWx1ZSkgJiZcblx0XHRcdCFpc0FycmF5QnVmZmVyKHZhbHVlKVxuXHR9XG5cblx0ZXhwb3J0cy5kZWVwQ29weSA9IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBzb3VyY2UpIHtcblx0XHRcdHZhciB0dmFsID0gdGFyZ2V0W25hbWVdLFxuICBcdFx0XHQgICAgc3ZhbCA9IHNvdXJjZVtuYW1lXTtcblx0XHRcdGlmIChuYW1lICE9PSAnX19wcm90b19fJyAmJiB0dmFsICE9PSBzdmFsKSB7XG5cdFx0XHRcdGlmIChzaG91bGREZWVwQ29weShzdmFsKSkge1xuXHRcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ZhbCkgPT09ICdbb2JqZWN0IERhdGVdJykgeyAvLyB1c2UgdGhpcyBkYXRlIHRlc3QgdG8gaGFuZGxlIGNyb3NzaW5nIGZyYW1lIGJvdW5kYXJpZXNcblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IG5ldyBEYXRlKHN2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFuZy5pc0FycmF5KHN2YWwpKSB7XG4gXHRcdFx0XHRcdFx0ICB0YXJnZXRbbmFtZV0gPSBleHBvcnRzLmRlZXBDb3B5QXJyYXkoc3ZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICh0dmFsICYmIHR5cGVvZiB0dmFsID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0XHRleHBvcnRzLmRlZXBDb3B5KHR2YWwsIHN2YWwpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gZXhwb3J0cy5kZWVwQ29weSh7fSwgc3ZhbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IHN2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRleHBvcnRzLmRlZXBDb3B5QXJyYXkgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgY2xvbmVkQXJyYXkgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdmFsSXRlbSA9IHNvdXJjZVtpXTtcblx0XHRcdGlmICh0eXBlb2Ygc3ZhbEl0ZW0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGNsb25lZEFycmF5LnB1c2goZXhwb3J0cy5kZWVwQ29weSh7fSwgc3ZhbEl0ZW0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lZEFycmF5LnB1c2goc3ZhbEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZWRBcnJheTtcblx0fTtcblxuXHRleHBvcnRzLmRlZXBDcmVhdGUgPSBmdW5jdGlvbiBkZWVwQ3JlYXRlKHNvdXJjZSwgcHJvcGVydGllcyl7XG5cdFx0cHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG5cdFx0dmFyIHRhcmdldCA9IGxhbmcuZGVsZWdhdGUoc291cmNlKSxcblx0XHRcdG5hbWUsIHZhbHVlO1xuXG5cdFx0Zm9yKG5hbWUgaW4gc291cmNlKXtcblx0XHRcdHZhbHVlID0gc291cmNlW25hbWVdO1xuXG5cdFx0XHRpZih2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKXtcblx0XHRcdFx0dGFyZ2V0W25hbWVdID0gZXhwb3J0cy5kZWVwQ3JlYXRlKHZhbHVlLCBwcm9wZXJ0aWVzW25hbWVdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGV4cG9ydHMuZGVlcENvcHkodGFyZ2V0LCBwcm9wZXJ0aWVzKTtcblx0fTtcblxuXHR2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZSB8fCBmdW5jdGlvbihvYmopeyByZXR1cm4gb2JqOyB9O1xuXHRmdW5jdGlvbiBva0hhbmRsZXIocmVzcG9uc2Upe1xuXHRcdHJldHVybiBmcmVlemUocmVzcG9uc2UpO1xuXHR9XG5cdGZ1bmN0aW9uIGRhdGFIYW5kbGVyIChyZXNwb25zZSkge1xuXHRcdHJldHVybiByZXNwb25zZS5kYXRhICE9PSB1bmRlZmluZWQgPyByZXNwb25zZS5kYXRhIDogcmVzcG9uc2UudGV4dDtcblx0fVxuXG5cdGV4cG9ydHMuZGVmZXJyZWQgPSBmdW5jdGlvbiBkZWZlcnJlZChyZXNwb25zZSwgY2FuY2VsLCBpc1ZhbGlkLCBpc1JlYWR5LCBoYW5kbGVSZXNwb25zZSwgbGFzdCl7XG5cdFx0dmFyIGRlZiA9IG5ldyBEZWZlcnJlZChmdW5jdGlvbihyZWFzb24pe1xuXHRcdFx0Y2FuY2VsICYmIGNhbmNlbChkZWYsIHJlc3BvbnNlKTtcblxuXHRcdFx0aWYoIXJlYXNvbiB8fCAhKHJlYXNvbiBpbnN0YW5jZW9mIFJlcXVlc3RFcnJvcikgJiYgIShyZWFzb24gaW5zdGFuY2VvZiBDYW5jZWxFcnJvcikpe1xuXHRcdFx0XHRyZXR1cm4gbmV3IENhbmNlbEVycm9yKCdSZXF1ZXN0IGNhbmNlbGVkJywgcmVzcG9uc2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlYXNvbjtcblx0XHR9KTtcblxuXHRcdGRlZi5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHRcdGRlZi5pc1ZhbGlkID0gaXNWYWxpZDtcblx0XHRkZWYuaXNSZWFkeSA9IGlzUmVhZHk7XG5cdFx0ZGVmLmhhbmRsZVJlc3BvbnNlID0gaGFuZGxlUmVzcG9uc2U7XG5cblx0XHRmdW5jdGlvbiBlcnJIYW5kbGVyKGVycm9yKXtcblx0XHRcdGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdFx0dmFyIHJlc3BvbnNlUHJvbWlzZSA9IGRlZi50aGVuKG9rSGFuZGxlcikub3RoZXJ3aXNlKGVyckhhbmRsZXIpO1xuXG5cdFx0aWYoZXhwb3J0cy5ub3RpZnkpe1xuXHRcdFx0cmVzcG9uc2VQcm9taXNlLnRoZW4oXG5cdFx0XHRcdGxhbmcuaGl0Y2goZXhwb3J0cy5ub3RpZnksICdlbWl0JywgJ2xvYWQnKSxcblx0XHRcdFx0bGFuZy5oaXRjaChleHBvcnRzLm5vdGlmeSwgJ2VtaXQnLCAnZXJyb3InKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVByb21pc2UgPSByZXNwb25zZVByb21pc2UudGhlbihkYXRhSGFuZGxlcik7XG5cblx0XHQvLyBodHRwOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE2Nzk0XG5cdFx0Ly8gVGhlIGZvbGxvd2luZyB3b3JrcyBhcm91bmQgYSBsZWFrIGluIElFOSB0aHJvdWdoIHRoZVxuXHRcdC8vIHByb3RvdHlwZSB1c2luZyBsYW5nLmRlbGVnYXRlIG9uIGRhdGFQcm9taXNlIGFuZFxuXHRcdC8vIGFzc2lnbmluZyB0aGUgcmVzdWx0IGEgcHJvcGVydHkgd2l0aCBhIHJlZmVyZW5jZSB0b1xuXHRcdC8vIHJlc3BvbnNlUHJvbWlzZS5cblx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBkYXRhUHJvbWlzZSkge1xuXHRcdFx0aWYgKGRhdGFQcm9taXNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHByb21pc2VbcHJvcF0gPSBkYXRhUHJvbWlzZVtwcm9wXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cHJvbWlzZS5yZXNwb25zZSA9IHJlc3BvbnNlUHJvbWlzZTtcblx0XHRmcmVlemUocHJvbWlzZSk7XG5cdFx0Ly8gRW5kIGxlYWsgZml4XG5cblxuXHRcdGlmKGxhc3Qpe1xuXHRcdFx0ZGVmLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuXHRcdFx0XHRsYXN0LmNhbGwoZGVmLCByZXNwb25zZSk7XG5cdFx0XHR9LCBmdW5jdGlvbihlcnJvcil7XG5cdFx0XHRcdGxhc3QuY2FsbChkZWYsIHJlc3BvbnNlLCBlcnJvcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRkZWYucHJvbWlzZSA9IHByb21pc2U7XG5cdFx0ZGVmLnRoZW4gPSBwcm9taXNlLnRoZW47XG5cblx0XHRyZXR1cm4gZGVmO1xuXHR9O1xuXG5cdGV4cG9ydHMuYWRkQ29tbW9uTWV0aG9kcyA9IGZ1bmN0aW9uIGFkZENvbW1vbk1ldGhvZHMocHJvdmlkZXIsIG1ldGhvZHMpe1xuXHRcdGFycmF5LmZvckVhY2gobWV0aG9kc3x8WydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJ10sIGZ1bmN0aW9uKG1ldGhvZCl7XG5cdFx0XHRwcm92aWRlclsobWV0aG9kID09PSAnREVMRVRFJyA/ICdERUwnIDogbWV0aG9kKS50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0XHRcdG9wdGlvbnMgPSBsYW5nLmRlbGVnYXRlKG9wdGlvbnN8fHt9KTtcblx0XHRcdFx0b3B0aW9ucy5tZXRob2QgPSBtZXRob2Q7XG5cdFx0XHRcdHJldHVybiBwcm92aWRlcih1cmwsIG9wdGlvbnMpO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlQXJncyA9IGZ1bmN0aW9uIHBhcnNlQXJncyh1cmwsIG9wdGlvbnMsIHNraXBEYXRhKXtcblx0XHR2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdHF1ZXJ5ID0gb3B0aW9ucy5xdWVyeTtcblxuXHRcdGlmKGRhdGEgJiYgIXNraXBEYXRhKXtcblx0XHRcdGlmKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAoIShoYXMoJ25hdGl2ZS14aHIyJykpIHx8ICEoaXNBcnJheUJ1ZmZlcihkYXRhKSB8fCBpc0Jsb2IoZGF0YSkgKSkpe1xuXHRcdFx0XHRvcHRpb25zLmRhdGEgPSBpb1F1ZXJ5Lm9iamVjdFRvUXVlcnkoZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocXVlcnkpe1xuXHRcdFx0aWYodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jyl7XG5cdFx0XHRcdHF1ZXJ5ID0gaW9RdWVyeS5vYmplY3RUb1F1ZXJ5KHF1ZXJ5KTtcblx0XHRcdH1cblx0XHRcdGlmKG9wdGlvbnMucHJldmVudENhY2hlKXtcblx0XHRcdFx0cXVlcnkgKz0gKHF1ZXJ5ID8gJyYnIDogJycpICsgJ3JlcXVlc3QucHJldmVudENhY2hlPScgKyAoKyhuZXcgRGF0ZSkpO1xuXHRcdFx0fVxuXHRcdH1lbHNlIGlmKG9wdGlvbnMucHJldmVudENhY2hlKXtcblx0XHRcdHF1ZXJ5ID0gJ3JlcXVlc3QucHJldmVudENhY2hlPScgKyAoKyhuZXcgRGF0ZSkpO1xuXHRcdH1cblxuXHRcdGlmKHVybCAmJiBxdWVyeSl7XG5cdFx0XHR1cmwgKz0gKH51cmwuaW5kZXhPZignPycpID8gJyYnIDogJz8nKSArIHF1ZXJ5O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdG9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRnZXRIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlck5hbWUpeyByZXR1cm4gbnVsbDsgfVxuXHRcdH07XG5cdH07XG5cblx0ZXhwb3J0cy5jaGVja1N0YXR1cyA9IGZ1bmN0aW9uKHN0YXQpe1xuXHRcdHN0YXQgPSBzdGF0IHx8IDA7XG5cdFx0cmV0dXJuIChzdGF0ID49IDIwMCAmJiBzdGF0IDwgMzAwKSB8fCAvLyBhbGxvdyBhbnkgMlhYIHJlc3BvbnNlIGNvZGVcblx0XHRcdHN0YXQgPT09IDMwNCB8fCAgICAgICAgICAgICAgICAgLy8gb3IsIGdldCBpdCBvdXQgb2YgdGhlIGNhY2hlXG5cdFx0XHRzdGF0ID09PSAxMjIzIHx8ICAgICAgICAgICAgICAgIC8vIG9yLCBJbnRlcm5ldCBFeHBsb3JlciBtYW5nbGVkIHRoZSBzdGF0dXMgY29kZVxuXHRcdFx0IXN0YXQ7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yLCB3ZSdyZSBUaXRhbml1bS9icm93c2VyIGNocm9tZS9jaHJvbWUgZXh0ZW5zaW9uIHJlcXVlc3RpbmcgYSBsb2NhbCBmaWxlXG5cdH07XG59KTtcbiIsImRlZmluZShbXG5cdCcuL3V0aWwnLFxuXHQnLi4vZXJyb3JzL1JlcXVlc3RUaW1lb3V0RXJyb3InLFxuXHQnLi4vZXJyb3JzL0NhbmNlbEVycm9yJyxcblx0Jy4uL19iYXNlL2FycmF5Jyxcblx0Jy4uL2hhcyFob3N0LWJyb3dzZXI/Li4vX2Jhc2Uvd2luZG93OicsXG5cdCcuLi9oYXMhaG9zdC1icm93c2VyP2RvbS1hZGRldmVudGxpc3RlbmVyPzouLi9vbjonXG5dLCBmdW5jdGlvbih1dGlsLCBSZXF1ZXN0VGltZW91dEVycm9yLCBDYW5jZWxFcnJvciwgYXJyYXksIHdpbiwgb24pe1xuXHQvLyBhdm9pZCBzZXR0aW5nIGEgdGltZXIgcGVyIHJlcXVlc3QuIEl0IGRlZ3JhZGVzIHBlcmZvcm1hbmNlIG9uIElFXG5cdC8vIHNvbWV0aGluZyBmaWVyZWNlIGlmIHdlIGRvbid0IHVzZSB1bmlmaWVkIGxvb3BzLlxuXHR2YXIgX2luRmxpZ2h0SW50dmwgPSBudWxsLFxuXHRcdF9pbkZsaWdodCA9IFtdO1xuXG5cdGZ1bmN0aW9uIHdhdGNoSW5GbGlnaHQoKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdGludGVybmFsIG1ldGhvZCB0aGF0IGNoZWNrcyBlYWNoIGluZmxpZ2h0IFhNTEh0dHBSZXF1ZXN0IHRvIHNlZVxuXHRcdC8vXHRcdGlmIGl0IGhhcyBjb21wbGV0ZWQgb3IgaWYgdGhlIHRpbWVvdXQgc2l0dWF0aW9uIGFwcGxpZXMuXG5cblx0XHR2YXIgbm93ID0gKyhuZXcgRGF0ZSk7XG5cblx0XHQvLyB3ZSBuZWVkIG1hbnVhbCBsb29wIGJlY2F1c2Ugd2Ugb2Z0ZW4gbW9kaWZ5IF9pbkZsaWdodCAoYW5kIHRoZXJlZm9yZSAnaScpIHdoaWxlIGl0ZXJhdGluZ1xuXHRcdGZvcih2YXIgaSA9IDAsIGRmZDsgaSA8IF9pbkZsaWdodC5sZW5ndGggJiYgKGRmZCA9IF9pbkZsaWdodFtpXSk7IGkrKyl7XG5cdFx0XHR2YXIgcmVzcG9uc2UgPSBkZmQucmVzcG9uc2UsXG5cdFx0XHRcdG9wdGlvbnMgPSByZXNwb25zZS5vcHRpb25zO1xuXHRcdFx0aWYoKGRmZC5pc0NhbmNlbGVkICYmIGRmZC5pc0NhbmNlbGVkKCkpIHx8IChkZmQuaXNWYWxpZCAmJiAhZGZkLmlzVmFsaWQocmVzcG9uc2UpKSl7XG5cdFx0XHRcdF9pbkZsaWdodC5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0d2F0Y2guX29uQWN0aW9uICYmIHdhdGNoLl9vbkFjdGlvbigpO1xuXHRcdFx0fWVsc2UgaWYoZGZkLmlzUmVhZHkgJiYgZGZkLmlzUmVhZHkocmVzcG9uc2UpKXtcblx0XHRcdFx0X2luRmxpZ2h0LnNwbGljZShpLS0sIDEpO1xuXHRcdFx0XHRkZmQuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuXHRcdFx0XHR3YXRjaC5fb25BY3Rpb24gJiYgd2F0Y2guX29uQWN0aW9uKCk7XG5cdFx0XHR9ZWxzZSBpZihkZmQuc3RhcnRUaW1lKXtcblx0XHRcdFx0Ly8gZGlkIHdlIHRpbWVvdXQ/XG5cdFx0XHRcdGlmKGRmZC5zdGFydFRpbWUgKyAob3B0aW9ucy50aW1lb3V0IHx8IDApIDwgbm93KXtcblx0XHRcdFx0XHRfaW5GbGlnaHQuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0IHNvIHRoZSBpbyBtb2R1bGUgY2FuIGRvIGFwcHJvcHJpYXRlIGNsZWFudXAuXG5cdFx0XHRcdFx0ZGZkLmNhbmNlbChuZXcgUmVxdWVzdFRpbWVvdXRFcnJvcignVGltZW91dCBleGNlZWRlZCcsIHJlc3BvbnNlKSk7XG5cdFx0XHRcdFx0d2F0Y2guX29uQWN0aW9uICYmIHdhdGNoLl9vbkFjdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2F0Y2guX29uSW5GbGlnaHQgJiYgd2F0Y2guX29uSW5GbGlnaHQoZGZkKTtcblxuXHRcdGlmKCFfaW5GbGlnaHQubGVuZ3RoKXtcblx0XHRcdGNsZWFySW50ZXJ2YWwoX2luRmxpZ2h0SW50dmwpO1xuXHRcdFx0X2luRmxpZ2h0SW50dmwgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHdhdGNoKGRmZCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRXYXRjaGVzIHRoZSBpbyByZXF1ZXN0IHJlcHJlc2VudGVkIGJ5IGRmZCB0byBzZWUgaWYgaXQgY29tcGxldGVzLlxuXHRcdC8vIGRmZDogRGVmZXJyZWRcblx0XHQvL1x0XHRUaGUgRGVmZXJyZWQgb2JqZWN0IHRvIHdhdGNoLlxuXHRcdC8vIHJlc3BvbnNlOiBPYmplY3Rcblx0XHQvL1x0XHRUaGUgb2JqZWN0IHVzZWQgYXMgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0IHByb21pc2UuXG5cdFx0Ly8gdmFsaWRDaGVjazogRnVuY3Rpb25cblx0XHQvL1x0XHRGdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGlmIHRoZSBJTyByZXF1ZXN0IGlzIHN0aWxsIHZhbGlkLiBHZXRzIHRoZSBkZmRcblx0XHQvL1x0XHRvYmplY3QgYXMgaXRzIG9ubHkgYXJndW1lbnQuXG5cdFx0Ly8gaW9DaGVjazogRnVuY3Rpb25cblx0XHQvL1x0XHRGdW5jdGlvbiB1c2VkIHRvIGNoZWNrIGlmIGJhc2ljIElPIGNhbGwgd29ya2VkLiBHZXRzIHRoZSBkZmRcblx0XHQvL1x0XHRvYmplY3QgYXMgaXRzIG9ubHkgYXJndW1lbnQuXG5cdFx0Ly8gcmVzSGFuZGxlOiBGdW5jdGlvblxuXHRcdC8vXHRcdEZ1bmN0aW9uIHVzZWQgdG8gcHJvY2VzcyByZXNwb25zZS4gR2V0cyB0aGUgZGZkXG5cdFx0Ly9cdFx0b2JqZWN0IGFzIGl0cyBvbmx5IGFyZ3VtZW50LlxuXHRcdGlmKGRmZC5yZXNwb25zZS5vcHRpb25zLnRpbWVvdXQpe1xuXHRcdFx0ZGZkLnN0YXJ0VGltZSA9ICsobmV3IERhdGUpO1xuXHRcdH1cblxuXHRcdGlmKGRmZC5pc0Z1bGZpbGxlZCgpKXtcblx0XHRcdC8vIGJhaWwgb3V0IGlmIHRoZSBkZWZlcnJlZCBpcyBhbHJlYWR5IGZ1bGZpbGxlZFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF9pbkZsaWdodC5wdXNoKGRmZCk7XG5cdFx0aWYoIV9pbkZsaWdodEludHZsKXtcblx0XHRcdF9pbkZsaWdodEludHZsID0gc2V0SW50ZXJ2YWwod2F0Y2hJbkZsaWdodCwgNTApO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzeW5jIHJlcXVlc3RzIHNlcGFyYXRlbHkgZnJvbSBhc3luYzpcblx0XHQvLyBodHRwOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0Lzg0Njdcblx0XHRpZihkZmQucmVzcG9uc2Uub3B0aW9ucy5zeW5jKXtcblx0XHRcdHdhdGNoSW5GbGlnaHQoKTtcblx0XHR9XG5cdH1cblxuXHR3YXRjaC5jYW5jZWxBbGwgPSBmdW5jdGlvbiBjYW5jZWxBbGwoKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdENhbmNlbHMgYWxsIHBlbmRpbmcgSU8gcmVxdWVzdHMsIHJlZ2FyZGxlc3Mgb2YgSU8gdHlwZVxuXHRcdHRyeXtcblx0XHRcdGFycmF5LmZvckVhY2goX2luRmxpZ2h0LCBmdW5jdGlvbihkZmQpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0ZGZkLmNhbmNlbChuZXcgQ2FuY2VsRXJyb3IoJ0FsbCByZXF1ZXN0cyBjYW5jZWxlZC4nKSk7XG5cdFx0XHRcdH1jYXRjaChlKXt9XG5cdFx0XHR9KTtcblx0XHR9Y2F0Y2goZSl7fVxuXHR9O1xuXG5cdGlmKHdpbiAmJiBvbiAmJiB3aW4uZG9jLmF0dGFjaEV2ZW50KXtcblx0XHQvLyBBdXRvbWF0aWNhbGx5IGNhbGwgY2FuY2VsIGFsbCBpbyBjYWxscyBvbiB1bmxvYWQgaW4gSUVcblx0XHQvLyBodHRwOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzIzNTdcblx0XHRvbih3aW4uZ2xvYmFsLCAndW5sb2FkJywgZnVuY3Rpb24oKXtcblx0XHRcdHdhdGNoLmNhbmNlbEFsbCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHdhdGNoO1xufSk7XG4iLCJkZWZpbmUoW1xuXHQnLi4vZXJyb3JzL1JlcXVlc3RFcnJvcicsXG5cdCcuL3dhdGNoJyxcblx0Jy4vaGFuZGxlcnMnLFxuXHQnLi91dGlsJyxcblx0Jy4uL2hhcycvKj09PT09LFxuXHQnLi4vcmVxdWVzdCcsXG5cdCcuLi9fYmFzZS9kZWNsYXJlJyA9PT09PSovXG5dLCBmdW5jdGlvbihSZXF1ZXN0RXJyb3IsIHdhdGNoLCBoYW5kbGVycywgdXRpbCwgaGFzLyo9PT09PSwgcmVxdWVzdCwgZGVjbGFyZSA9PT09PSovKXtcblx0aGFzLmFkZCgnbmF0aXZlLXhocicsIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gaWYgdHJ1ZSwgdGhlIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSBYSFIgaW1wbGVtZW50YXRpb25cblx0XHRyZXR1cm4gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJztcblx0fSk7XG5cdGhhcy5hZGQoJ2Rvam8tZm9yY2UtYWN0aXZleC14aHInLCBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBoYXMoJ2FjdGl2ZXgnKSAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdmaWxlOic7XG5cdH0pO1xuXG5cdGhhcy5hZGQoJ25hdGl2ZS14aHIyJywgZnVuY3Rpb24oKXtcblx0XHRpZighaGFzKCduYXRpdmUteGhyJykgfHwgaGFzKCdkb2pvLWZvcmNlLWFjdGl2ZXgteGhyJykpeyByZXR1cm47IH1cblx0XHR2YXIgeCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHJldHVybiB0eXBlb2YgeFsnYWRkRXZlbnRMaXN0ZW5lciddICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0KHR5cGVvZiBvcGVyYSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHhbJ3VwbG9hZCddICE9PSAndW5kZWZpbmVkJyk7XG5cdH0pO1xuXG5cdGhhcy5hZGQoJ25hdGl2ZS1mb3JtZGF0YScsIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gaWYgdHJ1ZSwgdGhlIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSBGb3JtRGF0YSBpbXBsZW1lbnRhdGlvblxuXHRcdHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnO1xuXHR9KTtcblxuXHRoYXMuYWRkKCduYXRpdmUtYmxvYicsIGZ1bmN0aW9uKCl7XG5cdFx0Ly8gaWYgdHJ1ZSwgdGhlIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSBCbG9iIGltcGxlbWVudGF0aW9uXG5cdFx0cmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblx0fSk7XG5cblx0aGFzLmFkZCgnbmF0aXZlLWFycmF5YnVmZmVyJywgZnVuY3Rpb24oKXtcblx0XHQvLyBpZiB0cnVlLCB0aGUgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlIEFycmF5QnVmZmVyIGltcGxlbWVudGF0aW9uXG5cdFx0cmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cdH0pO1xuXG5cdGhhcy5hZGQoJ25hdGl2ZS1yZXNwb25zZS10eXBlJywgZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gaGFzKCduYXRpdmUteGhyJykgJiYgdHlwZW9mIG5ldyBYTUxIdHRwUmVxdWVzdCgpLnJlc3BvbnNlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG5cdH0pO1xuXG5cdGhhcy5hZGQoJ25hdGl2ZS14aHIyLWJsb2InLCBmdW5jdGlvbigpe1xuXHRcdGlmKCFoYXMoJ25hdGl2ZS1yZXNwb25zZS10eXBlJykpeyByZXR1cm47IH1cblx0XHR2YXIgeCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdC8vIFRoZSBVUkwgdXNlZCBoZXJlIGRvZXMgbm90IGhhdmUgdG8gYmUgcmVhY2hhYmxlIGFzIHRoZSBYSFIncyBgc2VuZGAgbWV0aG9kIGlzIG5ldmVyIGNhbGxlZC5cblx0XHQvLyBJdCBkb2VzIG5lZWQgdG8gYmUgcGFyc2FibGUvcmVzb2x2YWJsZSBpbiBhbGwgY2FzZXMsIHNvIGl0IHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBVUkwuXG5cdFx0Ly8gWE1MSHR0cFJlcXVlc3Qgd2l0aGluIGEgV29ya2VyIGNyZWF0ZWQgZnJvbSBhIEJsb2IgZG9lcyBub3Qgc3VwcG9ydCByZWxhdGl2ZSBVUkwgcGF0aHMuXG5cdFx0eC5vcGVuKCdHRVQnLCAnaHR0cHM6Ly9kb2pvdG9vbGtpdC5vcmcvJywgdHJ1ZSk7XG5cdFx0eC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cdFx0Ly8gd2lsbCBub3QgYmUgc2V0IGlmIHVuc3VwcG9ydGVkXG5cdFx0dmFyIHJlc3BvbnNlVHlwZSA9IHgucmVzcG9uc2VUeXBlO1xuXHRcdHguYWJvcnQoKTtcblx0XHRyZXR1cm4gcmVzcG9uc2VUeXBlID09PSAnYmxvYic7XG5cdH0pO1xuXG5cdC8vIEdvb2dsZSBDaHJvbWUgZG9lc24ndCBzdXBwb3J0IFwianNvblwiIHJlc3BvbnNlIHR5cGVcblx0Ly8gdXAgdG8gdmVyc2lvbiAzMCwgc28gaXQncyBpbnRlbnRpb25hbGx5IG5vdCBpbmNsdWRlZCBoZXJlXG5cdHZhciBuYXRpdmVSZXNwb25zZVR5cGVzID0ge1xuXHRcdCdibG9iJzogaGFzKCduYXRpdmUteGhyMi1ibG9iJykgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInLFxuXHRcdCdkb2N1bWVudCc6ICdkb2N1bWVudCcsXG5cdFx0J2FycmF5YnVmZmVyJzogJ2FycmF5YnVmZmVyJ1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBlcnJvcil7XG5cdFx0dmFyIF94aHIgPSByZXNwb25zZS54aHI7XG5cdFx0cmVzcG9uc2Uuc3RhdHVzID0gcmVzcG9uc2UueGhyLnN0YXR1cztcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBGaXJlZm94IHRocm93cyBhbiBlcnJvciB3aGVuIHRyeWluZyB0byBhY2Nlc3Ncblx0XHRcdC8vIHhoci5yZXNwb25zZVRleHQgaWYgcmVzcG9uc2UgaXNuJ3QgdGV4dFxuXHRcdFx0cmVzcG9uc2UudGV4dCA9IF94aHIucmVzcG9uc2VUZXh0O1xuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRpZihyZXNwb25zZS5vcHRpb25zLmhhbmRsZUFzID09PSAneG1sJyl7XG5cdFx0XHRyZXNwb25zZS5kYXRhID0gX3hoci5yZXNwb25zZVhNTDtcblx0XHR9XG5cblx0XHR2YXIgaGFuZGxlRXJyb3I7XG5cdFx0aWYoZXJyb3Ipe1xuXHRcdFx0dGhpcy5yZWplY3QoZXJyb3IpO1xuXHRcdH1lbHNle1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRoYW5kbGVycyhyZXNwb25zZSk7XG5cdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdGhhbmRsZUVycm9yID0gZTtcblx0XHRcdH1cblx0XHRcdGlmKHV0aWwuY2hlY2tTdGF0dXMoX3hoci5zdGF0dXMpKXtcblx0XHRcdFx0aWYoIWhhbmRsZUVycm9yKXtcblx0XHRcdFx0XHR0aGlzLnJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChoYW5kbGVFcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZighaGFuZGxlRXJyb3Ipe1xuXHRcdFx0XHRcdGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcignVW5hYmxlIHRvIGxvYWQgJyArIHJlc3BvbnNlLnVybCArICcgc3RhdHVzOiAnICsgX3hoci5zdGF0dXMsIHJlc3BvbnNlKTtcblx0XHRcdFx0XHR0aGlzLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcignVW5hYmxlIHRvIGxvYWQgJyArIHJlc3BvbnNlLnVybCArICcgc3RhdHVzOiAnICsgX3hoci5zdGF0dXMgK1xuXHRcdFx0XHRcdFx0JyBhbmQgYW4gZXJyb3IgaW4gaGFuZGxlQXM6IHRyYW5zZm9ybWF0aW9uIG9mIHJlc3BvbnNlJywgcmVzcG9uc2UpO1xuXHRcdFx0XHRcdHRoaXMucmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBpc1ZhbGlkLCBpc1JlYWR5LCBhZGRMaXN0ZW5lcnMsIGNhbmNlbDtcblx0aWYoaGFzKCduYXRpdmUteGhyMicpKXtcblx0XHQvLyBBbnkgcGxhdGZvcm0gd2l0aCBYSFIyIHdpbGwgb25seSB1c2UgdGhlIHdhdGNoIG1lY2hhbmlzbSBmb3IgdGltZW91dC5cblxuXHRcdGlzVmFsaWQgPSBmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0Q2hlY2sgdG8gc2VlIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSB0YWtlbiBvdXQgb2YgdGhlIHdhdGNoIHF1ZXVlXG5cdFx0XHRyZXR1cm4gIXRoaXMuaXNGdWxmaWxsZWQoKTtcblx0XHR9O1xuXHRcdGNhbmNlbCA9IGZ1bmN0aW9uKGRmZCwgcmVzcG9uc2Upe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdENhbmNlbGVyIGZvciBkZWZlcnJlZFxuXHRcdFx0cmVzcG9uc2UueGhyLmFib3J0KCk7XG5cdFx0fTtcblx0XHRhZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbihfeGhyLCBkZmQsIHJlc3BvbnNlLCB1cGxvYWRQcm9ncmVzcyl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0QWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuXHRcdFx0ZnVuY3Rpb24gb25Mb2FkKGV2dCl7XG5cdFx0XHRcdGRmZC5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBvbkVycm9yKGV2dCl7XG5cdFx0XHRcdHZhciBfeGhyID0gZXZ0LnRhcmdldDtcblx0XHRcdFx0dmFyIGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcignVW5hYmxlIHRvIGxvYWQgJyArIHJlc3BvbnNlLnVybCArICcgc3RhdHVzOiAnICsgX3hoci5zdGF0dXMsIHJlc3BvbnNlKTtcblx0XHRcdFx0ZGZkLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uUHJvZ3Jlc3ModHJhbnNmZXJUeXBlLCBldnQpe1xuXHRcdFx0XHRyZXNwb25zZS50cmFuc2ZlclR5cGUgPSB0cmFuc2ZlclR5cGU7XG5cdFx0XHRcdGlmKGV2dC5sZW5ndGhDb21wdXRhYmxlKXtcblx0XHRcdFx0XHRyZXNwb25zZS5sb2FkZWQgPSBldnQubG9hZGVkO1xuXHRcdFx0XHRcdHJlc3BvbnNlLnRvdGFsID0gZXZ0LnRvdGFsO1xuXHRcdFx0XHRcdGRmZC5wcm9ncmVzcyhyZXNwb25zZSk7XG5cdFx0XHRcdH0gZWxzZSBpZihyZXNwb25zZS54aHIucmVhZHlTdGF0ZSA9PT0gMyl7XG5cdFx0XHRcdFx0cmVzcG9uc2UubG9hZGVkID0gKCdsb2FkZWQnIGluIGV2dCkgPyBldnQubG9hZGVkIDogZXZ0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdGRmZC5wcm9ncmVzcyhyZXNwb25zZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Eb3dubG9hZFByb2dyZXNzKGV2dCkge1xuXHRcdFx0XHRyZXR1cm4gb25Qcm9ncmVzcygnZG93bmxvYWQnLCBldnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBvblVwbG9hZFByb2dyZXNzKGV2dCkge1xuXHRcdFx0XHRyZXR1cm4gb25Qcm9ncmVzcygndXBsb2FkJywgZXZ0KTtcblx0XHRcdH1cblxuXHRcdFx0X3hoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkLCBmYWxzZSk7XG5cdFx0XHRfeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvciwgZmFsc2UpO1xuXHRcdFx0X3hoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uRG93bmxvYWRQcm9ncmVzcywgZmFsc2UpO1xuXG5cdFx0XHRpZiAodXBsb2FkUHJvZ3Jlc3MgJiYgX3hoci51cGxvYWQpIHtcblx0XHRcdFx0X3hoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBvblVwbG9hZFByb2dyZXNzLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0XHRfeGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQsIGZhbHNlKTtcblx0XHRcdFx0X3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IsIGZhbHNlKTtcblx0XHRcdFx0X3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uRG93bmxvYWRQcm9ncmVzcywgZmFsc2UpO1xuXHRcdFx0XHRfeGhyLnVwbG9hZC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIG9uVXBsb2FkUHJvZ3Jlc3MsIGZhbHNlKTtcblx0XHRcdFx0X3hociA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdGlzVmFsaWQgPSBmdW5jdGlvbihyZXNwb25zZSl7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2UueGhyLnJlYWR5U3RhdGU7IC8vYm9vbGVhblxuXHRcdH07XG5cdFx0aXNSZWFkeSA9IGZ1bmN0aW9uKHJlc3BvbnNlKXtcblx0XHRcdHJldHVybiA0ID09PSByZXNwb25zZS54aHIucmVhZHlTdGF0ZTsgLy9ib29sZWFuXG5cdFx0fTtcblx0XHRjYW5jZWwgPSBmdW5jdGlvbihkZmQsIHJlc3BvbnNlKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRjYW5jZWxsZXIgZnVuY3Rpb24gZm9yIHV0aWwuZGVmZXJyZWQgY2FsbC5cblx0XHRcdHZhciB4aHIgPSByZXNwb25zZS54aHI7XG5cdFx0XHR2YXIgX2F0ID0gdHlwZW9mIHhoci5hYm9ydDtcblx0XHRcdGlmKF9hdCA9PT0gJ2Z1bmN0aW9uJyB8fCBfYXQgPT09ICdvYmplY3QnIHx8IF9hdCA9PT0gJ3Vua25vd24nKXtcblx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXJOYW1lKXtcblx0XHRyZXR1cm4gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyTmFtZSk7XG5cdH1cblxuXHR2YXIgdW5kZWZpbmVkLFxuXHRcdGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdHF1ZXJ5OiBudWxsLFxuXHRcdFx0c3luYzogZmFsc2UsXG5cdFx0XHRtZXRob2Q6ICdHRVQnXG5cdFx0fTtcblx0ZnVuY3Rpb24geGhyKHVybCwgb3B0aW9ucywgcmV0dXJuRGVmZXJyZWQpe1xuXHRcdHZhciBpc0Zvcm1EYXRhID0gaGFzKCduYXRpdmUtZm9ybWRhdGEnKSAmJiBvcHRpb25zICYmIG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YTtcblx0XHR2YXIgcmVzcG9uc2UgPSB1dGlsLnBhcnNlQXJncyhcblx0XHRcdHVybCxcblx0XHRcdHV0aWwuZGVlcENyZWF0ZShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyksXG5cdFx0XHRpc0Zvcm1EYXRhXG5cdFx0KTtcblx0XHR1cmwgPSByZXNwb25zZS51cmw7XG5cdFx0b3B0aW9ucyA9IHJlc3BvbnNlLm9wdGlvbnM7XG5cdFx0dmFyIGhhc05vRGF0YSA9ICFvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJyAmJiBvcHRpb25zLm1ldGhvZCAhPT0gJ1BVVCc7XG5cblx0XHRpZihoYXMoJ2llJykgPD0gMTApe1xuXHRcdFx0Ly8gb2xkZXIgSUUgYnJlYWtzIHBvaW50IDkgaW4gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1vcGVuKCktbWV0aG9kIGFuZCBzZW5kcyBmcmFnbWVudCwgc28gc3RyaXAgaXRcblx0XHRcdHVybCA9IHVybC5zcGxpdCgnIycpWzBdO1xuXHRcdH1cblxuXHRcdHZhciByZW1vdmVyLFxuXHRcdFx0bGFzdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlbW92ZXIgJiYgcmVtb3ZlcigpO1xuXHRcdFx0fTtcblxuXHRcdC8vTWFrZSB0aGUgRGVmZXJyZWQgb2JqZWN0IGZvciB0aGlzIHhociByZXF1ZXN0LlxuXHRcdHZhciBkZmQgPSB1dGlsLmRlZmVycmVkKFxuXHRcdFx0cmVzcG9uc2UsXG5cdFx0XHRjYW5jZWwsXG5cdFx0XHRpc1ZhbGlkLFxuXHRcdFx0aXNSZWFkeSxcblx0XHRcdGhhbmRsZVJlc3BvbnNlLFxuXHRcdFx0bGFzdFxuXHRcdCk7XG5cdFx0dmFyIF94aHIgPSByZXNwb25zZS54aHIgPSB4aHIuX2NyZWF0ZSgpO1xuXG5cdFx0aWYoIV94aHIpe1xuXHRcdFx0Ly8gSWYgWEhSIGZhY3Rvcnkgc29tZWhvdyByZXR1cm5zIG5vdGhpbmdzLFxuXHRcdFx0Ly8gY2FuY2VsIHRoZSBkZWZlcnJlZC5cblx0XHRcdGRmZC5jYW5jZWwobmV3IFJlcXVlc3RFcnJvcignWEhSIHdhcyBub3QgY3JlYXRlZCcpKTtcblx0XHRcdHJldHVybiByZXR1cm5EZWZlcnJlZCA/IGRmZCA6IGRmZC5wcm9taXNlO1xuXHRcdH1cblxuXHRcdHJlc3BvbnNlLmdldEhlYWRlciA9IGdldEhlYWRlcjtcblxuXHRcdGlmKGFkZExpc3RlbmVycyl7XG5cdFx0XHRyZW1vdmVyID0gYWRkTGlzdGVuZXJzKF94aHIsIGRmZCwgcmVzcG9uc2UsIG9wdGlvbnMudXBsb2FkUHJvZ3Jlc3MpO1xuXHRcdH1cblxuXHRcdC8vIElFMTEgdHJlYXRzIGRhdGE6IHVuZGVmaW5lZCBkaWZmZXJlbnQgdGhhbiBvdGhlciBicm93c2Vyc1xuXHRcdHZhciBkYXRhID0gdHlwZW9mKG9wdGlvbnMuZGF0YSkgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG9wdGlvbnMuZGF0YSxcblx0XHRcdGFzeW5jID0gIW9wdGlvbnMuc3luYyxcblx0XHRcdG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuXG5cdFx0dHJ5e1xuXHRcdFx0Ly8gSUU2IHdvbid0IGxldCB5b3UgY2FsbCBhcHBseSgpIG9uIHRoZSBuYXRpdmUgZnVuY3Rpb24uXG5cdFx0XHRfeGhyLm9wZW4obWV0aG9kLCB1cmwsIGFzeW5jLCBvcHRpb25zLnVzZXIgfHwgdW5kZWZpbmVkLCBvcHRpb25zLnBhc3N3b3JkIHx8IHVuZGVmaW5lZCk7XG5cblx0XHRcdGlmKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKXtcblx0XHRcdFx0X3hoci53aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLndpdGhDcmVkZW50aWFscztcblx0XHRcdH1cblxuXHRcdFx0aWYoaGFzKCduYXRpdmUtcmVzcG9uc2UtdHlwZScpICYmIG9wdGlvbnMuaGFuZGxlQXMgaW4gbmF0aXZlUmVzcG9uc2VUeXBlcykge1xuXHRcdFx0XHRfeGhyLnJlc3BvbnNlVHlwZSA9IG5hdGl2ZVJlc3BvbnNlVHlwZXNbb3B0aW9ucy5oYW5kbGVBc107XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzLFxuXHRcdFx0XHRjb250ZW50VHlwZSA9IChpc0Zvcm1EYXRhIHx8IGhhc05vRGF0YSkgPyBmYWxzZSA6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXHRcdFx0aWYoaGVhZGVycyl7XG5cdFx0XHRcdGZvcih2YXIgaGRyIGluIGhlYWRlcnMpe1xuXHRcdFx0XHRcdGlmKGhkci50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJyl7XG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlcnNbaGRyXTtcblx0XHRcdFx0XHR9ZWxzZSBpZihoZWFkZXJzW2hkcl0pe1xuXHRcdFx0XHRcdFx0Ly9Pbmx5IGFkZCBoZWFkZXIgaWYgaXQgaGFzIGEgdmFsdWUuIFRoaXMgYWxsb3dzIGZvciBpbnN0YW5jZSwgc2tpcHBpbmdcblx0XHRcdFx0XHRcdC8vaW5zZXJ0aW9uIG9mIFgtUmVxdWVzdGVkLVdpdGggYnkgc3BlY2lmeWluZyBlbXB0eSB2YWx1ZS5cblx0XHRcdFx0XHRcdF94aHIuc2V0UmVxdWVzdEhlYWRlcihoZHIsIGhlYWRlcnNbaGRyXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlICE9PSBmYWxzZSl7XG5cdFx0XHRcdF94aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWhlYWRlcnMgfHwgISgnWC1SZXF1ZXN0ZWQtV2l0aCcgaW4gaGVhZGVycykpe1xuXHRcdFx0XHRfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYodXRpbC5ub3RpZnkpe1xuXHRcdFx0XHR1dGlsLm5vdGlmeS5lbWl0KCdzZW5kJywgcmVzcG9uc2UsIGRmZC5wcm9taXNlLmNhbmNlbCk7XG5cdFx0XHR9XG5cdFx0XHRfeGhyLnNlbmQoZGF0YSk7XG5cdFx0fWNhdGNoKGUpe1xuXHRcdFx0ZGZkLnJlamVjdChlKTtcblx0XHR9XG5cblx0XHR3YXRjaChkZmQpO1xuXHRcdF94aHIgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHJldHVybkRlZmVycmVkID8gZGZkIDogZGZkLnByb21pc2U7XG5cdH1cblxuXHQvKj09PT09XG5cdHhociA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucyl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZW5kcyBhIHJlcXVlc3QgdXNpbmcgWE1MSHR0cFJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gVVJMIGFuZCBvcHRpb25zLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QveGhyLl9fT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHhoci5fX0Jhc2VPcHRpb25zID0gZGVjbGFyZShyZXF1ZXN0Ll9fQmFzZU9wdGlvbnMsIHtcblx0XHQvLyBzeW5jOiBCb29sZWFuP1xuXHRcdC8vXHRcdFdoZXRoZXIgdG8gbWFrZSBhIHN5bmNocm9ub3VzIHJlcXVlc3Qgb3Igbm90LiBEZWZhdWx0XG5cdFx0Ly9cdFx0aXMgYGZhbHNlYCAoYXN5bmNocm9ub3VzKS5cblx0XHQvLyBkYXRhOiBTdHJpbmd8T2JqZWN0fEZvcm1EYXRhP1xuXHRcdC8vXHRcdERhdGEgdG8gdHJhbnNmZXIuIFRoaXMgaXMgaWdub3JlZCBmb3IgR0VUIGFuZCBERUxFVEVcblx0XHQvL1x0XHRyZXF1ZXN0cy5cblx0XHQvLyBoZWFkZXJzOiBPYmplY3Q/XG5cdFx0Ly9cdFx0SGVhZGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxuXHRcdC8vIHVzZXI6IFN0cmluZz9cblx0XHQvL1x0XHRVc2VybmFtZSB0byB1c2UgZHVyaW5nIHRoZSByZXF1ZXN0LlxuXHRcdC8vIHBhc3N3b3JkOiBTdHJpbmc/XG5cdFx0Ly9cdFx0UGFzc3dvcmQgdG8gdXNlIGR1cmluZyB0aGUgcmVxdWVzdC5cblx0XHQvLyB3aXRoQ3JlZGVudGlhbHM6IEJvb2xlYW4/XG5cdFx0Ly9cdFx0Rm9yIGNyb3NzLXNpdGUgcmVxdWVzdHMsIHdoZXRoZXIgdG8gc2VuZCBjcmVkZW50aWFsc1xuXHRcdC8vXHRcdG9yIG5vdC5cblx0XHQvLyB1cGxvYWRQcm9ncmVzczogQm9vbGVhbj9cblx0XHQvL1x0XHRVcGxvYWQgcHJvZ3Jlc3MgZXZlbnRzIGNhdXNlIHByZWZsaWdodGVkIHJlcXVlc3RzLiBUaGlzXG5cdFx0Ly9cdFx0b3B0aW9uIGVuYWJsZXMgdXBsb2FkIHByb2dyZXNzIGV2ZW50IHN1cHBvcnQgYnV0IGFsc29cblx0XHQvL1x0XHRjYXVzZXMgYWxsIHJlcXVlc3RzIHRvIGJlIHByZWZsaWdodGVkLlxuXHR9KTtcblx0eGhyLl9fTWV0aG9kT3B0aW9ucyA9IGRlY2xhcmUobnVsbCwge1xuXHRcdC8vIG1ldGhvZDogU3RyaW5nP1xuXHRcdC8vXHRcdFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgdG8gbWFrZSB0aGUgcmVxdWVzdC4gTXVzdCBiZVxuXHRcdC8vXHRcdHVwcGVyY2FzZS4gRGVmYXVsdCBpcyBgXCJHRVRcImAuXG5cdH0pO1xuXHR4aHIuX19PcHRpb25zID0gZGVjbGFyZShbeGhyLl9fQmFzZU9wdGlvbnMsIHhoci5fX01ldGhvZE9wdGlvbnNdKTtcblxuXHR4aHIuZ2V0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBHRVQgcmVxdWVzdCB1c2luZyBYTUxIdHRwUmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBVUkwgYW5kIG9wdGlvbnMuXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRVUkwgdG8gcmVxdWVzdFxuXHRcdC8vIG9wdGlvbnM6IGRvam8vcmVxdWVzdC94aHIuX19CYXNlT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHhoci5wb3N0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBQT1NUIHJlcXVlc3QgdXNpbmcgWE1MSHR0cFJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gVVJMIGFuZCBvcHRpb25zLlxuXHRcdC8vIHVybDogU3RyaW5nXG5cdFx0Ly9cdFx0VVJMIHRvIHJlcXVlc3Rcblx0XHQvLyBvcHRpb25zOiBkb2pvL3JlcXVlc3QveGhyLl9fQmFzZU9wdGlvbnM/XG5cdFx0Ly9cdFx0T3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXG5cdFx0Ly8gcmV0dXJuczogZG9qby9yZXF1ZXN0Ll9fUHJvbWlzZVxuXHR9O1xuXHR4aHIucHV0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFNlbmQgYW4gSFRUUCBQVVQgcmVxdWVzdCB1c2luZyBYTUxIdHRwUmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBVUkwgYW5kIG9wdGlvbnMuXG5cdFx0Ly8gdXJsOiBTdHJpbmdcblx0XHQvL1x0XHRVUkwgdG8gcmVxdWVzdFxuXHRcdC8vIG9wdGlvbnM6IGRvam8vcmVxdWVzdC94aHIuX19CYXNlT3B0aW9ucz9cblx0XHQvL1x0XHRPcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cblx0XHQvLyByZXR1cm5zOiBkb2pvL3JlcXVlc3QuX19Qcm9taXNlXG5cdH07XG5cdHhoci5kZWwgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0U2VuZCBhbiBIVFRQIERFTEVURSByZXF1ZXN0IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHdpdGggdGhlIGdpdmVuIFVSTCBhbmQgb3B0aW9ucy5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFVSTCB0byByZXF1ZXN0XG5cdFx0Ly8gb3B0aW9uczogZG9qby9yZXF1ZXN0L3hoci5fX0Jhc2VPcHRpb25zP1xuXHRcdC8vXHRcdE9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LlxuXHRcdC8vIHJldHVybnM6IGRvam8vcmVxdWVzdC5fX1Byb21pc2Vcblx0fTtcblx0PT09PT0qL1xuXHR4aHIuX2NyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRkb2VzIHRoZSB3b3JrIG9mIHBvcnRhYmx5IGdlbmVyYXRpbmcgYSBuZXcgWE1MSFRUUFJlcXVlc3Qgb2JqZWN0LlxuXHRcdHRocm93IG5ldyBFcnJvcignWE1MSFRUUCBub3QgYXZhaWxhYmxlJyk7XG5cdH07XG5cdGlmKGhhcygnbmF0aXZlLXhocicpICYmICFoYXMoJ2Rvam8tZm9yY2UtYWN0aXZleC14aHInKSl7XG5cdFx0eGhyLl9jcmVhdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdH07XG5cdH1lbHNlIGlmKGhhcygnYWN0aXZleCcpKXtcblx0XHR0cnl7XG5cdFx0XHRuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcblx0XHRcdHhoci5fY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpO1xuXHRcdFx0fTtcblx0XHR9Y2F0Y2goZSl7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdFx0XHR4aHIuX2NyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fWNhdGNoKGUpe31cblx0XHR9XG5cdH1cblxuXHR1dGlsLmFkZENvbW1vbk1ldGhvZHMoeGhyKTtcblxuXHRyZXR1cm4geGhyO1xufSk7XG4iLCJkZWZpbmUoW1wiLi4vaGFzXCIsIFwicmVxdWlyZVwiXSxcblx0XHRmdW5jdGlvbihoYXMsIHJlcXVpcmUpe1xuXG5cInVzZSBzdHJpY3RcIjtcbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0dmFyIHRlc3REaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRoYXMuYWRkKFwiZG9tLXFzYTIuMVwiLCAhIXRlc3REaXYucXVlcnlTZWxlY3RvckFsbCk7XG5cdGhhcy5hZGQoXCJkb20tcXNhM1wiLCBmdW5jdGlvbigpe1xuXHRcdC8vIHRlc3QgdG8gc2VlIGlmIHdlIGhhdmUgYSByZWFzb25hYmxlIG5hdGl2ZSBzZWxlY3RvciBlbmdpbmUgYXZhaWxhYmxlXG5cdFx0dHJ5e1xuXHRcdFx0dGVzdERpdi5pbm5lckhUTUwgPSBcIjxwIGNsYXNzPSdURVNUJz48L3A+XCI7IC8vIHRlc3Qga2luZCBvZiBmcm9tIHNpenpsZVxuXHRcdFx0Ly8gU2FmYXJpIGNhbid0IGhhbmRsZSB1cHBlcmNhc2Ugb3IgdW5pY29kZSBjaGFyYWN0ZXJzIHdoZW5cblx0XHRcdC8vIGluIHF1aXJrcyBtb2RlLCBJRTggY2FuJ3QgaGFuZGxlIHBzZXVkb3MgbGlrZSA6ZW1wdHlcblx0XHRcdHJldHVybiB0ZXN0RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuVEVTVDplbXB0eVwiKS5sZW5ndGggPT0gMTtcblx0XHR9Y2F0Y2goZSl7fVxuXHR9KTtcbn1cblxudmFyIGZ1bGxFbmdpbmU7XG52YXIgYWNtZSA9IFwiLi9hY21lXCIsIGxpdGUgPSBcIi4vbGl0ZVwiO1xucmV0dXJuIHtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBtb2R1bGUgaGFuZGxlcyBsb2FkaW5nIHRoZSBhcHByb3ByaWF0ZSBzZWxlY3RvciBlbmdpbmUgZm9yIHRoZSBnaXZlbiBicm93c2VyXG5cblx0bG9hZDogZnVuY3Rpb24oaWQsIHBhcmVudFJlcXVpcmUsIGxvYWRlZCwgY29uZmlnKXtcblx0XHRpZiAoY29uZmlnICYmIGNvbmZpZy5pc0J1aWxkKSB7XG5cdFx0XHQvL0luZGljYXRlIHRoYXQgdGhlIG9wdGltaXplciBzaG91bGQgbm90IHdhaXRcblx0XHRcdC8vZm9yIHRoaXMgcmVzb3VyY2UgYW55IG1vcmUgYW5kIGNvbXBsZXRlIG9wdGltaXphdGlvbi5cblx0XHRcdC8vVGhpcyByZXNvdXJjZSB3aWxsIGJlIHJlc29sdmVkIGR5bmFtaWNhbGx5IGR1cmluZ1xuXHRcdFx0Ly9ydW4gdGltZSBpbiB0aGUgd2ViIGJyb3dzZXIuXG5cdFx0XHRsb2FkZWQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcmVxID0gcmVxdWlyZTtcblx0XHQvLyBoZXJlIHdlIGltcGxlbWVudCB0aGUgZGVmYXVsdCBsb2dpYyBmb3IgY2hvb3NpbmcgYSBzZWxlY3RvciBlbmdpbmVcblx0XHRpZCA9IGlkID09IFwiZGVmYXVsdFwiID8gaGFzKFwiY29uZmlnLXNlbGVjdG9yRW5naW5lXCIpIHx8IFwiY3NzM1wiIDogaWQ7XG5cdFx0aWQgPSBpZCA9PSBcImNzczJcIiB8fCBpZCA9PSBcImxpdGVcIiA/IGxpdGUgOlxuXHRcdFx0XHRpZCA9PSBcImNzczIuMVwiID8gaGFzKFwiZG9tLXFzYTIuMVwiKSA/IGxpdGUgOiBhY21lIDpcblx0XHRcdFx0aWQgPT0gXCJjc3MzXCIgPyBoYXMoXCJkb20tcXNhM1wiKSA/IGxpdGUgOiBhY21lIDpcblx0XHRcdFx0aWQgPT0gXCJhY21lXCIgPyBhY21lIDogKHJlcSA9IHBhcmVudFJlcXVpcmUpICYmIGlkO1xuXHRcdGlmKGlkLmNoYXJBdChpZC5sZW5ndGgtMSkgPT0gJz8nKXtcblx0XHRcdGlkID0gaWQuc3Vic3RyaW5nKDAsaWQubGVuZ3RoIC0gMSk7XG5cdFx0XHR2YXIgb3B0aW9uYWxMb2FkID0gdHJ1ZTtcblx0XHR9XG5cdFx0Ly8gdGhlIHF1ZXJ5IGVuZ2luZSBpcyBvcHRpb25hbCwgb25seSBsb2FkIGl0IGlmIGEgbmF0aXZlIG9uZSBpcyBub3QgYXZhaWxhYmxlIG9yIGV4aXN0aW5nIG9uZSBoYXMgbm90IGJlZW4gbG9hZGVkXG5cdFx0aWYob3B0aW9uYWxMb2FkICYmIChoYXMoXCJkb20tY29tcGxpYW50LXFzYVwiKSB8fCBmdWxsRW5naW5lKSl7XG5cdFx0XHRyZXR1cm4gbG9hZGVkKGZ1bGxFbmdpbmUpO1xuXHRcdH1cblx0XHQvLyBsb2FkIHRoZSByZWZlcmVuY2VkIHNlbGVjdG9yIGVuZ2luZVxuXHRcdHJlcShbaWRdLCBmdW5jdGlvbihlbmdpbmUpe1xuXHRcdFx0aWYoaWQgIT0gXCIuL2xpdGVcIil7XG5cdFx0XHRcdGZ1bGxFbmdpbmUgPSBlbmdpbmU7XG5cdFx0XHR9XG5cdFx0XHRsb2FkZWQoZW5naW5lKTtcblx0XHR9KTtcblx0fVxufTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4uL2hhc1wiLCBcIi4uL19iYXNlL2tlcm5lbFwiXSwgZnVuY3Rpb24oaGFzLCBkb2pvKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgdGVzdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG52YXIgbWF0Y2hlc1NlbGVjdG9yID0gdGVzdERpdi5tYXRjaGVzIHx8IHRlc3REaXYud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHRlc3REaXYubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHRlc3REaXYubXNNYXRjaGVzU2VsZWN0b3IgfHwgdGVzdERpdi5vTWF0Y2hlc1NlbGVjdG9yO1xudmFyIHF1ZXJ5U2VsZWN0b3JBbGwgPSB0ZXN0RGl2LnF1ZXJ5U2VsZWN0b3JBbGw7XG52YXIgdW5pb25TcGxpdCA9IC8oW15cXHMsXSg/OlwiKD86XFxcXC58W15cIl0pK1wifCcoPzpcXFxcLnxbXiddKSsnfFteLF0pKikvZztcbmhhcy5hZGQoXCJkb20tbWF0Y2hlcy1zZWxlY3RvclwiLCAhIW1hdGNoZXNTZWxlY3Rvcik7XG5oYXMuYWRkKFwiZG9tLXFzYVwiLCAhIXF1ZXJ5U2VsZWN0b3JBbGwpOyBcblxuLy8gdGhpcyBpcyBhIHNpbXBsZSBxdWVyeSBlbmdpbmUuIEl0IGhhcyBoYW5kbGVzIGJhc2ljIHNlbGVjdG9ycywgYW5kIGZvciBzaW1wbGVcbi8vIGNvbW1vbiBzZWxlY3RvcnMgaXMgZXh0cmVtZWx5IGZhc3RcbnZhciBsaXRlRW5naW5lID0gZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3Qpe1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRBIHNtYWxsIGxpZ2h0d2VpZ2h0IHF1ZXJ5IHNlbGVjdG9yIGVuZ2luZSB0aGF0IGltcGxlbWVudHMgQ1NTMi4xIHNlbGVjdG9yc1xuXHQvL1x0XHRtaW51cyBwc2V1ZG8tY2xhc3NlcyBhbmQgdGhlIHNpYmxpbmcgY29tYmluYXRvciwgcGx1cyBDU1MzIGF0dHJpYnV0ZSBzZWxlY3RvcnNcblxuXHRpZihjb21iaW5lICYmIHNlbGVjdG9yLmluZGV4T2YoJywnKSA+IC0xKXtcblx0XHRyZXR1cm4gY29tYmluZShzZWxlY3Rvciwgcm9vdCk7XG5cdH1cblx0Ly8gdXNlIHRoZSByb290J3Mgb3duZXJEb2N1bWVudCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRyeSB0byB1c2UgZG9qby5kb2MuIE5vdGUgXG5cdC8vIHRoYXQgd2UgZG9uJ3QgdXNlIGRvam8vX2Jhc2Uvd2luZG93J3MgZG9jIHRvIHJlZHVjZSBkZXBlbmRlbmNpZXMsIGFuZCBcblx0Ly8gZmFsbGJhY2sgdG8gcGxhaW4gZG9jdW1lbnQgaWYgZG9qby5kb2MgaGFzbid0IGJlZW4gZGVmaW5lZCAoYnkgZG9qby9fYmFzZS93aW5kb3cpLlxuXHQvLyBwcmVzdW1hYmx5IHdlIHdpbGwgaGF2ZSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcyBpbiAyLjAgXG5cdHZhciBkb2MgPSByb290ID8gcm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QgOiBkb2pvLmRvYyB8fCBkb2N1bWVudCwgXG5cdFx0bWF0Y2ggPSAocXVlcnlTZWxlY3RvckFsbCA/IFxuXHRcdFx0L14oW1xcd10qKSMoW1xcd1xcLV0rJCl8XihcXC4pKFtcXHdcXC1cXCpdKyQpfF4oXFx3KyQpLyA6IC8vIHRoaXMgb25lIG9ubHkgbWF0Y2hlcyBvbiBzaW1wbGUgcXVlcmllcyB3aGVyZSB3ZSBjYW4gYmVhdCBxU0Egd2l0aCBzcGVjaWZpYyBtZXRob2RzXG5cdFx0XHQvXihbXFx3XSopIyhbXFx3XFwtXSspKD86XFxzKyguKikpPyR8KD86XnwoPnwuK1xccyspKShbXFx3XFwtXFwqXSspKFxcUyokKS8pIC8vIHRoaXMgb25lIG1hdGNoZXMgcGFydHMgb2YgdGhlIHF1ZXJ5IHRoYXQgd2UgY2FuIHVzZSB0byBzcGVlZCB1cCBtYW51YWwgZmlsdGVyaW5nXG5cdFx0XHQuZXhlYyhzZWxlY3Rvcik7XG5cdHJvb3QgPSByb290IHx8IGRvYztcblx0aWYobWF0Y2gpe1xuXHRcdHZhciBpc0luc2lkZURvbVRyZWUgPSBoYXMoJ2llJykgPT09IDggJiYgaGFzKCdxdWlya3MnKT9cblx0XHRcdHJvb3Qubm9kZVR5cGUgPT09IGRvYy5ub2RlVHlwZTpcblx0XHRcdHJvb3QucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiByb290Lm5vZGVUeXBlICE9PSA5ICYmIHJvb3QucGFyZW50Tm9kZSA9PT0gZG9jO1xuXG5cdFx0Ly8gZmFzdCBwYXRoIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgcXVlcnlTZWxlY3RvckFsbCBleGlzdHNcblx0XHRpZihtYXRjaFsyXSAmJiBpc0luc2lkZURvbVRyZWUpe1xuXHRcdFx0Ly8gYW4gI2lkXG5cdFx0XHQvLyB1c2UgZG9qby5ieUlkIGlmIGF2YWlsYWJsZSBhcyBpdCBmaXhlcyB0aGUgaWQgcmV0cmlldmFsIGluIElFLCBub3RlIHRoYXQgd2UgY2FuJ3QgdXNlIHRoZSBkb2pvIG5hbWVzcGFjZSBpbiAyLjAsIGJ1dCBpZiB0aGVyZSBpcyBhIGNvbmRpdGlvbmFsIG1vZHVsZSB1c2UsIHdlIHdpbGwgdXNlIHRoYXRcblx0XHRcdHZhciBmb3VuZCA9IGRvam8uYnlJZCA/IGRvam8uYnlJZChtYXRjaFsyXSwgZG9jKSA6IGRvYy5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XG5cdFx0XHRpZighZm91bmQgfHwgKG1hdGNoWzFdICYmIG1hdGNoWzFdICE9IGZvdW5kLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpe1xuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhIHRhZyBxdWFsaWZlciBhbmQgaXQgZG9lc24ndCBtYXRjaCwgbm8gbWF0Y2hlc1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRpZihyb290ICE9IGRvYyl7XG5cdFx0XHRcdC8vIHRoZXJlIGlzIGEgcm9vdCBlbGVtZW50LCBtYWtlIHN1cmUgd2UgYXJlIGEgY2hpbGQgb2YgaXRcblx0XHRcdFx0dmFyIHBhcmVudCA9IGZvdW5kO1xuXHRcdFx0XHR3aGlsZShwYXJlbnQgIT0gcm9vdCl7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYoIXBhcmVudCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hbM10gP1xuXHRcdFx0XHRcdGxpdGVFbmdpbmUobWF0Y2hbM10sIGZvdW5kKSBcblx0XHRcdFx0XHQ6IFtmb3VuZF07XG5cdFx0fVxuXHRcdGlmKG1hdGNoWzNdICYmIHJvb3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSl7XG5cdFx0XHQvLyBhIC5jbGFzc1xuXHRcdFx0cmV0dXJuIHJvb3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtYXRjaFs0XSk7XG5cdFx0fVxuXHRcdHZhciBmb3VuZDtcblx0XHRpZihtYXRjaFs1XSl7XG5cdFx0XHQvLyBhIHRhZ1xuXHRcdFx0Zm91bmQgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKG1hdGNoWzVdKTtcblx0XHRcdGlmKG1hdGNoWzRdIHx8IG1hdGNoWzZdKXtcblx0XHRcdFx0c2VsZWN0b3IgPSAobWF0Y2hbNF0gfHwgXCJcIikgKyBtYXRjaFs2XTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyB0aGF0IHdhcyB0aGUgZW50aXJldHkgb2YgdGhlIHF1ZXJ5LCByZXR1cm4gcmVzdWx0c1xuXHRcdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmKHF1ZXJ5U2VsZWN0b3JBbGwpe1xuXHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3Rcblx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRpZiAocm9vdC5ub2RlVHlwZSA9PT0gMSAmJiByb290Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIpe1x0XHRcdFx0XG5cdFx0XHRyZXR1cm4gdXNlUm9vdChyb290LCBzZWxlY3Rvciwgcm9vdC5xdWVyeVNlbGVjdG9yQWxsKTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIHdlIGNhbiB1c2UgdGhlIG5hdGl2ZSBxU0Fcblx0XHRcdHJldHVybiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdH1cblx0fWVsc2UgaWYoIWZvdW5kKXtcblx0XHQvLyBzZWFyY2ggYWxsIGNoaWxkcmVuIGFuZCB0aGVuIGZpbHRlclxuXHRcdGZvdW5kID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG5cdH1cblx0Ly8gbm93IHdlIGZpbHRlciB0aGUgbm9kZXMgdGhhdCB3ZXJlIGZvdW5kIHVzaW5nIHRoZSBtYXRjaGVzU2VsZWN0b3Jcblx0dmFyIHJlc3VsdHMgPSBbXTtcblx0Zm9yKHZhciBpID0gMCwgbCA9IGZvdW5kLmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0dmFyIG5vZGUgPSBmb3VuZFtpXTtcblx0XHRpZihub2RlLm5vZGVUeXBlID09IDEgJiYganNNYXRjaGVzU2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IsIHJvb3QpKXtcblx0XHRcdC8vIGtlZXAgdGhlIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yXG5cdFx0XHRyZXN1bHRzLnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufTtcbnZhciB1c2VSb290ID0gZnVuY3Rpb24oY29udGV4dCwgcXVlcnksIG1ldGhvZCl7XG5cdC8vIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIHRlbXBvcmFyeSBpZCBzbyB3ZSBjYW4gZG8gcm9vdGVkIHFTQSBxdWVyaWVzLCB0aGlzIGlzIHRha2VuIGZyb20gc2l6emxlXG5cdHZhciBvbGRDb250ZXh0ID0gY29udGV4dCxcblx0XHRvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpLFxuXHRcdG5pZCA9IG9sZCB8fCBcIl9fZG9qb19fXCIsXG5cdFx0aGFzUGFyZW50ID0gY29udGV4dC5wYXJlbnROb2RlLFxuXHRcdHJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgPSAvXlxccypbK35dLy50ZXN0KHF1ZXJ5KTtcblxuXHRpZihyZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yICYmICFoYXNQYXJlbnQpe1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZighb2xkKXtcblx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIG5pZCk7XG5cdH1lbHNle1xuXHRcdG5pZCA9IG5pZC5yZXBsYWNlKC8nL2csIFwiXFxcXCQmXCIpO1xuXHR9XG5cdGlmKHJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgJiYgaGFzUGFyZW50KXtcblx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHR9XG5cdHZhciBzZWxlY3RvcnMgPSBxdWVyeS5tYXRjaCh1bmlvblNwbGl0KTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKyl7XG5cdFx0c2VsZWN0b3JzW2ldID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIiArIHNlbGVjdG9yc1tpXTtcblx0fVxuXHRxdWVyeSA9IHNlbGVjdG9ycy5qb2luKFwiLFwiKTtcblxuXHR0cnl7XG5cdFx0cmV0dXJuIG1ldGhvZC5jYWxsKGNvbnRleHQsIHF1ZXJ5KTtcblx0fWZpbmFsbHl7XG5cdFx0aWYoIW9sZCl7XG5cdFx0XHRvbGRDb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdH1cblx0fVxufTtcblxuaWYoIWhhcyhcImRvbS1tYXRjaGVzLXNlbGVjdG9yXCIpKXtcblx0dmFyIGpzTWF0Y2hlc1NlbGVjdG9yID0gKGZ1bmN0aW9uKCl7XG5cdFx0Ly8gYSBKUyBpbXBsZW1lbnRhdGlvbiBvZiBDU1Mgc2VsZWN0b3IgbWF0Y2hpbmcsIGZpcnN0IHdlIHN0YXJ0IHdpdGggdGhlIHZhcmlvdXMgaGFuZGxlcnNcblx0XHR2YXIgY2FzZUZpeCA9IHRlc3REaXYudGFnTmFtZSA9PSBcImRpdlwiID8gXCJ0b0xvd2VyQ2FzZVwiIDogXCJ0b1VwcGVyQ2FzZVwiO1xuXHRcdHZhciBzZWxlY3RvclR5cGVzID0ge1xuXHRcdFx0XCJcIjogZnVuY3Rpb24odGFnTmFtZSl7XG5cdFx0XHRcdHRhZ05hbWUgPSB0YWdOYW1lW2Nhc2VGaXhdKCk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS50YWdOYW1lID09IHRhZ05hbWU7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0XCIuXCI6IGZ1bmN0aW9uKGNsYXNzTmFtZSl7XG5cdFx0XHRcdHZhciBjbGFzc05hbWVTcGFjZWQgPSAnICcgKyBjbGFzc05hbWUgKyAnICc7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihub2RlKXtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpID4gLTEgJiYgKCcgJyArIG5vZGUuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKGNsYXNzTmFtZVNwYWNlZCkgPiAtMTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRcIiNcIjogZnVuY3Rpb24oaWQpe1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuaWQgPT0gaWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR2YXIgYXR0ckNvbXBhcmF0b3JzID0ge1xuXHRcdFx0XCJePVwiOiBmdW5jdGlvbihhdHRyVmFsdWUsIHZhbHVlKXtcblx0XHRcdFx0cmV0dXJuIGF0dHJWYWx1ZS5pbmRleE9mKHZhbHVlKSA9PSAwO1xuXHRcdFx0fSxcblx0XHRcdFwiKj1cIjogZnVuY3Rpb24oYXR0clZhbHVlLCB2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiBhdHRyVmFsdWUuaW5kZXhPZih2YWx1ZSkgPiAtMTtcblx0XHRcdH0sXG5cdFx0XHRcIiQ9XCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gYXR0clZhbHVlLnN1YnN0cmluZyhhdHRyVmFsdWUubGVuZ3RoIC0gdmFsdWUubGVuZ3RoLCBhdHRyVmFsdWUubGVuZ3RoKSA9PSB2YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRcIn49XCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gKCcgJyArIGF0dHJWYWx1ZSArICcgJykuaW5kZXhPZignICcgKyB2YWx1ZSArICcgJykgPiAtMTtcblx0XHRcdH0sXG5cdFx0XHRcInw9XCI6IGZ1bmN0aW9uKGF0dHJWYWx1ZSwgdmFsdWUpe1xuXHRcdFx0XHRyZXR1cm4gKGF0dHJWYWx1ZSArICctJykuaW5kZXhPZih2YWx1ZSArICctJykgPT0gMDtcblx0XHRcdH0sXG5cdFx0XHRcIj1cIjogZnVuY3Rpb24oYXR0clZhbHVlLCB2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiBhdHRyVmFsdWUgPT0gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0XCJcIjogZnVuY3Rpb24oYXR0clZhbHVlLCB2YWx1ZSl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSwgdHlwZSl7XG5cdFx0XHR2YXIgZmlyc3RDaGFyID0gdmFsdWUuY2hhckF0KDApO1xuXHRcdFx0aWYoZmlyc3RDaGFyID09ICdcIicgfHwgZmlyc3RDaGFyID09IFwiJ1wiKXtcblx0XHRcdFx0Ly8gaXQgaXMgcXVvdGVkLCByZW1vdmUgdGhlIHF1b3Rlc1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCcnKTtcblx0XHRcdHZhciBjb21wYXJhdG9yID0gYXR0ckNvbXBhcmF0b3JzW3R5cGUgfHwgXCJcIl07XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdHZhciBhdHRyVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHRcdFx0cmV0dXJuIGF0dHJWYWx1ZSAmJiBjb21wYXJhdG9yKGF0dHJWYWx1ZSwgdmFsdWUpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gYW5jZXN0b3IobWF0Y2hlcil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSwgcm9vdCl7XG5cdFx0XHRcdHdoaWxlKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAhPSByb290KXtcblx0XHRcdFx0XHRpZihtYXRjaGVyKG5vZGUsIHJvb3QpKXtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gcGFyZW50KG1hdGNoZXIpe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHJvb3Qpe1xuXHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlciA/IFxuXHRcdFx0XHRcdG5vZGUgIT0gcm9vdCAmJiBtYXRjaGVyKG5vZGUsIHJvb3QpXG5cdFx0XHRcdFx0OiBub2RlID09IHJvb3Q7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHR2YXIgY2FjaGUgPSB7fTtcblx0XHRmdW5jdGlvbiBhbmQobWF0Y2hlciwgbmV4dCl7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlciA/XG5cdFx0XHRcdGZ1bmN0aW9uKG5vZGUsIHJvb3Qpe1xuXHRcdFx0XHRcdHJldHVybiBuZXh0KG5vZGUpICYmIG1hdGNoZXIobm9kZSwgcm9vdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0OiBuZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IsIHJvb3Qpe1xuXHRcdFx0Ly8gdGhpcyByZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gaWYgdGhlIG5vZGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgKG9wdGlvbmFsbHkgd2l0aGluIHRoZSBnaXZlbiByb290KVxuXHRcdFx0dmFyIG1hdGNoZXIgPSBjYWNoZVtzZWxlY3Rvcl07IC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGNyZWF0ZWQgYSBtYXRjaGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3Jcblx0XHRcdGlmKCFtYXRjaGVyKXtcblx0XHRcdFx0Ly8gY3JlYXRlIGEgbWF0Y2hlciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yXG5cdFx0XHRcdC8vIHBhcnNlIHRoZSBzZWxlY3RvcnNcblx0XHRcdFx0aWYoc2VsZWN0b3IucmVwbGFjZSgvKD86XFxzKihbPiBdKVxccyopfCgjfFxcLik/KCg/OlxcXFwufFtcXHctXSkrKXxcXFtcXHMqKFtcXHctXSspXFxzKiguPz0pP1xccyooXCIoPzpcXFxcLnxbXlwiXSkrXCJ8Jyg/OlxcXFwufFteJ10pKyd8KD86XFxcXC58W15cXF1dKSopXFxzKlxcXS9nLCBmdW5jdGlvbih0LCBjb21iaW5hdG9yLCB0eXBlLCB2YWx1ZSwgYXR0ck5hbWUsIGF0dHJUeXBlLCBhdHRyVmFsdWUpe1xuXHRcdFx0XHRcdGlmKHZhbHVlKXtcblx0XHRcdFx0XHRcdG1hdGNoZXIgPSBhbmQobWF0Y2hlciwgc2VsZWN0b3JUeXBlc1t0eXBlIHx8IFwiXCJdKHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYoY29tYmluYXRvcil7XG5cdFx0XHRcdFx0XHRtYXRjaGVyID0gKGNvbWJpbmF0b3IgPT0gXCIgXCIgPyBhbmNlc3RvciA6IHBhcmVudCkobWF0Y2hlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYoYXR0ck5hbWUpe1xuXHRcdFx0XHRcdFx0bWF0Y2hlciA9IGFuZChtYXRjaGVyLCBhdHRyKGF0dHJOYW1lLCBhdHRyVmFsdWUsIGF0dHJUeXBlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHR9KSl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yIGluIHF1ZXJ5XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFtYXRjaGVyKXtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWNoZVtzZWxlY3Rvcl0gPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHJ1biB0aGUgbWF0Y2hlciBmdW5jdGlvbiBvbiB0aGUgbm9kZVxuXHRcdFx0cmV0dXJuIG1hdGNoZXIobm9kZSwgcm9vdCk7XG5cdFx0fTtcblx0fSkoKTtcbn1cbmlmKCFoYXMoXCJkb20tcXNhXCIpKXtcblx0dmFyIGNvbWJpbmUgPSBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCl7XG5cdFx0Ly8gY29tYmluZWQgcXVlcmllc1xuXHRcdHZhciBzZWxlY3RvcnMgPSBzZWxlY3Rvci5tYXRjaCh1bmlvblNwbGl0KTtcblx0XHR2YXIgaW5kZXhlZCA9IFtdO1xuXHRcdC8vIGFkZCBhbGwgcmVzdWx0cyBhbmQga2VlcCB1bmlxdWUgb25lcywgdGhpcyBvbmx5IHJ1bnMgaW4gSUUsIHNvIHdlIHRha2UgYWR2YW50YWdlIFxuXHRcdC8vIG9mIGtub3duIElFIGZlYXR1cmVzLCBwYXJ0aWN1bGFybHkgc291cmNlSW5kZXggd2hpY2ggaXMgdW5pcXVlIGFuZCBhbGxvd3MgdXMgdG8gXG5cdFx0Ly8gb3JkZXIgdGhlIHJlc3VsdHMgXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRzZWxlY3RvciA9IG5ldyBTdHJpbmcoc2VsZWN0b3JzW2ldLnJlcGxhY2UoL1xccyokLywnJykpO1xuXHRcdFx0c2VsZWN0b3IuaW5kZXhPZiA9IGVzY2FwZTsgLy8ga2VlcCBpdCBmcm9tIHJlY3Vyc2l2ZWx5IGVudGVyaW5nIGNvbWJpbmVcblx0XHRcdHZhciByZXN1bHRzID0gbGl0ZUVuZ2luZShzZWxlY3Rvciwgcm9vdCk7XG5cdFx0XHRmb3IodmFyIGogPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGogPCBsOyBqKyspe1xuXHRcdFx0XHR2YXIgbm9kZSA9IHJlc3VsdHNbal07XG5cdFx0XHRcdGluZGV4ZWRbbm9kZS5zb3VyY2VJbmRleF0gPSBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBub3cgY29udmVydCBmcm9tIGEgc3BhcnNlIGFycmF5IHRvIGEgZGVuc2UgYXJyYXlcblx0XHR2YXIgdG90YWxSZXN1bHRzID0gW107XG5cdFx0Zm9yKGkgaW4gaW5kZXhlZCl7XG5cdFx0XHR0b3RhbFJlc3VsdHMucHVzaChpbmRleGVkW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRvdGFsUmVzdWx0cztcblx0fTtcbn1cblxubGl0ZUVuZ2luZS5tYXRjaCA9IG1hdGNoZXNTZWxlY3RvciA/IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yLCByb290KXtcblx0aWYocm9vdCAmJiByb290Lm5vZGVUeXBlICE9IDkpe1xuXHRcdC8vIGRvZXNuJ3Qgc3VwcG9ydCB0aHJlZSBhcmdzLCB1c2Ugcm9vdGVkIGlkIHRyaWNrXG5cdFx0cmV0dXJuIHVzZVJvb3Qocm9vdCwgc2VsZWN0b3IsIGZ1bmN0aW9uKHF1ZXJ5KXtcblx0XHRcdHJldHVybiBtYXRjaGVzU2VsZWN0b3IuY2FsbChub2RlLCBxdWVyeSk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gd2UgaGF2ZSBhIG5hdGl2ZSBtYXRjaGVzU2VsZWN0b3IsIHVzZSB0aGF0XG5cdHJldHVybiBtYXRjaGVzU2VsZWN0b3IuY2FsbChub2RlLCBzZWxlY3Rvcik7XG59IDoganNNYXRjaGVzU2VsZWN0b3I7IC8vIG90aGVyd2lzZSB1c2UgdGhlIEpTIG1hdGNoZXMgaW1wbFxuXG5yZXR1cm4gbGl0ZUVuZ2luZTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vaGFzXCJdLCBmdW5jdGlvbihoYXMpe1xuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vc25pZmZcblxuXHQvKj09PT09XG5cdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VGhpcyBtb2R1bGUgc2V0cyBoYXMoKSBmbGFncyBiYXNlZCBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHRcdC8vXHRcdEl0IHJldHVybnMgdGhlIGhhcygpIGZ1bmN0aW9uLlxuXHR9O1xuXHQ9PT09PSovXG5cblx0aWYoaGFzKFwiaG9zdC1icm93c2VyXCIpKXtcblx0XHR2YXIgbiA9IG5hdmlnYXRvcixcblx0XHRcdGR1YSA9IG4udXNlckFnZW50LFxuXHRcdFx0ZGF2ID0gbi5hcHBWZXJzaW9uLFxuXHRcdFx0dHYgPSBwYXJzZUZsb2F0KGRhdik7XG5cdFx0aGFzLmFkZChcImFpclwiLCBkdWEuaW5kZXhPZihcIkFkb2JlQUlSXCIpID49IDApO1xuXHRcdGhhcy5hZGQoXCJ3cFwiLCBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIldpbmRvd3MgUGhvbmVcIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcIm1zYXBwXCIsIHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiTVNBcHBIb3N0L1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHRoYXMuYWRkKFwia2h0bWxcIiwgZGF2LmluZGV4T2YoXCJLb25xdWVyb3JcIikgPj0gMCA/IHR2IDogdW5kZWZpbmVkKTtcblx0XHRoYXMuYWRkKFwiZWRnZVwiLCBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIkVkZ2UvXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJvcHJcIiwgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJPUFIvXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdC8vIE5PVEU6IGh0dHBzOi8vZGV2Lm9wZXJhLmNvbS9ibG9nL29wZXJhLXVzZXItYWdlbnQtc3RyaW5ncy1vcGVyYS0xNS1hbmQtYmV5b25kL1xuXHRcdGhhcy5hZGQoXCJ3ZWJraXRcIiwgIWhhcyhcIndwXCIpIC8vIE5PVEU6IG5lY2Vzc2FyeSBzaW5jZSBXaW5kb3dzIFBob25lIDguMSBVcGRhdGUgMSwgc2VlICMxODU0MFxuXHRcdFx0JiYgIWhhcyhcImVkZ2VcIikgJiYgcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJXZWJLaXQvXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJjaHJvbWVcIiwgIWhhcyhcImVkZ2VcIikgJiYgIWhhcyhcIm9wclwiKVxuXHRcdFx0XHQmJiBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIkNocm9tZS9cIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcImFuZHJvaWRcIiwgIWhhcyhcIndwXCIpIC8vIE5PVEU6IG5lY2Vzc2FyeSBzaW5jZSBXaW5kb3dzIFBob25lIDguMSBVcGRhdGUgMSwgc2VlICMxODUyOFxuXHRcdFx0XHQmJiBwYXJzZUZsb2F0KGR1YS5zcGxpdChcIkFuZHJvaWQgXCIpWzFdKSB8fCB1bmRlZmluZWQpO1xuXHRcdGhhcy5hZGQoXCJzYWZhcmlcIiwgZGF2LmluZGV4T2YoXCJTYWZhcmlcIikgPj0gMFxuXHRcdFx0XHQmJiAhaGFzKFwid3BcIikgLy8gTk9URTogbmVjZXNzYXJ5IHNpbmNlIFdpbmRvd3MgUGhvbmUgOC4xIFVwZGF0ZSAxLCBzZWUgIzE4NTQwXG5cdFx0XHRcdCYmICFoYXMoXCJjaHJvbWVcIikgJiYgIWhhcyhcImFuZHJvaWRcIikgJiYgIWhhcyhcImVkZ2VcIikgJiYgIWhhcyhcIm9wclwiKSA/XG5cdFx0XHRwYXJzZUZsb2F0KGRhdi5zcGxpdChcIlZlcnNpb24vXCIpWzFdKSA6IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcIm1hY1wiLCBkYXYuaW5kZXhPZihcIk1hY2ludG9zaFwiKSA+PSAwKTtcblx0XHRoYXMuYWRkKFwicXVpcmtzXCIsIGRvY3VtZW50LmNvbXBhdE1vZGUgPT0gXCJCYWNrQ29tcGF0XCIpO1xuXHRcdGlmKCFoYXMoXCJ3cFwiKSAvLyBOT1RFOiBuZWNlc3Nhcnkgc2luY2UgV2luZG93cyBQaG9uZSA4LjEgVXBkYXRlIDEsIHNlZSAjMTg1Mjhcblx0XHRcdFx0JiYgZHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkvKSl7XG5cdFx0XHR2YXIgcCA9IFJlZ0V4cC4kMS5yZXBsYWNlKC9QLywgXCJwXCIpO1xuXHRcdFx0dmFyIHYgPSBkdWEubWF0Y2goL09TIChbXFxkX10rKS8pID8gUmVnRXhwLiQxIDogXCIxXCI7XG5cdFx0XHR2YXIgb3MgPSBwYXJzZUZsb2F0KHYucmVwbGFjZSgvXy8sIFwiLlwiKS5yZXBsYWNlKC9fL2csIFwiXCIpKTtcblx0XHRcdGhhcy5hZGQocCwgb3MpO1x0XHQvLyBcImlwaG9uZVwiLCBcImlwYWRcIiBvciBcImlwb2RcIlxuXHRcdFx0aGFzLmFkZChcImlvc1wiLCBvcyk7XG5cdFx0fVxuXHRcdGhhcy5hZGQoXCJiYlwiLCAoZHVhLmluZGV4T2YoXCJCbGFja0JlcnJ5XCIpID49IDAgfHwgZHVhLmluZGV4T2YoXCJCQjEwXCIpID49IDApICYmIHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiVmVyc2lvbi9cIilbMV0pIHx8IHVuZGVmaW5lZCk7XG5cdFx0aGFzLmFkZChcInRyaWRlbnRcIiwgcGFyc2VGbG9hdChkYXYuc3BsaXQoXCJUcmlkZW50L1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblxuXHRcdGhhcy5hZGQoXCJzdmdcIiwgdHlwZW9mIFNWR0FuZ2xlICE9PSBcInVuZGVmaW5lZFwiKTtcblxuXHRcdGlmKCFoYXMoXCJ3ZWJraXRcIikpe1xuXHRcdFx0Ly8gT3BlcmFcblx0XHRcdGlmKGR1YS5pbmRleE9mKFwiT3BlcmFcIikgPj0gMCl7XG5cdFx0XHRcdC8vIHNlZSBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLXVhLXN0cmluZy1jaGFuZ2VzIGFuZCBodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vcGFnZXMvT3BlcmEvXG5cdFx0XHRcdC8vIDkuOCBoYXMgYm90aCBzdHlsZXM7IDw5LjgsIDkuOSBvbmx5IG9sZCBzdHlsZVxuXHRcdFx0XHRoYXMuYWRkKFwib3BlcmFcIiwgdHYgPj0gOS44ID8gcGFyc2VGbG9hdChkdWEuc3BsaXQoXCJWZXJzaW9uL1wiKVsxXSkgfHwgdHYgOiB0dik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1vemlsbGEgYW5kIGZpcmVmb3hcblx0XHRcdGlmKGR1YS5pbmRleE9mKFwiR2Vja29cIikgPj0gMCAmJiAhaGFzKFwid3BcIikgLy8gTk9URTogbmVjZXNzYXJ5IHNpbmNlIFdpbmRvd3MgUGhvbmUgOC4xIFVwZGF0ZSAxXG5cdFx0XHRcdFx0JiYgIWhhcyhcImtodG1sXCIpICYmICFoYXMoXCJ0cmlkZW50XCIpICYmICFoYXMoXCJlZGdlXCIpKXtcblx0XHRcdFx0aGFzLmFkZChcIm1vemlsbGFcIiwgdHYpO1xuXHRcdFx0fVxuXHRcdFx0aWYoaGFzKFwibW96aWxsYVwiKSl7XG5cdFx0XHRcdC8vV2UgcmVhbGx5IG5lZWQgdG8gZ2V0IGF3YXkgZnJvbSB0aGlzLiBDb25zaWRlciBhIHNhbmUgaXNHZWNrbyBhcHByb2FjaCBmb3IgdGhlIGZ1dHVyZS5cblx0XHRcdFx0aGFzLmFkZChcImZmXCIsIHBhcnNlRmxvYXQoZHVhLnNwbGl0KFwiRmlyZWZveC9cIilbMV0gfHwgZHVhLnNwbGl0KFwiTWluZWZpZWxkL1wiKVsxXSkgfHwgdW5kZWZpbmVkKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSUVcblx0XHRcdGlmKGRvY3VtZW50LmFsbCAmJiAhaGFzKFwib3BlcmFcIikpe1xuXHRcdFx0XHR2YXIgaXNJRSA9IHBhcnNlRmxvYXQoZGF2LnNwbGl0KFwiTVNJRSBcIilbMV0pIHx8IHVuZGVmaW5lZDtcblxuXHRcdFx0XHQvL0luIGNhc2VzIHdoZXJlIHRoZSBwYWdlIGhhcyBhbiBIVFRQIGhlYWRlciBvciBNRVRBIHRhZyB3aXRoXG5cdFx0XHRcdC8vWC1VQS1Db21wYXRpYmxlLCB0aGVuIGl0IGlzIGluIGVtdWxhdGlvbiBtb2RlLlxuXHRcdFx0XHQvL01ha2Ugc3VyZSBpc0lFIHJlZmxlY3RzIHRoZSBkZXNpcmVkIHZlcnNpb24uXG5cdFx0XHRcdC8vZG9jdW1lbnQuZG9jdW1lbnRNb2RlIG9mIDUgbWVhbnMgcXVpcmtzIG1vZGUuXG5cdFx0XHRcdC8vT25seSBzd2l0Y2ggdGhlIHZhbHVlIGlmIGRvY3VtZW50TW9kZSdzIG1ham9yIHZlcnNpb25cblx0XHRcdFx0Ly9pcyBkaWZmZXJlbnQgZnJvbSBpc0lFJ3MgbWFqb3IgdmVyc2lvbi5cblx0XHRcdFx0dmFyIG1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG5cdFx0XHRcdGlmKG1vZGUgJiYgbW9kZSAhPSA1ICYmIE1hdGguZmxvb3IoaXNJRSkgIT0gbW9kZSl7XG5cdFx0XHRcdFx0aXNJRSA9IG1vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoYXMuYWRkKFwiaWVcIiwgaXNJRSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdpaVxuXHRcdFx0aGFzLmFkZChcIndpaVwiLCB0eXBlb2Ygb3BlcmEgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcGVyYS53aWlyZW1vdGUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBoYXM7XG59KTtcbiIsImRlZmluZShbXG5cdFwiLi9fYmFzZS9rZXJuZWxcIixcdC8vIGtlcm5lbC5nbG9iYWxcblx0XCIuL19iYXNlL2xhbmdcIlxuXSwgZnVuY3Rpb24oa2VybmVsLCBsYW5nKXtcblxuLy8gbW9kdWxlOlxuLy9cdFx0ZG9qby9zdHJpbmdcbnZhciBFU0NBUEVfUkVHRVhQID0gL1smPD4nXCJcXC9dL2c7XG52YXIgRVNDQVBFX01BUCA9IHtcblx0JyYnOiAnJmFtcDsnLFxuXHQnPCc6ICcmbHQ7Jyxcblx0Jz4nOiAnJmd0OycsXG5cdCdcIic6ICcmcXVvdDsnLFxuXHRcIidcIjogJyYjeDI3OycsXG5cdCcvJzogJyYjeDJGOydcbn07XG52YXIgc3RyaW5nID0ge1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRTdHJpbmcgdXRpbGl0aWVzIGZvciBEb2pvXG59O1xubGFuZy5zZXRPYmplY3QoXCJkb2pvLnN0cmluZ1wiLCBzdHJpbmcpO1xuXG5zdHJpbmcuZXNjYXBlID0gZnVuY3Rpb24oLypTdHJpbmcqL3N0cil7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdEVmZmljaWVudGx5IGVzY2FwZSBhIHN0cmluZyBmb3IgaW5zZXJ0aW9uIGludG8gSFRNTCAoaW5uZXJIVE1MIG9yIGF0dHJpYnV0ZXMpLCByZXBsYWNpbmcgJiwgPCwgPiwgXCIsICcsIGFuZCAvIGNoYXJhY3RlcnMuXG5cdC8vIHN0cjpcblx0Ly9cdFx0dGhlIHN0cmluZyB0byBlc2NhcGVcblx0aWYoIXN0cil7IHJldHVybiBcIlwiOyB9XG5cdHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkVHRVhQLCBmdW5jdGlvbihjKSB7XG5cdFx0cmV0dXJuIEVTQ0FQRV9NQVBbY107XG5cdH0pO1xufTtcblxuc3RyaW5nLnJlcCA9IGZ1bmN0aW9uKC8qU3RyaW5nKi9zdHIsIC8qSW50ZWdlciovbnVtKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0RWZmaWNpZW50bHkgcmVwbGljYXRlIGEgc3RyaW5nIGBuYCB0aW1lcy5cblx0Ly8gc3RyOlxuXHQvL1x0XHR0aGUgc3RyaW5nIHRvIHJlcGxpY2F0ZVxuXHQvLyBudW06XG5cdC8vXHRcdG51bWJlciBvZiB0aW1lcyB0byByZXBsaWNhdGUgdGhlIHN0cmluZ1xuXG5cdGlmKG51bSA8PSAwIHx8ICFzdHIpeyByZXR1cm4gXCJcIjsgfVxuXG5cdHZhciBidWYgPSBbXTtcblx0Zm9yKDs7KXtcblx0XHRpZihudW0gJiAxKXtcblx0XHRcdGJ1Zi5wdXNoKHN0cik7XG5cdFx0fVxuXHRcdGlmKCEobnVtID4+PSAxKSl7IGJyZWFrOyB9XG5cdFx0c3RyICs9IHN0cjtcblx0fVxuXHRyZXR1cm4gYnVmLmpvaW4oXCJcIik7XHQvLyBTdHJpbmdcbn07XG5cbnN0cmluZy5wYWQgPSBmdW5jdGlvbigvKlN0cmluZyovdGV4dCwgLypJbnRlZ2VyKi9zaXplLCAvKlN0cmluZz8qL2NoLCAvKkJvb2xlYW4/Ki9lbmQpe1xuXHQvLyBzdW1tYXJ5OlxuXHQvL1x0XHRQYWQgYSBzdHJpbmcgdG8gZ3VhcmFudGVlIHRoYXQgaXQgaXMgYXQgbGVhc3QgYHNpemVgIGxlbmd0aCBieVxuXHQvL1x0XHRmaWxsaW5nIHdpdGggdGhlIGNoYXJhY3RlciBgY2hgIGF0IGVpdGhlciB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZVxuXHQvL1x0XHRzdHJpbmcuIFBhZHMgYXQgdGhlIHN0YXJ0LCBieSBkZWZhdWx0LlxuXHQvLyB0ZXh0OlxuXHQvL1x0XHR0aGUgc3RyaW5nIHRvIHBhZFxuXHQvLyBzaXplOlxuXHQvL1x0XHRsZW5ndGggdG8gcHJvdmlkZSBwYWRkaW5nXG5cdC8vIGNoOlxuXHQvL1x0XHRjaGFyYWN0ZXIgdG8gcGFkLCBkZWZhdWx0cyB0byAnMCdcblx0Ly8gZW5kOlxuXHQvL1x0XHRhZGRzIHBhZGRpbmcgYXQgdGhlIGVuZCBpZiB0cnVlLCBvdGhlcndpc2UgcGFkcyBhdCBzdGFydFxuXHQvLyBleGFtcGxlOlxuXHQvL1x0fFx0Ly8gRmlsbCB0aGUgc3RyaW5nIHRvIGxlbmd0aCAxMCB3aXRoIFwiK1wiIGNoYXJhY3RlcnMgb24gdGhlIHJpZ2h0LiAgWWllbGRzIFwiRG9qbysrKysrK1wiLlxuXHQvL1x0fFx0c3RyaW5nLnBhZChcIkRvam9cIiwgMTAsIFwiK1wiLCB0cnVlKTtcblxuXHRpZighY2gpe1xuXHRcdGNoID0gJzAnO1xuXHR9XG5cdHZhciBvdXQgPSBTdHJpbmcodGV4dCksXG5cdFx0cGFkID0gc3RyaW5nLnJlcChjaCwgTWF0aC5jZWlsKChzaXplIC0gb3V0Lmxlbmd0aCkgLyBjaC5sZW5ndGgpKTtcblx0cmV0dXJuIGVuZCA/IG91dCArIHBhZCA6IHBhZCArIG91dDtcdC8vIFN0cmluZ1xufTtcblxuc3RyaW5nLnN1YnN0aXR1dGUgPSBmdW5jdGlvbihcdC8qU3RyaW5nKi9cdFx0dGVtcGxhdGUsXG5cdFx0XHRcdFx0XHRcdFx0XHQvKk9iamVjdHxBcnJheSovbWFwLFxuXHRcdFx0XHRcdFx0XHRcdFx0LypGdW5jdGlvbj8qL1x0dHJhbnNmb3JtLFxuXHRcdFx0XHRcdFx0XHRcdFx0LypPYmplY3Q/Ki9cdFx0dGhpc09iamVjdCl7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFBlcmZvcm1zIHBhcmFtZXRlcml6ZWQgc3Vic3RpdHV0aW9ucyBvbiBhIHN0cmluZy4gVGhyb3dzIGFuXG5cdC8vXHRcdGV4Y2VwdGlvbiBpZiBhbnkgcGFyYW1ldGVyIGlzIHVubWF0Y2hlZC5cblx0Ly8gdGVtcGxhdGU6XG5cdC8vXHRcdGEgc3RyaW5nIHdpdGggZXhwcmVzc2lvbnMgaW4gdGhlIGZvcm0gYCR7a2V5fWAgdG8gYmUgcmVwbGFjZWQgb3Jcblx0Ly9cdFx0YCR7a2V5OmZvcm1hdH1gIHdoaWNoIHNwZWNpZmllcyBhIGZvcm1hdCBmdW5jdGlvbi4ga2V5cyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cdC8vXHRcdFRoZSBzcGVjaWFsIHNlcXVlbmNlIGAke31gIGNhbiBiZSB1c2VkIGVzY2FwZSBgJGAuXG5cdC8vIG1hcDpcblx0Ly9cdFx0aGFzaCB0byBzZWFyY2ggZm9yIHN1YnN0aXR1dGlvbnNcblx0Ly8gdHJhbnNmb3JtOlxuXHQvL1x0XHRhIGZ1bmN0aW9uIHRvIHByb2Nlc3MgYWxsIHBhcmFtZXRlcnMgYmVmb3JlIHN1YnN0aXR1dGlvbiB0YWtlc1xuXHQvL1x0XHRwbGFjZSwgZS5nLiBteWxpYi5lbmNvZGVYTUxcblx0Ly8gdGhpc09iamVjdDpcblx0Ly9cdFx0d2hlcmUgdG8gbG9vayBmb3Igb3B0aW9uYWwgZm9ybWF0IGZ1bmN0aW9uOyBkZWZhdWx0IHRvIHRoZSBnbG9iYWxcblx0Ly9cdFx0bmFtZXNwYWNlXG5cdC8vIGV4YW1wbGU6XG5cdC8vXHRcdFN1YnN0aXR1dGVzIHR3byBleHByZXNzaW9ucyBpbiBhIHN0cmluZyBmcm9tIGFuIEFycmF5IG9yIE9iamVjdFxuXHQvL1x0fFx0Ly8gcmV0dXJucyBcIkZpbGUgJ2Zvby5odG1sJyBpcyBub3QgZm91bmQgaW4gZGlyZWN0b3J5ICcvdGVtcCcuXCJcblx0Ly9cdHxcdC8vIGJ5IHByb3ZpZGluZyBzdWJzdGl0dXRpb24gZGF0YSBpbiBhbiBBcnJheVxuXHQvL1x0fFx0c3RyaW5nLnN1YnN0aXR1dGUoXG5cdC8vXHR8XHRcdFwiRmlsZSAnJHswfScgaXMgbm90IGZvdW5kIGluIGRpcmVjdG9yeSAnJHsxfScuXCIsXG5cdC8vXHR8XHRcdFtcImZvby5odG1sXCIsXCIvdGVtcFwiXVxuXHQvL1x0fFx0KTtcblx0Ly9cdHxcblx0Ly9cdHxcdC8vIGFsc28gcmV0dXJucyBcIkZpbGUgJ2Zvby5odG1sJyBpcyBub3QgZm91bmQgaW4gZGlyZWN0b3J5ICcvdGVtcCcuXCJcblx0Ly9cdHxcdC8vIGJ1dCBwcm92aWRlcyBzdWJzdGl0dXRpb24gZGF0YSBpbiBhbiBPYmplY3Qgc3RydWN0dXJlLiAgRG90dGVkXG5cdC8vXHR8XHQvLyBub3RhdGlvbiBtYXkgYmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgc3RydWN0dXJlLlxuXHQvL1x0fFx0c3RyaW5nLnN1YnN0aXR1dGUoXG5cdC8vXHR8XHRcdFwiRmlsZSAnJHtuYW1lfScgaXMgbm90IGZvdW5kIGluIGRpcmVjdG9yeSAnJHtpbmZvLmRpcn0nLlwiLFxuXHQvL1x0fFx0XHR7IG5hbWU6IFwiZm9vLmh0bWxcIiwgaW5mbzogeyBkaXI6IFwiL3RlbXBcIiB9IH1cblx0Ly9cdHxcdCk7XG5cdC8vIGV4YW1wbGU6XG5cdC8vXHRcdFVzZSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBtb2RpZnkgdGhlIHZhbHVlczpcblx0Ly9cdHxcdC8vIHJldHVybnMgXCJmaWxlICdmb28uaHRtbCcgaXMgbm90IGZvdW5kIGluIGRpcmVjdG9yeSAnL3RlbXAnLlwiXG5cdC8vXHR8XHRzdHJpbmcuc3Vic3RpdHV0ZShcblx0Ly9cdHxcdFx0XCIkezB9IGlzIG5vdCBmb3VuZCBpbiAkezF9LlwiLFxuXHQvL1x0fFx0XHRbXCJmb28uaHRtbFwiLFwiL3RlbXBcIl0sXG5cdC8vXHR8XHRcdGZ1bmN0aW9uKHN0cil7XG5cdC8vXHR8XHRcdFx0Ly8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHR5cGVcblx0Ly9cdHxcdFx0XHR2YXIgcHJlZml4ID0gKHN0ci5jaGFyQXQoMCkgPT0gXCIvXCIpID8gXCJkaXJlY3RvcnlcIjogXCJmaWxlXCI7XG5cdC8vXHR8XHRcdFx0cmV0dXJuIHByZWZpeCArIFwiICdcIiArIHN0ciArIFwiJ1wiO1xuXHQvL1x0fFx0XHR9XG5cdC8vXHR8XHQpO1xuXHQvLyBleGFtcGxlOlxuXHQvL1x0XHRVc2UgYSBmb3JtYXR0ZXJcblx0Ly9cdHxcdC8vIHJldHVybnMgXCJ0aGluZ2VyIC0tIGhvd2R5XCJcblx0Ly9cdHxcdHN0cmluZy5zdWJzdGl0dXRlKFxuXHQvL1x0fFx0XHRcIiR7MDpwb3N0Zml4fVwiLCBbXCJ0aGluZ2VyXCJdLCBudWxsLCB7XG5cdC8vXHR8XHRcdFx0cG9zdGZpeDogZnVuY3Rpb24odmFsdWUsIGtleSl7XG5cdC8vXHR8XHRcdFx0XHRyZXR1cm4gdmFsdWUgKyBcIiAtLSBob3dkeVwiO1xuXHQvL1x0fFx0XHRcdH1cblx0Ly9cdHxcdFx0fVxuXHQvL1x0fFx0KTtcblxuXHR0aGlzT2JqZWN0ID0gdGhpc09iamVjdCB8fCBrZXJuZWwuZ2xvYmFsO1xuXHR0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0gP1xuXHRcdGxhbmcuaGl0Y2godGhpc09iamVjdCwgdHJhbnNmb3JtKSA6IGZ1bmN0aW9uKHYpeyByZXR1cm4gdjsgfTtcblxuXHRyZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFwkXFx7KFteXFxzXFw6XFx9XSopKD86XFw6KFteXFxzXFw6XFx9XSspKT9cXH0vZyxcblx0XHRmdW5jdGlvbihtYXRjaCwga2V5LCBmb3JtYXQpe1xuXHRcdFx0aWYgKGtleSA9PSAnJyl7XG5cdFx0XHRcdHJldHVybiAnJCc7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdmFsdWUgPSBsYW5nLmdldE9iamVjdChrZXksIGZhbHNlLCBtYXApO1xuXHRcdFx0aWYoZm9ybWF0KXtcblx0XHRcdFx0dmFsdWUgPSBsYW5nLmdldE9iamVjdChmb3JtYXQsIGZhbHNlLCB0aGlzT2JqZWN0KS5jYWxsKHRoaXNPYmplY3QsIHZhbHVlLCBrZXkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdCA9IHRyYW5zZm9ybSh2YWx1ZSwga2V5KTtcblxuXHRcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignc3RyaW5nLnN1YnN0aXR1dGUgY291bGQgbm90IGZpbmQga2V5IFwiJyArIGtleSArICdcIiBpbiB0ZW1wbGF0ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG5cdFx0fSk7IC8vIFN0cmluZ1xufTtcblxuc3RyaW5nLnRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0gP1xuXHRsYW5nLnRyaW0gOiAvLyBhbGlhc2luZyB0byB0aGUgbmF0aXZlIGZ1bmN0aW9uXG5cdGZ1bmN0aW9uKHN0cil7XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpO1xuXHRcdGZvcih2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRpZigvXFxTLy50ZXN0KHN0ci5jaGFyQXQoaSkpKXtcblx0XHRcdFx0c3RyID0gc3RyLnN1YnN0cmluZygwLCBpICsgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xuXG4vKj09PT09XG4gc3RyaW5nLnRyaW0gPSBmdW5jdGlvbihzdHIpe1xuXHQgLy8gc3VtbWFyeTpcblx0IC8vXHRcdFRyaW1zIHdoaXRlc3BhY2UgZnJvbSBib3RoIHNpZGVzIG9mIHRoZSBzdHJpbmdcblx0IC8vIHN0cjogU3RyaW5nXG5cdCAvL1x0XHRTdHJpbmcgdG8gYmUgdHJpbW1lZFxuXHQgLy8gcmV0dXJuczogU3RyaW5nXG5cdCAvL1x0XHRSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZ1xuXHQgLy8gZGVzY3JpcHRpb246XG5cdCAvL1x0XHRUaGlzIHZlcnNpb24gb2YgdHJpbSgpIHdhcyB0YWtlbiBmcm9tIFtTdGV2ZW4gTGV2aXRoYW4ncyBibG9nXShodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdCkuXG5cdCAvL1x0XHRUaGUgc2hvcnQgeWV0IHBlcmZvcm1hbnQgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uIGlzIGRvam8vX2Jhc2UvbGFuZy50cmltKCksXG5cdCAvL1x0XHR3aGljaCBpcyBwYXJ0IG9mIERvam8gYmFzZS4gIFVzZXMgU3RyaW5nLnByb3RvdHlwZS50cmltIGluc3RlYWQsIGlmIGF2YWlsYWJsZS5cblx0IHJldHVybiBcIlwiO1x0Ly8gU3RyaW5nXG4gfTtcbiA9PT09PSovXG5cblx0cmV0dXJuIHN0cmluZztcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwicmVxdWlyZVwiLCBcIi4vaGFzXCIsIFwiLi9oYXMhaG9zdC1icm93c2VyPy4vcmVxdWVzdFwiXSwgZnVuY3Rpb24oZG9qbywgcmVxdWlyZSwgaGFzLCByZXF1ZXN0KXtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRkb2pvL3RleHRcblxuXHR2YXIgZ2V0VGV4dDtcblx0aWYoaGFzKFwiaG9zdC1icm93c2VyXCIpKXtcblx0XHRnZXRUZXh0PSBmdW5jdGlvbih1cmwsIHN5bmMsIGxvYWQpe1xuXHRcdFx0cmVxdWVzdCh1cmwsIHtzeW5jOiEhc3luYywgaGVhZGVyczogeyAnWC1SZXF1ZXN0ZWQtV2l0aCc6IG51bGwgfSB9KS50aGVuKGxvYWQpO1xuXHRcdH07XG5cdH1lbHNle1xuXHRcdC8vIFBhdGggZm9yIG5vZGUuanMgYW5kIHJoaW5vLCB0byBsb2FkIGZyb20gbG9jYWwgZmlsZSBzeXN0ZW0uXG5cdFx0Ly8gVE9ETzogdXNlIG5vZGUuanMgbmF0aXZlIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGVwZW5kaW5nIG9uIGEgcmVxdWlyZS5nZXRUZXh0KCkgbWV0aG9kIHRvIGV4aXN0LlxuXHRcdGlmKHJlcXVpcmUuZ2V0VGV4dCl7XG5cdFx0XHRnZXRUZXh0PSByZXF1aXJlLmdldFRleHQ7XG5cdFx0fWVsc2V7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiZG9qby90ZXh0IHBsdWdpbiBmYWlsZWQgdG8gbG9hZCBiZWNhdXNlIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IGdldFRleHRcIik7XG5cdFx0fVxuXHR9XG5cblx0dmFyXG5cdFx0dGhlQ2FjaGUgPSB7fSxcblxuXHRcdHN0cmlwPSBmdW5jdGlvbih0ZXh0KXtcblx0XHRcdC8vU3RyaXBzIDw/eG1sIC4uLj8+IGRlY2xhcmF0aW9ucyBzbyB0aGF0IGV4dGVybmFsIFNWRyBhbmQgWE1MXG5cdFx0XHQvL2RvY3VtZW50cyBjYW4gYmUgYWRkZWQgdG8gYSBkb2N1bWVudCB3aXRob3V0IHdvcnJ5LiBBbHNvLCBpZiB0aGUgc3RyaW5nXG5cdFx0XHQvL2lzIGFuIEhUTUwgZG9jdW1lbnQsIG9ubHkgdGhlIHBhcnQgaW5zaWRlIHRoZSBib2R5IHRhZyBpcyByZXR1cm5lZC5cblx0XHRcdGlmKHRleHQpe1xuXHRcdFx0XHR0ZXh0PSB0ZXh0LnJlcGxhY2UoL15cXHMqPFxcP3htbChcXHMpK3ZlcnNpb249W1xcJ1xcXCJdKFxcZCkqLihcXGQpKltcXCdcXFwiXShcXHMpKlxcPz4vaW0sIFwiXCIpO1xuXHRcdFx0XHR2YXIgbWF0Y2hlcz0gdGV4dC5tYXRjaCgvPGJvZHlbXj5dKj5cXHMqKFtcXHNcXFNdKylcXHMqPFxcL2JvZHk+L2ltKTtcblx0XHRcdFx0aWYobWF0Y2hlcyl7XG5cdFx0XHRcdFx0dGV4dD0gbWF0Y2hlc1sxXTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRleHQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fSxcblxuXHRcdG5vdEZvdW5kID0ge30sXG5cblx0XHRwZW5kaW5nID0ge307XG5cblx0ZG9qby5jYWNoZSA9IGZ1bmN0aW9uKC8qU3RyaW5nfHxPYmplY3QqL21vZHVsZSwgLypTdHJpbmcqL3VybCwgLypTdHJpbmd8fE9iamVjdD8qL3ZhbHVlKXtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdEEgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHN0b3JpbmcgdGhlIHN0cmluZyBjb250ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGVcblx0XHQvL1x0XHRtb2R1bGUgYW5kIHVybCBhcmd1bWVudHMuXG5cdFx0Ly8gZGVzY3JpcHRpb246XG5cdFx0Ly9cdFx0SWYgbW9kdWxlIGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgc2xhc2hlcywgdGhlbiBpdCBpcyBpbnRlcnByZXR0ZWQgYXMgYSBmdWxseVxuXHRcdC8vXHRcdHJlc29sdmVkIHBhdGggKHR5cGljYWxseSBhIHJlc3VsdCByZXR1cm5lZCBieSByZXF1aXJlLnRvVXJsKSwgYW5kIHVybCBzaG91bGQgbm90IGJlXG5cdFx0Ly9cdFx0cHJvdmlkZWQuIFRoaXMgaXMgdGhlIHByZWZlcnJlZCBzaWduYXR1cmUuIElmIG1vZHVsZSBpcyBhIHN0cmluZyB0aGF0IGRvZXMgbm90XG5cdFx0Ly9cdFx0Y29udGFpbiBzbGFzaGVzLCB0aGVuIHVybCBtdXN0IGFsc28gYmUgcHJvdmlkZWQgYW5kIG1vZHVsZSBhbmQgdXJsIGFyZSB1c2VkIHRvXG5cdFx0Ly9cdFx0Y2FsbCBgZG9qby5tb2R1bGVVcmwoKWAgdG8gZ2VuZXJhdGUgYSBtb2R1bGUgVVJMLiBUaGlzIHNpZ25hdHVyZSBpcyBkZXByZWNhdGVkLlxuXHRcdC8vXHRcdElmIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlIGNhY2hlIHZhbHVlIGZvciB0aGUgbW9kdWxlVXJsIHdpbGwgYmUgc2V0IHRvXG5cdFx0Ly9cdFx0dGhhdCB2YWx1ZS4gT3RoZXJ3aXNlLCBkb2pvLmNhY2hlIHdpbGwgZmV0Y2ggdGhlIG1vZHVsZVVybCBhbmQgc3RvcmUgaXRcblx0XHQvL1x0XHRpbiBpdHMgaW50ZXJuYWwgY2FjaGUgYW5kIHJldHVybiB0aGF0IGNhY2hlZCB2YWx1ZSBmb3IgdGhlIFVSTC4gVG8gY2xlYXJcblx0XHQvL1x0XHRhIGNhY2hlIHZhbHVlIHBhc3MgbnVsbCBmb3IgdmFsdWUuIFNpbmNlIFhNTEh0dHBSZXF1ZXN0IChYSFIpIGlzIHVzZWQgdG8gZmV0Y2ggdGhlXG5cdFx0Ly9cdFx0dGhlIFVSTCBjb250ZW50cywgb25seSBtb2R1bGVzIG9uIHRoZSBzYW1lIGRvbWFpbiBvZiB0aGUgcGFnZSBjYW4gdXNlIHRoaXMgY2FwYWJpbGl0eS5cblx0XHQvL1x0XHRUaGUgYnVpbGQgc3lzdGVtIGNhbiBpbmxpbmUgdGhlIGNhY2hlIHZhbHVlcyB0aG91Z2gsIHRvIGFsbG93IGZvciB4ZG9tYWluIGhvc3RpbmcuXG5cdFx0Ly8gbW9kdWxlOiBTdHJpbmd8fE9iamVjdFxuXHRcdC8vXHRcdElmIGEgU3RyaW5nIHdpdGggc2xhc2hlcywgYSBmdWxseSByZXNvbHZlZCBwYXRoOyBpZiBhIFN0cmluZyB3aXRob3V0IHNsYXNoZXMsIHRoZVxuXHRcdC8vXHRcdG1vZHVsZSBuYW1lIHRvIHVzZSBmb3IgdGhlIGJhc2UgcGFydCBvZiB0aGUgVVJMLCBzaW1pbGFyIHRvIG1vZHVsZSBhcmd1bWVudFxuXHRcdC8vXHRcdHRvIGBkb2pvLm1vZHVsZVVybGAuIElmIGFuIE9iamVjdCwgc29tZXRoaW5nIHRoYXQgaGFzIGEgLnRvU3RyaW5nKCkgbWV0aG9kIHRoYXRcblx0XHQvL1x0XHRnZW5lcmF0ZXMgYSB2YWxpZCBwYXRoIGZvciB0aGUgY2FjaGUgaXRlbS4gRm9yIGV4YW1wbGUsIGEgZG9qby5fVXJsIG9iamVjdC5cblx0XHQvLyB1cmw6IFN0cmluZ1xuXHRcdC8vXHRcdFRoZSByZXN0IG9mIHRoZSBwYXRoIHRvIGFwcGVuZCB0byB0aGUgcGF0aCBkZXJpdmVkIGZyb20gdGhlIG1vZHVsZSBhcmd1bWVudC4gSWZcblx0XHQvL1x0XHRtb2R1bGUgaXMgYW4gb2JqZWN0LCB0aGVuIHRoaXMgc2Vjb25kIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluc3RlYWQuXG5cdFx0Ly8gdmFsdWU6IFN0cmluZ3x8T2JqZWN0P1xuXHRcdC8vXHRcdElmIGEgU3RyaW5nLCB0aGUgdmFsdWUgdG8gdXNlIGluIHRoZSBjYWNoZSBmb3IgdGhlIG1vZHVsZS91cmwgY29tYmluYXRpb24uXG5cdFx0Ly9cdFx0SWYgYW4gT2JqZWN0LCBpdCBjYW4gaGF2ZSB0d28gcHJvcGVydGllczogdmFsdWUgYW5kIHNhbml0aXplLiBUaGUgdmFsdWUgcHJvcGVydHlcblx0XHQvL1x0XHRzaG91bGQgYmUgdGhlIHZhbHVlIHRvIHVzZSBpbiB0aGUgY2FjaGUsIGFuZCBzYW5pdGl6ZSBjYW4gYmUgc2V0IHRvIHRydWUgb3IgZmFsc2UsXG5cdFx0Ly9cdFx0dG8gaW5kaWNhdGUgaWYgWE1MIGRlY2xhcmF0aW9ucyBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSB2YWx1ZSBhbmQgaWYgdGhlIEhUTUxcblx0XHQvL1x0XHRpbnNpZGUgYSBib2R5IHRhZyBpbiB0aGUgdmFsdWUgc2hvdWxkIGJlIGV4dHJhY3RlZCBhcyB0aGUgcmVhbCB2YWx1ZS4gVGhlIHZhbHVlIGFyZ3VtZW50XG5cdFx0Ly9cdFx0b3IgdGhlIHZhbHVlIHByb3BlcnR5IG9uIHRoZSB2YWx1ZSBhcmd1bWVudCBhcmUgdXN1YWxseSBvbmx5IHVzZWQgYnkgdGhlIGJ1aWxkIHN5c3RlbVxuXHRcdC8vXHRcdGFzIGl0IGlubGluZXMgY2FjaGUgY29udGVudC5cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFRvIGFzayBkb2pvLmNhY2hlIHRvIGZldGNoIGNvbnRlbnQgYW5kIHN0b3JlIGl0IGluIHRoZSBjYWNoZSAodGhlIGRvam9bXCJjYWNoZVwiXSBzdHlsZVxuXHRcdC8vXHRcdG9mIGNhbGwgaXMgdXNlZCB0byBhdm9pZCBhbiBpc3N1ZSB3aXRoIHRoZSBidWlsZCBzeXN0ZW0gZXJyb25lb3VzbHkgdHJ5aW5nIHRvIGludGVyblxuXHRcdC8vXHRcdHRoaXMgZXhhbXBsZS4gVG8gZ2V0IHRoZSBidWlsZCBzeXN0ZW0gdG8gaW50ZXJuIHlvdXIgZG9qby5jYWNoZSBjYWxscywgdXNlIHRoZVxuXHRcdC8vXHRcdFwiZG9qby5jYWNoZVwiIHN0eWxlIG9mIGNhbGwpOlxuXHRcdC8vXHRcdHwgLy9JZiB0ZW1wbGF0ZS5odG1sIGNvbnRhaW5zIFwiPGgxPkhlbGxvPC9oMT5cIiB0aGF0IHdpbGwgYmVcblx0XHQvL1x0XHR8IC8vdGhlIHZhbHVlIGZvciB0aGUgdGV4dCB2YXJpYWJsZS5cblx0XHQvL1x0XHR8IC8vTm90ZTogVGhpcyBpcyBwcmUtQU1ELCBkZXByZWNhdGVkIHN5bnRheFxuXHRcdC8vXHRcdHwgdmFyIHRleHQgPSBkb2pvW1wiY2FjaGVcIl0oXCJteS5tb2R1bGVcIiwgXCJ0ZW1wbGF0ZS5odG1sXCIpO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0VG8gYXNrIGRvam8uY2FjaGUgdG8gZmV0Y2ggY29udGVudCBhbmQgc3RvcmUgaXQgaW4gdGhlIGNhY2hlLCBhbmQgc2FuaXRpemUgdGhlIGlucHV0XG5cdFx0Ly9cdFx0ICh0aGUgZG9qb1tcImNhY2hlXCJdIHN0eWxlIG9mIGNhbGwgaXMgdXNlZCB0byBhdm9pZCBhbiBpc3N1ZSB3aXRoIHRoZSBidWlsZCBzeXN0ZW1cblx0XHQvL1x0XHRlcnJvbmVvdXNseSB0cnlpbmcgdG8gaW50ZXJuIHRoaXMgZXhhbXBsZS4gVG8gZ2V0IHRoZSBidWlsZCBzeXN0ZW0gdG8gaW50ZXJuIHlvdXJcblx0XHQvL1x0XHRkb2pvLmNhY2hlIGNhbGxzLCB1c2UgdGhlIFwiZG9qby5jYWNoZVwiIHN0eWxlIG9mIGNhbGwpOlxuXHRcdC8vXHRcdHwgLy9JZiB0ZW1wbGF0ZS5odG1sIGNvbnRhaW5zIFwiPGh0bWw+PGJvZHk+PGgxPkhlbGxvPC9oMT48L2JvZHk+PC9odG1sPlwiLCB0aGVcblx0XHQvL1x0XHR8IC8vdGV4dCB2YXJpYWJsZSB3aWxsIGNvbnRhaW4ganVzdCBcIjxoMT5IZWxsbzwvaDE+XCIuXG5cdFx0Ly9cdFx0fCAvL05vdGU6IFRoaXMgaXMgcHJlLUFNRCwgZGVwcmVjYXRlZCBzeW50YXhcblx0XHQvL1x0XHR8IHZhciB0ZXh0ID0gZG9qb1tcImNhY2hlXCJdKFwibXkubW9kdWxlXCIsIFwidGVtcGxhdGUuaHRtbFwiLCB7c2FuaXRpemU6IHRydWV9KTtcblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFNhbWUgZXhhbXBsZSBhcyBwcmV2aW91cywgYnV0IGRlbW9uc3RyYXRlcyBob3cgYW4gb2JqZWN0IGNhbiBiZSBwYXNzZWQgaW4gYXNcblx0XHQvL1x0XHR0aGUgZmlyc3QgYXJndW1lbnQsIHRoZW4gdGhlIHZhbHVlIGFyZ3VtZW50IGNhbiB0aGVuIGJlIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdFx0Ly9cdFx0fCAvL0lmIHRlbXBsYXRlLmh0bWwgY29udGFpbnMgXCI8aHRtbD48Ym9keT48aDE+SGVsbG88L2gxPjwvYm9keT48L2h0bWw+XCIsIHRoZVxuXHRcdC8vXHRcdHwgLy90ZXh0IHZhcmlhYmxlIHdpbGwgY29udGFpbiBqdXN0IFwiPGgxPkhlbGxvPC9oMT5cIi5cblx0XHQvL1x0XHR8IC8vTm90ZTogVGhpcyBpcyBwcmUtQU1ELCBkZXByZWNhdGVkIHN5bnRheFxuXHRcdC8vXHRcdHwgdmFyIHRleHQgPSBkb2pvW1wiY2FjaGVcIl0obmV3IGRvam8uX1VybChcIm15L21vZHVsZS90ZW1wbGF0ZS5odG1sXCIpLCB7c2FuaXRpemU6IHRydWV9KTtcblxuXHRcdC8vXHQgKiAoc3RyaW5nIHN0cmluZyBbdmFsdWVdKSA9PiAobW9kdWxlLCB1cmwsIHZhbHVlKVxuXHRcdC8vXHQgKiAob2JqZWN0IFt2YWx1ZV0pICAgICAgICA9PiAobW9kdWxlLCB2YWx1ZSksIHVybCBkZWZhdWx0cyB0byBcIlwiXG5cdFx0Ly9cblx0XHQvL1x0ICogaWYgbW9kdWxlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCBtdXN0IGJlIGNvbnZlcnRhYmxlIHRvIGEgc3RyaW5nXG5cdFx0Ly9cdCAqIChtb2R1bGUsIHVybCkgbW9kdWxlICsgKHVybCA/IChcIi9cIiArIHVybCkgOiBcIlwiKSBtdXN0IGJlIGEgbGVnYWwgYXJndW1lbnQgdG8gcmVxdWlyZS50b1VybFxuXHRcdC8vXHQgKiB2YWx1ZSBtYXkgYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0OyBpZiBhbiBvYmplY3QgdGhlbiBtYXkgaGF2ZSB0aGUgcHJvcGVydGllcyBcInZhbHVlXCIgYW5kL29yIFwic2FuaXRpemVcIlxuXHRcdHZhciBrZXk7XG5cdFx0aWYodHlwZW9mIG1vZHVsZT09XCJzdHJpbmdcIil7XG5cdFx0XHRpZigvXFwvLy50ZXN0KG1vZHVsZSkpe1xuXHRcdFx0XHQvLyBtb2R1bGUgaXMgYSB2ZXJzaW9uIDEuNysgcmVzb2x2ZWQgcGF0aFxuXHRcdFx0XHRrZXkgPSBtb2R1bGU7XG5cdFx0XHRcdHZhbHVlID0gdXJsO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIG1vZHVsZSBpcyBhIHZlcnNpb24gMS42LSBhcmd1bWVudCB0byBkb2pvLm1vZHVsZVVybFxuXHRcdFx0XHRrZXkgPSByZXF1aXJlLnRvVXJsKG1vZHVsZS5yZXBsYWNlKC9cXC4vZywgXCIvXCIpICsgKHVybCA/IChcIi9cIiArIHVybCkgOiBcIlwiKSk7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRrZXkgPSBtb2R1bGUgKyBcIlwiO1xuXHRcdFx0dmFsdWUgPSB1cmw7XG5cdFx0fVxuXHRcdHZhclxuXHRcdFx0dmFsID0gKHZhbHVlICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlLFxuXHRcdFx0c2FuaXRpemUgPSB2YWx1ZSAmJiB2YWx1ZS5zYW5pdGl6ZTtcblxuXHRcdGlmKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIil7XG5cdFx0XHQvL1dlIGhhdmUgYSBzdHJpbmcsIHNldCBjYWNoZSB2YWx1ZVxuXHRcdFx0dGhlQ2FjaGVba2V5XSA9IHZhbDtcblx0XHRcdHJldHVybiBzYW5pdGl6ZSA/IHN0cmlwKHZhbCkgOiB2YWw7XG5cdFx0fWVsc2UgaWYodmFsID09PSBudWxsKXtcblx0XHRcdC8vUmVtb3ZlIGNhY2hlZCB2YWx1ZVxuXHRcdFx0ZGVsZXRlIHRoZUNhY2hlW2tleV07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9ZWxzZXtcblx0XHRcdC8vQWxsb3cgY2FjaGUgdmFsdWVzIHRvIGJlIGVtcHR5IHN0cmluZ3MuIElmIGtleSBwcm9wZXJ0eSBkb2VzXG5cdFx0XHQvL25vdCBleGlzdCwgZmV0Y2ggaXQuXG5cdFx0XHRpZighKGtleSBpbiB0aGVDYWNoZSkpe1xuXHRcdFx0XHRnZXRUZXh0KGtleSwgdHJ1ZSwgZnVuY3Rpb24odGV4dCl7XG5cdFx0XHRcdFx0dGhlQ2FjaGVba2V5XT0gdGV4dDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2FuaXRpemUgPyBzdHJpcCh0aGVDYWNoZVtrZXldKSA6IHRoZUNhY2hlW2tleV07XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIHRoZSBkb2pvL3RleHQhIHBsdWdpbiBhbmQgdGhlIGRvam8uY2FjaGUgQVBJLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdFdlIGNob29zZSB0byBpbmNsdWRlIG91ciBvd24gcGx1Z2luIHRvIGxldmVyYWdlIGZ1bmN0aW9uYWxpdHkgYWxyZWFkeSBjb250YWluZWQgaW4gZG9qb1xuXHRcdC8vXHRcdGFuZCB0aGVyZWJ5IHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGUgcGx1Z2luIGNvbXBhcmVkIHRvIHZhcmlvdXMgZm9yZWlnbiBsb2FkZXIgaW1wbGVtZW50YXRpb25zLlxuXHRcdC8vXHRcdEFsc28sIHRoaXMgYWxsb3dzIGZvcmVpZ24gQU1EIGxvYWRlcnMgdG8gYmUgdXNlZCB3aXRob3V0IHRoZWlyIHBsdWdpbnMuXG5cdFx0Ly9cblx0XHQvL1x0XHRDQVVUSU9OOiB0aGlzIG1vZHVsZSBpcyBkZXNpZ25lZCB0byBvcHRpb25hbGx5IGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgdG8gc3VwcG9ydCB0aGUgZG9qbyB2MS54IHN5bmNocm9ub3VzXG5cdFx0Ly9cdFx0bG9hZGVyLiBUaGlzIGZlYXR1cmUgaXMgb3V0c2lkZSB0aGUgc2NvcGUgb2YgdGhlIENvbW1vbkpTIHBsdWdpbnMgc3BlY2lmaWNhdGlvbi5cblxuXHRcdC8vIHRoZSBkb2pvL3RleHQgY2FjaGVzIGl0J3Mgb3duIHJlc291cmNlcyBiZWNhdXNlIG9mIGRvam8uY2FjaGVcblx0XHRkeW5hbWljOiB0cnVlLFxuXG5cdFx0bm9ybWFsaXplOiBmdW5jdGlvbihpZCwgdG9BYnNNaWQpe1xuXHRcdFx0Ly8gaWQgaXMgc29tZXRoaW5nIGxpa2UgKHBhdGggbWF5IGJlIHJlbGF0aXZlKTpcblx0XHRcdC8vXG5cdFx0XHQvL1x0IFwicGF0aC90by90ZXh0Lmh0bWxcIlxuXHRcdFx0Ly9cdCBcInBhdGgvdG8vdGV4dC5odG1sIXN0cmlwXCJcblx0XHRcdHZhciBwYXJ0cz0gaWQuc3BsaXQoXCIhXCIpLFxuXHRcdFx0XHR1cmw9IHBhcnRzWzBdO1xuXHRcdFx0cmV0dXJuICgvXlxcLi8udGVzdCh1cmwpID8gdG9BYnNNaWQodXJsKSA6IHVybCkgKyAocGFydHNbMV0gPyBcIiFcIiArIHBhcnRzWzFdIDogXCJcIik7XG5cdFx0fSxcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uKGlkLCByZXF1aXJlLCBsb2FkKXtcblx0XHRcdC8vIGlkOiBTdHJpbmdcblx0XHRcdC8vXHRcdFBhdGggdG8gdGhlIHJlc291cmNlLlxuXHRcdFx0Ly8gcmVxdWlyZTogRnVuY3Rpb25cblx0XHRcdC8vXHRcdE9iamVjdCB0aGF0IGluY2x1ZGUgdGhlIGZ1bmN0aW9uIHRvVXJsIHdpdGggZ2l2ZW4gaWQgcmV0dXJucyBhIHZhbGlkIFVSTCBmcm9tIHdoaWNoIHRvIGxvYWQgdGhlIHRleHQuXG5cdFx0XHQvLyBsb2FkOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQsIHdoZW4gdGhlIGxvYWRpbmcgZmluaXNoZWQuXG5cblx0XHRcdC8vIGlkIGlzIHNvbWV0aGluZyBsaWtlIChwYXRoIGlzIGFsd2F5cyBhYnNvbHV0ZSk6XG5cdFx0XHQvL1xuXHRcdFx0Ly9cdCBcInBhdGgvdG8vdGV4dC5odG1sXCJcblx0XHRcdC8vXHQgXCJwYXRoL3RvL3RleHQuaHRtbCFzdHJpcFwiXG5cdFx0XHR2YXJcblx0XHRcdFx0cGFydHM9IGlkLnNwbGl0KFwiIVwiKSxcblx0XHRcdFx0c3RyaXBGbGFnPSBwYXJ0cy5sZW5ndGg+MSxcblx0XHRcdFx0YWJzTWlkPSBwYXJ0c1swXSxcblx0XHRcdFx0dXJsID0gcmVxdWlyZS50b1VybChwYXJ0c1swXSksXG5cdFx0XHRcdHJlcXVpcmVDYWNoZVVybCA9IFwidXJsOlwiICsgdXJsLFxuXHRcdFx0XHR0ZXh0ID0gbm90Rm91bmQsXG5cdFx0XHRcdGZpbmlzaCA9IGZ1bmN0aW9uKHRleHQpe1xuXHRcdFx0XHRcdGxvYWQoc3RyaXBGbGFnID8gc3RyaXAodGV4dCkgOiB0ZXh0KTtcblx0XHRcdFx0fTtcblx0XHRcdGlmKGFic01pZCBpbiB0aGVDYWNoZSl7XG5cdFx0XHRcdHRleHQgPSB0aGVDYWNoZVthYnNNaWRdO1xuXHRcdFx0fWVsc2UgaWYocmVxdWlyZS5jYWNoZSAmJiByZXF1aXJlQ2FjaGVVcmwgaW4gcmVxdWlyZS5jYWNoZSl7XG5cdFx0XHRcdHRleHQgPSByZXF1aXJlLmNhY2hlW3JlcXVpcmVDYWNoZVVybF07XG5cdFx0XHR9ZWxzZSBpZih1cmwgaW4gdGhlQ2FjaGUpe1xuXHRcdFx0XHR0ZXh0ID0gdGhlQ2FjaGVbdXJsXTtcblx0XHRcdH1cblx0XHRcdGlmKHRleHQ9PT1ub3RGb3VuZCl7XG5cdFx0XHRcdGlmKHBlbmRpbmdbdXJsXSl7XG5cdFx0XHRcdFx0cGVuZGluZ1t1cmxdLnB1c2goZmluaXNoKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dmFyIHBlbmRpbmdMaXN0ID0gcGVuZGluZ1t1cmxdID0gW2ZpbmlzaF07XG5cdFx0XHRcdFx0Z2V0VGV4dCh1cmwsICFyZXF1aXJlLmFzeW5jLCBmdW5jdGlvbih0ZXh0KXtcblx0XHRcdFx0XHRcdHRoZUNhY2hlW2Fic01pZF09IHRoZUNhY2hlW3VybF09IHRleHQ7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpPHBlbmRpbmdMaXN0Lmxlbmd0aDspe1xuXHRcdFx0XHRcdFx0XHRwZW5kaW5nTGlzdFtpKytdKHRleHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHBlbmRpbmdbdXJsXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGZpbmlzaCh0ZXh0KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cbn0pO1xuXG4iLCJkZWZpbmUoW1wiLi9FdmVudGVkXCJdLCBmdW5jdGlvbihFdmVudGVkKXtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vdG9waWNcblxuXHR2YXIgaHViID0gbmV3IEV2ZW50ZWQ7XG5cdHJldHVybiB7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRQdWJzdWIgaHViLlxuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0fCBcdHRvcGljLnN1YnNjcmliZShcInNvbWUvdG9waWNcIiwgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdC8vXHRcdHxcdC4uLiBkbyBzb21ldGhpbmcgd2l0aCBldmVudFxuXHRcdC8vXHRcdHxcdH0pO1xuXHRcdC8vXHRcdHxcdHRvcGljLnB1Ymxpc2goXCJzb21lL3RvcGljXCIsIHtuYW1lOlwic29tZSBldmVudFwiLCAuLi59KTtcblxuXHRcdHB1Ymxpc2g6IGZ1bmN0aW9uKHRvcGljLCBldmVudCl7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UHVibGlzaGVzIGEgbWVzc2FnZSB0byBhIHRvcGljIG9uIHRoZSBwdWIvc3ViIGh1Yi4gQWxsIGFyZ3VtZW50cyBhZnRlclxuXHRcdFx0Ly9cdFx0dGhlIGZpcnN0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBzdWJzY3JpYmVycywgc28gYW55IG51bWJlciBvZiBhcmd1bWVudHNcblx0XHRcdC8vXHRcdGNhbiBiZSBwcm92aWRlZCAobm90IGp1c3QgZXZlbnQpLlxuXHRcdFx0Ly8gdG9waWM6IFN0cmluZ1xuXHRcdFx0Ly9cdFx0VGhlIG5hbWUgb2YgdGhlIHRvcGljIHRvIHB1Ymxpc2ggdG9cblx0XHRcdC8vIGV2ZW50OiBPYmplY3Rcblx0XHRcdC8vXHRcdEFuIGV2ZW50IHRvIGRpc3RyaWJ1dGUgdG8gdGhlIHRvcGljIGxpc3RlbmVyc1xuXHRcdFx0cmV0dXJuIGh1Yi5lbWl0LmFwcGx5KGh1YiwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0c3Vic2NyaWJlOiBmdW5jdGlvbih0b3BpYywgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFN1YnNjcmliZXMgdG8gYSB0b3BpYyBvbiB0aGUgcHViL3N1YiBodWJcblx0XHRcdC8vIHRvcGljOiBTdHJpbmdcblx0XHRcdC8vXHRcdFRoZSB0b3BpYyB0byBzdWJzY3JpYmUgdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0QSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBtZXNzYWdlIGlzIHB1Ymxpc2hlZCB0byB0aGUgZ2l2ZW4gdG9waWNcblx0XHRcdHJldHVybiBodWIub24uYXBwbHkoaHViLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2Uva2VybmVsXCIsIFwiLi9hc3BlY3RcIiwgXCIuL2RvbVwiLCBcIi4vZG9tLWNsYXNzXCIsIFwiLi9fYmFzZS9sYW5nXCIsIFwiLi9vblwiLCBcIi4vaGFzXCIsIFwiLi9tb3VzZVwiLCBcIi4vZG9tUmVhZHlcIiwgXCIuL19iYXNlL3dpbmRvd1wiXSxcbmZ1bmN0aW9uKGRvam8sIGFzcGVjdCwgZG9tLCBkb21DbGFzcywgbGFuZywgb24sIGhhcywgbW91c2UsIGRvbVJlYWR5LCB3aW4pe1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby90b3VjaFxuXG5cdHZhciBpb3M0ID0gaGFzKFwiaW9zXCIpIDwgNTtcblxuXHQvLyBEZXRlY3QgaWYgcGxhdGZvcm0gc3VwcG9ydHMgUG9pbnRlciBFdmVudHMsIGFuZCBpZiBzbywgdGhlIG5hbWVzIG9mIHRoZSBldmVudHMgKHBvaW50ZXJkb3duIHZzLiBNU1BvaW50ZXJEb3duKS5cblx0dmFyIGhhc1BvaW50ZXIgPSBoYXMoXCJwb2ludGVyLWV2ZW50c1wiKSB8fCBoYXMoXCJNU1BvaW50ZXJcIiksXG5cdFx0cG9pbnRlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9pbnRlciA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB7IGRvd246IDEsIG1vdmU6IDEsIHVwOiAxLCBjYW5jZWw6IDEsIG92ZXI6IDEsIG91dDogMSB9KSB7XG5cdFx0XHRcdHBvaW50ZXJbdHlwZV0gPSBoYXMoXCJNU1BvaW50ZXJcIikgP1xuXHRcdFx0XHRcdFwiTVNQb2ludGVyXCIgKyB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSA6XG5cdFx0XHRcdFx0XCJwb2ludGVyXCIgKyB0eXBlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvaW50ZXI7XG5cdFx0fSkoKTtcblxuXHQvLyBEZXRlY3QgaWYgcGxhdGZvcm0gc3VwcG9ydHMgdGhlIHdlYmtpdCB0b3VjaHN0YXJ0L3RvdWNoZW5kLy4uLiBldmVudHNcblx0dmFyIGhhc1RvdWNoID0gaGFzKFwidG91Y2gtZXZlbnRzXCIpO1xuXG5cdC8vIENsaWNrIGdlbmVyYXRpb24gdmFyaWFibGVzXG5cdHZhciBjbGlja3NJbml0ZWQsIGNsaWNrVHJhY2tlciwgdXNlVGFyZ2V0ID0gZmFsc2UsIGNsaWNrVGFyZ2V0LCBjbGlja1gsIGNsaWNrWSwgY2xpY2tEeCwgY2xpY2tEeSwgY2xpY2tUaW1lO1xuXG5cdC8vIFRpbWUgb2YgbW9zdCByZWNlbnQgdG91Y2hzdGFydCwgdG91Y2htb3ZlLCBvciB0b3VjaGVuZCBldmVudFxuXHR2YXIgbGFzdFRvdWNoO1xuXG5cdGZ1bmN0aW9uIGR1YWxFdmVudChtb3VzZVR5cGUsIHRvdWNoVHlwZSwgcG9pbnRlclR5cGUpe1xuXHRcdC8vIFJldHVybnMgc3ludGhldGljIGV2ZW50IHRoYXQgbGlzdGVucyBmb3IgYm90aCB0aGUgc3BlY2lmaWVkIG1vdXNlIGV2ZW50IGFuZCBzcGVjaWZpZWQgdG91Y2ggZXZlbnQuXG5cdFx0Ly8gQnV0IGlnbm9yZSBmYWtlIG1vdXNlIGV2ZW50cyB0aGF0IHdlcmUgZ2VuZXJhdGVkIGR1ZSB0byB0aGUgdXNlciB0b3VjaGluZyB0aGUgc2NyZWVuLlxuXHRcdGlmKGhhc1BvaW50ZXIgJiYgcG9pbnRlclR5cGUpe1xuXHRcdFx0Ly8gSUUxMCs6IE1TUG9pbnRlciogZXZlbnRzIGFyZSBkZXNpZ25lZCB0byBoYW5kbGUgYm90aCBtb3VzZSBhbmQgdG91Y2ggaW4gYSB1bmlmb3JtIHdheSxcblx0XHRcdC8vIHNvIGp1c3QgdXNlIHRoYXQgcmVnYXJkbGVzcyBvZiBoYXNUb3VjaC5cblx0XHRcdHJldHVybiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHRcdHJldHVybiBvbihub2RlLCBwb2ludGVyVHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0fTtcblx0XHR9ZWxzZSBpZihoYXNUb3VjaCl7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0XHR2YXIgaGFuZGxlMSA9IG9uKG5vZGUsIHRvdWNoVHlwZSwgZnVuY3Rpb24oZXZ0KXtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGwodGhpcywgZXZ0KTtcblxuXHRcdFx0XHRcdFx0Ly8gT24gc2xvdyBtb2JpbGUgYnJvd3NlcnMgKHNlZSBodHRwczovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNzYzNCksXG5cdFx0XHRcdFx0XHQvLyBhIGhhbmRsZXIgZm9yIGEgdG91Y2ggZXZlbnQgbWF5IHRha2UgPjFzIHRvIHJ1bi4gIFRoYXQgdGltZSBzaG91bGRuJ3Rcblx0XHRcdFx0XHRcdC8vIGJlIGluY2x1ZGVkIGluIHRoZSBjYWxjdWxhdGlvbiBmb3IgbGFzdFRvdWNoLlxuXHRcdFx0XHRcdFx0bGFzdFRvdWNoID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRoYW5kbGUyID0gb24obm9kZSwgbW91c2VUeXBlLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0aWYoIWxhc3RUb3VjaCB8fCAobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gbGFzdFRvdWNoICsgMTAwMCl7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRoYW5kbGUxLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0aGFuZGxlMi5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH1lbHNle1xuXHRcdFx0Ly8gQXZvaWQgY3JlYXRpbmcgbGlzdGVuZXJzIGZvciB0b3VjaCBldmVudHMgb24gcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIG9sZGVyIGJyb3dzZXJzIGxpa2UgSUU2XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0XHRyZXR1cm4gb24obm9kZSwgbW91c2VUeXBlLCBsaXN0ZW5lcik7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtlZCgvKkRPTU5vZGUqLyBub2RlKXtcblx0XHQvLyBTZWFyY2ggZm9yIG5vZGUgYW5jZXN0b3IgaGFzIGJlZW4gbWFya2VkIHdpdGggdGhlIGRvam9DbGljayBwcm9wZXJ0eSB0byBpbmRpY2F0ZSBzcGVjaWFsIHByb2Nlc3NpbmcuXG5cdFx0Ly8gUmV0dXJucyBtYXJrZWQgYW5jZXN0b3IuXG5cdFx0ZG97XG5cdFx0XHRpZihub2RlLmRvam9DbGljayAhPT0gdW5kZWZpbmVkKXsgcmV0dXJuIG5vZGU7IH1cblx0XHR9d2hpbGUobm9kZSA9IG5vZGUucGFyZW50Tm9kZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkb0NsaWNrcyhlLCBtb3ZlVHlwZSwgZW5kVHlwZSl7XG5cdFx0Ly8gc3VtbWFyeTpcblx0XHQvL1x0XHRTZXR1cCB0b3VjaCBsaXN0ZW5lcnMgdG8gZ2VuZXJhdGUgc3ludGhldGljIGNsaWNrcyBpbW1lZGlhdGVseSAocmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgdGhlIGJyb3dzZXJcblx0XHQvL1x0XHR0byBnZW5lcmF0ZSBjbGlja3MgYWZ0ZXIgdGhlIGRvdWJsZS10YXAgZGVsYXkpIGFuZCBjb25zaXN0ZW50bHkgKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0Ly9cdFx0d2FzIGNhbGxlZCBpbiBhbiBldmVudCBsaXN0ZW5lci4gU3ludGhldGljIGNsaWNrcyBhcmUgZ2VuZXJhdGVkIG9ubHkgaWYgYSBub2RlIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhc1xuXHRcdC8vXHRcdGl0cyBkb2pvQ2xpY2sgcHJvcGVydHkgc2V0IHRvIHRydXRoeS4gSWYgYSBub2RlIHJlY2VpdmVzIHN5bnRoZXRpYyBjbGlja3MgYmVjYXVzZSBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgaXRzXG5cdFx0Ly8gICAgICBkb2pvQ2xpY2sgcHJvcGVydHkgc2V0IHRvIHRydXRoeSwgeW91IGNhbiBkaXNhYmxlIHN5bnRoZXRpYyBjbGlja3Mgb24gdGhpcyBub2RlIGJ5IHNldHRpbmcgaXRzIG93biBkb2pvQ2xpY2sgcHJvcGVydHlcblx0XHQvLyAgICAgIHRvIGZhbHN5LlxuXG5cdFx0aWYobW91c2UuaXNSaWdodChlKSl7XG5cdFx0XHRyZXR1cm47XHRcdC8vIGF2b2lkIHNwdXJpb3VzIGRvam9jbGljayBldmVudCBvbiBJRTEwKzsgcmlnaHQgY2xpY2sgaXMganVzdCBmb3IgY29udGV4dCBtZW51XG5cdFx0fVxuXG5cdFx0dmFyIG1hcmtlZE5vZGUgPSBtYXJrZWQoZS50YXJnZXQpO1xuXHRcdGNsaWNrVHJhY2tlciAgPSAhZS50YXJnZXQuZGlzYWJsZWQgJiYgbWFya2VkTm9kZSAmJiBtYXJrZWROb2RlLmRvam9DbGljazsgLy8gY2xpY2sgdGhyZXNob2xkID0gdHJ1ZSwgbnVtYmVyLCB4L3kgb2JqZWN0LCBvciBcInVzZVRhcmdldFwiXG5cdFx0aWYoY2xpY2tUcmFja2VyKXtcblx0XHRcdHVzZVRhcmdldCA9IChjbGlja1RyYWNrZXIgPT0gXCJ1c2VUYXJnZXRcIik7XG5cdFx0XHRjbGlja1RhcmdldCA9ICh1c2VUYXJnZXQ/bWFya2VkTm9kZTplLnRhcmdldCk7XG5cdFx0XHRpZih1c2VUYXJnZXQpe1xuXHRcdFx0XHQvLyBXZSBleHBlY3QgYSBjbGljaywgc28gcHJldmVudCBhbnkgb3RoZXJcblx0XHRcdFx0Ly8gZGVmYXVsdCBhY3Rpb24gb24gXCJ0b3VjaHByZXNzXCJcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0Y2xpY2tYID0gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW4uZ2xvYmFsLnBhZ2VYT2Zmc2V0IDogZS5jbGllbnRYO1xuXHRcdFx0Y2xpY2tZID0gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSB3aW4uZ2xvYmFsLnBhZ2VZT2Zmc2V0IDogZS5jbGllbnRZO1xuXHRcdFx0Y2xpY2tEeCA9ICh0eXBlb2YgY2xpY2tUcmFja2VyID09IFwib2JqZWN0XCIgPyBjbGlja1RyYWNrZXIueCA6ICh0eXBlb2YgY2xpY2tUcmFja2VyID09IFwibnVtYmVyXCIgPyBjbGlja1RyYWNrZXIgOiAwKSkgfHwgNDtcblx0XHRcdGNsaWNrRHkgPSAodHlwZW9mIGNsaWNrVHJhY2tlciA9PSBcIm9iamVjdFwiID8gY2xpY2tUcmFja2VyLnkgOiAodHlwZW9mIGNsaWNrVHJhY2tlciA9PSBcIm51bWJlclwiID8gY2xpY2tUcmFja2VyIDogMCkpIHx8IDQ7XG5cblx0XHRcdC8vIGFkZCBtb3ZlL2VuZCBoYW5kbGVycyBvbmx5IHRoZSBmaXJzdCB0aW1lIGEgbm9kZSB3aXRoIGRvam9DbGljayBpcyBzZWVuLFxuXHRcdFx0Ly8gc28gd2UgZG9uJ3QgYWRkIHRvbyBtdWNoIG92ZXJoZWFkIHdoZW4gZG9qb0NsaWNrIGlzIG5ldmVyIHNldC5cblx0XHRcdGlmKCFjbGlja3NJbml0ZWQpe1xuXHRcdFx0XHRjbGlja3NJbml0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHVwZGF0ZUNsaWNrVHJhY2tlcihlKXtcblx0XHRcdFx0XHRpZih1c2VUYXJnZXQpe1xuXHRcdFx0XHRcdFx0Y2xpY2tUcmFja2VyID0gZG9tLmlzRGVzY2VuZGFudChcblx0XHRcdFx0XHRcdFx0d2luLmRvYy5lbGVtZW50RnJvbVBvaW50KFxuXHRcdFx0XHRcdFx0XHRcdChlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbi5nbG9iYWwucGFnZVhPZmZzZXQgOiBlLmNsaWVudFgpLFxuXHRcdFx0XHRcdFx0XHRcdChlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbi5nbG9iYWwucGFnZVlPZmZzZXQgOiBlLmNsaWVudFkpKSxcblx0XHRcdFx0XHRcdFx0Y2xpY2tUYXJnZXQpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Y2xpY2tUcmFja2VyID0gY2xpY2tUcmFja2VyICYmXG5cdFx0XHRcdFx0XHRcdChlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXS50YXJnZXQgOiBlLnRhcmdldCkgPT0gY2xpY2tUYXJnZXQgJiZcblx0XHRcdFx0XHRcdFx0TWF0aC5hYnMoKGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luLmdsb2JhbC5wYWdlWE9mZnNldCA6IGUuY2xpZW50WCkgLSBjbGlja1gpIDw9IGNsaWNrRHggJiZcblx0XHRcdFx0XHRcdFx0TWF0aC5hYnMoKGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luLmdsb2JhbC5wYWdlWU9mZnNldCA6IGUuY2xpZW50WSkgLSBjbGlja1kpIDw9IGNsaWNrRHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0d2luLmRvYy5hZGRFdmVudExpc3RlbmVyKG1vdmVUeXBlLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRpZihtb3VzZS5pc1JpZ2h0KGUpKXtcblx0XHRcdFx0XHRcdHJldHVybjtcdFx0Ly8gYXZvaWQgc3B1cmlvdXMgZG9qb2NsaWNrIGV2ZW50IG9uIElFMTArOyByaWdodCBjbGljayBpcyBqdXN0IGZvciBjb250ZXh0IG1lbnVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXBkYXRlQ2xpY2tUcmFja2VyKGUpO1xuXHRcdFx0XHRcdGlmKHVzZVRhcmdldCl7XG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG5hdGl2ZSBzY3JvbGwgZXZlbnQgYW5kIGVuc3VyZSB0b3VjaGVuZCBpc1xuXHRcdFx0XHRcdFx0Ly8gZmlyZSBhZnRlciB0b3VjaCBtb3ZlcyBiZXR3ZWVuIHByZXNzIGFuZCByZWxlYXNlLlxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHRcdFx0d2luLmRvYy5hZGRFdmVudExpc3RlbmVyKGVuZFR5cGUsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdGlmKG1vdXNlLmlzUmlnaHQoZSkpe1xuXHRcdFx0XHRcdFx0cmV0dXJuO1x0XHQvLyBhdm9pZCBzcHVyaW91cyBkb2pvY2xpY2sgZXZlbnQgb24gSUUxMCs7IHJpZ2h0IGNsaWNrIGlzIGp1c3QgZm9yIGNvbnRleHQgbWVudVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR1cGRhdGVDbGlja1RyYWNrZXIoZSk7XG5cdFx0XHRcdFx0aWYoY2xpY2tUcmFja2VyKXtcblx0XHRcdFx0XHRcdGNsaWNrVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gKHVzZVRhcmdldD9jbGlja1RhcmdldDplLnRhcmdldCk7XG5cdFx0XHRcdFx0XHRpZih0YXJnZXQudGFnTmFtZSA9PT0gXCJMQUJFTFwiKXtcblx0XHRcdFx0XHRcdFx0Ly8gd2hlbiBjbGlja2luZyBvbiBhIGxhYmVsLCBmb3J3YXJkIGNsaWNrIHRvIGl0cyBhc3NvY2lhdGVkIGlucHV0IGlmIGFueVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBkb20uYnlJZCh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9yXCIpKSB8fCB0YXJnZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3NvbWUgYXR0cmlidXRlcyBjYW4gYmUgb24gdGhlIFRvdWNoIG9iamVjdCwgbm90IG9uIHRoZSBFdmVudDpcblx0XHRcdFx0XHRcdC8vaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLyN0b3VjaC1pbnRlcmZhY2Vcblx0XHRcdFx0XHRcdHZhciBzcmMgPSAoZS5jaGFuZ2VkVG91Y2hlcykgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZU1vdXNlRXZlbnQodHlwZSl7XG5cdFx0XHRcdFx0XHRcdC8vY3JlYXRlIHRoZSBzeW50aGV0aWMgZXZlbnQuXG5cdFx0XHRcdFx0XHRcdC8vaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyN3aWRsLU1vdXNlRXZlbnQtaW5pdE1vdXNlRXZlbnRcblx0XHRcdFx0XHRcdFx0dmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG5cdFx0XHRcdFx0XHRcdGV2dC5fZG9qb19jbGljayA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGV2dC5pbml0TW91c2VFdmVudCh0eXBlLFxuXHRcdFx0XHRcdFx0XHRcdHRydWUsIC8vYnViYmxlc1xuXHRcdFx0XHRcdFx0XHRcdHRydWUsIC8vY2FuY2VsYWJsZVxuXHRcdFx0XHRcdFx0XHRcdGUudmlldyxcblx0XHRcdFx0XHRcdFx0XHRlLmRldGFpbCxcblx0XHRcdFx0XHRcdFx0XHRzcmMuc2NyZWVuWCxcblx0XHRcdFx0XHRcdFx0XHRzcmMuc2NyZWVuWSxcblx0XHRcdFx0XHRcdFx0XHRzcmMuY2xpZW50WCxcblx0XHRcdFx0XHRcdFx0XHRzcmMuY2xpZW50WSxcblx0XHRcdFx0XHRcdFx0XHRlLmN0cmxLZXksXG5cdFx0XHRcdFx0XHRcdFx0ZS5hbHRLZXksXG5cdFx0XHRcdFx0XHRcdFx0ZS5zaGlmdEtleSxcblx0XHRcdFx0XHRcdFx0XHRlLm1ldGFLZXksXG5cdFx0XHRcdFx0XHRcdFx0MCwgLy9idXR0b25cblx0XHRcdFx0XHRcdFx0XHRudWxsIC8vcmVsYXRlZCB0YXJnZXRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV2dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBtb3VzZURvd25FdnQgPSBjcmVhdGVNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIpO1xuXHRcdFx0XHRcdFx0dmFyIG1vdXNlVXBFdnQgPSBjcmVhdGVNb3VzZUV2ZW50KFwibW91c2V1cFwiKTtcblx0XHRcdFx0XHRcdHZhciBjbGlja0V2dCA9IGNyZWF0ZU1vdXNlRXZlbnQoXCJjbGlja1wiKTtcblxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRvbi5lbWl0KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgbW91c2VEb3duRXZ0KTtcblx0XHRcdFx0XHRcdFx0b24uZW1pdCh0YXJnZXQsIFwibW91c2V1cFwiLCBtb3VzZVVwRXZ0KTtcblx0XHRcdFx0XHRcdFx0b24uZW1pdCh0YXJnZXQsIFwiY2xpY2tcIiwgY2xpY2tFdnQpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZnJlc2ggY2xpY2tUaW1lIGluIGNhc2UgYXBwLWRlZmluZWQgY2xpY2sgaGFuZGxlciB0b29rIGEgbG9uZyB0aW1lIHRvIHJ1blxuXHRcdFx0XHRcdFx0XHRjbGlja1RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0cnVlKTtcblxuXHRcdFx0XHRmdW5jdGlvbiBzdG9wTmF0aXZlRXZlbnRzKHR5cGUpe1xuXHRcdFx0XHRcdHdpbi5kb2MuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdC8vIFN0b3AgbmF0aXZlIGV2ZW50cyB3aGVuIHdlIGVtaXR0ZWQgb3VyIG93biBjbGljayBldmVudC4gIE5vdGUgdGhhdCB0aGUgbmF0aXZlIGNsaWNrIG1heSBvY2N1clxuXHRcdFx0XHRcdFx0Ly8gb24gYSBkaWZmZXJlbnQgbm9kZSB0aGFuIHRoZSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgd2FzIGdlbmVyYXRlZCBvbi4gIEZvciBleGFtcGxlLFxuXHRcdFx0XHRcdFx0Ly8gY2xpY2sgb24gYSBtZW51IGl0ZW0sIGNhdXNpbmcgdGhlIG1lbnUgdG8gZGlzYXBwZWFyLCBhbmQgdGhlbiAofjMwMG1zIGxhdGVyKSB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdFx0Ly8gc2VuZHMgYSBjbGljayBldmVudCB0byB0aGUgbm9kZSB0aGF0IHdhcyAqdW5kZXJuZWF0aCogdGhlIG1lbnUuICBTbyBzdG9wIGFsbCBuYXRpdmUgZXZlbnRzXG5cdFx0XHRcdFx0XHQvLyBzZW50IHNob3J0bHkgYWZ0ZXIgb3Vycywgc2ltaWxhciB0byB3aGF0IGlzIGRvbmUgaW4gZHVhbEV2ZW50LlxuXHRcdFx0XHRcdFx0Ly8gVGhlIElOUFVULmRpaml0T2ZmU2NyZWVuIHRlc3QgaXMgZm9yIG9mZnNjcmVlbiBpbnB1dHMgdXNlZCBpbiBkaWppdC9mb3JtL0J1dHRvbiwgb24gd2hpY2hcblx0XHRcdFx0XHRcdC8vIHdlIGNhbGwgY2xpY2soKSBleHBsaWNpdGx5LCB3ZSBkb24ndCB3YW50IHRvIHN0b3AgdGhpcyBldmVudC5cblx0XHRcdFx0XHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldDtcblx0XHRcdFx0XHRcdGlmKGNsaWNrVHJhY2tlciAmJiAhZS5fZG9qb19jbGljayAmJlxuXHRcdFx0XHRcdFx0XHRcdChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPD0gY2xpY2tUaW1lICsgMTAwMCAmJlxuXHRcdFx0XHRcdFx0XHRcdCEodGFyZ2V0LnRhZ05hbWUgPT0gXCJJTlBVVFwiICYmIGRvbUNsYXNzLmNvbnRhaW5zKHRhcmdldCwgXCJkaWppdE9mZlNjcmVlblwiKSkpe1xuXHRcdFx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRpZih0eXBlID09IFwiY2xpY2tcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdCh0YXJnZXQudGFnTmFtZSAhPSBcIklOUFVUXCIgfHxcblx0XHRcdFx0XHRcdFx0XHQodGFyZ2V0LnR5cGUgPT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAjMTgzNTIgRG8gbm90IHByZXZlbnREZWZhdWx0IGZvciByYWRpb3MgdGhhdCBhcmUgbm90IGRpaml0IG9yXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkb2pveC9tb2JpbGUgd2lkZ2V0cy5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIChUaGUgQ1NTIGNsYXNzIGRpaml0Q2hlY2tCb3hJbnB1dCBob2xkcyBmb3IgYm90aCBjaGVja2JveGVzIGFuZCByYWRpbyBidXR0b25zLilcblx0XHRcdFx0XHRcdFx0XHRcdChkb21DbGFzcy5jb250YWlucyh0YXJnZXQsIFwiZGlqaXRDaGVja0JveElucHV0XCIpIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRvbUNsYXNzLmNvbnRhaW5zKHRhcmdldCwgXCJtYmxSYWRpb0J1dHRvblwiKSkpIHx8XG5cdFx0XHRcdFx0XHRcdFx0KHRhcmdldC50eXBlID09IFwiY2hlY2tib3hcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gIzE4MzUyIERvIG5vdCBwcmV2ZW50RGVmYXVsdCBmb3IgY2hlY2tib3hlcyB0aGF0IGFyZSBub3QgZGlqaXQgb3Jcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGRvam94L21vYmlsZSB3aWRnZXRzLlxuXHRcdFx0XHRcdFx0XHRcdFx0KGRvbUNsYXNzLmNvbnRhaW5zKHRhcmdldCwgXCJkaWppdENoZWNrQm94SW5wdXRcIikgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZG9tQ2xhc3MuY29udGFpbnModGFyZ2V0LCBcIm1ibENoZWNrQm94XCIpKSkpICYmXG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnRhZ05hbWUgIT0gXCJURVhUQVJFQVwiICYmIHRhcmdldC50YWdOYW1lICE9IFwiQVVESU9cIiAmJiB0YXJnZXQudGFnTmFtZSAhPSBcIlZJREVPXCIpe1xuXHRcdFx0XHRcdFx0XHRcdC8vIHByZXZlbnREZWZhdWx0KCkgYnJlYWtzIHRleHR1YWwgPGlucHV0PnMgb24gYW5kcm9pZCwga2V5Ym9hcmQgZG9lc24ndCBwb3B1cCxcblx0XHRcdFx0XHRcdFx0XHQvLyBidXQgaXQgaXMgc3RpbGwgbmVlZGVkIGZvciBjaGVja2JveGVzIGFuZCByYWRpbyBidXR0b25zLCBvdGhlcndpc2UgaW4gc29tZSBjYXNlc1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBjaGVja2VkIHN0YXRlIGJlY29tZXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIHdpZGdldCdzIHN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdG9wTmF0aXZlRXZlbnRzKFwiY2xpY2tcIik7XG5cblx0XHRcdFx0Ly8gV2UgYWxzbyBzdG9wIG1vdXNlZG93bi91cCBzaW5jZSB0aGVzZSB3b3VsZCBiZSBzZW50IHdlbGwgYWZ0ZXIgd2l0aCBvdXIgXCJmYXN0XCIgY2xpY2sgKDMwMG1zKSxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGNvbmZ1c2Ugc29tZSBkaWppdCB3aWRnZXRzLlxuXHRcdFx0XHRzdG9wTmF0aXZlRXZlbnRzKFwibW91c2Vkb3duXCIpO1xuXHRcdFx0XHRzdG9wTmF0aXZlRXZlbnRzKFwibW91c2V1cFwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgaG92ZXJlZE5vZGU7XG5cblx0aWYoaGFzKFwidG91Y2hcIikpe1xuXHRcdGlmKGhhc1BvaW50ZXIpe1xuXHRcdFx0Ly8gTVNQb2ludGVyIChJRTEwKykgYWxyZWFkeSBoYXMgc3VwcG9ydCBmb3Igb3ZlciBhbmQgb3V0LCBzbyB3ZSBqdXN0IG5lZWQgdG8gaW5pdCBjbGljayBzdXBwb3J0XG5cdFx0XHRkb21SZWFkeShmdW5jdGlvbigpe1xuXHRcdFx0XHR3aW4uZG9jLmFkZEV2ZW50TGlzdGVuZXIocG9pbnRlci5kb3duLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdGRvQ2xpY2tzKGV2dCwgcG9pbnRlci5tb3ZlLCBwb2ludGVyLnVwKTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHR9KTtcblx0XHR9ZWxzZXtcblx0XHRcdGRvbVJlYWR5KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgY3VycmVudGx5IGhvdmVyZWQgbm9kZVxuXHRcdFx0XHRob3ZlcmVkTm9kZSA9IHdpbi5ib2R5KCk7XHQvLyBjdXJyZW50bHkgaG92ZXJlZCBub2RlXG5cblx0XHRcdFx0d2luLmRvYy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihldnQpe1xuXHRcdFx0XHRcdFx0bGFzdFRvdWNoID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdC8vIFByZWNlZGUgdG91Y2hzdGFydCBldmVudCB3aXRoIHRvdWNoLm92ZXIgZXZlbnQuICBEbkQgZGVwZW5kcyBvbiB0aGlzLlxuXHRcdFx0XHRcdC8vIFVzZSBhZGRFdmVudExpc3RlbmVyKGNiLCB0cnVlKSB0byBydW4gY2IgYmVmb3JlIGFueSB0b3VjaHN0YXJ0IGhhbmRsZXJzIG9uIG5vZGUgcnVuLFxuXHRcdFx0XHRcdC8vIGFuZCB0byBlbnN1cmUgdGhpcyBjb2RlIHJ1bnMgZXZlbiBpZiB0aGUgbGlzdGVuZXIgb24gdGhlIG5vZGUgZG9lcyBldmVudC5zdG9wKCkuXG5cdFx0XHRcdFx0dmFyIG9sZE5vZGUgPSBob3ZlcmVkTm9kZTtcblx0XHRcdFx0XHRob3ZlcmVkTm9kZSA9IGV2dC50YXJnZXQ7XG5cdFx0XHRcdFx0b24uZW1pdChvbGROb2RlLCBcImRvam90b3VjaG91dFwiLCB7XG5cdFx0XHRcdFx0XHRyZWxhdGVkVGFyZ2V0OiBob3ZlcmVkTm9kZSxcblx0XHRcdFx0XHRcdGJ1YmJsZXM6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRvbi5lbWl0KGhvdmVyZWROb2RlLCBcImRvam90b3VjaG92ZXJcIiwge1xuXHRcdFx0XHRcdFx0cmVsYXRlZFRhcmdldDogb2xkTm9kZSxcblx0XHRcdFx0XHRcdGJ1YmJsZXM6IHRydWVcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGRvQ2xpY2tzKGV2dCwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiKTsgLy8gaW5pdCBjbGljayBnZW5lcmF0aW9uXG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGNvcHlFdmVudFByb3BzKGV2dCl7XG5cdFx0XHRcdFx0Ly8gTWFrZSBjb3B5IG9mIGV2ZW50IG9iamVjdCBhbmQgYWxzbyBzZXQgYnViYmxlczp0cnVlLiAgVXNlZCB3aGVuIGNhbGxpbmcgb24uZW1pdCgpLlxuXHRcdFx0XHRcdHZhciBwcm9wcyA9IGxhbmcuZGVsZWdhdGUoZXZ0LCB7XG5cdFx0XHRcdFx0XHRidWJibGVzOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZihoYXMoXCJpb3NcIikgPj0gNil7XG5cdFx0XHRcdFx0XHQvLyBPbiBpT1M2IFwidG91Y2hlc1wiIGJlY2FtZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LCB3aGljaFxuXHRcdFx0XHRcdFx0Ly8gaXMgbm90IGhpdCBieSBmb3IuLi5pbi4gIERpdHRvIGZvciB0aGUgb3RoZXIgcHJvcGVydGllcyBiZWxvdy5cblx0XHRcdFx0XHRcdHByb3BzLnRvdWNoZXMgPSBldnQudG91Y2hlcztcblx0XHRcdFx0XHRcdHByb3BzLmFsdEtleSA9IGV2dC5hbHRLZXk7XG5cdFx0XHRcdFx0XHRwcm9wcy5jaGFuZ2VkVG91Y2hlcyA9IGV2dC5jaGFuZ2VkVG91Y2hlcztcblx0XHRcdFx0XHRcdHByb3BzLmN0cmxLZXkgPSBldnQuY3RybEtleTtcblx0XHRcdFx0XHRcdHByb3BzLm1ldGFLZXkgPSBldnQubWV0YUtleTtcblx0XHRcdFx0XHRcdHByb3BzLnNoaWZ0S2V5ID0gZXZ0LnNoaWZ0S2V5O1xuXHRcdFx0XHRcdFx0cHJvcHMudGFyZ2V0VG91Y2hlcyA9IGV2dC50YXJnZXRUb3VjaGVzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBwcm9wcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9uKHdpbi5kb2MsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0bGFzdFRvdWNoID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdHZhciBuZXdOb2RlID0gd2luLmRvYy5lbGVtZW50RnJvbVBvaW50KFxuXHRcdFx0XHRcdFx0ZXZ0LnBhZ2VYIC0gKGlvczQgPyAwIDogd2luLmdsb2JhbC5wYWdlWE9mZnNldCksIC8vIGlPUyA0IGV4cGVjdHMgcGFnZSBjb29yZHNcblx0XHRcdFx0XHRcdGV2dC5wYWdlWSAtIChpb3M0ID8gMCA6IHdpbi5nbG9iYWwucGFnZVlPZmZzZXQpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmKG5ld05vZGUpe1xuXHRcdFx0XHRcdFx0Ly8gRmlyZSBzeW50aGV0aWMgdG91Y2hvdmVyIGFuZCB0b3VjaG91dCBldmVudHMgb24gbm9kZXMgc2luY2UgdGhlIGJyb3dzZXIgd29uJ3QgZG8gaXQgbmF0aXZlbHkuXG5cdFx0XHRcdFx0XHRpZihob3ZlcmVkTm9kZSAhPT0gbmV3Tm9kZSl7XG5cdFx0XHRcdFx0XHRcdC8vIHRvdWNoIG91dCBvbiB0aGUgb2xkIG5vZGVcblx0XHRcdFx0XHRcdFx0b24uZW1pdChob3ZlcmVkTm9kZSwgXCJkb2pvdG91Y2hvdXRcIiwge1xuXHRcdFx0XHRcdFx0XHRcdHJlbGF0ZWRUYXJnZXQ6IG5ld05vZGUsXG5cdFx0XHRcdFx0XHRcdFx0YnViYmxlczogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyB0b3VjaG92ZXIgb24gdGhlIG5ldyBub2RlXG5cdFx0XHRcdFx0XHRcdG9uLmVtaXQobmV3Tm9kZSwgXCJkb2pvdG91Y2hvdmVyXCIsIHtcblx0XHRcdFx0XHRcdFx0XHRyZWxhdGVkVGFyZ2V0OiBob3ZlcmVkTm9kZSxcblx0XHRcdFx0XHRcdFx0XHRidWJibGVzOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdGhvdmVyZWROb2RlID0gbmV3Tm9kZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVW5saWtlIGEgbGlzdGVuZXIgb24gXCJ0b3VjaG1vdmVcIiwgb24obm9kZSwgXCJkb2pvdG91Y2htb3ZlXCIsIGxpc3RlbmVyKSBmaXJlcyB3aGVuIHRoZSBmaW5nZXJcblx0XHRcdFx0XHRcdC8vIGRyYWdzIG92ZXIgdGhlIHNwZWNpZmllZCBub2RlLCByZWdhcmRsZXNzIG9mIHdoaWNoIG5vZGUgdGhlIHRvdWNoIHN0YXJ0ZWQgb24uXG5cdFx0XHRcdFx0XHRpZighb24uZW1pdChuZXdOb2RlLCBcImRvam90b3VjaG1vdmVcIiwgY29weUV2ZW50UHJvcHMoZXZ0KSkpe1xuXHRcdFx0XHRcdFx0XHQvLyBlbWl0IHJldHVybnMgZmFsc2Ugd2hlbiBzeW50aGV0aWMgZXZlbnQgXCJkb2pvdG91Y2htb3ZlXCIgaXMgY2FuY2VsbGVkLCBzbyB3ZSBwcmV2ZW50IHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBldmVudCBcInRvdWNobW92ZVwiLlxuXHRcdFx0XHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEZpcmUgYSBkb2pvdG91Y2hlbmQgZXZlbnQgb24gdGhlIG5vZGUgd2hlcmUgdGhlIGZpbmdlciB3YXMgYmVmb3JlIGl0IHdhcyByZW1vdmVkIGZyb20gdGhlIHNjcmVlbi5cblx0XHRcdFx0Ly8gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgbmF0aXZlIHRvdWNoZW5kLCB3aGljaCBmaXJlcyBvbiB0aGUgbm9kZSB3aGVyZSB0aGUgZHJhZyBzdGFydGVkLlxuXHRcdFx0XHRvbih3aW4uZG9jLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRcdFx0XHRsYXN0VG91Y2ggPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdHZhciBub2RlID0gd2luLmRvYy5lbGVtZW50RnJvbVBvaW50KFxuXHRcdFx0XHRcdFx0ZXZ0LnBhZ2VYIC0gKGlvczQgPyAwIDogd2luLmdsb2JhbC5wYWdlWE9mZnNldCksIC8vIGlPUyA0IGV4cGVjdHMgcGFnZSBjb29yZHNcblx0XHRcdFx0XHRcdGV2dC5wYWdlWSAtIChpb3M0ID8gMCA6IHdpbi5nbG9iYWwucGFnZVlPZmZzZXQpXG5cdFx0XHRcdFx0KSB8fCB3aW4uYm9keSgpOyAvLyBpZiBvdXQgb2YgdGhlIHNjcmVlblxuXG5cdFx0XHRcdFx0b24uZW1pdChub2RlLCBcImRvam90b3VjaGVuZFwiLCBjb3B5RXZlbnRQcm9wcyhldnQpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvL2RldmljZSBuZXV0cmFsIGV2ZW50cyAtIHRvdWNoLnByZXNzfG1vdmV8cmVsZWFzZXxjYW5jZWwvb3Zlci9vdXRcblx0dmFyIHRvdWNoID0ge1xuXHRcdHByZXNzOiBkdWFsRXZlbnQoXCJtb3VzZWRvd25cIiwgXCJ0b3VjaHN0YXJ0XCIsIHBvaW50ZXIuZG93biksXG5cdFx0bW92ZTogZHVhbEV2ZW50KFwibW91c2Vtb3ZlXCIsIFwiZG9qb3RvdWNobW92ZVwiLCBwb2ludGVyLm1vdmUpLFxuXHRcdHJlbGVhc2U6IGR1YWxFdmVudChcIm1vdXNldXBcIiwgXCJkb2pvdG91Y2hlbmRcIiwgcG9pbnRlci51cCksXG5cdFx0Y2FuY2VsOiBkdWFsRXZlbnQobW91c2UubGVhdmUsIFwidG91Y2hjYW5jZWxcIiwgaGFzUG9pbnRlciA/IHBvaW50ZXIuY2FuY2VsIDogbnVsbCksXG5cdFx0b3ZlcjogZHVhbEV2ZW50KFwibW91c2VvdmVyXCIsIFwiZG9qb3RvdWNob3ZlclwiLCBwb2ludGVyLm92ZXIpLFxuXHRcdG91dDogZHVhbEV2ZW50KFwibW91c2VvdXRcIiwgXCJkb2pvdG91Y2hvdXRcIiwgcG9pbnRlci5vdXQpLFxuXHRcdGVudGVyOiBtb3VzZS5fZXZlbnRIYW5kbGVyKGR1YWxFdmVudChcIm1vdXNlb3ZlclwiLFwiZG9qb3RvdWNob3ZlclwiLCBwb2ludGVyLm92ZXIpKSxcblx0XHRsZWF2ZTogbW91c2UuX2V2ZW50SGFuZGxlcihkdWFsRXZlbnQoXCJtb3VzZW91dFwiLCBcImRvam90b3VjaG91dFwiLCBwb2ludGVyLm91dCkpXG5cdH07XG5cblx0Lyo9PT09PVxuXHR0b3VjaCA9IHtcblx0XHQvLyBzdW1tYXJ5OlxuXHRcdC8vXHRcdFRoaXMgbW9kdWxlIHByb3ZpZGVzIHVuaWZpZWQgdG91Y2ggZXZlbnQgaGFuZGxlcnMgYnkgZXhwb3J0aW5nXG5cdFx0Ly9cdFx0cHJlc3MsIG1vdmUsIHJlbGVhc2UgYW5kIGNhbmNlbCB3aGljaCBjYW4gYWxzbyBydW4gd2VsbCBvbiBkZXNrdG9wLlxuXHRcdC8vXHRcdEJhc2VkIG9uIGh0dHA6Ly9kdmNzLnczLm9yZy9oZy93ZWJldmVudHMvcmF3LWZpbGUvdGlwL3RvdWNoZXZlbnRzLmh0bWxcblx0XHQvLyAgICAgIEFsc28sIGlmIHRoZSBkb2pvQ2xpY2sgcHJvcGVydHkgaXMgc2V0IHRvIHRydXRoeSBvbiBhIERPTSBub2RlLCBkb2pvL3RvdWNoIGdlbmVyYXRlc1xuXHRcdC8vICAgICAgY2xpY2sgZXZlbnRzIGltbWVkaWF0ZWx5IGZvciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyAoZXhjZXB0IGZvciBkZXNjZW5kYW50cyB0aGF0XG5cdFx0Ly8gICAgICBoYXZlIGEgZG9qb0NsaWNrIHByb3BlcnR5IHNldCB0byBmYWxzeSksIHRvIGF2b2lkIHRoZSBkZWxheSBiZWZvcmUgbmF0aXZlIGJyb3dzZXIgY2xpY2sgZXZlbnRzLFxuXHRcdC8vICAgICAgYW5kIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBldnQucHJldmVudERlZmF1bHQoKSB3YXMgY2FsbGVkIGluIGEgdG91Y2gucHJlc3MgZXZlbnQgbGlzdGVuZXIuXG5cdFx0Ly9cblx0XHQvLyBleGFtcGxlOlxuXHRcdC8vXHRcdFVzZWQgd2l0aCBkb2pvL29uXG5cdFx0Ly9cdFx0fFx0ZGVmaW5lKFtcImRvam8vb25cIiwgXCJkb2pvL3RvdWNoXCJdLCBmdW5jdGlvbihvbiwgdG91Y2gpe1xuXHRcdC8vXHRcdHxcdFx0b24obm9kZSwgdG91Y2gucHJlc3MsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vXHRcdHxcdFx0b24obm9kZSwgdG91Y2gubW92ZSwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly9cdFx0fFx0XHRvbihub2RlLCB0b3VjaC5yZWxlYXNlLCBmdW5jdGlvbihlKXt9KTtcblx0XHQvL1x0XHR8XHRcdG9uKG5vZGUsIHRvdWNoLmNhbmNlbCwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRVc2VkIHdpdGggdG91Y2guKiBkaXJlY3RseVxuXHRcdC8vXHRcdHxcdHRvdWNoLnByZXNzKG5vZGUsIGZ1bmN0aW9uKGUpe30pO1xuXHRcdC8vXHRcdHxcdHRvdWNoLm1vdmUobm9kZSwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly9cdFx0fFx0dG91Y2gucmVsZWFzZShub2RlLCBmdW5jdGlvbihlKXt9KTtcblx0XHQvL1x0XHR8XHR0b3VjaC5jYW5jZWwobm9kZSwgZnVuY3Rpb24oZSl7fSk7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRIYXZlIGRvam8vdG91Y2ggZ2VuZXJhdGUgY2xpY2tzIHdpdGhvdXQgZGVsYXksIHdpdGggYSBkZWZhdWx0IG1vdmUgdGhyZXNob2xkIG9mIDQgcGl4ZWxzXG5cdFx0Ly9cdFx0fFx0bm9kZS5kb2pvQ2xpY2sgPSB0cnVlO1xuXHRcdC8vIGV4YW1wbGU6XG5cdFx0Ly9cdFx0SGF2ZSBkb2pvL3RvdWNoIGdlbmVyYXRlIGNsaWNrcyB3aXRob3V0IGRlbGF5LCB3aXRoIGEgbW92ZSB0aHJlc2hvbGQgb2YgMTAgcGl4ZWxzIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseVxuXHRcdC8vXHRcdHxcdG5vZGUuZG9qb0NsaWNrID0gMTA7XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHRIYXZlIGRvam8vdG91Y2ggZ2VuZXJhdGUgY2xpY2tzIHdpdGhvdXQgZGVsYXksIHdpdGggYSBtb3ZlIHRocmVzaG9sZCBvZiA1MCBwaXhlbHMgaG9yaXpvbnRhbGx5IGFuZCAxMCBwaXhlbHMgdmVydGljYWxseVxuXHRcdC8vXHRcdHxcdG5vZGUuZG9qb0NsaWNrID0ge3g6NTAsIHk6NX07XG5cdFx0Ly8gZXhhbXBsZTpcblx0XHQvL1x0XHREaXNhYmxlIGNsaWNrcyB3aXRob3V0IGRlbGF5IGdlbmVyYXRlZCBieSBkb2pvL3RvdWNoIG9uIGEgbm9kZSB0aGF0IGhhcyBhbiBhbmNlc3RvciB3aXRoIHByb3BlcnR5IGRvam9DbGljayBzZXQgdG8gdHJ1dGh5XG5cdFx0Ly9cdFx0fCAgbm9kZS5kb2pvQ2xpY2sgPSBmYWxzZTtcblxuXHRcdHByZXNzOiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byAndG91Y2hzdGFydCd8J21vdXNlZG93bicgZm9yIHRoZSBnaXZlbiBub2RlXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH0sXG5cdFx0bW92ZTogZnVuY3Rpb24obm9kZSwgbGlzdGVuZXIpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJlZ2lzdGVyIGEgbGlzdGVuZXIgdGhhdCBmaXJlcyB3aGVuIHRoZSBtb3VzZSBjdXJzb3Igb3IgYSBmaW5nZXIgaXMgZHJhZ2dlZCBvdmVyIHRoZSBnaXZlbiBub2RlLlxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdHJlbGVhc2U6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRvIHJlbGVhc2luZyB0aGUgbW91c2UgYnV0dG9uIHdoaWxlIHRoZSBjdXJzb3IgaXMgb3ZlciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly9cdFx0KGkuZS4gXCJtb3VzZXVwXCIpIG9yIGZvciByZW1vdmluZyB0aGUgZmluZ2VyIGZyb20gdGhlIHNjcmVlbiB3aGlsZSB0b3VjaGluZyB0aGUgZ2l2ZW4gbm9kZS5cblx0XHRcdC8vIG5vZGU6IERvbVxuXHRcdFx0Ly9cdFx0VGFyZ2V0IG5vZGUgdG8gbGlzdGVuIHRvXG5cdFx0XHQvLyBsaXN0ZW5lcjogRnVuY3Rpb25cblx0XHRcdC8vXHRcdENhbGxiYWNrIGZ1bmN0aW9uXG5cdFx0XHQvLyByZXR1cm5zOlxuXHRcdFx0Ly9cdFx0QSBoYW5kbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgYnkgaGFuZGxlLnJlbW92ZSgpXG5cdFx0fSxcblx0XHRjYW5jZWw6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRvICd0b3VjaGNhbmNlbCd8J21vdXNlbGVhdmUnIGZvciB0aGUgZ2l2ZW4gbm9kZVxuXHRcdFx0Ly8gbm9kZTogRG9tXG5cdFx0XHQvL1x0XHRUYXJnZXQgbm9kZSB0byBsaXN0ZW4gdG9cblx0XHRcdC8vIGxpc3RlbmVyOiBGdW5jdGlvblxuXHRcdFx0Ly9cdFx0Q2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdC8vIHJldHVybnM6XG5cdFx0XHQvL1x0XHRBIGhhbmRsZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBieSBoYW5kbGUucmVtb3ZlKClcblx0XHR9LFxuXHRcdG92ZXI6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRvICdtb3VzZW92ZXInIG9yIHRvdWNoIGVxdWl2YWxlbnQgZm9yIHRoZSBnaXZlbiBub2RlXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH0sXG5cdFx0b3V0OiBmdW5jdGlvbihub2RlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBzdW1tYXJ5OlxuXHRcdFx0Ly9cdFx0UmVnaXN0ZXIgYSBsaXN0ZW5lciB0byAnbW91c2VvdXQnIG9yIHRvdWNoIGVxdWl2YWxlbnQgZm9yIHRoZSBnaXZlbiBub2RlXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH0sXG5cdFx0ZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRvIG1vdXNlLmVudGVyIG9yIHRvdWNoIGVxdWl2YWxlbnQgZm9yIHRoZSBnaXZlbiBub2RlXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH0sXG5cdFx0bGVhdmU6IGZ1bmN0aW9uKG5vZGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIHN1bW1hcnk6XG5cdFx0XHQvL1x0XHRSZWdpc3RlciBhIGxpc3RlbmVyIHRvIG1vdXNlLmxlYXZlIG9yIHRvdWNoIGVxdWl2YWxlbnQgZm9yIHRoZSBnaXZlbiBub2RlXG5cdFx0XHQvLyBub2RlOiBEb21cblx0XHRcdC8vXHRcdFRhcmdldCBub2RlIHRvIGxpc3RlbiB0b1xuXHRcdFx0Ly8gbGlzdGVuZXI6IEZ1bmN0aW9uXG5cdFx0XHQvL1x0XHRDYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Ly8gcmV0dXJuczpcblx0XHRcdC8vXHRcdEEgaGFuZGxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGJ5IGhhbmRsZS5yZW1vdmUoKVxuXHRcdH1cblx0fTtcblx0PT09PT0qL1xuXG5cdGhhcyhcImV4dGVuZC1kb2pvXCIpICYmIChkb2pvLnRvdWNoID0gdG91Y2gpO1xuXG5cdHJldHVybiB0b3VjaDtcbn0pO1xuIiwiZGVmaW5lKFtcblx0XCIuL0RlZmVycmVkXCIsXG5cdFwiLi9wcm9taXNlL1Byb21pc2VcIlxuXSwgZnVuY3Rpb24oRGVmZXJyZWQsIFByb21pc2Upe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBtb2R1bGU6XG5cdC8vXHRcdGRvam8vd2hlblxuXG5cdHJldHVybiBmdW5jdGlvbiB3aGVuKHZhbHVlT3JQcm9taXNlLCBjYWxsYmFjaywgZXJyYmFjaywgcHJvZ2JhY2spe1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VHJhbnNwYXJlbnRseSBhcHBsaWVzIGNhbGxiYWNrcyB0byB2YWx1ZXMgYW5kL29yIHByb21pc2VzLlxuXHRcdC8vIGRlc2NyaXB0aW9uOlxuXHRcdC8vXHRcdEFjY2VwdHMgcHJvbWlzZXMgYnV0IGFsc28gdHJhbnNwYXJlbnRseSBoYW5kbGVzIG5vbi1wcm9taXNlcy4gSWYgbm9cblx0XHQvL1x0XHRjYWxsYmFja3MgYXJlIHByb3ZpZGVkIHJldHVybnMgYSBwcm9taXNlLCByZWdhcmRsZXNzIG9mIHRoZSBpbml0aWFsXG5cdFx0Ly9cdFx0dmFsdWUuIEZvcmVpZ24gcHJvbWlzZXMgYXJlIGNvbnZlcnRlZC5cblx0XHQvL1xuXHRcdC8vXHRcdElmIGNhbGxiYWNrcyBhcmUgcHJvdmlkZWQgYW5kIHRoZSBpbml0aWFsIHZhbHVlIGlzIG5vdCBhIHByb21pc2UsXG5cdFx0Ly9cdFx0dGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IHdpdGggbm8gZXJyb3IgaGFuZGxpbmcuIFJldHVybnNcblx0XHQvL1x0XHRhIHByb21pc2UgaWYgdGhlIGluaXRpYWwgdmFsdWUgaXMgYSBwcm9taXNlLCBvciB0aGUgcmVzdWx0IG9mIHRoZVxuXHRcdC8vXHRcdGNhbGxiYWNrIG90aGVyd2lzZS5cblx0XHQvLyB2YWx1ZU9yUHJvbWlzZTpcblx0XHQvL1x0XHRFaXRoZXIgYSByZWd1bGFyIHZhbHVlIG9yIGFuIG9iamVjdCB3aXRoIGEgYHRoZW4oKWAgbWV0aG9kIHRoYXRcblx0XHQvL1x0XHRmb2xsb3dzIHRoZSBQcm9taXNlcy9BIHNwZWNpZmljYXRpb24uXG5cdFx0Ly8gY2FsbGJhY2s6IEZ1bmN0aW9uP1xuXHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCwgb3IgYSBub24tcHJvbWlzZVxuXHRcdC8vXHRcdGlzIHJlY2VpdmVkLlxuXHRcdC8vIGVycmJhY2s6IEZ1bmN0aW9uP1xuXHRcdC8vXHRcdENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cblx0XHQvLyBwcm9nYmFjazogRnVuY3Rpb24/XG5cdFx0Ly9cdFx0Q2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBwcm9taXNlIGVtaXRzIGEgcHJvZ3Jlc3MgdXBkYXRlLlxuXHRcdC8vIHJldHVybnM6IGRvam8vcHJvbWlzZS9Qcm9taXNlXG5cdFx0Ly9cdFx0UHJvbWlzZSwgb3IgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCwgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2suXG5cblx0XHR2YXIgcmVjZWl2ZWRQcm9taXNlID0gdmFsdWVPclByb21pc2UgJiYgdHlwZW9mIHZhbHVlT3JQcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcblx0XHR2YXIgbmF0aXZlUHJvbWlzZSA9IHJlY2VpdmVkUHJvbWlzZSAmJiB2YWx1ZU9yUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG5cblx0XHRpZighcmVjZWl2ZWRQcm9taXNlKXtcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKXtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWVPclByb21pc2UpIDogdmFsdWVPclByb21pc2U7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWZlcnJlZCgpLnJlc29sdmUodmFsdWVPclByb21pc2UpO1xuXHRcdFx0fVxuXHRcdH1lbHNlIGlmKCFuYXRpdmVQcm9taXNlKXtcblx0XHRcdHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCh2YWx1ZU9yUHJvbWlzZS5jYW5jZWwpO1xuXHRcdFx0dmFsdWVPclByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLnByb2dyZXNzKTtcblx0XHRcdHZhbHVlT3JQcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcblx0XHR9XG5cblx0XHRpZihjYWxsYmFjayB8fCBlcnJiYWNrIHx8IHByb2diYWNrKXtcblx0XHRcdHJldHVybiB2YWx1ZU9yUHJvbWlzZS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrLCBwcm9nYmFjayk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcblx0fTtcbn0pO1xuIiwiZGVmaW5lKFtcIi4vX2Jhc2UvbGFuZ1wiLCBcIi4vc25pZmZcIiwgXCIuL19iYXNlL3dpbmRvd1wiLCBcIi4vZG9tXCIsIFwiLi9kb20tZ2VvbWV0cnlcIiwgXCIuL2RvbS1zdHlsZVwiLCBcIi4vZG9tLWNvbnN0cnVjdFwiXSxcblx0ZnVuY3Rpb24obGFuZywgaGFzLCBiYXNlV2luZG93LCBkb20sIGdlb20sIHN0eWxlLCBkb21Db25zdHJ1Y3Qpe1xuXG5cdC8vIGZlYXR1cmUgZGV0ZWN0aW9uXG5cdC8qIG5vdCBuZWVkZWQgYnV0IGluY2x1ZGVkIGhlcmUgZm9yIGZ1dHVyZSByZWZlcmVuY2Vcblx0aGFzLmFkZChcInJ0bC1pbm5lclZlcnRpY2FsU2Nyb2xsQmFyLW9uLWxlZnRcIiwgZnVuY3Rpb24od2luLCBkb2Mpe1xuXHRcdHZhclx0Ym9keSA9IGJhc2VXaW5kb3cuYm9keShkb2MpLFxuXHRcdFx0c2Nyb2xsYWJsZSA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoJ2RpdicsIHtcblx0XHRcdFx0c3R5bGU6IHtvdmVyZmxvdzonc2Nyb2xsJywgb3ZlcmZsb3dYOidoaWRkZW4nLCBkaXJlY3Rpb246J3J0bCcsIHZpc2liaWxpdHk6J2hpZGRlbicsIHBvc2l0aW9uOidhYnNvbHV0ZScsIGxlZnQ6JzAnLCB3aWR0aDonNjRweCcsIGhlaWdodDonNjRweCd9XG5cdFx0XHR9LCBib2R5LCBcImxhc3RcIiksXG5cdFx0XHRjZW50ZXIgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdjZW50ZXInLCB7XG5cdFx0XHRcdHN0eWxlOiB7b3ZlcmZsb3c6J2hpZGRlbicsIGRpcmVjdGlvbjonbHRyJ31cblx0XHRcdH0sIHNjcm9sbGFibGUsIFwibGFzdFwiKSxcblx0XHRcdGlubmVyID0gZG9tQ29uc3RydWN0LmNyZWF0ZSgnZGl2Jywge1xuXHRcdFx0XHRzdHlsZToge292ZXJmbG93Oid2aXNpYmxlJywgZGlzcGxheTonaW5saW5lJyB9XG5cdFx0XHR9LCBjZW50ZXIsIFwibGFzdFwiKTtcblx0XHRpbm5lci5pbm5lckhUTUw9XCImbmJzcDtcIjtcblx0XHR2YXIgbWlkUG9pbnQgPSBNYXRoLm1heChpbm5lci5vZmZzZXRMZWZ0LCBnZW9tLnBvc2l0aW9uKGlubmVyKS54KTtcblx0XHR2YXIgcmV0ID0gbWlkUG9pbnQgPj0gMzI7XG5cdFx0Y2VudGVyLnJlbW92ZUNoaWxkKGlubmVyKTtcblx0XHRzY3JvbGxhYmxlLnJlbW92ZUNoaWxkKGNlbnRlcik7XG5cdFx0Ym9keS5yZW1vdmVDaGlsZChzY3JvbGxhYmxlKTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9KTtcblx0Ki9cblx0aGFzLmFkZChcInJ0bC1hZGp1c3QtcG9zaXRpb24tZm9yLXZlcnRpY2FsU2Nyb2xsQmFyXCIsIGZ1bmN0aW9uKHdpbiwgZG9jKXtcblx0XHR2YXJcdGJvZHkgPSBiYXNlV2luZG93LmJvZHkoZG9jKSxcblx0XHRcdHNjcm9sbGFibGUgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdkaXYnLCB7XG5cdFx0XHRcdHN0eWxlOiB7b3ZlcmZsb3c6J3Njcm9sbCcsIG92ZXJmbG93WDondmlzaWJsZScsIGRpcmVjdGlvbjoncnRsJywgdmlzaWJpbGl0eTonaGlkZGVuJywgcG9zaXRpb246J2Fic29sdXRlJywgbGVmdDonMCcsIHRvcDonMCcsIHdpZHRoOic2NHB4JywgaGVpZ2h0Oic2NHB4J31cblx0XHRcdH0sIGJvZHksIFwibGFzdFwiKSxcblx0XHRcdGRpdiA9IGRvbUNvbnN0cnVjdC5jcmVhdGUoJ2RpdicsIHtcblx0XHRcdFx0c3R5bGU6IHtvdmVyZmxvdzonaGlkZGVuJywgZGlyZWN0aW9uOidsdHInfVxuXHRcdFx0fSwgc2Nyb2xsYWJsZSwgXCJsYXN0XCIpLFxuXHRcdFx0cmV0ID0gZ2VvbS5wb3NpdGlvbihkaXYpLnggIT0gMDtcblx0XHRzY3JvbGxhYmxlLnJlbW92ZUNoaWxkKGRpdik7XG5cdFx0Ym9keS5yZW1vdmVDaGlsZChzY3JvbGxhYmxlKTtcblx0XHRyZXR1cm4gcmV0O1xuXHR9KTtcblxuXHRoYXMuYWRkKFwicG9zaXRpb24tZml4ZWQtc3VwcG9ydFwiLCBmdW5jdGlvbih3aW4sIGRvYyl7XG5cdFx0Ly8gSUU2LCBJRTcrcXVpcmtzLCBhbmQgc29tZSBvbGRlciBtb2JpbGUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBwb3NpdGlvbjpmaXhlZFxuXHRcdHZhclx0Ym9keSA9IGJhc2VXaW5kb3cuYm9keShkb2MpLFxuXHRcdFx0b3V0ZXIgPSBkb21Db25zdHJ1Y3QuY3JlYXRlKCdzcGFuJywge1xuXHRcdFx0XHRzdHlsZToge3Zpc2liaWxpdHk6J2hpZGRlbicsIHBvc2l0aW9uOidmaXhlZCcsIGxlZnQ6JzFweCcsIHRvcDonMXB4J31cblx0XHRcdH0sIGJvZHksIFwibGFzdFwiKSxcblx0XHRcdGlubmVyID0gZG9tQ29uc3RydWN0LmNyZWF0ZSgnc3BhbicsIHtcblx0XHRcdFx0c3R5bGU6IHtwb3NpdGlvbjonZml4ZWQnLCBsZWZ0OicwJywgdG9wOicwJ31cblx0XHRcdH0sIG91dGVyLCBcImxhc3RcIiksXG5cdFx0XHRyZXQgPSBnZW9tLnBvc2l0aW9uKGlubmVyKS54ICE9IGdlb20ucG9zaXRpb24ob3V0ZXIpLng7XG5cdFx0b3V0ZXIucmVtb3ZlQ2hpbGQoaW5uZXIpO1xuXHRcdGJvZHkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuXHRcdHJldHVybiByZXQ7XG5cdH0pO1xuXG5cdC8vIG1vZHVsZTpcblx0Ly9cdFx0ZG9qby93aW5kb3dcblxuXHR2YXIgd2luZG93ID0ge1xuXHRcdC8vIHN1bW1hcnk6XG5cdFx0Ly9cdFx0VE9ET0NcblxuXHRcdGdldEJveDogZnVuY3Rpb24oLypEb2N1bWVudD8qLyBkb2Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFJldHVybnMgdGhlIGRpbWVuc2lvbnMgYW5kIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgdmlld2FibGUgYXJlYSBvZiBhIGJyb3dzZXIgd2luZG93XG5cblx0XHRcdGRvYyA9IGRvYyB8fCBiYXNlV2luZG93LmRvYztcblxuXHRcdFx0dmFyXG5cdFx0XHRcdHNjcm9sbFJvb3QgPSAoZG9jLmNvbXBhdE1vZGUgPT0gJ0JhY2tDb21wYXQnKSA/IGJhc2VXaW5kb3cuYm9keShkb2MpIDogZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0Ly8gZ2V0IHNjcm9sbCBwb3NpdGlvblxuXHRcdFx0XHRzY3JvbGwgPSBnZW9tLmRvY1Njcm9sbChkb2MpLCAvLyBzY3JvbGxSb290LnNjcm9sbFRvcC9MZWZ0IHNob3VsZCB3b3JrXG5cdFx0XHRcdHcsIGg7XG5cblx0XHRcdGlmKGhhcyhcInRvdWNoXCIpKXsgLy8gaWYoc2Nyb2xsYmFycyBub3Qgc3VwcG9ydGVkKVxuXHRcdFx0XHR2YXIgdWlXaW5kb3cgPSB3aW5kb3cuZ2V0KGRvYyk7ICAgLy8gdXNlIFVJIHdpbmRvdywgbm90IGRvam8uZ2xvYmFsIHdpbmRvd1xuXHRcdFx0XHQvLyBvbiBtb2JpbGUsIHNjcm9sbFJvb3QuY2xpZW50SGVpZ2h0IDw9IHVpV2luZG93LmlubmVySGVpZ2h0IDw9IHNjcm9sbFJvb3Qub2Zmc2V0SGVpZ2h0LCByZXR1cm4gdWlXaW5kb3cuaW5uZXJIZWlnaHRcblx0XHRcdFx0dyA9IHVpV2luZG93LmlubmVyV2lkdGggfHwgc2Nyb2xsUm9vdC5jbGllbnRXaWR0aDsgLy8gfHwgc2Nyb2xsUm9vdC5jbGllbnRYWFggcHJvYmFibHkgbmV2ZXIgZXZhbHVhdGVkXG5cdFx0XHRcdGggPSB1aVdpbmRvdy5pbm5lckhlaWdodCB8fCBzY3JvbGxSb290LmNsaWVudEhlaWdodDtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBvbiBkZXNrdG9wcywgc2Nyb2xsUm9vdC5jbGllbnRIZWlnaHQgPD0gc2Nyb2xsUm9vdC5vZmZzZXRIZWlnaHQgPD0gdWlXaW5kb3cuaW5uZXJIZWlnaHQsIHJldHVybiBzY3JvbGxSb290LmNsaWVudEhlaWdodFxuXHRcdFx0XHQvLyB1aVdpbmRvdy5pbm5lcldpZHRoL0hlaWdodCBpbmNsdWRlcyB0aGUgc2Nyb2xsYmFyIGFuZCBjYW5ub3QgYmUgdXNlZFxuXHRcdFx0XHR3ID0gc2Nyb2xsUm9vdC5jbGllbnRXaWR0aDtcblx0XHRcdFx0aCA9IHNjcm9sbFJvb3QuY2xpZW50SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bDogc2Nyb2xsLngsXG5cdFx0XHRcdHQ6IHNjcm9sbC55LFxuXHRcdFx0XHR3OiB3LFxuXHRcdFx0XHRoOiBoXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uKC8qRG9jdW1lbnQqLyBkb2Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdEdldCB3aW5kb3cgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBkb2N1bWVudCBkb2MuXG5cdFx0XHQvLyBkb2M6XG5cdFx0XHQvL1x0XHRUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSBhc3NvY2lhdGVkIHdpbmRvdyBmb3IuXG5cblx0XHRcdC8vIEluIHNvbWUgSUUgdmVyc2lvbnMgKGF0IGxlYXN0IDYuMCksIGRvY3VtZW50LnBhcmVudFdpbmRvdyBkb2VzIG5vdCByZXR1cm4gYVxuXHRcdFx0Ly8gcmVmZXJlbmNlIHRvIHRoZSByZWFsIHdpbmRvdyBvYmplY3QgKG1heWJlIGEgY29weSksIHNvIHdlIG11c3QgZml4IGl0IGFzIHdlbGxcblx0XHRcdC8vIFdlIHVzZSBJRSBzcGVjaWZpYyBleGVjU2NyaXB0IHRvIGF0dGFjaCB0aGUgcmVhbCB3aW5kb3cgcmVmZXJlbmNlIHRvXG5cdFx0XHQvLyBkb2N1bWVudC5fcGFyZW50V2luZG93IGZvciBsYXRlciB1c2Vcblx0XHRcdGlmKGhhcyhcImllXCIpICYmIHdpbmRvdyAhPT0gZG9jdW1lbnQucGFyZW50V2luZG93KXtcblx0XHRcdFx0Lypcblx0XHRcdFx0SW4gSUUgNiwgb25seSB0aGUgdmFyaWFibGUgXCJ3aW5kb3dcIiBjYW4gYmUgdXNlZCB0byBjb25uZWN0IGV2ZW50cyAob3RoZXJzXG5cdFx0XHRcdG1heSBiZSBvbmx5IGNvcGllcykuXG5cdFx0XHRcdCovXG5cdFx0XHRcdGRvYy5wYXJlbnRXaW5kb3cuZXhlY1NjcmlwdChcImRvY3VtZW50Ll9wYXJlbnRXaW5kb3cgPSB3aW5kb3c7XCIsIFwiSmF2YXNjcmlwdFwiKTtcblx0XHRcdFx0Ly90byBwcmV2ZW50IG1lbW9yeSBsZWFrLCB1bnNldCBpdCBhZnRlciB1c2Vcblx0XHRcdFx0Ly9hbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRvIGFkZCBhbiBvblVubG9hZCBoYW5kbGVyIHdoaWNoIHNlZW1zIG92ZXJraWxsIHRvIG1lIChsaXVjb3VnYXIpXG5cdFx0XHRcdHZhciB3aW4gPSBkb2MuX3BhcmVudFdpbmRvdztcblx0XHRcdFx0ZG9jLl9wYXJlbnRXaW5kb3cgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gd2luO1x0Ly9cdFdpbmRvd1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZG9jLnBhcmVudFdpbmRvdyB8fCBkb2MuZGVmYXVsdFZpZXc7XHQvL1x0V2luZG93XG5cdFx0fSxcblxuXHRcdHNjcm9sbEludG9WaWV3OiBmdW5jdGlvbigvKkRvbU5vZGUqLyBub2RlLCAvKk9iamVjdD8qLyBwb3Mpe1xuXHRcdFx0Ly8gc3VtbWFyeTpcblx0XHRcdC8vXHRcdFNjcm9sbCB0aGUgcGFzc2VkIG5vZGUgaW50byB2aWV3IHVzaW5nIG1pbmltYWwgbW92ZW1lbnQsIGlmIGl0IGlzIG5vdCBhbHJlYWR5LlxuXG5cdFx0XHQvLyBEb24ndCByZWx5IG9uIG5vZGUuc2Nyb2xsSW50b1ZpZXcgd29ya2luZyBqdXN0IGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzIHRoZXJlIHNpbmNlXG5cdFx0XHQvLyBpdCBmb3JjZXMgdGhlIG5vZGUgdG8gdGhlIHBhZ2UncyBib3R0b20gb3IgdG9wIChhbmQgbGVmdCBvciByaWdodCBpbiBJRSkgd2l0aG91dCBjb25zaWRlcmF0aW9uIGZvciB0aGUgbWluaW1hbCBtb3ZlbWVudC5cblx0XHRcdC8vIFdlYktpdCdzIG5vZGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCBkb2Vzbid0IHdvcmsgZWl0aGVyIGZvciBpbm5lciBzY3JvbGxiYXJzIGluIHJpZ2h0LXRvLWxlZnQgbW9kZVxuXHRcdFx0Ly8gYW5kIHdoZW4gdGhlcmUncyBhIGZpeGVkIHBvc2l0aW9uIHNjcm9sbGFibGUgZWxlbWVudFxuXG5cdFx0XHR0cnl7IC8vIGNhdGNoIHVuZXhwZWN0ZWQvdW5yZWNyZWF0YWJsZSBlcnJvcnMgKCM3ODA4KSBzaW5jZSB3ZSBjYW4gcmVjb3ZlciB1c2luZyBhIHNlbWktYWNjZXB0YWJsZSBuYXRpdmUgbWV0aG9kXG5cdFx0XHRcdG5vZGUgPSBkb20uYnlJZChub2RlKTtcblx0XHRcdFx0dmFyXHRkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgYmFzZVdpbmRvdy5kb2MsXHQvLyBUT0RPOiB3aHkgYmFzZVdpbmRvdy5kb2M/ICBJc24ndCBub2RlLm93bmVyRG9jdW1lbnQgYWx3YXlzIGRlZmluZWQ/XG5cdFx0XHRcdFx0Ym9keSA9IGJhc2VXaW5kb3cuYm9keShkb2MpLFxuXHRcdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50IHx8IGJvZHkucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRpc0lFID0gaGFzKFwiaWVcIikgfHwgaGFzKFwidHJpZGVudFwiKSxcblx0XHRcdFx0XHRpc1dLID0gaGFzKFwid2Via2l0XCIpO1xuXHRcdFx0XHQvLyBpZiBhbiB1bnRlc3RlZCBicm93c2VyLCB0aGVuIHVzZSB0aGUgbmF0aXZlIG1ldGhvZFxuXHRcdFx0XHRpZihub2RlID09IGJvZHkgfHwgbm9kZSA9PSBodG1sKXsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmKCEoaGFzKFwibW96aWxsYVwiKSB8fCBpc0lFIHx8IGlzV0sgfHwgaGFzKFwib3BlcmFcIikgfHwgaGFzKFwidHJpZGVudFwiKSB8fCBoYXMoXCJlZGdlXCIpKVxuXHRcdFx0XHRcdFx0JiYgKFwic2Nyb2xsSW50b1ZpZXdcIiBpbiBub2RlKSl7XG5cdFx0XHRcdFx0bm9kZS5zY3JvbGxJbnRvVmlldyhmYWxzZSk7IC8vIHNob3J0LWNpcmN1aXQgdG8gbmF0aXZlIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhclx0YmFja0NvbXBhdCA9IGRvYy5jb21wYXRNb2RlID09ICdCYWNrQ29tcGF0Jyxcblx0XHRcdFx0XHRyb290V2lkdGggPSBNYXRoLm1pbihib2R5LmNsaWVudFdpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsIGh0bWwuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRXaWR0aCksXG5cdFx0XHRcdFx0cm9vdEhlaWdodCA9IE1hdGgubWluKGJvZHkuY2xpZW50SGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCB8fCBib2R5LmNsaWVudEhlaWdodCksXG5cdFx0XHRcdFx0c2Nyb2xsUm9vdCA9IChpc1dLIHx8IGJhY2tDb21wYXQpID8gYm9keSA6IGh0bWwsXG5cdFx0XHRcdFx0bm9kZVBvcyA9IHBvcyB8fCBnZW9tLnBvc2l0aW9uKG5vZGUpLFxuXHRcdFx0XHRcdGVsID0gbm9kZS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdGlzRml4ZWQgPSBmdW5jdGlvbihlbCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKGlzSUUgPD0gNiB8fCAoaXNJRSA9PSA3ICYmIGJhY2tDb21wYXQpKVxuXHRcdFx0XHRcdFx0XHQ/IGZhbHNlXG5cdFx0XHRcdFx0XHRcdDogKGhhcyhcInBvc2l0aW9uLWZpeGVkLXN1cHBvcnRcIikgJiYgKHN0eWxlLmdldChlbCwgJ3Bvc2l0aW9uJykudG9Mb3dlckNhc2UoKSA9PSBcImZpeGVkXCIpKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdHNjcm9sbEVsZW1lbnRCeSA9IGZ1bmN0aW9uKGVsLCB4LCB5KXtcblx0XHRcdFx0XHRcdGlmKGVsLnRhZ05hbWUgPT0gXCJCT0RZXCIgfHwgZWwudGFnTmFtZSA9PSBcIkhUTUxcIil7XG5cdFx0XHRcdFx0XHRcdHNlbGYuZ2V0KGVsLm93bmVyRG9jdW1lbnQpLnNjcm9sbEJ5KHgsIHkpO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHggJiYgKGVsLnNjcm9sbExlZnQgKz0geCk7XG5cdFx0XHRcdFx0XHRcdHkgJiYgKGVsLnNjcm9sbFRvcCArPSB5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZihpc0ZpeGVkKG5vZGUpKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblx0XHRcdFx0d2hpbGUoZWwpe1xuXHRcdFx0XHRcdGlmKGVsID09IGJvZHkpeyBlbCA9IHNjcm9sbFJvb3Q7IH1cblx0XHRcdFx0XHR2YXJcdGVsUG9zID0gZ2VvbS5wb3NpdGlvbihlbCksXG5cdFx0XHRcdFx0XHRmaXhlZFBvcyA9IGlzRml4ZWQoZWwpLFxuXHRcdFx0XHRcdFx0cnRsID0gc3R5bGUuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlyZWN0aW9uLnRvTG93ZXJDYXNlKCkgPT0gXCJydGxcIjtcblxuXHRcdFx0XHRcdGlmKGVsID09IHNjcm9sbFJvb3Qpe1xuXHRcdFx0XHRcdFx0ZWxQb3MudyA9IHJvb3RXaWR0aDsgZWxQb3MuaCA9IHJvb3RIZWlnaHQ7XG5cdFx0XHRcdFx0XHRpZihzY3JvbGxSb290ID09IGh0bWwgJiYgKGlzSUUgfHwgaGFzKFwidHJpZGVudFwiKSkgJiYgcnRsKXtcblx0XHRcdFx0XHRcdFx0ZWxQb3MueCArPSBzY3JvbGxSb290Lm9mZnNldFdpZHRoLWVsUG9zLnc7Ly8gSUUgd29ya2Fyb3VuZCB3aGVyZSBzY3JvbGxiYXIgY2F1c2VzIG5lZ2F0aXZlIHhcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsUG9zLnggPSAwO1xuXHRcdFx0XHRcdFx0ZWxQb3MueSA9IDA7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHR2YXIgcGIgPSBnZW9tLmdldFBhZEJvcmRlckV4dGVudHMoZWwpO1xuXHRcdFx0XHRcdFx0ZWxQb3MudyAtPSBwYi53OyBlbFBvcy5oIC09IHBiLmg7IGVsUG9zLnggKz0gcGIubDsgZWxQb3MueSArPSBwYi50O1xuXHRcdFx0XHRcdFx0dmFyIGNsaWVudFNpemUgPSBlbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0XHRcdFx0c2Nyb2xsQmFyU2l6ZSA9IGVsUG9zLncgLSBjbGllbnRTaXplO1xuXHRcdFx0XHRcdFx0aWYoY2xpZW50U2l6ZSA+IDAgJiYgc2Nyb2xsQmFyU2l6ZSA+IDApe1xuXHRcdFx0XHRcdFx0XHRpZihydGwgJiYgaGFzKFwicnRsLWFkanVzdC1wb3NpdGlvbi1mb3ItdmVydGljYWxTY3JvbGxCYXJcIikpe1xuXHRcdFx0XHRcdFx0XHRcdGVsUG9zLnggKz0gc2Nyb2xsQmFyU2l6ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbFBvcy53ID0gY2xpZW50U2l6ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsaWVudFNpemUgPSBlbC5jbGllbnRIZWlnaHQ7XG5cdFx0XHRcdFx0XHRzY3JvbGxCYXJTaXplID0gZWxQb3MuaCAtIGNsaWVudFNpemU7XG5cdFx0XHRcdFx0XHRpZihjbGllbnRTaXplID4gMCAmJiBzY3JvbGxCYXJTaXplID4gMCl7XG5cdFx0XHRcdFx0XHRcdGVsUG9zLmggPSBjbGllbnRTaXplO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihmaXhlZFBvcyl7IC8vIGJvdW5kZWQgYnkgdmlld3BvcnQsIG5vdCBwYXJlbnRzXG5cdFx0XHRcdFx0XHRpZihlbFBvcy55IDwgMCl7XG5cdFx0XHRcdFx0XHRcdGVsUG9zLmggKz0gZWxQb3MueTsgZWxQb3MueSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihlbFBvcy54IDwgMCl7XG5cdFx0XHRcdFx0XHRcdGVsUG9zLncgKz0gZWxQb3MueDsgZWxQb3MueCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihlbFBvcy55ICsgZWxQb3MuaCA+IHJvb3RIZWlnaHQpe1xuXHRcdFx0XHRcdFx0XHRlbFBvcy5oID0gcm9vdEhlaWdodCAtIGVsUG9zLnk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihlbFBvcy54ICsgZWxQb3MudyA+IHJvb3RXaWR0aCl7XG5cdFx0XHRcdFx0XHRcdGVsUG9zLncgPSByb290V2lkdGggLSBlbFBvcy54O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBjYWxjdWxhdGUgb3ZlcmZsb3cgaW4gYWxsIDQgZGlyZWN0aW9uc1xuXHRcdFx0XHRcdHZhclx0bCA9IG5vZGVQb3MueCAtIGVsUG9zLngsIC8vIGJleW9uZCBsZWZ0OiA8IDBcbi8vXHRcdFx0XHRcdFx0dCA9IG5vZGVQb3MueSAtIE1hdGgubWF4KGVsUG9zLnksIDApLCAvLyBiZXlvbmQgdG9wOiA8IDBcblx0XHRcdFx0XHRcdHQgPSBub2RlUG9zLnkgLSBlbFBvcy55LCAvLyBiZXlvbmQgdG9wOiA8IDBcblx0XHRcdFx0XHRcdHIgPSBsICsgbm9kZVBvcy53IC0gZWxQb3MudywgLy8gYmV5b25kIHJpZ2h0OiA+IDBcblx0XHRcdFx0XHRcdGJvdCA9IHQgKyBub2RlUG9zLmggLSBlbFBvcy5oOyAvLyBiZXlvbmQgYm90dG9tOiA+IDBcblx0XHRcdFx0XHR2YXIgcywgb2xkO1xuXHRcdFx0XHRcdGlmKHIgKiBsID4gMCAmJiAoISFlbC5zY3JvbGxMZWZ0IHx8IGVsID09IHNjcm9sbFJvb3QgfHwgZWwuc2Nyb2xsV2lkdGggPiBlbC5vZmZzZXRIZWlnaHQpKXtcblx0XHRcdFx0XHRcdHMgPSBNYXRoW2wgPCAwPyBcIm1heFwiIDogXCJtaW5cIl0obCwgcik7XG5cdFx0XHRcdFx0XHRpZihydGwgJiYgKChpc0lFID09IDggJiYgIWJhY2tDb21wYXQpIHx8IGhhcyhcInRyaWRlbnRcIikgPj0gNSkpeyBzID0gLXM7IH1cblx0XHRcdFx0XHRcdG9sZCA9IGVsLnNjcm9sbExlZnQ7XG5cdFx0XHRcdFx0XHRzY3JvbGxFbGVtZW50QnkoZWwsIHMsIDApO1xuXHRcdFx0XHRcdFx0cyA9IGVsLnNjcm9sbExlZnQgLSBvbGQ7XG5cdFx0XHRcdFx0XHRub2RlUG9zLnggLT0gcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoYm90ICogdCA+IDAgJiYgKCEhZWwuc2Nyb2xsVG9wIHx8IGVsID09IHNjcm9sbFJvb3QgfHwgZWwuc2Nyb2xsSGVpZ2h0ID4gZWwub2Zmc2V0SGVpZ2h0KSl7XG5cdFx0XHRcdFx0XHRzID0gTWF0aC5jZWlsKE1hdGhbdCA8IDA/IFwibWF4XCIgOiBcIm1pblwiXSh0LCBib3QpKTtcblx0XHRcdFx0XHRcdG9sZCA9IGVsLnNjcm9sbFRvcDtcblx0XHRcdFx0XHRcdHNjcm9sbEVsZW1lbnRCeShlbCwgMCwgcyk7XG5cdFx0XHRcdFx0XHRzID0gZWwuc2Nyb2xsVG9wIC0gb2xkO1xuXHRcdFx0XHRcdFx0bm9kZVBvcy55IC09IHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsID0gKGVsICE9IHNjcm9sbFJvb3QpICYmICFmaXhlZFBvcyAmJiBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZXJyb3Ipe1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdzY3JvbGxJbnRvVmlldzogJyArIGVycm9yKTtcblx0XHRcdFx0bm9kZS5zY3JvbGxJbnRvVmlldyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGhhcyhcImV4dGVuZC1kb2pvXCIpICYmIGxhbmcuc2V0T2JqZWN0KFwiZG9qby53aW5kb3dcIiwgd2luZG93KTtcblxuXHRyZXR1cm4gd2luZG93O1xufSk7XG4iLCIoZnVuY3Rpb24oZGVmaW5lKXtcbnZhciBmb3JEb2N1bWVudCwgZnJhZ21lbnRGYXN0ZXJIZXVyaXN0aWMgPSAvWy0rLD4gXS87IC8vIGlmIGl0IGhhcyBhbnkgb2YgdGhlc2UgY29tYmluYXRvcnMsIGl0IGlzIHByb2JhYmx5IGdvaW5nIHRvIGJlIGZhc3RlciB3aXRoIGEgZG9jdW1lbnQgZnJhZ21lbnQgXG5kZWZpbmUoW10sIGZvckRvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBuZXdGcmFnbWVudEZhc3RlckhldXJpc3RpYyl7XG5cInVzZSBzdHJpY3RcIjtcblx0Ly8gbW9kdWxlOlxuXHQvL1x0XHRwdXQtc2VsZWN0b3IvcHV0XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgbW9kdWxlIGRlZmluZXMgYSBmYXN0IGxpZ2h0d2VpZ2h0IGZ1bmN0aW9uIGZvciB1cGRhdGluZyBhbmQgY3JlYXRpbmcgbmV3IGVsZW1lbnRzXG5cdC8vXHRcdHRlcnNlLCBDU1Mgc2VsZWN0b3ItYmFzZWQgc3ludGF4LiBUaGUgc2luZ2xlIGZ1bmN0aW9uIGZyb20gdGhpcyBtb2R1bGUgY3JlYXRlc1xuXHQvLyBcdFx0bmV3IERPTSBlbGVtZW50cyBhbmQgdXBkYXRlcyBleGlzdGluZyBlbGVtZW50cy4gU2VlIFJFQURNRS5tZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0Ly9cdGV4YW1wbGVzOlxuXHQvL1x0XHRUbyBjcmVhdGUgYSBzaW1wbGUgZGl2IHdpdGggYSBjbGFzcyBuYW1lIG9mIFwiZm9vXCI6XG5cdC8vXHRcdHxcdHB1dChcImRpdi5mb29cIik7XG5cdGZyYWdtZW50RmFzdGVySGV1cmlzdGljID0gbmV3RnJhZ21lbnRGYXN0ZXJIZXVyaXN0aWMgfHwgZnJhZ21lbnRGYXN0ZXJIZXVyaXN0aWM7XG5cdHZhciBzZWxlY3RvclBhcnNlID0gLyg/OlxccyooWy0rICw8Pl0pKT9cXHMqKFxcLnwhXFwuP3wjKT8oWy1cXHdcXHUwMEEwLVxcdUZGRkYlJHxdKyk/KD86XFxbKFteXFxdPV0rKT0/WydcIl0/KFteXFxdJ1wiXSopWydcIl0/XFxdKT8vZyxcblx0XHR1bmRlZmluZWQsIG5hbWVzcGFjZUluZGV4LCBuYW1lc3BhY2VzID0gZmFsc2UsXG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50LFxuXHRcdGllQ3JlYXRlRWxlbWVudCA9IHR5cGVvZiBkb2MuY3JlYXRlRWxlbWVudCA9PSBcIm9iamVjdFwiOyAvLyB0ZWxsdGFsZSBzaWduIG9mIHRoZSBvbGQgSUUgYmVoYXZpb3Igd2l0aCBjcmVhdGVFbGVtZW50IHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBsYXRlciBhZGRpdGlvbiBvZiBuYW1lIFxuXHRmdW5jdGlvbiBpbnNlcnRUZXh0Tm9kZShlbGVtZW50LCB0ZXh0KXtcblx0XHRlbGVtZW50LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG5cdH1cblx0ZnVuY3Rpb24gcHV0KHRvcFJlZmVyZW5jZUVsZW1lbnQpe1xuXHRcdHZhciBmcmFnbWVudCwgbGFzdFNlbGVjdG9yQXJnLCBuZXh0U2libGluZywgcmVmZXJlbmNlRWxlbWVudCwgY3VycmVudCxcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGFyZ3NbMF07IC8vIHVzZSB0aGUgZmlyc3QgYXJndW1lbnQgYXMgdGhlIGRlZmF1bHQgcmV0dXJuIHZhbHVlIGluIGNhc2Ugb25seSBhbiBlbGVtZW50IGlzIHBhc3NlZCBpblxuXHRcdGZ1bmN0aW9uIGluc2VydExhc3RFbGVtZW50KCl7XG5cdFx0XHQvLyB3ZSBwZXJmb3JtIGluc2VydEJlZm9yZSBhY3Rpb25zIGFmdGVyIHRoZSBlbGVtZW50IGlzIGZ1bGx5IGNyZWF0ZWQgdG8gd29yayBwcm9wZXJseSB3aXRoIFxuXHRcdFx0Ly8gPGlucHV0PiB0YWdzIGluIG9sZGVyIHZlcnNpb25zIG9mIElFIHRoYXQgcmVxdWlyZSB0eXBlIGF0dHJpYnV0ZXNcblx0XHRcdC8vXHR0byBiZSBzZXQgYmVmb3JlIGl0IGlzIGF0dGFjaGVkIHRvIGEgcGFyZW50LlxuXHRcdFx0Ly8gV2UgYWxzbyBoYW5kbGUgdG9wIGxldmVsIGFzIGEgZG9jdW1lbnQgZnJhZ21lbnQgYWN0aW9ucyBpbiBhIGNvbXBsZXggY3JlYXRpb24gXG5cdFx0XHQvLyBhcmUgZG9uZSBvbiBhIGRldGFjaGVkIERPTSB3aGljaCBpcyBtdWNoIGZhc3RlclxuXHRcdFx0Ly8gQWxzbyBpZiB0aGVyZSBpcyBhIHBhcnNlIGVycm9yLCB3ZSBnZW5lcmFsbHkgZXJyb3Igb3V0IGJlZm9yZSBkb2luZyBhbnkgRE9NIG9wZXJhdGlvbnMgKG1vcmUgYXRvbWljKSBcblx0XHRcdGlmKGN1cnJlbnQgJiYgcmVmZXJlbmNlRWxlbWVudCAmJiBjdXJyZW50ICE9IHJlZmVyZW5jZUVsZW1lbnQpe1xuXHRcdFx0XHQocmVmZXJlbmNlRWxlbWVudCA9PSB0b3BSZWZlcmVuY2VFbGVtZW50ICYmXG5cdFx0XHRcdFx0Ly8gdG9wIGxldmVsLCBtYXkgdXNlIGZyYWdtZW50IGZvciBmYXN0ZXIgYWNjZXNzIFxuXHRcdFx0XHRcdChmcmFnbWVudCB8fCBcblx0XHRcdFx0XHRcdC8vIGZyYWdtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LCBjaGVjayB0byBzZWUgaWYgd2UgcmVhbGx5IHdhbnQgdG8gY3JlYXRlIGl0IFxuXHRcdFx0XHRcdFx0KGZyYWdtZW50ID0gZnJhZ21lbnRGYXN0ZXJIZXVyaXN0aWMudGVzdChhcmd1bWVudCkgJiYgZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkpXG5cdFx0XHRcdFx0XHRcdC8vIGFueSBvZiB0aGUgYWJvdmUgZmFpbHMganVzdCB1c2UgdGhlIHJlZmVyZW5jZUVsZW1lbnQgIFxuXHRcdFx0XHRcdFx0XHQgPyBmcmFnbWVudCA6IHJlZmVyZW5jZUVsZW1lbnQpLlxuXHRcdFx0XHRcdFx0XHRcdGluc2VydEJlZm9yZShjdXJyZW50LCBuZXh0U2libGluZyB8fCBudWxsKTsgLy8gZG8gdGhlIGFjdHVhbCBpbnNlcnRpb25cblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xuXHRcdFx0dmFyIGFyZ3VtZW50ID0gYXJnc1tpXTtcblx0XHRcdGlmKHR5cGVvZiBhcmd1bWVudCA9PSBcIm9iamVjdFwiKXtcblx0XHRcdFx0bGFzdFNlbGVjdG9yQXJnID0gZmFsc2U7XG5cdFx0XHRcdGlmKGFyZ3VtZW50IGluc3RhbmNlb2YgQXJyYXkpe1xuXHRcdFx0XHRcdC8vIGFuIGFycmF5XG5cdFx0XHRcdFx0Y3VycmVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0Zm9yKHZhciBrZXkgPSAwOyBrZXkgPCBhcmd1bWVudC5sZW5ndGg7IGtleSsrKXtcblx0XHRcdFx0XHRcdGN1cnJlbnQuYXBwZW5kQ2hpbGQocHV0KGFyZ3VtZW50W2tleV0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YXJndW1lbnQgPSBjdXJyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGFyZ3VtZW50Lm5vZGVUeXBlKXtcblx0XHRcdFx0XHRjdXJyZW50ID0gYXJndW1lbnQ7XG5cdFx0XHRcdFx0aW5zZXJ0TGFzdEVsZW1lbnQoKTtcblx0XHRcdFx0XHRyZWZlcmVuY2VFbGVtZW50ID0gYXJndW1lbnQ7XG5cdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSAwO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyBhbiBvYmplY3QgaGFzaFxuXHRcdFx0XHRcdGZvcih2YXIga2V5IGluIGFyZ3VtZW50KXtcblx0XHRcdFx0XHRcdGN1cnJlbnRba2V5XSA9IGFyZ3VtZW50W2tleV07XG5cdFx0XHRcdFx0fVx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKGxhc3RTZWxlY3RvckFyZyl7XG5cdFx0XHRcdC8vIGEgdGV4dCBub2RlIHNob3VsZCBiZSBjcmVhdGVkXG5cdFx0XHRcdC8vIHRha2UgYSBzY2FsYXIgdmFsdWUsIHVzZSBjcmVhdGVUZXh0Tm9kZSBzbyBpdCBpcyBwcm9wZXJseSBlc2NhcGVkXG5cdFx0XHRcdC8vIGNyZWF0ZVRleHROb2RlIGlzIGdlbmVyYWxseSBzZXZlcmFsIHRpbWVzIGZhc3RlciB0aGFuIGRvaW5nIGFuIGVzY2FwZWQgaW5uZXJIVE1MIGluc2VydGlvbjogaHR0cDovL2pzcGVyZi5jb20vY3JlYXRldGV4dG5vZGUtdnMtaW5uZXJodG1sLzJcblx0XHRcdFx0bGFzdFNlbGVjdG9yQXJnID0gZmFsc2U7XG5cdFx0XHRcdGluc2VydFRleHROb2RlKGN1cnJlbnQsIGFyZ3VtZW50KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZihpIDwgMSl7XG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIHN0YXJ0aW5nIHdpdGggYSBzZWxlY3RvciwgdGhlcmUgaXMgbm8gdG9wIGVsZW1lbnRcblx0XHRcdFx0XHR0b3BSZWZlcmVuY2VFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0U2VsZWN0b3JBcmcgPSB0cnVlO1xuXHRcdFx0XHR2YXIgbGVmdG92ZXJDaGFyYWN0ZXJzID0gYXJndW1lbnQucmVwbGFjZShzZWxlY3RvclBhcnNlLCBmdW5jdGlvbih0LCBjb21iaW5hdG9yLCBwcmVmaXgsIHZhbHVlLCBhdHRyTmFtZSwgYXR0clZhbHVlKXtcblx0XHRcdFx0XHRpZihjb21iaW5hdG9yKXtcblx0XHRcdFx0XHRcdC8vIGluc2VydCB0aGUgbGFzdCBjdXJyZW50IG9iamVjdFxuXHRcdFx0XHRcdFx0aW5zZXJ0TGFzdEVsZW1lbnQoKTtcblx0XHRcdFx0XHRcdGlmKGNvbWJpbmF0b3IgPT0gJy0nIHx8IGNvbWJpbmF0b3IgPT0gJysnKXtcblx0XHRcdFx0XHRcdFx0Ly8gKyBvciAtIGNvbWJpbmF0b3IsIFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgPi0gYXMgYSBtZWFucyBvZiBpbmRpY2F0aW5nIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQ/XG5cdFx0XHRcdFx0XHRcdHJlZmVyZW5jZUVsZW1lbnQgPSAobmV4dFNpYmxpbmcgPSAoY3VycmVudCB8fCByZWZlcmVuY2VFbGVtZW50KSkucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGlmKGNvbWJpbmF0b3IgPT0gXCIrXCIpe1xuXHRcdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0XHRcdH0vLyBlbHNlIGEgLSBvcGVyYXRvciwgYWdhaW4gbm90IGluIENTUywgYnV0IG9idmlvdXMgaW4gaXQncyBtZWFuaW5nIChjcmVhdGUgbmV4dCBlbGVtZW50IGJlZm9yZSB0aGUgY3VycmVudC9yZWZlcmVuY2VFbGVtZW50KVxuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGlmKGNvbWJpbmF0b3IgPT0gXCI8XCIpe1xuXHRcdFx0XHRcdFx0XHRcdC8vIHBhcmVudCBjb21iaW5hdG9yIChub3QgcmVhbGx5IGluIENTUywgYnV0IHRoZW9yaXplZCwgYW5kIG9idmlvdXMgaW4gaXQncyBtZWFuaW5nKVxuXHRcdFx0XHRcdFx0XHRcdHJlZmVyZW5jZUVsZW1lbnQgPSBjdXJyZW50ID0gKGN1cnJlbnQgfHwgcmVmZXJlbmNlRWxlbWVudCkucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0aWYoY29tYmluYXRvciA9PSBcIixcIil7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBjb21tYSBjb21iaW5hdG9yLCBzdGFydCBhIG5ldyBzZWxlY3RvclxuXHRcdFx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlRWxlbWVudCA9IHRvcFJlZmVyZW5jZUVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0fWVsc2UgaWYoY3VycmVudCl7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBlbHNlIGRlc2NlbmRlbnQgb3IgY2hpbGQgc2VsZWN0b3IgKGRvZXNuJ3QgbWF0dGVyLCB0cmVhdGVkIHRoZSBzYW1lKSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZmVyZW5jZUVsZW1lbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuZXh0U2libGluZyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihjdXJyZW50KXtcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlRWxlbWVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0YWcgPSAhcHJlZml4ICYmIHZhbHVlO1xuXHRcdFx0XHRcdGlmKHRhZyB8fCAoIWN1cnJlbnQgJiYgKHByZWZpeCB8fCBhdHRyTmFtZSkpKXtcblx0XHRcdFx0XHRcdGlmKHRhZyA9PSBcIiRcIil7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgYSB2YXJpYWJsZSB0byBiZSByZXBsYWNlZCB3aXRoIGEgdGV4dCBub2RlXG5cdFx0XHRcdFx0XHRcdGluc2VydFRleHROb2RlKHJlZmVyZW5jZUVsZW1lbnQsIGFyZ3NbKytpXSk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gTmVlZCB0byBjcmVhdGUgYW4gZWxlbWVudFxuXHRcdFx0XHRcdFx0XHR0YWcgPSB0YWcgfHwgcHV0LmRlZmF1bHRUYWc7XG5cdFx0XHRcdFx0XHRcdHZhciBpZUlucHV0TmFtZSA9IGllQ3JlYXRlRWxlbWVudCAmJiBhcmdzW2kgKzFdICYmIGFyZ3NbaSArMV0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYoaWVJbnB1dE5hbWUpe1xuXHRcdFx0XHRcdFx0XHRcdC8vIGluIElFLCB3ZSBoYXZlIHRvIHVzZSB0aGUgY3Jhenkgbm9uLXN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQgdG8gY3JlYXRlIGlucHV0J3MgdGhhdCBoYXZlIGEgbmFtZSBcblx0XHRcdFx0XHRcdFx0XHR0YWcgPSAnPCcgKyB0YWcgKyAnIG5hbWU9XCInICsgaWVJbnB1dE5hbWUgKyAnXCI+Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyB3ZSBzd3RpY2ggYmV0d2VlbiBjcmVhdGlvbiBtZXRob2RzIGJhc2VkIG9uIG5hbWVzcGFjZSB1c2FnZVxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gbmFtZXNwYWNlcyAmJiB+KG5hbWVzcGFjZUluZGV4ID0gdGFnLmluZGV4T2YoJ3wnKSkgP1xuXHRcdFx0XHRcdFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlc1t0YWcuc2xpY2UoMCwgbmFtZXNwYWNlSW5kZXgpXSwgdGFnLnNsaWNlKG5hbWVzcGFjZUluZGV4ICsgMSkpIDogXG5cdFx0XHRcdFx0XHRcdFx0ZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocHJlZml4KXtcblx0XHRcdFx0XHRcdGlmKHZhbHVlID09IFwiJFwiKXtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBhcmdzWysraV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihwcmVmaXggPT0gXCIjXCIpe1xuXHRcdFx0XHRcdFx0XHQvLyAjaWQgd2FzIHNwZWNpZmllZFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50LmlkID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gd2UgYXJlIGluIHRoZSBjbGFzc05hbWUgYWRkaXRpb24gYW5kIHJlbW92YWwgYnJhbmNoXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50Q2xhc3NOYW1lID0gY3VycmVudC5jbGFzc05hbWU7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSB0aGUgY2xhc3NOYW1lIChuZWVkZWQgZm9yIGFkZGl0aW9uIG9yIHJlbW92YWwpXG5cdFx0XHRcdFx0XHRcdC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9yZW1vdmUtY2xhc3MtbmFtZS1hbGdvcml0aG0vMiBmb3Igc29tZSB0ZXN0cyBvbiB0aGlzXG5cdFx0XHRcdFx0XHRcdHZhciByZW1vdmVkID0gY3VycmVudENsYXNzTmFtZSAmJiAoXCIgXCIgKyBjdXJyZW50Q2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoXCIgXCIgKyB2YWx1ZSArIFwiIFwiLCBcIiBcIik7XG5cdFx0XHRcdFx0XHRcdGlmKHByZWZpeCA9PSBcIi5cIil7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWRkaXRpb24sIGFkZCB0aGUgY2xhc3NOYW1lXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5jbGFzc05hbWUgPSBjdXJyZW50Q2xhc3NOYW1lID8gKHJlbW92ZWQgKyB2YWx1ZSkuc3Vic3RyaW5nKDEpIDogdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVsc2UgYSAnIScgY2xhc3MgcmVtb3ZhbFxuXHRcdFx0XHRcdFx0XHRcdGlmKGFyZ3VtZW50ID09IFwiIVwiKXtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCBzaWduYWwgdG8gZGVsZXRlIHRoaXMgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoaWVDcmVhdGVFbGVtZW50KXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvbCcgaW5uZXJIVE1MIHRyaWNrIHRvIGdldCBJRSB0byBkbyBzb21lIGNsZWFudXBcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHV0KFwiZGl2XCIsIGN1cnJlbnQsICc8JykuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH1lbHNlIGlmKHBhcmVudE5vZGUgPSBjdXJyZW50LnBhcmVudE5vZGUpeyAvLyBpbnRlbnRpb25hbCBhc3NpZ21lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gdXNlIGEgZmFzdGVyLCBhbmQgbW9yZSBjb3JyZWN0IChmb3IgbmFtZXNwYWNlZCBlbGVtZW50cykgcmVtb3ZhbCAoaHR0cDovL2pzcGVyZi5jb20vcmVtb3ZlY2hpbGQtaW5uZXJodG1sKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2UgYWxyZWFkeSBoYXZlIHJlbW92ZWQgdGhlIGNsYXNzLCBqdXN0IG5lZWQgdG8gdHJpbVxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZCA9IHJlbW92ZWQuc3Vic3RyaW5nKDEsIHJlbW92ZWQubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBpdCBjaGFuZ2VkLCB0aGlzIGNhbiBzYXZlIGEgbG90IG9mIHRpbWVcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHJlbW92ZWQgIT0gY3VycmVudENsYXNzTmFtZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuY2xhc3NOYW1lID0gcmVtb3ZlZDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gQ1NTIGNsYXNzIHJlbW92YWxcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoYXR0ck5hbWUpe1xuXHRcdFx0XHRcdFx0aWYoYXR0clZhbHVlID09IFwiJFwiKXtcblx0XHRcdFx0XHRcdFx0YXR0clZhbHVlID0gYXJnc1srK2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gW25hbWU9dmFsdWVdXG5cdFx0XHRcdFx0XHRpZihhdHRyTmFtZSA9PSBcInN0eWxlXCIpe1xuXHRcdFx0XHRcdFx0XHQvLyBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSBvZiBzZXRBdHRyaWJ1dGUgbm90IHdvcmtpbmcgaW4gb2xkIElFXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQuc3R5bGUuY3NzVGV4dCA9IGF0dHJWYWx1ZTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHR2YXIgbWV0aG9kID0gYXR0ck5hbWUuY2hhckF0KDApID09IFwiIVwiID8gKGF0dHJOYW1lID0gYXR0ck5hbWUuc3Vic3RyaW5nKDEpKSAmJiAncmVtb3ZlQXR0cmlidXRlJyA6ICdzZXRBdHRyaWJ1dGUnO1xuXHRcdFx0XHRcdFx0XHRhdHRyVmFsdWUgPSBhdHRyVmFsdWUgPT09ICcnID8gYXR0ck5hbWUgOiBhdHRyVmFsdWU7XG5cdFx0XHRcdFx0XHRcdC8vIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHVzZSBhIG5hbWVzcGFjZVxuXHRcdFx0XHRcdFx0XHRuYW1lc3BhY2VzICYmIH4obmFtZXNwYWNlSW5kZXggPSBhdHRyTmFtZS5pbmRleE9mKCd8JykpID9cblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50W21ldGhvZCArIFwiTlNcIl0obmFtZXNwYWNlc1thdHRyTmFtZS5zbGljZSgwLCBuYW1lc3BhY2VJbmRleCldLCBhdHRyTmFtZS5zbGljZShuYW1lc3BhY2VJbmRleCArIDEpLCBhdHRyVmFsdWUpIDpcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50W21ldGhvZF0oYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKGxlZnRvdmVyQ2hhcmFjdGVycyl7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBjaGFyIFwiICsgbGVmdG92ZXJDaGFyYWN0ZXJzICsgXCIgaW4gXCIgKyBhcmd1bWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zZXJ0TGFzdEVsZW1lbnQoKTtcblx0XHRcdFx0cmVmZXJlbmNlRWxlbWVudCA9IHJldHVyblZhbHVlID0gY3VycmVudCB8fCByZWZlcmVuY2VFbGVtZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0b3BSZWZlcmVuY2VFbGVtZW50ICYmIGZyYWdtZW50KXtcblx0XHRcdC8vIHdlIG5vdyBpbnNlcnQgdGhlIHRvcCBsZXZlbCBlbGVtZW50cyBmb3IgdGhlIGZyYWdtZW50IGlmIGl0IGV4aXN0c1xuXHRcdFx0dG9wUmVmZXJlbmNlRWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fVxuXHRwdXQuYWRkTmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSwgdXJpKXtcblx0XHRpZihkb2MuY3JlYXRlRWxlbWVudE5TKXtcblx0XHRcdChuYW1lc3BhY2VzIHx8IChuYW1lc3BhY2VzID0ge30pKVtuYW1lXSA9IHVyaTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vIGZvciBvbGQgSUVcblx0XHRcdGRvYy5uYW1lc3BhY2VzLmFkZChuYW1lLCB1cmkpO1xuXHRcdH1cblx0fTtcblx0cHV0LmRlZmF1bHRUYWcgPSBcImRpdlwiO1xuXHRwdXQuZm9yRG9jdW1lbnQgPSBmb3JEb2N1bWVudDtcblx0cmV0dXJuIHB1dDtcbn0pO1xufSkoZnVuY3Rpb24oaWQsIGRlcHMsIGZhY3Rvcnkpe1xuXHRmYWN0b3J5ID0gZmFjdG9yeSB8fCBkZXBzO1xuXHRpZih0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdC8vIEFNRCBsb2FkZXJcblx0XHRkZWZpbmUoW10sIGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSgpO1xuXHRcdH0pO1xuXHR9ZWxzZSBpZih0eXBlb2Ygd2luZG93ID09IFwidW5kZWZpbmVkXCIpe1xuXHRcdC8vIHNlcnZlciBzaWRlIEphdmFTY3JpcHQsIHByb2JhYmx5IChob3BlZnVsbHkpIE5vZGVKU1xuXHRcdHJlcXVpcmUoXCIuL25vZGUtaHRtbFwiKShtb2R1bGUsIGZhY3RvcnkpO1xuXHR9ZWxzZXtcblx0XHQvLyBwbGFpbiBzY3JpcHQgaW4gYSBicm93c2VyXG5cdFx0cHV0ID0gZmFjdG9yeSgpO1xuXHR9XG59KTtcbiIsIi8qXG4gKiAoQykgQ29weXJpZ2h0IEhDTCBUZWNobm9sb2dpZXMgTHRkLiAyMDE5XG4gKiAoQykgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE3IEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qXG4gKiBBIHRoaW4gd3JhcHBlciB0aGF0IGltcGxlbWVudHMgYW4gRVM2IFByb21pc2UgcG9seWZpbGwgdXNpbmcgRG9qbyBwcm9taXNlcy5cbiAqIE11Y2ggc21hbGxlciB0aGFuIG90aGVyIFByb21pc2UgcG9seWZpbGxzIGlmIHRoZSBEb2pvIG1vZHVsZXMgYXJlIGFscmVhZHlcbiAqIGJlaW5nIHVzZWQuXG4gKi9cbiBkZWZpbmUoW1xuXHRcImRvam8vRGVmZXJyZWRcIixcblx0XCJkb2pvL3Byb21pc2UvUHJvbWlzZVwiLFxuXHRcImRvam8vcHJvbWlzZS9hbGxcIixcblx0XCJkb2pvL3Byb21pc2UvZmlyc3RcIixcblx0XCJkb2pvL19iYXNlL2xhbmdcIixcblx0XCJkb2pvL19iYXNlL2FycmF5XCJcbl0sIGZ1bmN0aW9uKFxuXHREZWZlcnJlZCxcblx0RG9qb1Byb21pc2UsXG5cdGFsbCxcblx0Zmlyc3QsXG5cdGxhbmcsXG5cdGFycmF5XG4pIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIFByb21pc2U7XG5cblx0ZnVuY3Rpb24gd3JhcChkb2pvUHJvbWlzZSkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShkb2pvUHJvbWlzZSk7XG5cdH1cblxuXHQvKlxuXHQgKiBEb2pvIHByb21pc2VzIGNhbiByZXNvbHZlIHN5bmNocm9ub3VzbHkgYnV0IEVTNiBwcm9taXNlc1xuXHQgKiBhbHdheXMgcmVzb2x2ZSBhc3luY2hyb25vdXNseS4gIFdyYXBwaW5nIHRoZSBjYWxsYmFja3Ncblx0ICogd2l0aCB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCB0aGUgRVM2IGJlaGF2aW9yIGlzXG5cdCAqIGFkaGVyZWQgdG8uXG5cdCAqL1xuXHRmdW5jdGlvbiBuZXdBc3luY0NhbGxiYWNrKGNiKSB7XG5cdFx0aWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGNiO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0dmFyIGRmZCA9IG5ldyBEZWZlcnJlZCgpO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkZmQucmVzb2x2ZShjYi5hcHBseShudWxsLCBhcmdzKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGRmZC5yZWplY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gZGZkLnByb21pc2U7XG5cdFx0fTtcblx0fVxuXHRQcm9taXNlID0gbGFuZy5leHRlbmQoZnVuY3Rpb24gUHJvbWlzZVdyYXBwZXIoZXhlY3V0b3IpIHtcblx0XHRpZiAoZXhlY3V0b3IgaW5zdGFuY2VvZiBEb2pvUHJvbWlzZSkge1xuXHRcdFx0Ly8gd3JhcHBpbmcgYW4gZXhpc3RpbmcgRG9qbyBwcm9taXNlXG5cdFx0XHR0aGlzLnByb21pc2UgPSBleGVjdXRvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IGRvam8vRGVmZXJyZWRcblx0XHRcdHZhciBkZmQgPSBuZXcgRGVmZXJyZWQoKTtcblx0XHRcdHRoaXMucHJvbWlzZSA9IGRmZC5wcm9taXNlO1xuXHRcdFx0ZXhlY3V0b3IoXG5cdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IGRmZC5yZXNvbHZlKHZhbHVlLCBmYWxzZSk7IH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChyZWFzb24pIHsgZGZkLnJlamVjdChyZWFzb24sIGZhbHNlKTsgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sIHtcblx0XHQnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gd3JhcCh0aGlzLnByb21pc2Uub3RoZXJ3aXNlKFxuXHRcdFx0XHRuZXdBc3luY0NhbGxiYWNrKG9uUmVqZWN0ZWQpXG5cdFx0XHQpKTtcblx0XHR9LFxuXHRcdHRoZW46IGZ1bmN0aW9uKG9uRnVsbGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuIHdyYXAodGhpcy5wcm9taXNlLnRoZW4oXG5cdFx0XHRcdG5ld0FzeW5jQ2FsbGJhY2sob25GdWxsZmlsbGVkKSxcblx0XHRcdFx0bmV3QXN5bmNDYWxsYmFjayhvblJlamVjdGVkKVxuXHRcdFx0KSk7XG5cdFx0fSxcblx0XHRmaW5hbGx5OiBmdW5jdGlvbihvblNldHRsZWQpIHtcblx0XHRcdHJldHVybiB3cmFwKHRoaXMucHJvbWlzZS5hbHdheXMoXG5cdFx0XHRcdG5ld0FzeW5jQ2FsbGJhY2sob25TZXR0bGVkKVxuXHRcdFx0KSk7XG5cdFx0fVxuXHR9KTtcblx0UHJvbWlzZS5hbGwgPSBmdW5jdGlvbihpdGVyYWJsZSkge1xuXHRcdHJldHVybiB3cmFwKGFsbChhcnJheS5tYXAoaXRlcmFibGUsIGZ1bmN0aW9uKHdyYXBwZWQpIHtcblx0XHRcdHJldHVybiB3cmFwcGVkIGluc3RhbmNlb2YgUHJvbWlzZSA/IHdyYXBwZWQucHJvbWlzZSA6IHdyYXBwZWQ7XG5cdFx0fSkpKTtcblx0fTtcblx0UHJvbWlzZS5yYWNlID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcblx0XHRyZXR1cm4gd3JhcChmaXJzdChhcnJheS5tYXAoaXRlcmFibGUsIGZ1bmN0aW9uKHdyYXBwZWQpIHtcblx0XHRcdHJldHVybiB3cmFwcGVkIGluc3RhbmNlb2YgUHJvbWlzZSA/IHdyYXBwZWQucHJvbWlzZSA6IHdyYXBwZWQ7XG5cdFx0fSkpKTtcblx0fTtcblx0UHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbihyZWFzb24pIHtcblx0XHRyZXR1cm4gd3JhcCgobmV3IERlZmVycmVkKCkpLnJlamVjdChyZWFzb24pKTtcblx0fTtcblx0UHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gd3JhcCgobmV3IERlZmVycmVkKCkpLnJlc29sdmUodmFsdWUpKTtcblx0fTtcblx0aWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuXHRcdHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZTtcblx0fTtcblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIi8qXHJcbiAqIChDKSBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTIsIDIwMTYgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcclxuIiwiZGVmaW5lKFtcbiAgXCJkYm9vdHN0cmFwXCIsXG4gIFwic2JcIixcbiAgXCJkb2pvL3BhcnNlclwiLFxuICBcImRvam8vaGFzIXdlYnBhY2s/ZG9qby13ZWJwYWNrLXBsdWdpbi9hbWQvZG9qb0VTNlByb21pc2VcIlxuXSwgZnVuY3Rpb24oKSB7XG5cbn0pO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDaGVjayBpZiBtb2R1bGUgZXhpc3RzIChkZXZlbG9wbWVudCBvbmx5KVxuXHRpZiAoX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG1vZHVsZUlkICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiKGZ1bmN0aW9uKCkgeyAvKiBTdGFydCBkb2pvLXdlYnBhY2stcGx1Z2luIGV4dGVuc2lvbnMgKi9cblx0XHRmdW5jdGlvbiBtaXgoZGVzdCwgc3JjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHRcdGZvcih2YXIgbiBpbiBzcmMpIGRlc3Rbbl0gPSBzcmNbbl07XG5cdFx0XHRyZXR1cm4gZGVzdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0b1VybChuYW1lLCByZWZlcmVuY2VNb2R1bGUpIHtcblx0XHRcdHJldHVybiBsb2FkZXJTY29wZS5yZXF1aXJlLnRvVXJsKG5hbWUsIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdG9BYnNNaWQobmFtZSwgcmVmZXJlbmNlTW9kdWxlKSB7XG5cdFx0XHRyZXR1cm4gbG9hZGVyU2NvcGUucmVxdWlyZS50b0Fic01pZChuYW1lLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdH1cblxuXHRcdC8vIGRvam8gcmVxdWlyZSBmdW5jdGlvbi5cblx0XHRmdW5jdGlvbiByZXEoY29uZmlnLCBkZXBlbmRlbmNpZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dFJlcXVpcmUoY29uZmlnLCBkZXBlbmRlbmNpZXMsIGNhbGxiYWNrLCAwLCByZXEpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVDb250ZXh0UmVxdWlyZShtb2R1bGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdFx0aWYgKCFtb2R1bGUpIHJldHVybiByZXE7XG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBtb2R1bGUuYWJzTWlkO1xuXHRcdFx0aWYgKCFtb2R1bGVJZCAmJiByZXEuYWJzTWlkc0J5SWRbbW9kdWxlLmlkXSkge1xuXHRcdFx0XHRtb2R1bGVJZCA9IHJlcS5hYnNNaWRzQnlJZFttb2R1bGUuaWRdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFtb2R1bGVJZCkgcmV0dXJuIHJlcTtcblx0XHRcdHZhciByZXN1bHQgPSBmdW5jdGlvbihhMSwgYTIsIGEzKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0UmVxdWlyZShhMSwgYTIsIGEzLCBtb2R1bGVJZCwgcmVxKTtcblx0XHRcdH07XG5cdFx0XHRmb3IgKHZhciBwIGluIHJlcSkge1xuXHRcdFx0XHRpZiAocmVxLmhhc093blByb3BlcnR5KHApKSB7XG5cdFx0XHRcdFx0cmVzdWx0W3BdID0gcmVxW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQudG9VcmwgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJldHVybiB0b1VybChuYW1lLCBtb2R1bGVJZCA/IHttaWQ6IG1vZHVsZUlkfSA6IG51bGwpO1xuXHRcdFx0fTtcblx0XHRcdHJlc3VsdC50b0Fic01pZCA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHRvQWJzTWlkKG5hbWUsIG1vZHVsZUlkID8ge21pZDogbW9kdWxlSWR9IDogbnVsbCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAocmVxLnVuZGVmKSB7XG5cdFx0XHRcdHJlc3VsdC51bmRlZiA9IGZ1bmN0aW9uKG1pZCkge1xuXHRcdFx0XHRcdHJlcS51bmRlZihtaWQsIG1vZHVsZUlkKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVnaXN0ZXJBYnNNaWRzKGFic01pZHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdFx0Zm9yICh2YXIgcyBpbiBhYnNNaWRzKSB7XG5cdFx0XHRcdHJlcS5hYnNNaWRzW3NdID0gYWJzTWlkc1tzXTtcblx0XHRcdFx0aWYgKCFyZXEuYWJzTWlkc0J5SWRbYWJzTWlkc1tzXV0pIHtcblx0XHRcdFx0XHRyZXEuYWJzTWlkc0J5SWRbYWJzTWlkc1tzXV0gPSBzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVRlcm5hcnlIYXNFeHByZXNzaW9uKGV4cHIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdFx0Ly8gRXhwZWN0cyBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIHN1cHBvcnRlZCBieSBkb2pvL2hhcy5qcyBsb2FkZXIsIGV4Y2VwdCB0aGF0IG1vZHVsZSBpZGVudGlmaWVycyBhcmVcblx0XHRcdC8vIGludGVnZXJzIGNvcnJlc3BvbmRpbmcgdG8gd2VicGFjayBtb2R1bGUgaWRzLiAgUmV0dXJucyBhIG1vZHVsZSByZWZlcmVuY2UgaWYgZXZhbHVhdGlvbiBvZiB0aGUgZXhwcmVzc2lvblxuXHRcdFx0Ly8gdXNpbmcgdGhlIGN1cnJlbnRseSBkZWZpbmVkIGZlYXR1cmVzIHJldHVybnMgYSBtb2R1bGUgaWQsIG9yIGVsc2UgdW5kZWZpbmVkLlxuXG5cdFx0XHR2YXIgaGFzID0gZmluZE1vZHVsZShcImRvam8vaGFzXCIsIG51bGwsIGZhbHNlKTtcblx0XHRcdHZhciBpZCA9IGhhcy5ub3JtYWxpemUoZXhwciwgZnVuY3Rpb24oYXJnKXtyZXR1cm4gYXJnO30pO1xuXHRcdFx0cmV0dXJuIGlkICYmIF9fd2VicGFja19yZXF1aXJlX18oaWQpIHx8IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kTW9kdWxlKG1pZCwgcmVmZXJlbmNlTW9kdWxlLCBub0luc3RhbGwsIGFzTW9kdWxlT2JqKSB7XG5cdFx0XHRtaWQgPSBtaWQuc3BsaXQoXCIhXCIpLm1hcChmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0XHRcdHZhciBpc1JlbGF0aXZlID0gc2VnbWVudC5jaGFyQXQoMCkgPT09ICcuJztcblx0XHRcdFx0aWYoaXNSZWxhdGl2ZSAmJiAhcmVmZXJlbmNlTW9kdWxlKXtcblx0XHRcdFx0XHRyZXR1cm4gc2VnbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG9BYnNNaWQoc2VnbWVudCwgcmVmZXJlbmNlTW9kdWxlID8ge21pZDogcmVmZXJlbmNlTW9kdWxlfSA6IG51bGwpO1xuXHRcdFx0fSkuam9pbihcIiFcIik7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKG1pZCBpbiByZXEuYWJzTWlkcyAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLm1bcmVxLmFic01pZHNbbWlkXV0pIHtcblx0XHRcdFx0aWYgKG5vSW5zdGFsbCkge1xuXHRcdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bcmVxLmFic01pZHNbbWlkXV07XG5cdFx0XHRcdFx0cmVzdWx0ID0gbW9kdWxlICYmIChhc01vZHVsZU9iaiA/IG1vZHVsZSA6IG1vZHVsZS5leHBvcnRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcS5hYnNNaWRzW21pZF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSBub3QgZm91bmQ6ICcgKyBtaWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb2pvTW9kdWxlRnJvbVdlYnBhY2tNb2R1bGUod2VicGFja01vZHVsZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0XHRpZiAod2VicGFja01vZHVsZS5hYnNNaWQpIHJldHVybiB3ZWJwYWNrTW9kdWxlOyAgLy8gQWxyZWFkeSBjb252ZXJ0ZWRcblx0XHRcdHZhciByZXN1bHQgPSB7aTp3ZWJwYWNrTW9kdWxlLmlkfTtcblx0XHRcdHZhciBpZCA9IHJlcS5hYnNNaWRzQnlJZFt3ZWJwYWNrTW9kdWxlLmlkXTtcblx0XHRcdGlmIChpZCkge1xuXHRcdFx0XHRyZXN1bHQuaWQgPSByZXN1bHQuYWJzTWlkID0gaWQ7XG5cdFx0XHR9XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcImV4cG9ydHNcIiwge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2VicGFja01vZHVsZS5leHBvcnRzO30sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHt3ZWJwYWNrTW9kdWxlLmV4cG9ydHMgPSB2YWx1ZTt9LFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb250ZXh0UmVxdWlyZShhMSwgYTIsIGEzLCByZWZlcmVuY2VNb2R1bGUsIHJlcSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuXHRcdFx0dmFyIHR5cGUgPSAoe30udG9TdHJpbmcpLmNhbGwoYTEpO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG5cdFx0XHRcdC8vIGEzIGlzIHBhc3NlZCBieSByZXF1aXJlIGNhbGxzIGluamVjdGVkIGludG8gZGVwZW5kZW5jeSBhcnJheXMgZm9yIGRlcGVuZGVuY2llcyBzcGVjaWZpZWRcblx0XHRcdFx0Ly8gYXMgaWRlbnRpZmllcnMgKHZzLiBzdHJpbmcgbGl0ZXJhbHMpLlxuXHRcdFx0XHR2YXIgbm9JbnN0YWxsID0gIShhMyA9PT0gZmFsc2UpO1xuXHRcdFx0XHR2YXIgbSA9IGZpbmRNb2R1bGUoYTEsIHJlZmVyZW5jZU1vZHVsZSwgbm9JbnN0YWxsKTtcblx0XHRcdFx0aWYgKHR5cGVvZiBtID09PSAnb2JqZWN0JyAmJiBtLl9fRE9KT19XRUJQQUNLX0RFRklORV9QUk9NSVNFX18pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSBub3QgZm91bmQ6ICcgKyBhMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG07XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUmVxdWlyZSBjb25maWcgaXMgbm90IHN1cHBvcnRlZCBieSBXZWJQYWNrJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHR2YXIgbW9kdWxlcyA9IFtdLCBjYWxsYmFjayA9IGEyLCBlcnJvcnMgPSBbXTtcblx0XHRcdFx0YTEuZm9yRWFjaChmdW5jdGlvbiAobWlkKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG1vZHVsZXMucHVzaChmaW5kTW9kdWxlKG1pZCwgcmVmZXJlbmNlTW9kdWxlKSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0ZXJyb3JzLnB1c2goe21pZDogbWlkLCBlcnJvcjogZX0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRpZiAodHJ1ZSAmJiBpc0RlZmluZVByb21pc2UobW9kdWxlcykpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHRcdFx0XHRcdFx0XHRQcm9taXNlLmFsbCh3cmFwUHJvbWlzZXMobW9kdWxlcykpLnRoZW4oZnVuY3Rpb24oZGVwcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkodGhpcywgdW53cmFwUHJvbWlzZXMoZGVwcykpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdFx0XHRcdH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyKXtjb25zb2xlLmVycm9yKGVycik7fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSh0aGlzLCBtb2R1bGVzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKFwiZmluZE1vZHVsZXNcIik7XG5cdFx0XHRcdFx0ZXJyb3Iuc3JjID0gXCJkb2pvLXdlYnBhY2stcGx1Z2luXCI7XG5cdFx0XHRcdFx0ZXJyb3IuaW5mbyA9IGVycm9ycztcblx0XHRcdFx0XHRyZXEuc2lnbmFsKFwiZXJyb3JcIiwgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHJlcXVpcmUgY2FsbCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXEudG9VcmwgPSB0b1VybDtcblx0XHRyZXEudG9BYnNNaWQgPSB0b0Fic01pZDtcblx0XHRyZXEuYWJzTWlkcyA9IHt9O1xuXHRcdHJlcS5hYnNNaWRzQnlJZCA9IFtdO1xuXHRcdHJlcS5hc3luYyA9IDE7XG5cdFx0ZnVuY3Rpb24gd3JhcFByb21pc2VzKGRlcHMpIHtcblx0XHRcdHZhciByZXN1bHQgPSAoQXJyYXkuaXNBcnJheShkZXBzKSA/IGRlcHMgOiBbZGVwc10pLm1hcChmdW5jdGlvbihtKSB7XG5cdFx0XHRcdHJldHVybiAobSAmJiB0eXBlb2YgbS50aGVuID09PSAnZnVuY3Rpb24nICYmICFtLl9fRE9KT19XRUJQQUNLX0RFRklORV9QUk9NSVNFX18pID8ge19fRE9KT19XRUJQQUNLX1BST01JU0VfVkFMVUVfXzogbX0gOiBtO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShkZXBzKSA/IHJlc3VsdCA6IHJlc3VsdFswXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bndyYXBQcm9taXNlcyhkZXBzKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gKEFycmF5LmlzQXJyYXkoZGVwcykgPyBkZXBzIDogW2RlcHNdKS5tYXAoZnVuY3Rpb24obSkge1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLl9fRE9KT19XRUJQQUNLX1BST01JU0VfVkFMVUVfXyB8fCBtO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShkZXBzKSA/IHJlc3VsdCA6IHJlc3VsdFswXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0RlZmluZVByb21pc2UodmFsdWVzKSB7XG5cdFx0XHRyZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdKS5zb21lKGZ1bmN0aW9uKGRlcCkge1xuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGRlcCA9PT0gJ29iamVjdCcgJiYgZGVwLl9fRE9KT19XRUJQQUNLX0RFRklORV9QUk9NSVNFX187XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhc3luY0RlZmluZU1vZHVsZShkZWZBcnJheSwgZGVmRmFjdG9yeSwgbW9kdWxlLCBleHBvcnRzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXHRcdFx0ZnVuY3Rpb24gc2V0RGVmaW5lUHJvbWlzZShwcm9taXNlKSB7XG5cdFx0XHRcdHByb21pc2UuX19ET0pPX1dFQlBBQ0tfREVGSU5FX1BST01JU0VfXyA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkZWZNb2R1bGUoZGVwcykge1xuXHRcdFx0XHRtb2R1bGUgJiYgKG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyk7XG5cdFx0XHRcdHZhciByZXN1bHQgPSAgZGVmRmFjdG9yeS5hcHBseShudWxsLCBkZXBzKTtcblx0XHRcdFx0aWYgKHR5cGVvZiBtb2R1bGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHQvLyBtb2R1bGUgaXMgYWN0dWFsbHkgYSBjYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0XHRcdG1vZHVsZShyZXN1bHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IG1vZHVsZS5leHBvcnRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzRGVmaW5lUHJvbWlzZShkZWZBcnJheSkpIHtcblx0XHRcdFx0cmV0dXJuIGRlZk1vZHVsZShkZWZBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gc2V0RGVmaW5lUHJvbWlzZShQcm9taXNlLmFsbChkZWZBcnJheSkudGhlbihmdW5jdGlvbihkZXBzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdyYXBQcm9taXNlcyhkZWZNb2R1bGUodW53cmFwUHJvbWlzZXMoZGVwcykpKTtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0dmFyIGdsb2JhbE9iaiA9IHRoaXN8fHdpbmRvdztcblx0cmVnaXN0ZXJBYnNNaWRzKHtcblx0XHRcInRoZW1lcy90YWNoeW9ucy9qcy9pbmRleC5qc1wiOlwiLi90aGVtZXMvdGFjaHlvbnMvanMvaW5kZXguanNcIixcblx0XHRcImRib290c3RyYXAvbWFpblwiOlwiLi9saWJyYXJpZXMvZGJvb3RzdHJhcC9tYWluLmpzXCIsXG5cdFx0XCJkYm9vdHN0cmFwL2ljb25fc3VwcG9ydFwiOlwiLi9saWJyYXJpZXMvZGJvb3RzdHJhcC9pY29uX3N1cHBvcnQuanNcIixcblx0XHRcImRvam8vX2Jhc2UvZGVjbGFyZVwiOlwiLi9saWJyYXJpZXMvZG9qby9fYmFzZS9kZWNsYXJlLmpzXCIsXG5cdFx0XCJkb2pvL19iYXNlL2tlcm5lbFwiOlwiLi9saWJyYXJpZXMvZG9qby9fYmFzZS9rZXJuZWwuanNcIixcblx0XHRcImRvam8vZ2xvYmFsXCI6XCIuL2xpYnJhcmllcy9kb2pvL2dsb2JhbC5qc1wiLFxuXHRcdFwiZG9qby9oYXNcIjpcIi4vbGlicmFyaWVzL2Rvam8vaGFzLmpzXCIsXG5cdFx0XCJkb2pvL19iYXNlL2NvbmZpZ1wiOlwiLi9saWJyYXJpZXMvZG9qby9fYmFzZS9jb25maWcuanNcIixcblx0XHRcImRvam8vX2Jhc2UvbGFuZ1wiOlwiLi9saWJyYXJpZXMvZG9qby9fYmFzZS9sYW5nLmpzXCIsXG5cdFx0XCJkb2pvL3NuaWZmXCI6XCIuL2xpYnJhcmllcy9kb2pvL3NuaWZmLmpzXCIsXG5cdFx0XCJkb2pvL19iYXNlL2FycmF5XCI6XCIuL2xpYnJhcmllcy9kb2pvL19iYXNlL2FycmF5LmpzXCIsXG5cdFx0XCJkb2pvL2RvbS1jb25zdHJ1Y3RcIjpcIi4vbGlicmFyaWVzL2Rvam8vZG9tLWNvbnN0cnVjdC5qc1wiLFxuXHRcdFwiZG9qby9fYmFzZS93aW5kb3dcIjpcIi4vbGlicmFyaWVzL2Rvam8vX2Jhc2Uvd2luZG93LmpzXCIsXG5cdFx0XCJkb2pvL2RvbVwiOlwiLi9saWJyYXJpZXMvZG9qby9kb20uanNcIixcblx0XHRcImRvam8vZG9tLWF0dHJcIjpcIi4vbGlicmFyaWVzL2Rvam8vZG9tLWF0dHIuanNcIixcblx0XHRcImRvam8vZG9tLXN0eWxlXCI6XCIuL2xpYnJhcmllcy9kb2pvL2RvbS1zdHlsZS5qc1wiLFxuXHRcdFwiZG9qby9kb20tcHJvcFwiOlwiLi9saWJyYXJpZXMvZG9qby9kb20tcHJvcC5qc1wiLFxuXHRcdFwiZG9qby9fYmFzZS9jb25uZWN0XCI6XCIuL2xpYnJhcmllcy9kb2pvL19iYXNlL2Nvbm5lY3QuanNcIixcblx0XHRcImRvam8vb25cIjpcIi4vbGlicmFyaWVzL2Rvam8vb24uanNcIixcblx0XHQvLyBcIi9ob21lL2FsaS9wdWJsaWNfaHRtbC9zdGFyYnVnL3N0YXJidWcvbm9kZV9tb2R1bGVzL2Rvam8td2VicGFjay1wbHVnaW4vbGliL05vTW9kdWxlLmpzXCIgPSBcIi4vbm9kZV9tb2R1bGVzL2Rvam8td2VicGFjay1wbHVnaW4vbGliL05vTW9kdWxlLmpzXCJcblx0XHRcImRvam8vYXNwZWN0XCI6XCIuL2xpYnJhcmllcy9kb2pvL2FzcGVjdC5qc1wiLFxuXHRcdFwiZG9qby90b3BpY1wiOlwiLi9saWJyYXJpZXMvZG9qby90b3BpYy5qc1wiLFxuXHRcdFwiZG9qby9FdmVudGVkXCI6XCIuL2xpYnJhcmllcy9kb2pvL0V2ZW50ZWQuanNcIixcblx0XHRcImRvam8vX2Jhc2UvZXZlbnRcIjpcIi4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvZXZlbnQuanNcIixcblx0XHRcImRvam8vZG9tLWdlb21ldHJ5XCI6XCIuL2xpYnJhcmllcy9kb2pvL2RvbS1nZW9tZXRyeS5qc1wiLFxuXHRcdFwiZG9qby9tb3VzZVwiOlwiLi9saWJyYXJpZXMvZG9qby9tb3VzZS5qc1wiLFxuXHRcdFwiZG9qby9fYmFzZS9zbmlmZlwiOlwiLi9saWJyYXJpZXMvZG9qby9fYmFzZS9zbmlmZi5qc1wiLFxuXHRcdFwiZG9qby9rZXlzXCI6XCIuL2xpYnJhcmllcy9kb2pvL2tleXMuanNcIixcblx0XHRcImRvam8vZG9tLWNsYXNzXCI6XCIuL2xpYnJhcmllcy9kb2pvL2RvbS1jbGFzcy5qc1wiLFxuXHRcdFwiZGlqaXQvX1RlbXBsYXRlZE1peGluXCI6XCIuL2xpYnJhcmllcy9kaWppdC9fVGVtcGxhdGVkTWl4aW4uanNcIixcblx0XHRcImRvam8vY2FjaGVcIjpcIi4vbGlicmFyaWVzL2Rvam8vY2FjaGUuanNcIixcblx0XHRcImRvam8vdGV4dFwiOlwiLi9saWJyYXJpZXMvZG9qby90ZXh0LmpzXCIsXG5cdFx0XCJkb2pvL3JlcXVlc3RcIjpcIi4vbGlicmFyaWVzL2Rvam8vcmVxdWVzdC5qc1wiLFxuXHRcdFwiZG9qby9yZXF1ZXN0L3hoclwiOlwiLi9saWJyYXJpZXMvZG9qby9yZXF1ZXN0L3hoci5qc1wiLFxuXHRcdFwiZG9qby9yZXF1ZXN0L2RlZmF1bHQhXCI6XCIuL2xpYnJhcmllcy9kb2pvL3JlcXVlc3QveGhyLmpzXCIsXG5cdFx0XCJkb2pvL2Vycm9ycy9SZXF1ZXN0RXJyb3JcIjpcIi4vbGlicmFyaWVzL2Rvam8vZXJyb3JzL1JlcXVlc3RFcnJvci5qc1wiLFxuXHRcdFwiZG9qby9lcnJvcnMvY3JlYXRlXCI6XCIuL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9jcmVhdGUuanNcIixcblx0XHRcImRvam8vcmVxdWVzdC93YXRjaFwiOlwiLi9saWJyYXJpZXMvZG9qby9yZXF1ZXN0L3dhdGNoLmpzXCIsXG5cdFx0XCJkb2pvL3JlcXVlc3QvdXRpbFwiOlwiLi9saWJyYXJpZXMvZG9qby9yZXF1ZXN0L3V0aWwuanNcIixcblx0XHRcImRvam8vZXJyb3JzL0NhbmNlbEVycm9yXCI6XCIuL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9DYW5jZWxFcnJvci5qc1wiLFxuXHRcdFwiZG9qby9EZWZlcnJlZFwiOlwiLi9saWJyYXJpZXMvZG9qby9EZWZlcnJlZC5qc1wiLFxuXHRcdFwiZG9qby9wcm9taXNlL1Byb21pc2VcIjpcIi4vbGlicmFyaWVzL2Rvam8vcHJvbWlzZS9Qcm9taXNlLmpzXCIsXG5cdFx0XCJkb2pvL3Byb21pc2UvaW5zdHJ1bWVudGF0aW9uXCI6XCIuL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvaW5zdHJ1bWVudGF0aW9uLmpzXCIsXG5cdFx0XCJkb2pvL3Byb21pc2UvdHJhY2VyXCI6XCIuL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvdHJhY2VyLmpzXCIsXG5cdFx0XCJkb2pvL2lvLXF1ZXJ5XCI6XCIuL2xpYnJhcmllcy9kb2pvL2lvLXF1ZXJ5LmpzXCIsXG5cdFx0XCJkb2pvL2Vycm9ycy9SZXF1ZXN0VGltZW91dEVycm9yXCI6XCIuL2xpYnJhcmllcy9kb2pvL2Vycm9ycy9SZXF1ZXN0VGltZW91dEVycm9yLmpzXCIsXG5cdFx0XCJkb2pvL3JlcXVlc3QvaGFuZGxlcnNcIjpcIi4vbGlicmFyaWVzL2Rvam8vcmVxdWVzdC9oYW5kbGVycy5qc1wiLFxuXHRcdFwiZG9qby9qc29uXCI6XCIuL2xpYnJhcmllcy9kb2pvL2pzb24uanNcIixcblx0XHRcImRvam8vc3RyaW5nXCI6XCIuL2xpYnJhcmllcy9kb2pvL3N0cmluZy5qc1wiLFxuXHRcdFwiZGlqaXQvX0F0dGFjaE1peGluXCI6XCIuL2xpYnJhcmllcy9kaWppdC9fQXR0YWNoTWl4aW4uanNcIixcblx0XHRcImRvam8vdG91Y2hcIjpcIi4vbGlicmFyaWVzL2Rvam8vdG91Y2guanNcIixcblx0XHRcImRvam8vZG9tUmVhZHlcIjpcIi4vbGlicmFyaWVzL2Rvam8vZG9tUmVhZHkuanNcIixcblx0XHRcImRpaml0L19XaWRnZXRCYXNlXCI6XCIuL2xpYnJhcmllcy9kaWppdC9fV2lkZ2V0QmFzZS5qc1wiLFxuXHRcdFwiZG9qby9yZWFkeVwiOlwiLi9saWJyYXJpZXMvZG9qby9yZWFkeS5qc1wiLFxuXHRcdFwiZG9qby9TdGF0ZWZ1bFwiOlwiLi9saWJyYXJpZXMvZG9qby9TdGF0ZWZ1bC5qc1wiLFxuXHRcdFwiZG9qby93aGVuXCI6XCIuL2xpYnJhcmllcy9kb2pvL3doZW4uanNcIixcblx0XHRcImRpaml0L0Rlc3Ryb3lhYmxlXCI6XCIuL2xpYnJhcmllcy9kaWppdC9EZXN0cm95YWJsZS5qc1wiLFxuXHRcdFwiZGlqaXQvcmVnaXN0cnlcIjpcIi4vbGlicmFyaWVzL2Rpaml0L3JlZ2lzdHJ5LmpzXCIsXG5cdFx0XCJkaWppdC9tYWluXCI6XCIuL2xpYnJhcmllcy9kaWppdC9tYWluLmpzXCIsXG5cdFx0XCJkaWppdC9fQmlkaU1peGluXCI6XCIuL2xpYnJhcmllcy9kaWppdC9fQmlkaU1peGluLmpzXCIsXG5cdFx0XCJzYi9tYWluXCI6XCIuL2NvcmUvYXBwL3B1YmxpYy9qcy9zYi9tYWluLmpzXCIsXG5cdFx0XCJzYi9rZXJuZWxcIjpcIi4vY29yZS9hcHAvcHVibGljL2pzL3NiL2tlcm5lbC5qc1wiLFxuXHRcdFwicHV0LXNlbGVjdG9yL3B1dFwiOlwiLi9saWJyYXJpZXMvcHV0LXNlbGVjdG9yL3B1dC5qc1wiLFxuXHRcdFwic3RhcmJ1Zy9mb3JtL19Gb3JtV2lkZ2V0XCI6XCIuL2NvcmUvYXBwL3B1YmxpYy9qcy9zdGFyYnVnL2Zvcm0vX0Zvcm1XaWRnZXQuanNcIixcblx0XHRcImRpaml0L2Zvcm0vX0Zvcm1XaWRnZXRNaXhpblwiOlwiLi9saWJyYXJpZXMvZGlqaXQvZm9ybS9fRm9ybVdpZGdldE1peGluLmpzXCIsXG5cdFx0XCJkb2pvL3dpbmRvd1wiOlwiLi9saWJyYXJpZXMvZG9qby93aW5kb3cuanNcIixcblx0XHRcImRpaml0L2ExMXlcIjpcIi4vbGlicmFyaWVzL2Rpaml0L2ExMXkuanNcIixcblx0XHRcImRvam8vcGFyc2VyXCI6XCIuL2xpYnJhcmllcy9kb2pvL3BhcnNlci5qc1wiLFxuXHRcdFwiZG9qby9fYmFzZS91cmxcIjpcIi4vbGlicmFyaWVzL2Rvam8vX2Jhc2UvdXJsLmpzXCIsXG5cdFx0XCJkb2pvL3Byb21pc2UvYWxsXCI6XCIuL2xpYnJhcmllcy9kb2pvL3Byb21pc2UvYWxsLmpzXCIsXG5cdFx0XCJkb2pvL2RhdGUvc3RhbXBcIjpcIi4vbGlicmFyaWVzL2Rvam8vZGF0ZS9zdGFtcC5qc1wiLFxuXHRcdFwiZG9qby9xdWVyeVwiOlwiLi9saWJyYXJpZXMvZG9qby9xdWVyeS5qc1wiLFxuXHRcdFwiZG9qby9zZWxlY3Rvci9fbG9hZGVyXCI6XCIuL2xpYnJhcmllcy9kb2pvL3NlbGVjdG9yL19sb2FkZXIuanNcIixcblx0XHRcImRvam8vc2VsZWN0b3IvbGl0ZVwiOlwiLi9saWJyYXJpZXMvZG9qby9zZWxlY3Rvci9saXRlLmpzXCIsXG5cdFx0XCJkb2pvL3NlbGVjdG9yL19sb2FkZXIhZGVmYXVsdFwiOlwiLi9saWJyYXJpZXMvZG9qby9zZWxlY3Rvci9saXRlLmpzXCIsXG5cdFx0XCJkb2pvLXdlYnBhY2stcGx1Z2luL2FtZC9kb2pvRVM2UHJvbWlzZVwiOlwiLi9ub2RlX21vZHVsZXMvZG9qby13ZWJwYWNrLXBsdWdpbi9hbWQvZG9qb0VTNlByb21pc2UuanNcIixcblx0XHRcImRvam8vcHJvbWlzZS9maXJzdFwiOlwiLi9saWJyYXJpZXMvZG9qby9wcm9taXNlL2ZpcnN0LmpzXCJcblx0XHQvLyBcIi9ob21lL2FsaS9wdWJsaWNfaHRtbC9zdGFyYnVnL3N0YXJidWcvbGlicmFyaWVzL2Rpc3QvZG9qby5qc1wiID0gXCIuL2xpYnJhcmllcy9kaXN0L2Rvam8uanNcIlxuXHR9KTtcblxuXHRnbG9iYWxPYmoucmVxdWlyZSA9IHJlcTtcblx0XHQoc2VsZltcIndlYnBhY2tDaHVua1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtcIl0gfHwgW10pLnJlZ2lzdGVyQWJzTWlkcyA9IHJlZ2lzdGVyQWJzTWlkcztcblxuXHQvLyBleHBvc2UgdGhlIERvam8gY29tcGF0aWJpbGl0eSBmdW5jdGlvbnMgYXMgYSBwcm9wZXJ0aWVzIG9mIF9fd2VicGFja19yZXF1aXJlX19cblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZGogJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5kai5uYW1lICE9PSAnZG9qby13ZWJwYWNrLXBsdWdpbicpIHRocm93IG5ldyBFcnJvcihcIl9fd2VicGFja19yZXF1aXJlX18uZGogbmFtZSBjb2xsaXNpb24uXCIpXG5cdF9fd2VicGFja19yZXF1aXJlX18uZGogPSB7XG5cdFx0bmFtZTogJ2Rvam8td2VicGFjay1wbHVnaW4nLFxuXHRcdHI6IHJlcSxcblx0XHRjOiBjcmVhdGVDb250ZXh0UmVxdWlyZSxcblx0XHRtOiBkb2pvTW9kdWxlRnJvbVdlYnBhY2tNb2R1bGUsXG5cdFx0aDogcmVzb2x2ZVRlcm5hcnlIYXNFeHByZXNzaW9uLFxuXHRcdGQ6IGFzeW5jRGVmaW5lTW9kdWxlLFxuXHRcdHc6IHdyYXBQcm9taXNlcyxcblx0XHR1OiB1bndyYXBQcm9taXNlc1xuXHR9O1xuXHR2YXIgbG9hZGVyU2NvcGUgPSBPYmplY3QuY3JlYXRlKGdsb2JhbE9iaiwge1xuXHQgICBkb2N1bWVudDp7dmFsdWU6IGdsb2JhbE9iai5kb2N1bWVudH0sXG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2FkZXJTY29wZSwge1xuXHQgICB3aW5kb3c6e3ZhbHVlOmxvYWRlclNjb3BlfSxcblx0ICAgZ2xvYmFsOnt2YWx1ZTpsb2FkZXJTY29wZX1cblx0fSk7XG5cdGxvYWRlclNjb3BlLmRlZmluZSA9IGxvYWRlclNjb3BlLnJlcXVpcmUgPSB1bmRlZmluZWRcblx0Z2xvYmFsT2JqLmRvam9Db25maWcgPSBnbG9iYWxPYmouZG9qb0NvbmZpZyB8fCB7fVxuXHR2YXIgdXNlckNvbmZpZyA9IG1peChnbG9iYWxPYmouZG9qb0NvbmZpZywgKHsnYmFzZVVybCc6Jy8nLCdhc3luYyc6dHJ1ZSwnbWFwJzooeycqJzooeydzYi9tb2RhbC90aGVtZS9kZWZhdWx0Jzonc2IvbW9kYWwvdGhlbWUvdGFjaHlvbnMnLCdzYi9mb3JtL3RoZW1lL2Ryb3Bkb3duL2RlZmF1bHQnOidzYi9mb3JtL3RoZW1lL2Ryb3Bkb3duL3RhY2h5b25zJywnc2IvZm9ybS90aGVtZS91cGxvYWRCdXR0b24vZGVmYXVsdCc6J3NiL2Zvcm0vdGhlbWUvdXBsb2FkQnV0dG9uL3RhY2h5b25zJywnc2IvZm9ybS90aGVtZS9NdWx0aXBsZVNlbGVjdC9kZWZhdWx0Jzonc2IvZm9ybS90aGVtZS9NdWx0aXBsZVNlbGVjdC90YWNoeW9ucyd9KX0pLCdwYWNrYWdlcyc6Wyh7J25hbWUnOidkb2pvJywnbG9jYXRpb24nOidsaWJyYXJpZXMvZG9qbyd9KSwoeyduYW1lJzonZGlqaXQnLCdsb2NhdGlvbic6J2xpYnJhcmllcy9kaWppdCd9KSwoeyduYW1lJzonZHN0b3JlJywnbG9jYXRpb24nOidsaWJyYXJpZXMvZHN0b3JlJ30pLCh7J25hbWUnOidkZ3JpZCcsJ2xvY2F0aW9uJzonbGlicmFyaWVzL2RncmlkJ30pLCh7J25hbWUnOidwdXQtc2VsZWN0b3InLCdsb2NhdGlvbic6J2xpYnJhcmllcy9wdXQtc2VsZWN0b3InfSksKHsnbmFtZSc6J3hzdHlsZScsJ2xvY2F0aW9uJzonbGlicmFyaWVzL3hzdHlsZSd9KSwoeyduYW1lJzonZGJvb3RzdHJhcCcsJ2xvY2F0aW9uJzonbGlicmFyaWVzL2Rib290c3RyYXAnfSksKHsnbmFtZSc6J2Jvb3RzdHJhcCcsJ2xvY2F0aW9uJzonbGlicmFyaWVzL2Rvam8tYm9vdHN0cmFwJ30pLCh7J25hbWUnOidzYicsJ2xvY2F0aW9uJzonY29yZS9hcHAvcHVibGljL2pzL3NiJ30pLCh7J25hbWUnOidzdGFyYnVnJywnbG9jYXRpb24nOidjb3JlL2FwcC9wdWJsaWMvanMvc3RhcmJ1Zyd9KSwoeyduYW1lJzondGFjaHlvbnMtYW1kJywnbG9jYXRpb24nOid0aGVtZXMvdGFjaHlvbnMvcHVibGljL2pzJ30pXX0pKTtcblx0dmFyIGRlZmF1bHRDb25maWcgPSAoeydoYXNDYWNoZSc6KHsnd2VicGFjayc6MSwnaG9zdC1icm93c2VyJzoxLCdkb20nOjEsJ2Rvam8tbG9hZGVyJzoxLCdkb2pvLWhhcy1hcGknOjEsJ2Rvam8tZG9tLXJlYWR5LWFwaSc6MSwnZG9qby1zbmlmZic6MSwnZG9qby10ZXN0LXNuaWZmJzoxLCdjb25maWctZGVmZXJyZWRJbnN0cnVtZW50YXRpb24nOjEsJ2NvbmZpZy10bG1TaWJsaW5nT2ZEb2pvJzoxfSl9KTtcblx0dmFyIGRvam9Mb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9saWJyYXJpZXMvZGlzdC9kb2pvLmpzXCIpO1xuXHRkb2pvTG9hZGVyLmNhbGwobG9hZGVyU2NvcGUsIHVzZXJDb25maWcsIGRlZmF1bHRDb25maWcsIGxvYWRlclNjb3BlLCBsb2FkZXJTY29wZSk7XG5cdE9iamVjdC5rZXlzKGxvYWRlclNjb3BlLnJlcXVpcmUucGFja3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBrZyA9IGxvYWRlclNjb3BlLnJlcXVpcmUucGFja3Nba2V5XTtcblx0XHRpZiAoKC8oXlxcLyl8KFxcOikvLnRlc3QocGtnLm1haW4pXHQvLyBtYWluIHBhdGggaXMgYWJzb2x1dGVcblx0XHQgICAgfHwgcGtnLm1haW4uc3BsaXQoJy8nKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwYXRoQ29tcCkge1xuXHRcdFx0XHRcdGlmIChhY2MgPCAwIHx8IHBhdGhDb21wID09PSAnLicpIHJldHVybiBhY2M7XG5cdFx0XHRcdFx0cmV0dXJuIChwYXRoQ29tcCA9PT0gJy4uJyA/IC0tYWNjIDogKythY2MpO1xuXHRcdFx0XHR9LCAwKSA8PSAwKSAvLyBtYWluIHBhdGggaXMgb3V0c2lkZSBwYWNrYWdlXG5cdFx0XHRcdCYmIHR5cGVvZiBwa2cucmVhbE1haW4gPT09ICd1bmRlZmluZWQnXHQvLyBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkanVzdGVkXG5cdFx0KSB7XG5cdFx0XHRwa2cucmVhbE1haW4gPSBwa2cubWFpbjtcblx0XHRcdHBrZy5tYWluID0gJyc7XG5cdFx0fVxuXHR9KTtcblx0ZnVuY3Rpb24gdG9BYnNNaWQobmFtZSwgcmVmZXJlbmNlTW9kdWxlKSB7XG5cdFx0dmFyIGFic01pZCA9IGxvYWRlclNjb3BlLnJlcXVpcmUub3JpZ2luYWxUb0Fic01pZChuYW1lLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdGlmIChhYnNNaWQuaW5kZXhPZignLycpID09PSBhYnNNaWQubGVuZ3RoLTEpIHtcblx0XHRcdHZhciBwa2dOYW1lID0gYWJzTWlkLnN1YnN0cmluZygwLCBhYnNNaWQubGVuZ3RoLTEpO1xuXHRcdFx0dmFyIHBrZyA9IGxvYWRlclNjb3BlLnJlcXVpcmUucGFja3NbcGtnTmFtZV07XG5cdFx0XHRpZiAocGtnICYmIHBrZy5yZWFsTWFpbikge1xuXHRcdFx0XHRhYnNNaWQgPSBwa2dOYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYWJzTWlkO1xuXHR9XG5cdGZ1bmN0aW9uIHRvVXJsKG5hbWUsIHJlZmVyZW5jZU1vZHVsZSkge1xuXHRcdHZhciB1cmwgPSBsb2FkZXJTY29wZS5yZXF1aXJlLm9yaWdpbmFsVG9VcmwobmFtZSwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHR2YXIgcGtnID0gbG9hZGVyU2NvcGUucmVxdWlyZS5wYWNrc1tuYW1lXTtcblx0XHRpZiAocGtnICYmIHBrZy5yZWFsTWFpbikge1xuXHRcdFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XG5cdFx0XHRpZiAoLyheXFwvKXwoXFw6KS8udGVzdChwa2cucmVhbE1haW4pKSB7XG5cdFx0XHRcdC8vIGFic29sdXRlIFVSTFxuXHRcdFx0XHRwYXJ0c1swXSA9IHBrZy5yZWFsTWFpbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTFxuXHRcdFx0XHRwYXJ0c1swXSA9IHBhcnRzWzBdICsgJy8nICsgcGtnLnJlYWxNYWluO1xuXHRcdFx0fVxuXHRcdFx0dXJsID0gcGFydHMuam9pbignPycpO1xuXHRcdH1cblx0XHRyZXR1cm4gdXJsO1xuXHR9XG5cdGxvYWRlclNjb3BlLnJlcXVpcmUub3JpZ2luYWxUb0Fic01pZCA9IGxvYWRlclNjb3BlLnJlcXVpcmUudG9BYnNNaWQ7XG5cdGxvYWRlclNjb3BlLnJlcXVpcmUub3JpZ2luYWxUb1VybCA9IGxvYWRlclNjb3BlLnJlcXVpcmUudG9Vcmw7XG5cdGxvYWRlclNjb3BlLnJlcXVpcmUudG9BYnNNaWQgPSB0b0Fic01pZDtcblx0bG9hZGVyU2NvcGUucmVxdWlyZS50b1VybCA9IHRvVXJsO1xuXHRbJ2Jhc2VVcmwnLCdoYXMnLCdyYXdDb25maWcnLCdvbicsJ3NpZ25hbCddLmZvckVhY2goZnVuY3Rpb24obmFtZSkge3JlcVtuYW1lXSA9IGxvYWRlclNjb3BlLnJlcXVpcmVbbmFtZV19KVxuXHR2YXIgYWJzTWlkc1dhaXRpbmcgPSBnbG9iYWxPYmpbXCJ3ZWJwYWNrQ2h1bmtcIl0uYWJzTWlkc1dhaXRpbmc7XG5cdGlmIChhYnNNaWRzV2FpdGluZykge1xuXHQgICBhYnNNaWRzV2FpdGluZy5mb3JFYWNoKHJlZ2lzdGVyQWJzTWlkcyk7XG5cdCAgIGRlbGV0ZSBnbG9iYWxPYmpbXCJ3ZWJwYWNrQ2h1bmtcIl0uYWJzTWlkc1dhaXRpbmc7XG5cdH1cbn0pKCk7IC8qIEVuZCBkb2pvLXdlYnBhY2stcGx1Z2luIGV4dGVuc2lvbnMgKi8iLCIiLCIvLyBtb2R1bGUgZmFjdG9yaWVzIGFyZSB1c2VkIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vdGhlbWVzL3RhY2h5b25zL2pzL2luZGV4LmpzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==